diff --git a/synced/convex/docs/_betaAdmonition.md b/synced/convex/docs/_betaAdmonition.md
new file mode 100644
index 0000000..9319346
--- /dev/null
+++ b/synced/convex/docs/_betaAdmonition.md
@@ -0,0 +1,5 @@
+<Admonition type="caution" title={`${props.feature} ${props.verb} in beta`}>
+  {props.feature} {props.verb} currently a [beta
+  feature](/production/state/#beta-features). If you have feedback or feature
+  requests, [let us know on Discord](https://convex.dev/community)!
+</Admonition>
diff --git a/synced/convex/docs/_betaContactUsAdmonition.md b/synced/convex/docs/_betaContactUsAdmonition.md
new file mode 100644
index 0000000..5631ad9
--- /dev/null
+++ b/synced/convex/docs/_betaContactUsAdmonition.md
@@ -0,0 +1,6 @@
+<Admonition type="caution" title={`${props.feature} ${props.verb} in beta`}>
+  {props.feature} {props.verb} currently in an early access
+  [beta](/production/state/#beta-features). For access, contact us [on
+  Discord](https://convex.dev/community) or by email at
+  [support@convex.dev](mailto:support@convex.dev)!
+</Admonition>
diff --git a/synced/convex/docs/_convexValues.md b/synced/convex/docs/_convexValues.md
new file mode 100644
index 0000000..0d55bcc
--- /dev/null
+++ b/synced/convex/docs/_convexValues.md
@@ -0,0 +1,18 @@
+Convex supports the following types of values:
+
+<div className="convex-full-width">
+
+| Convex Type | TS/JS Type                                                                                                                   | <div style={{width: "11em"}}>Example Usage</div> | Validator for [Argument Validation](/functions/validation) and [Schemas](/database/schemas) | `json` Format for [Export](/database/import-export) | Notes                                                                                                                                                                                                                                                                                                                                                  |
+| ----------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
+| Id          | [Id](/database/document-ids) ([string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type)) | `doc._id`                                        | `v.id(tableName)`                                                                           | string                                              | See [Document IDs](/database/document-ids).                                                                                                                                                                                                                                                                                                            |
+| Null        | [null](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#null_type)                                    | `null`                                           | `v.null()`                                                                                  | null                                                | JavaScript's `undefined` is not a valid Convex value. Functions the return `undefined` or do not return will return `null` when called from a client. Use `null` instead.                                                                                                                                                                              |
+| Int64       | [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#bigint_type)                                | `3n`                                             | `v.int64()`                                                                                 | string (base10)                                     | Int64s only support BigInts between -2^63 and 2^63-1. Convex supports `bigint`s in [most modern browsers](https://caniuse.com/bigint).                                                                                                                                                                                                                 |
+| Float64     | [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#number_type)                                | `3.1`                                            | `v.number()`                                                                                | number / string                                     | Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as strings.                                                                                                                                                                                                                       |
+| Boolean     | [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#boolean_type)                              | `true`                                           | `v.boolean()`                                                                               | bool                                                |
+| String      | [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type)                                | `"abc"`                                          | `v.string()`                                                                                | string                                              | Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit when encoded as UTF-8.                                                                                                                                                                                                          |
+| Bytes       | [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)                  | `new ArrayBuffer(8)`                             | `v.bytes()`                                                                                 | string (base64)                                     | Convex supports first class bytestrings, passed in as `ArrayBuffer`s. Bytestrings must be smaller than the 1MB total size limit for Convex types.                                                                                                                                                                                                      |
+| Array       | [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)                              | `[1, 3.2, "abc"]`                                | `v.array(values)`                                                                           | array                                               | Arrays can have at most 8192 values.                                                                                                                                                                                                                                                                                                                   |
+| Object      | [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#objects)                                    | `{a: "abc"}`                                     | `v.object({property: value})`                                                               | object                                              | Convex only supports "plain old JavaScript objects" (objects that do not have a custom prototype). Convex includes all [enumerable properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties). Objects can have at most 1024 entries. Field names must be nonempty and not start with "$" or "\_". |
+| Record      | [Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)                                    | `{"a": "1", "b": "2"}`                           | `v.record(keys, values)`                                                                    | object                                              | Records are objects at runtime, but can have dynamic keys. Keys must be only ASCII characters, nonempty, and not start with "$" or "\_".                                                                                                                                                                                                               |
+
+</div>
diff --git a/synced/convex/docs/_proFeatureUpsell.md b/synced/convex/docs/_proFeatureUpsell.md
new file mode 100644
index 0000000..0a2ba3b
--- /dev/null
+++ b/synced/convex/docs/_proFeatureUpsell.md
@@ -0,0 +1,8 @@
+<Admonition
+  type="info"
+  title={`${props.feature} ${props.verb} a Convex Pro plan.`}
+>
+  {props.feature} {props.verb} a Convex Pro plan. [Learn
+  more](https://convex.dev/pricing) about our plans or
+  [upgrade](https://dashboard.convex.dev/team/settings/billing).
+</Admonition>
diff --git a/synced/convex/docs/agents.md b/synced/convex/docs/agents.md
new file mode 100644
index 0000000..cc01fbe
--- /dev/null
+++ b/synced/convex/docs/agents.md
@@ -0,0 +1,133 @@
+---
+title: "AI Agents"
+sidebar_position: 100
+description: "Building AI Agents with Convex"
+---
+
+# Building AI Agents with Convex
+
+Convex provides a powerful platform for building AI agents through its robust
+set of components.
+
+## Why Convex for AI Agents?
+
+Convex offers several advantages for building AI agents:
+
+1. **Durable Execution**: Long-running workflows that survive server restarts
+2. **Real-time State Management**: Reactive state updates for agent progress
+3. **Built-in Persistence**: Store conversation history and agent state
+4. **Parallel Processing**: Run multiple agent tasks concurrently
+5. **Error Handling**: Robust retry mechanisms for API calls
+
+## Core Components
+
+The [Agent](https://www.convex.dev/components/agent) and
+[Workflow](https://www.convex.dev/components/workflow) components can be used
+together to create powerful long running agents with memory.
+
+import { ComponentCardList } from "@site/src/components/ComponentCard";
+
+<ComponentCardList
+  items={[
+    {
+      title: "Agent",
+      description:
+        "Agents organize your AI workflows into units, with message history and vector search built in.",
+      href: "https://www.convex.dev/components/agent",
+    },
+    {
+      title: "Workflow",
+      description:
+        "Simplify programming long running code flows. Workflows execute durably with configurable retries and delays.",
+      href: "https://www.convex.dev/components/workflow",
+    },
+  ]}
+/>
+
+Learn more by reading:
+[AI Agents with Built-in Memory](https://stack.convex.dev/ai-agents).
+
+Sample code:
+
+```typescript
+// Define an agent similarly to the AI SDK
+const supportAgent = new Agent(components.agent, {
+  chat: openai.chat("gpt-4o-mini"),
+  textEmbedding: openai.embedding("text-embedding-3-small"),
+  instructions: "You are a helpful assistant.",
+  tools: { accountLookup, fileTicket, sendEmail },
+});
+
+// Use the agent from within a normal action:
+export const createThread = action({
+  args: { prompt: v.string() },
+  handler: async (ctx, { prompt }) => {
+    const { threadId, thread } = await supportAgent.createThread(ctx);
+    const result = await thread.generateText({ prompt });
+    return { threadId, text: result.text };
+  },
+});
+
+// Pick up where you left off, with the same or a different agent:
+export const continueThread = action({
+  args: { prompt: v.string(), threadId: v.string() },
+  handler: async (ctx, { prompt, threadId }) => {
+    // This includes previous message history from the thread automatically.
+    const { thread } = await anotherAgent.continueThread(ctx, { threadId });
+    const result = await thread.generateText({ prompt });
+    return result.text;
+  },
+});
+
+// Or use it within a workflow, specific to a user:
+export const supportAgentStep = supportAgent.asAction({ maxSteps: 10 });
+
+const workflow = new WorkflowManager(components.workflow);
+const s = internal.example; // where steps are defined
+
+export const supportAgentWorkflow = workflow.define({
+  args: { prompt: v.string(), userId: v.string(), threadId: v.string() },
+  handler: async (step, { prompt, userId, threadId }) => {
+    const suggestion = await step.runAction(s.supportAgentStep, {
+      threadId,
+      generateText: { prompt },
+    });
+    const polished = await step.runAction(s.adaptSuggestionForUser, {
+      suggestion,
+      userId,
+    });
+    await step.runMutation(s.sendUserMessage, {
+      userId,
+      message: polished.message,
+    });
+  },
+});
+```
+
+## Other Components
+
+Convex also provides other components to help you build reliable AI
+applications.
+
+<ComponentCardList
+  items={[
+    {
+      title: "Persistent Text Streaming",
+      description:
+        "Stream text from HTTP actions while storing data in the database, enabling access after the stream ends or by other users.",
+      href: "https://www.convex.dev/components/persistent-text-streaming",
+    },
+    {
+      title: "Action Retrier",
+      description:
+        "Add reliability to unreliable external service calls. Retry idempotent calls with exponential backoff until success.",
+      href: "https://www.convex.dev/components/retrier",
+    },
+    {
+      title: "Workpool",
+      description:
+        "Create tiers of parallelism to manage and prioritize large numbers of external requests efficiently.",
+      href: "https://www.convex.dev/components/workpool",
+    },
+  ]}
+/>
diff --git a/synced/convex/docs/ai.md b/synced/convex/docs/ai.md
new file mode 100644
index 0000000..1f23fc5
--- /dev/null
+++ b/synced/convex/docs/ai.md
@@ -0,0 +1,62 @@
+---
+title: AI Code Generation
+hide_table_of_contents: true
+---
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "https://chef.convex.dev",
+    label: "Prompt to build an app with Convex Chef",
+  }}
+/>
+
+Convex is designed around a small set of composable abstractions with strong
+guarantees that result in code that is not only faster to write, it’s easier to
+read and maintain, whether written by a team member or an LLM. Key features make
+sure you get bug-free AI generated code:
+
+1. **Queries are Just TypeScript** Your database queries are pure TypeScript
+   functions with end-to-end type safety and IDE support. This means AI can
+   generate database code using the large training set of TypeScript code
+   without switching to SQL.
+1. **Less Code for the Same Work** Since so much infrastructure and boiler plate
+   is automatically manged by Convex there is less code to write, and thus less
+   code to get wrong.
+1. **Automatic Reactivity** The reactive system automatically tracks data
+   dependencies and updates your UI. AI doesn't need to manually manage
+   subscriptions, WebSocket connections, or complex state synchronization—Convex
+   handles all of this automatically.
+1. **Transactional Guarantees** Queries are read-only and mutations run in
+   transactions. These constraints make it nearly impossible for AI to write
+   code that could corrupt your data or leave your app in an inconsistent state.
+
+Together, these features mean AI can focus on your business logic while Convex's
+guarantees prevent common failure modes. For up-to-date information on which
+models work best with Convex, check out our LLM
+[leaderboard](https://convex.dev/llm-leaderboard).
+
+## Convex AI rules
+
+AI code generation is most effective when you provide it with a set of rules to
+follow.
+
+See these documents for install instructions:
+
+- [Cursor](/ai/using-cursor.mdx#add-convex-cursorrules)
+- [Windsurf](/ai/using-windsurf.mdx#add-convex-rules)
+- [GitHub Copilot](/ai/using-github-copilot.mdx#add-convex-instructions)
+
+For all other IDEs, add the following rules file to your project and refer to it
+when prompting for changes:
+
+- [convex_rules.txt](https://convex.link/convex_rules.txt)
+
+We're constantly working on improving the quality of these rules for Convex by
+using rigorous evals. You can help by
+[contributing to our evals repo](https://github.com/get-convex/convex-evals).
+
+## Convex MCP Server
+
+[Setup the Convex MCP server](/ai/convex-mcp-server.mdx) to give your AI coding
+agent access to your Convex deployment to query and optimize your project.
diff --git a/synced/convex/docs/ai/convex-mcp-server.md b/synced/convex/docs/ai/convex-mcp-server.md
new file mode 100644
index 0000000..8f5f16e
--- /dev/null
+++ b/synced/convex/docs/ai/convex-mcp-server.md
@@ -0,0 +1,63 @@
+---
+title: "Convex MCP Server"
+sidebar_position: 300
+description: "Convex MCP server"
+---
+
+The Convex
+[Model Context Protocol](https://docs.cursor.com/context/model-context-protocol)
+(MCP) server provides several tools that allow AI agents to interact with your
+Convex deployment.
+
+## Setup
+
+Add the following command to your MCP servers configuration:
+
+`npx -y convex@latest mcp start`
+
+See editor specific instructions:
+
+- [Cursor](/ai/using-cursor.mdx#setup-the-convex-mcp-server)
+- [Windsurf](/ai/using-windsurf.mdx#setup-the-convex-mcp-server)
+- [VS Code](/ai/using-github-copilot.mdx#setup-the-convex-mcp-server)
+
+## Available Tools
+
+### Deployment Tools
+
+- **`status`**: Queries available deployments and returns a deployment selector
+  that can be used with other tools. This is typically the first tool you'll use
+  to find your Convex deployment.
+
+### Table Tools
+
+- **`tables`**: Lists all tables in a deployment along with their:
+
+  - Declared schemas (if present)
+  - Inferred schemas (automatically tracked by Convex)
+  - Table names and metadata
+
+- **`data`**: Allows pagination through documents in a specified table.
+
+- **`runOneoffQuery`**: Enables writing and executing sandboxed JavaScript
+  queries against your deployment's data. These queries are read-only and cannot
+  modify the database.
+
+### Function Tools
+
+- **`functionSpec`**: Provides metadata about all deployed functions, including:
+
+  - Function types
+  - Visibility settings
+  - Interface specifications
+
+- **`run`**: Executes deployed Convex functions with provided arguments.
+
+### Environment Variable Tools
+
+- **`envList`**: Lists all environment variables for a deployment
+- **`envGet`**: Retrieves the value of a specific environment variable
+- **`envSet`**: Sets a new environment variable or updates an existing one
+- **`envRemove`**: Removes an environment variable from the deployment
+
+[Read more about how to use the Convex MCP Server](https://stack.convex.dev/convex-mcp-server)
diff --git a/synced/convex/docs/ai/using-cursor.md b/synced/convex/docs/ai/using-cursor.md
new file mode 100644
index 0000000..5a2db61
--- /dev/null
+++ b/synced/convex/docs/ai/using-cursor.md
@@ -0,0 +1,127 @@
+---
+title: "Using Cursor with Convex"
+sidebar_position: 100
+description: "Tips and best practices for using Cursor with Convex"
+slug: "using-cursor"
+---
+
+[Cursor](https://cursor.com), the AI code editor, makes it easy to write and
+maintain apps built with Convex. Let's walk through how to setup Cursor for the
+best possible results with Convex.
+
+## Add Convex `.cursor/rules`
+
+To get the best results from Cursor put the model specific `.mdc` files in your
+project's `.cursor/rules` directory.
+
+- [Convex Cursor Rules](https://convex.link/convex_rules.mdc)
+
+<video
+  src="/video/showing_where_to_put_convex_rules.mp4"
+  autoPlay
+  loop
+  controls
+></video>
+
+We're constantly working on improving the quality of these rules for Convex by
+using rigorous evals. You can help by
+[contributing to our evals repo](https://github.com/get-convex/convex-evals).
+
+## Setup the Convex MCP Server
+
+The Convex CLI comes with a
+[Convex Model Context Protocol](/ai/convex-mcp-server.mdx) (MCP) server built
+in. The Convex MCP server gives your AI coding agent access to the your Convex
+deployment to query and optimize your project.
+
+To get started with Cursor, open "Cursor Settings > MCP", click on "Add new
+global MCP server", and add a "convex" section to "mcpServers" in the `mcp.json`
+file that's opened.
+
+```json
+{
+  "mcpServers": {
+    "convex": {
+      "command": "npx",
+      "args": ["-y", "convex@latest", "mcp", "start"]
+    }
+  }
+}
+```
+
+After adding the server, ensure the "convex" server is enabled and lit up green
+(you may need to click "Disabled" to enable it). Here's an example of Cursor
+configured successfully:
+
+![Chat UI](/img/cursor-with-convex/convex_mcp_setup.webp)
+
+If you're running into issues, confirm you're using Cursor version **0.47** or
+later (check under "Cursor > About Cursor" on macOS).
+
+Now start asking it questions like:
+
+- Evaluate and convex schema and suggest improvements
+- What are this app's public endpoints?
+- Run the `my_convex_function` query
+
+## Tips and tricks
+
+### Install and run Convex yourself
+
+Keeping Convex running is crucial because
+[it automatically generates](https://docs.convex.dev/cli#run-the-convex-dev-server)
+the client-side types. Without this, the agent can get stuck in a linting loop
+since it can't access the types for the queries and mutations it created.
+
+We recommended that you install (`npm install convex`) and run convex
+(`npx convex dev`) yourself in a terminal window.
+
+### Keep your requests small
+
+The best results when using agentic LLMs can be found when keeping the amount of
+changes you want to make small and git commit frequently. This lets you be more
+specific around the context you provide the agent and it means the agent doesn't
+need to do a lot of searching for context.
+
+After each successful prompt or series of prompts it is a good idea to commit
+your changes so that its simple to rollback to that point should the next prompt
+cause issues.
+
+### Update and reference your `README.md`
+
+The agent needs context about the specific business goals for your project.
+While it can infer some details from the files it reads, this becomes more
+challenging as your project grows. Providing general information about your
+project gives the agent a helpful head start.
+
+Rather than including this information in each prompt, it's better to write a
+comprehensive README.md file in your project root and reference it.
+
+[Some people](https://youtu.be/2PjmPU07KNs?t=145) advocate for crafting a
+Product Requirements Document (PRD), this may be a good idea for more complex
+projects.
+
+### Add Convex docs
+
+Adding Convex docs can let you specifically refer to Convex features when
+building your app.
+
+From **`Cursor Settings`** > **`Features`** > **`Docs`** add new doc, use the
+URL "https://docs.convex.dev/"
+
+![Chat UI](/img/cursor-with-convex/adding_convex_docs.webp)
+
+Cursor will then index all of the Convex docs for the LLM to use.
+
+![Chat UI](/img/cursor-with-convex/indexed_docs.webp)
+
+You can then reference those docs in your prompt with the `@Convex` symbol.
+
+![Chat UI](/img/cursor-with-convex/reference_convex_docs.webp)
+
+<Admonition type="tip" title="Add more Convex knowledge">
+
+You can perform the above steps for https://stack.convex.dev/ too if you would
+like to provide even more context to the agent.
+
+</Admonition>
diff --git a/synced/convex/docs/ai/using-github-copilot.md b/synced/convex/docs/ai/using-github-copilot.md
new file mode 100644
index 0000000..d8f3f38
--- /dev/null
+++ b/synced/convex/docs/ai/using-github-copilot.md
@@ -0,0 +1,72 @@
+---
+title: "Using GitHub Copilot with Convex"
+sidebar_position: 200
+description: "Tips and best practices for using GitHub Copilot with Convex"
+slug: "using-github-copilot"
+---
+
+[GitHub Copilot](https://github.com/features/copilot), the AI built into VS
+Code, makes it easy to write and maintain apps built with Convex. Let's walk
+through how to setup GitHub Copilot for the best possible results with Convex.
+
+## Add Convex Instructions
+
+Add the following
+[instructions](https://code.visualstudio.com/docs/copilot/copilot-customization#_instruction-files)
+file to your `.github/instructions` directory in your project and it will
+automatically be included when working with Typescript or Javascript files:
+
+- [convex.instructions.md](https://convex.link/convex_github_copilot_instructions)
+
+![Showing Where to Put GitHub Copilot Instructions](/img/showing-where-to-put-convex-instructions.png)
+
+If you would rather that the instructions file is NOT automatically pulled into
+context then open the file in your editor and alter the `applyTo` field at the
+top. Read more about instructions files here:
+https://code.visualstudio.com/docs/copilot/copilot-customization#_use-instructionsmd-files
+
+We're constantly working on improving the quality of these rules for Convex by
+using rigorous evals. You can help by
+[contributing to our evals repo](https://github.com/get-convex/convex-evals).
+
+## Setup the Convex MCP Server
+
+The Convex CLI comes with a
+[Convex Model Context Protocol](/ai/convex-mcp-server.mdx) (MCP) server built
+in. The Convex MCP server gives your AI coding agent access to the your Convex
+deployment to query and optimize your project.
+
+To get started with
+[MCP in VS Code](https://code.visualstudio.com/docs/copilot/chat/mcp-servers)
+then create a file in `.vscode/mcp.json` and add the following:
+
+```json
+{
+  "servers": {
+    "convex-mcp": {
+      "type": "stdio",
+      "command": "npx",
+      "args": ["-y", "convex@latest", "mcp", "start"]
+    }
+  }
+}
+```
+
+Once this is done it will take a few seconds to start up the MCP server and then
+you should see the Convex tool listed in the codelens:
+
+![Convex Tool in Codelens](/img/convex-tool-in-codelens.png)
+
+and in the selection of tools that the model has access to in chat:
+
+![Convex Tool in Chat](/img/convex-tools-in-chat.png)
+
+Now start asking it questions like:
+
+- Evaluate and convex schema and suggest improvements
+- What are this app's public endpoints?
+- Run the `my_convex_function` query
+
+If you want to use the MCP server globally for all your projects then you can
+add it to your user settings, please see these docs for more information:
+https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server-to-your-user-settings
diff --git a/synced/convex/docs/ai/using-windsurf.md b/synced/convex/docs/ai/using-windsurf.md
new file mode 100644
index 0000000..9e81fea
--- /dev/null
+++ b/synced/convex/docs/ai/using-windsurf.md
@@ -0,0 +1,57 @@
+---
+title: "Using Windsurf with Convex"
+sidebar_position: 200
+description: "Tips and best practices for using Windsurf with Convex"
+slug: "using-windsurf"
+---
+
+[Windsurf](https://codeium.com/windsurf), the AI code editor, makes it easy to
+write and maintain apps built with Convex. Let's walk through how to setup
+Windsurf for the best possible results with Convex.
+
+## Add Convex Rules
+
+Add the following rules file to your project and refer to it directly when
+prompting for changes:
+
+- [Convex Rules](https://convex.link/convex_rules.txt)
+
+We're constantly working on improving the quality of these rules for Convex by
+using rigorous evals. You can help by
+[contributing to our evals repo](https://github.com/get-convex/convex-evals).
+
+## Setup the Convex MCP Server
+
+The Convex CLI comes with a
+[Convex Model Context Protocol](/ai/convex-mcp-server.mdx) (MCP) server built
+in. The Convex MCP server gives your AI coding agent access to the your Convex
+deployment to query and optimize your project.
+
+To get started with Windsurf, open "Windsurf Settings > Cascade > Model Context
+Protocol (MCP) Servers", click on "Add Server", click "Add custom server", and
+add the following configuration for Convex.
+
+```json
+{
+  "mcpServers": {
+    "convex": {
+      "command": "npx",
+      "args": ["-y", "convex@latest", "mcp", "start"]
+    }
+  }
+}
+```
+
+After adding the server return to the "Windsurf Settings > Cascade > Model
+Context Protocol (MCP) Servers" screen an click "Refresh" button for Windsurf to
+pick up the new server.
+
+Once this is done you should see the Convex tool listed in the servers:
+
+![Chat UI](/img/windsurf-with-convex/windsurf_convex_mcp.png)
+
+Now start asking it questions like:
+
+- Evaluate and convex schema and suggest improvements
+- What are this app's public endpoints?
+- Run the `my_convex_function` query
diff --git a/synced/convex/docs/arch.png b/synced/convex/docs/arch.png
new file mode 100644
index 0000000000000000000000000000000000000000..bac0f610e162ba24cf353986875e402889f7bdf2
GIT binary patch
literal 438776
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%0Ay6<_R)<UGv%uw#CY+0&|(g*Ilo
zM@>cbqyaV_@TgJ%M$bX9z&wU&OqxR`EWhrcYzT8WCq$c9Jam<ikcb#aD&q?hlo>8m
z<M0gV!1j*$0gVik$06s+l1j?+IdbYdoht_Y!nWWVsOhtg8`M1yCyg*AiA1rd{1%o#
z7F@)&x+!4pRf)}t>(5o=Kz~~LyAA|un&e=a`3r`OgJZxH=)G(mmRrwq3E*e}<T<Q(
z@)_9^u1$LrWuF7{83pg~>DK6pD6glt6z6Y^tbSKHLV0rvS5<UeBx-H8G@@={j=HR@
zZx789?YyEg*1M;IdUnZKj*{!IEcQeGzK0)22@KEflX#<HvNw_N&~xbU93EqprIrt2
zICyT;4Z~e4Hn?!nfAot9QeBWF`ck5s*qx=YP-a*R1{JTv;dkM<<@Q$M<6UN^MLm1s
zbn%6hbWCc8$Bm{jdSIn=U?W8MUVxAVR2-!SJQ|&5!akp^FF;U7?kIaXn!|8dOj{9Z
zVwUtnj{=rOFCq;7ZEshX3_lmaqaJ^T4G069l=6BufiP*atE1*j9LuZg{aq2$YcZ;K
zO@5CM?!T>nxGdA_M7NDT2cCJlOQ`dyBd^lff&W(!RRR1r?~y4#Lu><Y9+q-s9bbdX
zejm@>I#yKnR_{ls<PfrC4}Us$H7n(6LNC3A9xW0P?3o7asscq(>~2K6SLE#M#?uxt
z;wv0oTdg-^U;No$SG~qa?Wly;l31@{4a{2@sSGJ*E^N#%SXSaCz1V|fAD}m;l0}|P
z96BR=KMa_GWA5?<W~xb2sd-E1YVCOfs6x&_1WMN1oo|j{#xoaP^A<X`3=vMWC>!l`
zP!?(IIdwi=aLy;U`JwRfjds%`g^wYJuMXd(61Xiuoq#hY$qYvc#Pg5XO7X7Y$$iI1
zC6nzwOixevC>&o)WAtE1Wc6%~VWZdjH!UY|N#|+O9)Du>3_Xgs;pFT43rq!oD^DQ_
zvdI?Y?_6J21GXK7h^hy39bg!bL5gZxO9!g7RuI)tj>gCR^760S_bx{%a}r&A&gTxZ
zHbO0L{eLw#3!*#P5jcdu)oFqAC-9HmI|nDg?d4VX3s<A(d+I1FSH`A`qIAY=USVam
zP7R6%s}K5}zI5pZdZW*)UEvn|cQ?+@I_IbOv)=z?diqX!Pz?*wK-83FuaG?S35C}4
z2uoyqKK`F;03n;c7aKZ%GAIuYw^HJdWjh$)jZ@Lg{4nv+wD7ghoE0@;tC<6DLd9TD
z6kWx(V<mLE1pBC)?1d6I)lBdb-Cb?{ignyuB;dtQD+5t)uW?DdflO|?<(G{CaDF(S
zs*ELSy)dQK`})4?X7(pH@Aj;-V(8-cSxllX_yZ=_IRE<TMw1Z<kAb5x%X*DOYrc;i
zhOOcRZ9&sj<xQb!LD*Y&;K1vk_h+rEQ5Ho+qF$0Nb1D<KBr@!TDOQ>}3#AmHvO^Gr
zzegBBZLIM}C&_aw=cOlCXL3S&W6>L2PL=F2Nr*2pRK2lQr6E_8JATyIok4K%;kNnA
z$^Kc<&4>B>HS6gZoa~J?C9lcPZs8kl@Ba$OkhvpWig0=swMH@dpj&-KIZ@;VRe4pu
ztqh*`QzMkJ8W&@HqcT+^qX0I#&K*10=XRP5iF-fQxx~Zp_ccw3ARj({l$$#sJo)Z-
zqkVWb!PJYzs8;BAImm>nICD0gWYs*ATs*l%I~}E>Ck2UWN3jiXm<5#GmZ?&b<4Y?A
z%&xw=pQPDy^+F4q**@#GUM<M{j~UwfEoMHSzk3uW3+THDEDA9sgW!#hL$#(&f|jD!
zK735*GijmJULlc@I4b2v;rHG7Oav2pOiqr?P2e0NayE2}OL1sb((+=jwTS#<XM2dv
zE4BP^AMrTRS4G!KshTJi{e2-Pa;4ThnK^ey^2T$LLan`BM@cH)gGDoaTkJmmOm2*e
z$nZ<D1qhbN9Si<QSGsuY{i=i2=+d<Ns4$2tZdOHw<ZA`yi&d2xDTQkQu#;3#48zR&
z_Evei!L>FQ*Wshr;w6a1QxqPIWp^rt!bP!ebQHS*vf9LWcpK+#i|zYg)NynwLKed7
zsxA2TcHu?8+b~nAeYa!1^2k=W(+r)=Sit&<_!m+DFa<I{kuE=SdZzz+@|+h}de#n7
z_?u{qLc9+KRcpix4<%oxsh^?EuOg9p$Ijy92xj~fV9fJ`WqC^dg~^3Gyx>vVubBxG
zZceu-?DmNAxL>~cUe-&cjwoc(1d!G2PSr_Ty~D8tCXyWgJG1%QVhD!j+gcV>PBPv=
zI@7Tn?Y{D_<Kh++o^+l9Vq%q6X+R6$IHRw=L;2yeV`DR)j~L86W)td{ou)Sk&vwT1
zvw4NZdRMz6)<E1zB=oSROzJ1KuDU~0b4{fRHnH*Bg)wlod>fMUAmk(a!NA)JRw%Tt
zB*}dsaut>*v;Q!gGAoy>Kv?GJsa%5{HrFrxsFxNR6cx2-$2k(BkzX~_Kk;*Y{hYFU
zy<_-FF|QypR}~`9ks<QRc*rtmZ0oHu@>Z$RkL5DMj)W)I+U<lzE#n8TRxa?o7Xcex
z*vaQ14xdieqR<ZP*s<)bJ3e$gZnxF>{nzY~Ec3P2cUPl|#hR}T2b0<MU>YAl$C4kE
zrRlha>j;RKv4ctuU0(HC7K1*fiu^(Whh+wrM8$~|35OQ^w=UIVMM-CK^MLa(o2?#B
zsikK%KZ&Pj&HjNX^!JkQITq4sP9&ahIVO=_XQ=FomN4&Q?*!Eq6uH7~5RfAZIK14V
zmbtyv?&3V_hKjugbt+1(C)7i3Aoir4`-YYJ#<#1PwxubAUAmw9yO$Fe!AD^J1_jih
zj)6)H!=%FuZawj==VY$lbCIFhVEcWu=hXt4i9TB%i=UU<0<YhGjc{1>97f-0Dyj$3
z$M5#R8R(<*g0)}zdU;^*9Wc<*73~9>Ii(S8kBj^r8?(IzUb3+{W9I3$Z}P(95UD9V
zG!S!IF-cz}MI<%1dRRv{WScM6Y?&TNB=6Uj#N2GAhpj?ku4HRlVsu>ZY6q$n*l@Ce
z$1N1}S`D+QW>U;AC@3Vyc}dLJ6?*(}(~V$Yw~^MYz@_nSb+@As{JPo*%aAJ@kgM9j
z^vn+MiE0D@<k8c)l5aS#2tn_p*mK2_4ee&%`Tp*wG_Exb7mkXa{GdE-q{4H@_MXe`
z-S#OyJ#K={_Xy;pJo`Ws5+^!Mni+{<4*}8gQVI6k!^-XP7E;8J8}BoFa7YR)JSk7v
z{k$0fn1nA;YMr`HIzA!0O~wES-!c!JqvJHgV10S0Q)>p{y|tLw55{zFqJU{bxM%X|
z@gUm<cDL_`hgSX?0`yqe*y$kcvKu4~=+D<V{&K#s@c%Ut0@(4~i@-dEewa;wa<eYD
z8>)(8b3Q*sStf`#g{h;ubC&#_HCXufHQ+lxoC`x@lMY!Z6T$&`a#J6x;c_7O0A$UU
z*26U0k&JHLr0Fb+(_wcW`~7nBTmT<h_+net-hikN32kkUc`<`^(Hc-vo>jMV`T?oM
z79_msH#MWzk=$?PQkhR01utLj+IM}82|xRCsX)Mg&t)$<XCYpV?qJ3AJ5=nqp!c=z
zh9m`ls|^_gCqi`r0waFMy&jJ;6n}@}ZYsg~JF&0L3iZ^!$GxTSnEnoqv}~Vs17`~3
zT2j}#Oq@r}$OsyOuj0AFqL*jf)YPmm$Kg4#F^i$B<-<LkW&Vca6*xyUmtm=X?v0N=
zP!k+i681X3TLedcM1!obTo@^r?8Lc?qmbvo(XFiwjX6InvE67dXkn6MU9S_nw=Bh$
zT=ids1+hvP`*L+3P$QQ(v&a6G1+ZTA_66A2X<KF`@_sJ0T(OFBTFX6Ed?@le1G+QF
z9)0;|<J|czCoaN9L8({C^e|q+tGlJGd5g<0TI^_Go*+>%%YFKM!C$sE)S<uawmWky
z`kYrxxs@7Un64UvD5N2uBh#GzopGRH!|tXex&m8}XlKcBF;^vQQUj7)xl=$aLcrK?
znZ{}{t9&-}*t)C&BPX~H)Fiz*vgxZJl=nNx0pd258}#QKFqy)DYroQ09BxbIbEb(u
zT>g9*-*^0E6Q21Q<)4%yv{s`__SmrGsOOch`#9N#9V=*vE3J({(jwjjkl+lb_`_@?
zm>a<qre1~@FJSV2>j>-s?B0%xZa0+2!XA@dTZ~rZNjwxWh0<2$3L496J12u-N+K^;
zK3;X;MmjF}B6ra9-SsjyZW>!Y4Ok1gH)_GL+$QW@retriRj!vpC1mYtE)$k&vBAHH
zf}CPY^X?D9A!P5@+h=@?V;03aiZ#3hl030z3<ZTg?A9SCd^Vd*qAyqOkF7RB=Te3H
zK)EUMh((dy%5yUL32qPFl1CoR3xtDqO)f!Q9H~_i?dS;CUs6jiJ>u44J-->gf%C-Q
zEdc2Vw6`M3!|@!J46&5_AXQbba?%*-<2QrEVaq;78sl`M7nGEuZ!Z^N6<#K2-FY|Z
z+}VH16uJ5kgcu|xS0jp7LANLVwit<I;N48F-cz|3LaOukImF5jRkV2?ollVHVT5rG
z7&D`86!J}@Y;t_WBEtdsr`Te%$RRXwRU}iKNjzVt9(r)AB()2niebLv=V=6I>DF{0
zOCv)G9Y`ogYE*$H)2t)@QO9V!EWX!5LdU|G1;z_Jc#yJQ;NuS|xE}y}Y&fgglnlUt
zNqA)!uSvmKW{W(QcnH!vLX$-rnJ!nyGkFcWL#f_C+b)LdzZ2&eSrSA=w%Fu4z)+z5
z+;%Gnf>zvJS4&k~&4|eJ@o&40j1h7*DZxN{>dIOkRdN%Gs3dQAbTlm#=1}YKfN%M_
znE6=~UsD?-|IC%sRc`>Ty&;aLcfG^ow8y3)YOLBMm&)}{-`?KLRKxbk_#Q5U_$_vW
zoh^UT`!K=@k-^IcINcKJmoJse_%s1d$_Qd1vYz59G_P>m!SA)$PSvmvzK=z(y<2-}
z36xpr^KXaHbtUxt$bGQE`Exe0Dwn`%oX_&4u#A`-rkR?<&yxwYX=$yFPU%K6fn8xv
z`vC}SDwoWL5UW=^F4!3u7_<x-*ZmN8o=L%gJzB{ZoAdYi9%L=h3g*I0lGD@F9<W95
z&l%vn4i{GnHLAZGtHIAF?(*)+=i#Ksbh7xYb3Jy6S&aK|BIO$gez7VB988AN@HM_!
zLIEtBiqgPhuJ?W7nttRwE=3~UXnA+KEYApLiRg(}5}%XIdGWn4u2dW2wcrthwIY^4
zqyqn@R_+J349#LllHJ)c<r-IU;suNN`Kx4V_B^4W*esH@)p_$@=AL(!?AhPebcJnf
z%A53jhIx_6{l8-a1<Po@N_*`!f&`5BcCv%8Fk60C3pmPFg9f9Jj?*BW=~Y!@O}SmY
zijaCOV6o4<osjxHcIqXGC{KgG@R|5I7qTqDx$UHe8dUpL{8oNJKMQigzGqKXDzKJX
zF1!Wtq0+}6W7A5jf5g;LQBJxeYIJX;xKjUZEva@wzEt3RT!7D%%xe4t5Ne7^;RS)z
zC3|3hJl@X7luT?lNuCNJ;D2J^r=o!&jC9yRRNPx`e6W2Kf@J{9C=6v_@1KrMb%Rt5
zBBk+D;Phtz;`}dNAU2?wHuMr)3p^|aQ=J(J*RiJP>`+@OFSEhGZ8!TuLLZQZb^%e}
zo>kp^xei`YYmu8&tBsNOCp&Y(lS40OAjjySXG06UyII)$9yat!HH8Vq4d}AaVPbz!
zN_5THhkXy@zi&%*vtUkkGD*~amTsU{)zK}%Sf5dtClL^6Wo|^SDi(rY)E4|8u$NuB
z___);oXDbD@BuxU+x7!8%klRih;R7Q(JN7?s_4tgHx4A;LxI_oi-iXuAP~QuNg}eW
zlf`_CT<La)fQXf#WuM&IF)Z!kq7S?|PhAqHZ?8_q;|2yQSr+&n_Xj_1vxI`=*CgVv
zQLXf}M+hxiU4y47W$?;&$YVWpJSsHno$@#tY9sZY4AuhIZa$G!|7&n4Nb!O@Sh?8P
z6dc9s4`gYOI+Jf0sdJPk>dCBkOuFB(1Y70XZ&I)o)yQJb>kW=Lnoxg;3=Yro7DMT=
zd^qE&aUh3$RW1#9=V|pKr&^_Lv2ot80#zDItkr%WOj~9HF3B)beoZ`$MQ7v#WN7G%
zswTwa%f66|0G!TkJ*un+&oC++0g~F|LHeQs5b~1Me}B$xI1?9v8_;hskeKTv_Zu9D
zeJY13z*Ba!Un~9K>c<R@crSZ_bCBg+)p`e`d2Y}byHtRjvaTkIjj8>Kb%{?`Gh%u2
zFm65tYvTWaH`I|Y+AqPOuYh>OppC%557j|$f-byi&bkg?SoTCt+F%LJ6I)D3kU6;F
zbDuK!Yv|eygD0CaP}1D1Q|Dr1fawE0U<N&*@p4(h7#s>m8&qNeyfuZ3>HT>u4I!1$
z?E?G=4PQ)wpk`b978WC9!1|MRDX7g{{i-yCXC6h&vD-U>;3{E^-*j066SaHnopI?P
z3fgBYlZ{X)WvRQ(2$K?ck3Qhh8bL5yFDJF!Kl$>iYFb1e9_rvo{wzd5+m`tFF@!K$
z%=89SL~Lj93y1+P$qtzag=UP(@WR79QCItucqWxYjGuPl!2|{d{sL(*TT`XpPJ_gt
ze{gE-WZT3Lp1qo{FKagj2kxA9S`=-vAMFD8ppGD;_Nm~Kn+Y+F?*^U2t+fHt5&WQN
z?6)EUAD*tkZ_v|`P74H5pg~75umeD{I)V7P)Dme+{fv*}e^K_1fpK+vA82DXP8!>`
zZ5s_5Hfn6EQR6hWZQC}Rq_LaEw(idR-gDkQ=k|QK-zGDYnb~Wtz1AN;JlBSjBV~{P
zZn_+D5Bc-~sQad|KuPQ8VumqX-e*TOvNQ=(uJ|gE$kR3A>xx!2Ih*vyeB~a`Om3Hl
zJe`&#s_uT7hy2P3Y_TSi+-CrYFrb!b?ph!y2|eE8xWDz?b_>XT69AqQ3^)_u*|p;b
zh0kd9m2zUW9q$_7{Wp;srd5gM$L>?i(pwG%UQ5iBGwP6ay}R<lML^$2Cp2zjb=0i8
zyL&*5Z?#fS;F=>j0YnL=Z{Y6z>kvtl+2X-E1k%f|fv~i-q_6-rRuI1jK)t7Ity4$!
za=0M35b@x+u4qy1hSd7|Z1LbVuMau4x)sf?jGD5`clVd@yu9?0>l0VG(7Vf&v1=GZ
zu)oLG8x){o&p#?eYB9SqS<P#>1>5zzg?9lRdEO6lX6ZeGsiljqm|f0fDP6RHwX~PK
z#e@N%by7J5077vu>f!57rCI$n-OYM6g8c4QCLDvRy5e^=k|F_JD)A!|(4Na+Cv{R@
z*0#qJ*5KYQnHMIb49B5Kb4U~HrDV2s?qw7wAQ!sU9RC<hftDNQy3>t>;wKIY5!eO5
zo^#-OzARLbVK!X`8w5QAA{$qadjKx~stWeyr=E~CDp(S9?&oLy1a2|Zib-5ZZ@X79
zN-|GE(bnUJ<uvs-6qFRJ-$OIHoc>#pztB9hX~C##F&SVM^pU3c>QBpe?U!|M+>1|x
zn{2+7s=RMWx8+{Ljlo2Ocb~9K!SbakGxhjm0rbdB*1DoO`<)OBJRQCEo_98@0fyY?
zdN)n_ymU2Q`2Z}J%>~wggn{+6jrUQS87XR<Z|<}z9urI5{6L4_z%&)z?_6>A_C16~
zh0cCmo1F+i!vJ5`;OX_kU3b_%)z?vZvt*-0@I&dtIg`Hya2?C;jt)hiWBu0M-U?;l
z-T<_!mMS@Z4nQ8vvX85zF`*h-j6cF%*ukG2y%RAj0Pwyg=Et2tXJq;6QGWDxZiYI=
zm+&Yzihl%k8a&cqVRO9Zxr_VS_CVd5$OzJla5V+tdzUYv9$t<Jk1+}L2wyw-P!;~9
z<aso0^=z6Nfy@KM!kRoTcFkK1{=mQdDHcOj=f6bZ!V-j&0jPvf=Y4NAXP~dvK8t1T
zCWhGq?qc|^wWBNktjSKHm`L)dfdrAE4OzPT6Ruh7LlPdl`xO|!OVk5EUE7f^`ikY4
zQV8GbZ9&9z)NoIONI!vW()-1=`x(#{*RGwr2J!?dyAl^pOMiWXw^-_)YxwT4vcF-j
z%pV6JJvvZADUc5!;U;~z+(W?ML^dN;RD>4H`~0*9DDg@%+WxWt3Z<2*r5L5`aER|Z
z5UO+8Jp-SDldji2FUx!PZrAxTi@gJJOY~Yo{N!>Ckgfq*2ih3(03i*$FeEf|ILqMo
z)A20!5grzJOThkSt`2Kqyva^8JA)A^RLI0t6AJ(jZZQ?-7t{98VrG6Qh-m%@BxZL9
zNe<I=g=%5o;L?gk4%s3m18!=RO00~M(rOh{Jg>l^Qe-<%I06B_<bi3cPQh^xO<>BZ
z(W7g`MfV;VkvGaL=+vfAKD|yYQO4EV6+rdOMcXai0{$UiN~*f4Px`#iw5L>hZ_)9U
z39ZF4ZTSGMmhh_HaEwV5KD3-6h4@#A;GaJ~*7LXV3;KpKy02kZu$5-rCumzE*CE=V
zrDW?N?P*R91E}{p;scaHe+%VS4MJ4^vAg$$i$LRx0t*XksRX;DFJ4fFA;}-uh5R0I
z`s7b~@^|z#=u5{muS3!%hc5I{a50J7wb!T=;5`+9{>yevMk9_tm`Fb0M}E;aek#2x
zO?P!*_oy+tlx`xF(lH$taQ$?das`SX7W236b#xcHe3u(-D9uwB@BRw_;;3*n{K(L_
z<{tK7IIo5WKhqu74ID$;B}pCcLBjxh@~9QZS-F{7Q$!d<#D&I1GQyf94x0|zk5ygP
zwN!|;OJzYX&CK8M-*6TEfiE-#AKC{JTPhBWGADYRTu}>1SZ13k5HubK*$>}M17s4*
zb|%?$?zw!LeV}$G2cvh9VctNpbP8ZI?%&{OH~v;@n2<>uFWBb?Y=HS*4rZ>`<FU&D
zyd>QKALm5Ud2aPLcicA%Rc;b3522{j`IY8N+1(~#(0jRe{-SCns_G&SgdKn}UX(^J
zIKT|)Y(Bv@A%7FYC)YS^@*$ChjsUk8-T;zS^`77eHa^69tbNzDO*f-7<jP~P+kKmk
z^CK5u^}#t5eBn1)#aM|jX5*2ePcB?Rs4NZsAWA*~7R;gKRfzB%T4Lk_-e>_=KzSI3
ze)EY#{hWCh-3GPys$#zBmpGS~Yh@ar$>|&sA>~JUnmqvqc(Ap2YU4o6shd5yB!qGV
zVFgSPy*IHWW9SdivYX=|oiv1^j6oICORV&Ea-Qc9ZH`SG-=NO$f`kIjH~cF^syA<G
zG6<a2fs8u%&6VTV?^Xei8%r!en0*ajRO(DCDC*`B#ZBEm3#_v@Jjhu(jxyVnXa#18
z1N#J>lYYB?1)zD%SwOXs-H(*zz&t^YBLW*31(jQ;YzmX~LjyKBorOy*@kr-Tj1qI(
zU~SFw26uA%mI#;g60O!{f=KK^`c4qLi;U<;&Gs(`_p{6{*QPbj5+{NFZRBFt%3DV%
zKeAbb{+25O(6zWOHM+Deu6|k$Phw(XaE6r47#`}9uQmDK^78XX03D-vEN2?EY2U_m
zkT$an0Q~pxCRK<s+Lk@z{NuG#kv_*YkF#PzXSK;Lwl}M#)N9q})l4Hb-CD$Q7hvkG
z?mN5S3`F^?eL`+r2F`-~Hdf~olvOLRAkc4(kx`97ApSfjO|#2ibmM(C13$cFz|t${
zHwW<JeWHU+XSVeMmOpK;J%T~tUGuuaoJ#>iw}p#Y1%Xok0i;U7IJ<nTj@tpuBj@MJ
zk4##V01zOI8%%w&ij)xlt%X3g&{+y(m3B0~HHRQ4B+v?<>wCKTTxHL~nVk-nF91uE
zl65c7LVz*Yd7wXYwAk5%#)7q6T|mU$+l3?SYZinA)s#3TNmvNZ*aYyAE8i+OecX?D
z{=?3|JmI?nQv03<OmGY1fV_TAknGtH88}GsX~aYLhqRih11vFA%&`s>QPkg$!(Pki
zh{!^36;0el!w!bH(p6D(Il{ETivHRk(Rfbo2;UQ2_=#R89zMz+F?l@s4uRrRC`S=Y
zSKT><2zkh%h2U*2np|mZ>`x%qK&)ZbHEc+Mc3K>_ab}GJ?GiQkcXpNPgNq%6)Lky!
z)Gv<e_=a3Z1j3{)kloz?FxisNBAed35nHTis5YoeFoOb8;nSUN?<_dvV1x-pQkOIC
zD9}@uo2>lU4<-)e(-Cv&q0)*zuP@J`MOC4?_&Mvqj<mMVbO^yG`B4n@?o-HmKlE*k
zp7V`Pjpys+>*w8@Kzo(PN3sIT_w_Vq@Jcf0NY$T5X*KIMc`AF&RVmfPAnORo*l5_N
z5#Rfmmj5jHHnAX==&)~k{j@^rD%a9M?$Ddy^!H}ghBTqRw}UI$)lUVlzR}%4I6Np0
zuX-MM*KLtjcW6S-?n!}3dylS+rj7v_Tc0s{=VdMebl-0~4~LI#D=9qRAxs4K0&TZu
z@-0v4ZMChPKAjAM7*x&4bK2!I+c}LPk+q)>q+Z-@M*+Ay<2jJ#m*+<rApeZ-F09-E
zn)nqZsSO4jEmE-qB}2us$ukcP_m_J-t|rqQ%tD~LNRrahF&}hYg#hAG9&9}lY!~;p
za6c~i6YHfqDU)$~Z-E7qGNW5(P)?0iX$6HufUKgH`D~4DpGE)RcL?`fHDT#8*HE}@
zYctD>VU`0Ez|n+4%krF-w$!Qe#RaDbmSjdHhK#tNMb%<m8$f!!6~aGnhnvTE5?Um@
z4!1AonIyi<SbjrMmP3{&bcAYCKvNU;{&C<Q>pnE-Y&{Yy(ijR?MnuGW3_gK%Qt4V@
z7S!#fF*zJhQ!Cni#tt%FHFuW2-0V<z5HgAh+ov^Qjb{kv8rD^Bd^MI8-_Q2OS4alr
zk!3)p-s01s5+R)5lRz1TjALC!N8s#TkS*@nl>xe9md|gT05aG4pXpIRLqm-R-U;i&
z2MT~K#<q*4!T)@vBBpqkhV2Y>f5seyL{xD?G4N0^19S|P+Ih3#c^P*b&3b+=1mrI7
z`qUD9cXslSVIcb~aULCmqR1-P!rGykvT#IwsZOK&>ikTW81GX-OInn4W$B&j_{G-0
zhf$EB<<+chOy{Knm-}S7v;2Qn)HP}s_+M~h0C)^d85B((Z3cC;mly<Phz|t5#&Q+A
z5Sko!HE^%vx@Qp-(q<$57tqj10GiIlP$7QbH1yKT0>qaHWfGo9&d+%)jVg`iZGh%X
zKCrvY)EL9f#kYyW_-khRyaX!yge3Hn!Q2IO0VNeQrU`f;g6RGMlz&T)g^!@^0x90q
zx)eg2X~8N%?z&V2fjkl@C=0zO^6fTMc-*vyqGvZe`vA5GO?C#HydFoNy2N7LTFe)=
zGSP|peDZ*<+10adTQt2#B15znjZf^@<s!=&3(Lgl&3Z>HiMEE!>Y?>_=iA7{@Hzn6
z4Xec89TVfIcvH?8Y%+y&ZMOwTS6^v{ovmz?3t9T{3ktqdfCYNnYJu=)^dNr1)@>;p
zJb{Ox*{J}{v^bOn;OWmfZ?ZuML%Tq35-oMH`E_t!=534_1$=sh7GkklVs%1|#KGSr
z<n+5E<>%MEelXBb7)|B0%SpI0gV~$|2&}x+hgL+;Muf6`c5grz{_CJ^E4`zUZCnNo
zUSZ3nR@H|(T<Y?}E7jB5&HmA$@=y5j06ukel4i|?+S|7)NAGa+>qSa_h5*Usf+tbw
zwvPi%%hZ8uEr3dWPnYmt0`wjU-=2^j7kM{P(hU_*TWw3H_+v{bDk{^t#p3y6OyB#X
z+R5_8f@`1=u@9Dzw4WU3_@i#M>Fe1CHv`+;SD=+r3U)uA{5#`>z@OFGIiI<j2g3p%
zG8CyHSEKUqGk|2z8Q%enyqY)s7w<W};d9dYQcElmm3y*8B^@2(M1F$T0c<P$d*Flm
z6YVz3y>8~Xb&h-eks%)d5-CY<Fyf`!?1=2HVte`XBjRs!a!-+W{+^hOH>{+7Ha7=9
zVLJrw^f$OF;Rj!Uw#W$JxX^w9AFJ`~(3m+Jd^<dIoALdkK2_TGJSHZ=Q&#>YB6jTR
zQob~UzfMBki(84fbS{>;+9^+RTCo4Jk4S2%L!RCwkEdJ%lVd|O__0*rq}mmd_%j4Q
z7n=@Z1uZl4OdXc44lfffM<2?aP6%Yf88Zl?oa+gOs{c=eftf}C;3iDAGVrXNuVYnT
zT8(}%Ov3S^px*yl;+{A4K=6rN{hCpUuEZ}PAJ$6Ir#pp#jE+xilA$c*tG676`Ux+f
zclNguWR~sM^|$AtK$DX{T=RY-=S7#-ccz3~FAGXKPLetvVVu=W-G4s`{({+MSMOuG
z%m_F4X+3?;Dc*;S#m-4*i5<R=SacYG;Jq;g4<z7(d>6aF-CKu0R?M-`6ICQ}T~cVf
z><`#OP(|3n0`=#FYNJ6);b^n#?ZX$Lk9GRppn4pmHx>4vO(yLyg(_3F-KBk-<D>0I
z^Tu4+(6ndSpOV1|zXT)_=QhKp8_;TC&P?<rL!AFaz+I-Yne>*`n%gJx(taOXHDx;o
zCbrztF1va>eWX6ieehg&^oh&Xvydv2=I><)pxeJ;0qjF}DU{1309j0bu_k|}$&Q3f
zM|f1&mX$Z)iS!)<X|2h4g4^XU8Q@TkcRi}l1G1nml%QiVY$@!$_R9^&HCEbbM=Q;v
zBrYcd?6AUbzK<=gpcxbZ2S^TZ%YfHoA8vSK>}-UR_#!E$^SC4w6;bx%D10k^g%EQ!
zKS0w^1x<{9hXY-Ee%i4+Q`(Ow-4w~MTqmid&3#4-f{1#?3S#gf;_t9A;Dev!e0yMg
zP)#05Z6Q#aT+d_L0A#6hws4$Ad#5YYZ0QB9=QWa`=Y#QRLNNg@TaQZ|owoY>Wsq)g
z{<C>sV*>z&nE{xflU+$RO(H-M$pf;7Ui0`kz`hK$y5a?+@cC4y1L|L)TY(;i$@njK
z5E5JZ=d!1^CoeMDL7TUjgS0`|t35cS$#CspvNE&^_rdSK#k!=?r{I)nL$@kj2+@Mw
zr0>rA0O%o{$==UWnhXH%AfEl|-MtLS&-%Y>^%WJMa};@=_kVa<N50))0S#6-`flzp
zAUPfyK?a;YODDr|q+Fi%m6JE!L4P4d{Vy=5O9hx>SLx8*f4pM@mc*A43gF;Rd9(vw
zk9_INqJU^i@i9R3+i8%BIv^16)&Y2wyFiiI{@@4In`%4CmU*g#lV*`VvTtxmdN2oi
znf!e-N8owN6$>-F!ry~?H(_8C<n10y{|8`N@C7M}+o?p)xy|KN_grJSf?IYHrQ)~k
za=c)d-U7e}i`4*ixcUC~DPKXRJg9ir82i^8_P;$TXh0^oDQdu1```9~zitkMAdTRm
zKT6adYnGL1|6tL+DiHEL^J@O%n*RFDg4slZQK*5xR4)YoG5UXnO#Sg>8}Mrb8v8zG
z{Cx=i{#jX5NLjWyQ)$xp(0>m){{DM?8-XQxmVi0>|7%3iu-^ih6qR8xqQ7mc|7AE)
z&Jx}QqOPGBx&3`N{`<fA35x)$NZ5hejqty2WPi-gzu&Wll4aYYZAklH*5<$8_m2mP
zX3*dmDI}YIe;=*CPBZYNFBCYS29cMTGYEqRf%=b6{M%3a^9>qcet@OL?_jCTfXJ^f
z|Gx&NGy)h-jb*I8^S_sL{>!iZ_CI(yZ>+zsqd(T+pKqwp0%lyNzAyty{_pqtpV#!q
z<4y3+|5673F9V}N2Lek`v7|By_SdH2-`5BT3N$I`|7Yy{zKUfziu#7*>Zq3t1V}C_
zgD7(oD}DtH8>*{}8V(OEgjF|P#6h712ggvTEXNlc2$YF&KZ!Y7%cQ@2<tOo}kfj2b
z7!>*ISK0#c9gIsrQ~H12qZiR#d$A?bk0xY!lE{PU^8lSbX&4tcO>~ecOLQ!l(7(!B
zv6iXHS|6!PM`n)1@no)0w4%(&EjRxayQSC!t;ng=G(iy+^v5?5W<sOUX{o-<?iqNU
z!g0_>9|t!a9?C}hQh?)QY3XvaGHgmIB@9!5_DhQoHOI}~*SVaqSHi^6;ZdGORuc0`
z9E}}*@@VhWny$}Nnj1h-As3fUq_ip#aOjs^bk`4~ilXTtvvmk2SI$<IYM<_GJc=oY
z33=c~0gGqeU5#T>+mQAnL&~D85WharKUnARsf^vJ-Meagx7)Z`w03;$M9TlEPI<!g
zbIJu!g8O4R00=|Iw+mvN0Q2~xBGgQ-2)I8M10D&?GJF;(?j|M$fcd;YvvuNoS8>8D
zNnciV$TC(LdAR~xVgK&@LGU1iZ>;fragIVA54(A!xYCJvsLA$(OucpKG%sX|fNH?L
z$0_PemX`|*gNp9gF!afeLEWKf2h&MO;T1?twpWkEhA-7VJiYVJ;u|x@-%om-rTZ_0
zl<N(v98Zzx)3r@Jyo%MSK5DVk(pxm<-IpUan{(2#%HsdN&iWBid{~!^t;9x|W-C3&
zf#c3zO0wB6ay<~4&VNXl_S=BUft9O2JACaODntq(CYFw^%5iPiy~G)7OU&3+J=Vr%
z7h`*sSB$Um=lumdhJ^%HKJ0*-KEwaL04Pb9XjIZ4FV)AQkd4*;V9@K3-4u;1t}!$q
zI{PuMAY-dv<<4p0QvSX9@E68U5s@a}DnqgBmvkN<sg{*y5j|648yME(84XDOhnfHk
zj&<#NU2sSUnc*4Ze1l;8gT0ylu!|qp5o9dAUXsD|{-@t>I99UR$ZXbpjQp+)&vyzt
zrS)yqU6Y#7eTK@+84kSYEkgo&vA#}*MigJHKB-*%Qi;#gON4%AOr57`>IwPIC*F)E
z_ZzAkNPT_f^<8h-m0Oj$obW&sI82|*ZH&JDv5JAMX5)ZVaI<gDZO!e+zgJ11uOQIH
z&jT=QDA*}{t<^}l7>IrVJvvJ~5W6MVH`WyH27Z!zP9(m=gy1E}YVo9_)**QW4z#?Y
zRWpc}X|ePZ`g`c;ce~pmU^huA*ZH!lWbMycSx8jhOj~t!4<4>nn&lfL@Y=TnInVux
zGZ<khN;D==^wH}?DwG>SSxaUlPccMeEnF(U2N=OfbNXJozpw{I&S)|Uff7z-eTnN6
zH3`Wb30#KTkqrIMt08{78mA7ox<9YR)wKz*c~boP^($=mG+Ks8lk0sBDLI9-qTsxn
zlq^5M8;z8Rp#Ybb08hGcxaxzL<<__e68!9FjCJ*!rXc-Oho{t*`V(0zdwCpcFlwIX
zE;c9;AoOQ!RFX1cpKpugdkd3G6fPlD2dRdg(sI3@nK@K*JSyv^^Vh@KRsq<#Zo@zR
zF%z(8epOYB+S8(jhB=~QV(3L3x^n5wj{7mZ*Vj#@`_XP?{N##1ep?Hh^IWfx5uEys
zy9vMB<l5j9uB{!W*qK9KkXlOqOece^^i*6(l;Jx?T%ZotToiDag^mDPD4#lMEa=;f
zCkw*e7n)C#;$BPa9cZ5Z_p~Gf8923B<Z1ulE<q%8y}=uS;#f>t8Z97LUWKlP_H&}v
z=xvM@yP#D|;`#gu3=j+WU2COS4USK;KiOS$PCt`T<|TbL$<yX=NC$tCCan34)$Rp-
zM^Ck;WcKgb`SZaVD)7}FCS`x@OZU?6SW=jh0IeJTw-`7tFK@@fr(!;RFd-`b%uuts
z`WTZ?b#QuC;+TEktv<&>N_F4NiSPUevXqQM?1`MaWP6gkJ@0N)*<!tTg0(jB2Zm2*
zN0koG7J1(J5B9%SutIpM)P7Z@(j<RixxT3rjkj0JFS(euTx`f!7CkrdZILTwi)~?Y
z+7&hl>LXYq(vElDLa?s4k|?!l6!ke!EhAye`68`aOshZvGl=q8V~c*#nQ`K{T6@`2
zsXY)4@x4mzE$K;u2nAyC{!q;KnL;<cVx5MXI0PCxb1ZXvRxT;^laEw~H)Skrv(>s3
z*PIc_oYvzb!HJ3T*E|-b1!Q-pyfw3NF7=f^tmZU{Y1EaNNKaOYS~)76L-Ta<zbLng
zL3uq6^k0%*Ur~9j(jy~bQm$I#(5W4A#Ln!}NS~i6+e<Zf=4bFzQ5DJ$-OTxnmfWvP
zJv6hn9>`xB;?zZRmvc*%%~;=4v&BE|l5wR}Y2Q4xinBlS=|$qL9M)NzeUze7C)Qcd
zus=vjljSX{Y?aoL6fkXV*6K|_S*{8+*H*3PF1U^aJBe{9zPY_X@ARbGo1I7*!O;*7
zMNgdf3X&Wrx5`(&H=|ObR=!TMqdt$uUBaXAXe^7rV|#7lBlrZlP9qkI!NzXYl0iHo
zCbgg~p4?zTbLVZTeVy2FV4s|Nxm~kas!wvVx=TEg8d+!Q%H@T3%VT=m#KxmBdJngE
zT{ABV?89}%tLl@wjUMF>vcixVYOB~TiACRFQ82WGC-Tx0NJdyr8Y4P~U$!5wxt(EF
zdJi?M3EARJAu@2p;(VkEW5I9l?|RQ`D9ocivGG-^jjN+z>&SkJ0<_n>);2Uh=Ifv@
zme*DDdN)6%R%xzA?m<U_JaXAzRFx@3f=o{J=y&^p%w&7BJu9mBpK44fsB<QBGwtrS
zU^tPrI5x#mVh|UqOj1ow%`*FpvrBQhD_0sNLQ`sqexbQORHtTOqe+OB{*G*a;~8|s
z?WwbcNH!d_8oZ+uv}ce@9ZyGge5e*1YTT1=>6#=OfF4`BH)CuwBem$Y({#k^DSJcU
z@N8LiNO5t-Dxqf~nyAMAeZ(cJ&UdtWw%Gn7*Bbir?QjE_RKr}VderwBvYHMFEx#C8
zn(-<5g#k7|Vc<gN0YVciQ-5T1G#=mtsv{LlngNE2Dq^z(yaoSJmA41>uaFg%&v5^D
z??xAbN8<BQ1J%#w&!3aFEBDMPnpm)0W>rwoHh6zM3)sC5?fH29iuo~aWs|TJdiT!x
z;z){0tt}4i`PFaqVq^m|0O6W?E_R)RE~e1hTgwJ+nGqTSxetzo9NGj6r@WQ9Yp&W_
zg3n^MBjVy|14fy;EG{D$2pjp(vLSCGoPqgevTD@sW)hfs6f)PTukQUN{XITUWVNjO
z^8RpdIEu#Gk#d`MJLBY5Qc|&~<$fc?|6;{u682(gVHiJra6ocbZ+B>9CP!SRem%<P
zJZWv`n}x)0^H$M*W^`lMg-z$w&%w;T9Q%7x4a*htV=su2i8V}WbG^Y7fz@8voMO{C
z5<dIhk6;fsu_IaSrG8iZE&}um@GaV)pm>$pXG0gDT*v{K94oJJ#LgcHXZ1WKZI(5O
zX>;nry|=ZC73b{EN>!W9idSoLbvTZY@3&K3j5kefme^618op8qY^Swj_NWexO9Qut
z^mD^P3$4>}`7PHf!gTNE>N0M_g5{FBwcCZ77_9-qToyX5W=olB@q*~mb*mbB)Dy4M
zSK7?W`i4b=MVlSWU|u6g%$xQ-7^8#?{u++8-FtB%y)*)^U=4Fa+h8ITZTk8BX%WuN
zBYce#*MKoio<Z}~n11P$17Rc%4XP+pypv;bf6N@Mz=MNltZX6vhi8#(6Fx7m(L-aw
z)YK~{I=>r2dtWP!J|vrQ51E<tZ`>y*&QZ*q_+<%vwp+gLuNoS0uOkVxG*(~gm2L@&
z^K6)p;FhteCW|q5J6@k_PV1>Pj+onAi^7lQbWeR8lcAIAxAd@lmYqs`1=q7k2|xNa
zWjXj`*Ek;HC$rlW+tp@NltCkAV9kh3HB1wZ7vrN-@ue<&zr;#r-XB~id&#mO`h9j{
zmFLiV5IWR<o)P)dr%ss*hw4lP8ma+E2G$cA9d%iw6xSKoU*t<m`<E!q<Z9w^IkC%i
zJQ+p!Pi>xLSgFy^w=B6w6Q?m=%w1H=c1G_{W!SZL&H@m`re1nLQAlVr01VyaA33Yw
z2~1L9>`n(?!=H&(G!!^x$`II)TU!`2*~sr4nC%Mf1xqUwIm|{iDs3@jYT&jCUk=}g
z5z)0p0-iKlk3CH~V&pWT^>++ZM&GH=u3QFKjmDc~TlYk$j!Xegt*zG*56=ritOn&^
zh-iVsBN8c2#~6IFFZd<h4ieTp_RmFjpxM6ZW<3?huxb`RjZ-gDocC!ay*gLaSq*5v
z`58m=zC5m30*Yh&-e#E@;yI3im@ss@J#iX}>LqMnc2$8R-RL{9*ls~E#n9OYe#JJ)
zoo9=8dg%m*cJ~g?Tlu2}zeuFPljbYy&}}9?iikg_x(<>yPD13mkVL?MJ0m?VhLG1W
zFQMqNu3_E;5!-&7u1TXON~x{&XpLeGArCjMuvn5Igr%~?z(%9ASzBHQu7z*nOX$0v
z2>{h6Nsf59N0?HT@cunQ+@8%L8Rh8+H+zu@O-fa%iVCt*o5SmPNm37>3459_G5&ev
z8;+$I>U>SU3|itzsP9+te`Y^|pj<@y-Yki+7$5&BXHg*x3Y}|!8xBK>o#p;*=zZwU
zkI$NQ`yA#d%c8fU+4WGBC}&$pxM;+DsaHR0^7FUc3_`Y6d*a0?St1Ouq+KJ&LuD>S
zLM4I^Ml3fW<8clQ-@AIa7EStm9=oDQXLova%9R@o{|Y@`efpb!E?+=6ysOmT1j!lR
zTHs^B>vMj>?sSdeerQ2AH!hEG;s&aw@HtoZm@@*r?URa0cM!xEPQ-2bC2XC^!ZaBr
zkyy+|3-hM%Nt;qUi;QcJr#K_bgr^h0sVE9)$FUmJ)v*lM7~d0f*|~NGpuxo!{alj%
z7J=Q;2xp|(>X=+4ZT~p?$`Tka=o<OF%svdnYbdx{vL!#PavF-~qKfAPA0lvR90XWB
zu$q&Ssj#GnA~vFF6HlOl^QBc_wDq-J4Tiv8r}Sjbe!q-?OtINI0%JKVd8Ts9eO{L=
zd<cR<H(-L=K!&$^b})8Fbw-G*#V0CFj-SXlhepOpOa}xJKZVU~UG8D!Ice<CH8dfg
zVd3Q_R(bx&t{2mrjE_zYrNQdQC=MzR=P*~K%yjSy6a+oD#n^4u2=Zi$GAowrU=4ai
zX0~ojJzX4+lAWvOP<1NJiKAe|u)z@+w5cE034Gv*I%1r2Xta+&K@hq04XAPTChQYG
zxL5UCAc0;8&yEg1UY$A+pQDLkVvvHVMk@@kYjLGgDTymD;obgnm>Ncv&3X2O^#~k?
z6h&1cFia2(($E&h=#!iHuZIJH2bZ(I(Tn4W1)nb01+JcV)p`!zk63qpa43pyZIH4O
zN_s!OflfrlCH6i{N$9*wvEZ{^;a=gV)sKFd-Dc2_epR?IgYwjSjd`ra>Pj$hv2@rX
z_t&k6BOr)9mT4No9;B4J2<e=3!SRS~iiF^jrAunp{2vfu63!cMVvt`S#m7*{j4DO1
zl?~9XKI^vS1wHxhg*qDRRihKDAw%+NbJix0vP<=rXl75>F&`gNWgETdp+RT=7&(5d
zlPlOwX5AyQmW7Cqmkrw(X-Pl)zmxob_9}=}!I#%vy{h{vmw&vXFSD_|F2KBN6m$%A
zyVy#@f$mt%ycrB*&rPRE_|Ek)!{w@*QT5(rc;R9%L11p_duT9pK#A{MXh}Z(>az<F
zZoB<TEsX!UYkHj%AGg>#`QBar15q3t1BFxE6p=IWS0Jg6>#m@7{{%lJr+pV$wqC0{
zDY7*%|GX=1JSEEl-|^gJ7_=4hn3k~XY>r#@XgqG2T<@Mxj37$=tc@6Lf%C~?B(wSn
zYL;7lW8f1G=3;uCHowl5pGfl8nCVWBgf6ke$%FA?t(qxXo^?xv_!^H{YPZwsWveI#
zWvsi-%@<R&?jEM)W369Pd+T$POcyax_z5lq?Q-(u_&-96MicmKVu%!El}Ak6bec@2
zpf#VKgY9pwq*R&%$`A9^FOQIzcB$23_q;#S!`R^%Uw_4_d70D$&z9kRQ=f(97jJzo
z=Ez&D=lHD&!~h>B(j1Rr^%$OBL+V%x!G)vBX}lAg31sa#b;~^|0`DVk1<K2%A8}5q
z(B(aEOLEP=jO3(qFZX%z?DR5;Ts!m1-90?Hw&>}_0X(pn0QAX+j<*8SwMCHh3jHLM
zlGikp5l*L#?q?mfStF?Mxj<(i{kdA?lW#@TYjPDTpi3(FcEX-~gQrWY6Xb+PPDZ<i
zi=@8YQm~LbB8+r*JYys0hIGQ`{+#=83uhQEu7*9_`S{8f&r*?BP)JP_PhO%qx|KNm
z8q{gLLObarpevuBp)4A7xm%8`;*_md`$g_jl=FN^!3PE$B&8pZF-#}ghOXA>6}h}g
zLq?9(j_5L{jqA}y>`K35-8k^ZtdJ3!tv<}1#G{^N_qkTgjh$X6`<vF7K_{e>B{fI=
zB*N(R(EIe=YK5cr>ol28!okVBkul>`<LgLpmB%G%CNV)KsdIb3DQrg9+TTB_g7jaV
zF>+kzFqg{f&1XAuDRzy?#s(K1B5yYuoJvN#ylPHY2SUSMSIO=$-*1W-q6tC48%DYO
zqGz&pPKA7wVyS`P!Ww!0NliPf2u?S^Y{q&X_gH0S?K1J7M~XL5^fhD`gIulBf0RHK
zVA3WzD?`caE?@@7zz}h6tf$zA*~!S;Oo$SakF+|RxL#V%$)~{^2voQFwT)&G_g%y4
zOIp15*j$n?Oe>zIg;@PSYtg^=7I-a!Sz>zP{IrfPt|+9boJct$OcDG9k6`$U=*hY?
zTLA0WY)B-wTN|QAR-@Wb!N<2<WBKh;$5J^9acZiW+9?HdUKGRgA;^5S$$o1H<o>8x
z>0&!|60=rr-`%Q3T6X-wU3cJ~HJSH`TN@dKm-^{^+{0ZHniBHmmdxvuj3?8kkXW>>
zkhWSPCC+kIGrYHFj%-S&n(m!jIeh9_#sOZhDkGvs!uX5yz)b~%9`$p5sA%}=N9Icw
zt{M*ANmwfUU+j4yx}1qHK53ac&cme#KIQUE@vj$iAI)_rMsY&SMTkE6C5BLRxUK*f
z-5ZE$bMRDrF*24YC*k8YisQ(H&)y~S2F83UhiVu~#IO-<bm;&~O~Y=(F?S|E4$spY
z!l>TBf}IX9d5k=sjgjUIE$g=9>s0`HWl_Tg?ZH=wkn`mxbYQ12Tx_n%u4m852stoy
zPz*3g=HajIe#Q4f=_$#=U$Qz+$Mt>zgPV^f!!gqNSQChcj{aRJ_6t+NO<jC&oOk%W
zWu(e9_(-}+A57)MlS*k0Jr7L}j49+acpqxYu}0g+@JG*zax+k4^#O_@uUYTtObyHV
zk~=3D1+0O~_G7`A-j_0CMf|;p{|HSK8DZWEvy*Thf7D(`ZR3$S)18+b`zR(p2SfO}
zKyCX@RkHwy4>lXvf{}#y=fT@lQLKS+pah9NMmbO0pi`E>N*7VRJDs`C@oK$ft&`k7
za6|-}EzwqwC;dD87}D=s<29W9{b6N9bRfY(+&X_bnT6?md_?Du*hspXPdTP0x(O7z
zd`0k|4Tkb<7s<#1f~K*Z#t?Xn#%@_xw<n<F#C%+>(sUGstvG7~Gux?<G|beC<w@v@
z872!0D0LZ6fI4sbBrLsdO&sgdlnDN-Ye)F2LEsPbMXAcnM3?~5^S&~C2BZ>FhB1OY
z3WkUBW1}OB;GLoBqemmrkax-V&Q6PEI<;Yi3+k2I`znU@TY=VG+UIv*egPcwWm+sM
z=Uf(hN%IjjG7Zlp$scN=zHd4SUpgAl7UrYIj^pDh!{f(=PfErKB*)-wL1qiW=8o%h
zNTEx*I#}|hm;_69*FO1#Ho|J$oIK?hj6-i4m}c;oBX#sr;!^Grw?PV<V;=iMj7F3;
z>|bJqe#ij7yzOfsWciOQ7|<ROY;asQ*^W<9161{-RJJPdd0mHWf)#VcorYCS5J^ds
zOhF%vf?e&VYK&!ywdzYmB_xU~j1@9?i2&8e=zN*Pk^ZpATFjN}T+tAeFR4sS=x^x9
znC!k;KF_;vN2{$G?ACQr+7?!|fV}|<mZtdR8lbqM(-eKJTnyOH&H$ppFv=!S0n|)^
zfbIy*8#(TwO^?Aw76AN-zu}Ecvl*zUel7Anh>L()ewiyN-XkR^AKst+B?RS_8v_js
z%UsRt^U`L&5^Vf<;~Ek*nGtAQ=I;m))&hb}n`8SP00Wnu-_u7Ra66iSL1T<^wP9Vx
z@jlZ&deXmpGEF7Wd8R3=@;D1jO$K#WaKCDZgt7~g8wYA68CHL-JYN};wcO1=Yv&ak
zRMF(PQpHZ?<ZXqnQcnF$Z<2{{v0063h}7)1Eyl+{DKN?IXk>pr-Ct90HXONaCl~&r
z3S;-10n%*m$xUnR^`t2;&;1o=J-Zt;$<9?H?X4tss@aNT9gBCEApNAZx31J)C70s}
zae1`ItQ4PrNSAvRBbF!WtYxQ!ILhfG|5YTcbpMQbcP{_B(@T3{_%2ne7@r*5<s?6`
zF`?Iem>FR1No5YtWOhbt&g$0D#89}Mg(|U&-=|h<;ZbQcr+|Y)?myD$<+o&r6VtZU
znXl^6yl@M=98}hSa`oQ#d_>q^CKI;a*VbBMA8si`hohrr8i7*h;^txXuYZYeLl9c6
z#KCa)f<`u2T*I4!<dxy9m61042JC2|N;(?+ZEYVRP_(>qgJE_)F}emdXSohCYPA^f
zkxrd^ThMxt6>N?JAP3IM7Tr2YWED!}Z<kB+A!-??k>i+|_mqW!kj3aK6V+962tBr{
zl<4%+`7+Y3NnASLm`EjyP&#@izJh|uu8|Wq{fteb3#u+v`FQyzOV<_!%YnBx97`d0
z_@4#qv-f_&6lp~&g^|1uzkSq*x&W<*XX1<^_3{*6z&G}*zy%<^9lG9!+8>G@>v7sH
z0iaXJ{QPbT0k??nHRiMA$;`WK^#Ugy7}eF)_P47fd4PFvLE`#=JCXpcc7rVc%N=TB
z4*b=7P?+(7aIDgVOvX(&7`RdQ>^v*fW^p-TcqTwV8eo#29LY%^1mRR99#*u<Plkns
z#eUH9l+traXaWQQneBHZy)FS)gE)uFfQ|~X&<_msw<`{fb=Ip|prD|2mb1)cyJb&L
zmkKrde%qtj04iAyS*LDlRHTd<pkvto3cp<BsO;d@1i0t<3!1IY>1{6$hY#F;^pW*R
z^>N<`zqt8xZfzM~61F&<6^WW9$!v-$*W^B$ZFfXrwP_Oyv^d5|aU!cxk9^dL%;5T>
z)u_#t?ymJg9vlK(O37Gp;lQe^0{?;#jmvSyhuF;Yas2e@x4qE8hUL~d9J816CN7%h
z?IW$)&#d<&5W$o_my|jFR}SX(pC_Hw1gov)^z3beFT2&Z-M;QY<z6@M*=?6BJ1Xtk
z_<yTG-?_3IwAhJ3LHX6Hk*O;1R{x#gh>HI5Ub{#bru=mP&k>hV709aM-urN88raaD
zmO92-xXW~YH|nQWww?2?BDS7{yWG1U4tp^okUPMLeMO*QP=hTN?7<q`9&zZN^=PP$
z*y`5IA>GMOa}dDV`fYw$|3Qs=DbTiu7MnGc3`xDuY+&zmm5}IXS_iVisC53)G=kcq
znbmXAL?*-zC`hz;rS|34Qj;a!>6suqBPKC$rYa-U{pq?$!MlwR2+CN4qcVHV%XT~i
z?h5r@9s%rsq9_E{kg8tc$ZT$o6WdvB)?|f+g~4l|0b>G^c<N+R!d>S=Bz)fUzHLw?
zFg^AZ<9}%Z^nn00p%JUthHD!2GD<)(FBY&g;X;?oBG&y0xGbqsJw}>GuT=mp6Rkr4
zhMN}fi*}?=5#)0<{ymc)wnWY=<oZSb1z;yFej~5Z7EA`5u9N^-$oTZ)JOCPMr4{^c
z02P2{r569JF^;Uj*;LvF{7%$0xl!e^zP}Mw0fAdG1^#`?wl~C08c!mg0Q&LI_*rfi
z*E9XudtXe5z1Tm(fC*^KUgNCrX)i8F+X$1DAkQ&Y7vsVA^rOck>C$Y7GaBED^r?gV
zXmitTXYoh0M55xt&MXtC4>CCV$_L#IYC{M}N7^SzhkozfmadUCoDRRFV^suzx}Nx%
zCEq2r^IXxSiz)ZeYjU0P1ouKysp}ZxuqGY`@zX}N@yL)ftdQTzCDZ4R@a!RJwFPXc
zb?fS%RDpfK$~HLR%OUNvir#17CuM*)XV`vVjZU`VqX>C)=B(pB`<}R>8-);WpM;$E
zO+Mr0!KV3gv9TRRPTxfg%zkqGQ{&~uQ`4c0eB(kT7B$OS3B4K(B+VXMY5b2mnTy`9
zD$FJ$MAzK-{PaYH;~##z4@4_wIJ3$kpJR!MWdz(;@hjxeP2y~K;AO-HnQlXf3?cqt
z;-^^UBZ+uyQl61O2e3LA+TEA8JQGVn&@&U<KPt&Hc|F6f%r)1Irooq{D`+fI=R5HE
z_dRDq>**K%^B@Pn{ZFqAq=kH=2JL`9f;>95zThWRg}aeUaA9LXR*+MODnQG7G>yx_
z;it;p+(!PpHP|D_dlr`3EgvmD#jJ@R#Wqxi->dC+hLD2?cwE>$Oc*h`viOB{Ki+;o
zMkcapJ8ucccFN2vOf_}JJhU*c@-q`-8AA)uK(J{2>HT=zI1HdWA+nkE0lMl}MjRz2
zO@@7?LZ?G@0DFz?)Vk{P+W~;1U(5Ym2jE~pYyS+-^|+p@1hcPBNK?pdTL#a{13(GJ
zT|NbD^&0`jlpsR4=j(-?WYdi4%Z>V6z`mu#1%XdRO3-qq^EG0Cc6X(%oS@Vk?2rC8
zAtH2Meqr-U*t8Wptaw1Osk=BD%cQc?0{)WZDB~%Mj(KnT9^4OqO|cJ}&4GKbZyjhv
z%jpX=x93?>x3ft5i?dI=*ZytIrsl~{N-?CFOkpNhpc=M@zg{!cfELw>w=iK+6-z*J
z(PCLTFWWQ2{Y4;@@o0@0LVsCKXjtg-3ty@RPaGggl46O0&`gu*MkJy>b}#;1x6dL9
z$@fsBOP1%F)JLrgnB^Qkonp4z(xbk5`84?JZ^dk3onD=bN^v>q%qYhp1-%N8@YNWi
zQ)v`y(ck|5bp6CFuy#G;w9hf1&iwvptEJuhhc#EC_pnpHaMkti{ajrFG1uxNKoJS|
z<Bw+=io;7%Ua0K!Du#e`<`lQ_rhMDH*qBw1%PM^HeUx91$LB1?HQUiHdt6-CY4w`L
zD#dNQQ;oU3kMXF|j}*!?JD;UXP}XQ3HRn5Y+58&eG)#^UlUWC!TS_La{!vQ-3N6v7
zpeL`P<5H#fI;Ia-l|Mip@%h~EWO<dE?TzPpeKEco&X;K-=%RQ!{Z!y%n-H>mx8MnI
zE5DoB!HbB982_xw1{Dfmze7|&9s=;zF~u}U?u2DQ(@0;o67_x!0n+H#wzz<x=oii~
zz%}nsj3~hMs9FMD0Uh<4*AzyM6+prwh$%8l%vY{wWk4}{+-<%}=87+_aS=XY0(^Zn
z#jN^9vuWby%L$%3wf)6Q?!+FL?dseaK&S*49RCa!gkD^`)w%rXdckn9%E12s5A68r
zcv%9S*KBvAIS=3nU7U6<(tmBVj)(;mr6u1OeTJb$pLbrXT`<m+aP@F~kUnf>APJ+a
z)Hk)Fg*N2JVH`{;7Yf4VUoiYYr$#gL!?3b*p*lIiAnse;6tL+%89zGKOgjrw_<5fG
zT(Pn`VY3Ey6!jrtgMZiID>{G_rJhs5RtkVd0wERz|Mm`<5Hw%*o!10~DJj-UX?leG
zQ)oPjDhAn>@^(OjHMK#YqN_kQhIZDXivw7v^3N4^ME7=r4}Cq+87D};wa-@3H8$BR
zPocGws<won=h+)D-aDLz-uwDcMw(4KK!Yz>Lub5nkD+`uTf>`GkbA*cBlwASVK2($
zV%eu=kjXW+I>>MuiE<&$ZKuC#$o?WUrX|i|tTA^0kjOSgUANUYRMgPE+hn|gSw35k
z@2r1VrU5hjF5jDBdcsS7rb&j+fVfv!1f{9An*m1G&kLUevy<S{s6QP<2EVPAiT<mu
zf0BZ~h)(g$7;OQ0XtYtM4K=x|PgO^7x(~6`#epj@Eb?GR*cHnDSsv80^UDWOtSXdg
zR$AyZyuMSs13ro3frITYOU%(Nh|;M49xzeg{~bMAGJTybD|4IOB0w40r+XkGH4k|>
zfdclhfrOIsTL}4@nvUWdK!}Vy#cZvOD@)QJQ6du8Z-3U5G6#lMMCLu95dc>kdY1p0
zOQ<4h3%p+O9R%zbICMZPlY~~YMig02-=j|T{CqI;9W23}uNNd_%HG8epuEB8bPy~{
zX)6jG9s>LO`!Q#r5RjflpIX^7Kkr%O+R_5z3uq&AA=ay+9C#M<-{u7r?|iML?yBr}
zsqYR-E6JF^w9+I2oz61Vw)<b&(J9m^EuH|a?5;rBbG|H-h)m3s7)3LeQWODjJOi(j
zB@P}NlQpT|#^I9E{@0=b#vl#`M8S0XS2LgLu9B2e4`(h)e_d-yhvL0=Prp(cyo{{E
zj}mb=TtBwueyQ>lq8lCaMR7NSs(Hy3FaNq4xnH078xUVIUNFX73wYX=Yca+$II&Mw
z+KB6F8|wY#MZ}0W)dl_DF%(p>>9-62E(1p~y|F@de-B?tk|#qvZQgXJZTx(y*Igjc
zxqv3O@$xLvzphKhMDCQiyZcl$Xl%VyVoz38-+Y?s&lV~-<ZpotkzhD>ylqgL7@L^e
z2GwO$X&7`3JxQ$#S}@cnNhBAtMPkdRRade7Ye#Ws0?*Pat0l8=MnPH}!;{e`U1%Cy
z-La-o?EoiKr<26n^vvZ0ogUT~iTi)8hX1*j-v02*K`N^1feE+(l*f7>u5n2D1JM<-
z^!0lJT#|QTO^Y)Dl($p@cAhBAQ*Z*}9TEWngWT1nn<s8L`Po-+&+Pl3Mqu~UQ-I?P
zQA7gX&8Yz4&Upx+yP&EdI@ReT&=G2a8wf?&#)#&9zpEjHxp}11rCJfC&PcD*L`Xqa
z4FxMz_jO4Qss%@hKn38Y1s0gy8%*bj31_4Uh9Lv!e$Yj9*k2xQZhr3Jlnr-Rv#&6N
zeieLxk19<w6&8z0-AaDln++zoU8tfY%%Ag(;)j%pl<NU|fh1NlEj2Ct{5ubm2ye&0
zGo}qi71YJlC0|Zm-p_-bEH|8(U47oT&h*mR;~>T?bY-yCaxgVLxdI;dlPM<LNe9S4
z=r}!(kJ$%L{uT<{^=fr9m3nm%B07qhn5|vP4b0<oX&<!<zF!&9h|MNVTz%{4o>iMV
z_!sv<Te=|J)$H?&)jJ#_YWbe82W$}usVZg%*i#3&ylDjGcFD1WVdPaW$4NR4DSTH>
zGc`_dC{tpw^&xxKY6^Cn-?WNur@-jM-@%w;^|Zq4HRcE~JoAYP_4>habS1ID6KI%r
za|dSkhN)|oLL(wUum>%nvl9d=@3MtsGJyh;q~uR>X`Iz<2#Et?|GRzuYyR=gK+&~0
z{Y*^&yNVbwkZ^743}|TRCWaKsJErE(!^$6P#XbFkpD|1Uc4W{LUdyUtrz$FSRo`jn
zq#v*%0D090OSO`Kpdiqe>u508Hv=~s3bsZ{;Uqqf2F3Zh;)$y=#V)c6o#wIpt6Z~H
zA`+3kL+o<4tao1#fv|licB)i^0T{xmPmrAl?;%JJvKq|%D&)fho0>R>y`c1<R@;ku
z$5T13EBrauT*1~{x1G9|1_70oO(0-8_!UPE`mZbbCRmL6Td^^>+iPj@r$~}slXB!b
z-)yZT>aUN{>8WI8#0Y25?<T2R&<muuAHQR;Y57LPTj%g`iPYs~Rp`a+uXwJ0E^Ljp
z8^s~xLU4GHpG2bA7&ljmaf&e#1BnREY|tMFZQg`~Uub@$iDW8&x%Uy~n6O^jqi5er
zQMCD;YRHp4H71%by=8-@GCpMmNl=l&-ABQ;{iUIUXzNsPTwJGsZ7=d{t-bZ=Wo%En
zzevHB5<CEX0(M~ai8r6c)TQ^fO<4+^D&#VENvxQx)_!E+S@R2&^=2f>jHCMdGY*en
zZany#4a?IpexIIzi$2!r8DB-o5MoqG=>?c8-cM;+29ndFHth2`9{E?6+v=JbCrdqL
zMolzcAEvK&x6BaJv43}zCd~n&EWB_$sWs@-*f`YmuwSNg0?z<}Djp-bqVPWs*#FrS
zgi)%FA{2>Sl;_7?yZxKDV0?UhTu<9!Hnx<rGW6;sDY__&x9#lhL1`um89M3!XTgTy
zRWb^S-izJQ_|5?E)iBt4S6>E}`SbnR!aze)QwpN;cups2%Urc!7YDyx=aP6ez=!Z1
zn#)jkbSpxADgs*M8Av~I+bBvMsb89G;HOs6*NpD&t%DEE&w4)35H2Sx-(zENKCIP1
z;Ztb+%o6;+<?MGM*cIPAUZkz&Vc4oL3uupD-(7E~i151~7exz{jWYtvjJj58Z%_*%
zCU(YodEZL7g%y=5nQG+ZY2~Ra14fK8NrI4wT)60`$5pDZmi!g&b<5{tA$gqT2X(k$
z>XQNugoQ6e@(pVpp6a#BJ{_-$NGTjgQ*dpdVixdP@0E_G?S5n07HySiJaupJolTtL
zWVt{8ayLE*KX|X@>t6N&@l;7;Rz_mIiFAkU_@XG9J^ou*Td}H8wuEc!ytEb`*8R)v
z0d4JUvU$tn;M}N2Y-06<^wtyRGC_PipC26sJDmUT<u-zkY8Vs?yRiOR?-O!oZY%?C
zyy#VPM888nwW~bQ`gCYmID5->VmsE=21Z_seTPHXDHzEY-#+kz9Q<%}j4<9)zg}&|
zrd1=ML&#Di<6!H={DOr)vJ#X;Q}s<sTFp6(IJ2eOTRMgK-*?tqyaoKhn+7iX%3VUJ
z<N5)opbypC+dC#7Mw8W#UVt6YJ=-ExEbE4<9|C5Z<79iAPL)mKo8S8>X7JMnP#@8Y
z9E9xI#}J3T33FpOx3+$mY+o5%?mX>m<8fUxKtwH^24cV8`;D5*izd3#;v^$wBsz}r
z2$Zq|$zRvpWjwKtPAXWK=#G5JrszTv*pS9lS}zqF^I8A*rvb+oieRZ6Aom3JB)jwa
zBXhws8F#NgPz(>M-p3ZYZSK{o2=AjdrfuTGrz{@_yB_EBH8Ej4uJhZI&Yhw<E95nl
zjN_-W=wR~2b%F<wyOw+E``-mdhr@KzEp;SJX{pF<HfuPn$WN<b4LuEYk=bQ*!I`TJ
zu)08n5sJ<|6gAyzpzZyq4A)^xQWA16FqOoU;6`t4xCri>c}tC4b8SrC7o+T>r|fiK
zU1f>+Z!c?%O6@oH1h}PUFVxylx_S2T6mj!DPBWY>F0o9#_J=5T%5ijj3|(I00fprq
z@NR`BA6o?<Z$bQl>hW>;XHV8bLHDR0JyL+g{%}ZiOcv_LLnm*6?fJl1VWnJouk71e
zo39b+{?Rs+$ad#(iUET=1k`Km6BYQ3=G_SGp4r(U;5Jxb5ZE?jS}<xB?2OaW8agO@
z5(^%~15Ir2$y#$^=O2AOy!ihZQ{63ENnhE_9Tb49v+fJtv?2(Wzve#ItkU1}d<#D)
zsvgJGn(!*Mfj(E6{1dY^=8xi%$CY2VS|nXK<Oqk5wR$)R4A<tPAEeI5(sWGXrA?E`
z`xd~08Z5?eokOz0P(R7~4AjAW?3gRa{Xj@BW(oq=k0a2=iHRM25XMqgPThOSr`=nq
za2x1+EqrecKVZ{O4r6S?HxGl&v?*bH^AZO7|1N@m$GV6Veis&D72p$tK(I=ZjET=_
z>$}xp1k@pskh5zKHVzL-G*fIH9Ad?*Y&Z3)+-jQ)bHIbho%RoDUKArjLZ~h(czJmP
z_<>`KI4^=sF?wTvzZi&V&;0;~9a(wg&K?dsVrhj1ZM)+>^Ts$rPHSXua1^E7lpK@*
zRbB&%AG*?04g%#%6)PtX502&63cg>HdhZkj_>_xk9rox2UGUNV6?nywf}q`E*_)G{
zeh_$czxqu?5l`n$5gHMpHiK3j{;s7ciP^CvW0a|`t}EENep#rt%EU7PO~C7t^{Hmx
zwEZb&qU&&T)en`Bj|We23^*O~IKDf*+_*KxmhtVUCS^beSK<c!GH6k|J3e&wZ8+l0
zjmhbnU&3hne<*v)us)mQOBi=|cMBfe-Ccq^1b2tv?hxEHkPzJ6-95OwYjAt-%=Ld}
zo|)ZuXE$F--@lgX?&?!j=ahKBCJuSXy%W7)pR;IynPR4#>%iTX%&WQ)pJF293OxQy
z+F$d?YV!s2UA|0IsiY@^9c~$>UhNFCUV76N9fkcF;TUNFLOl`I$qEh?n+dm+Zn?R;
z-AymA3Bc;S&3?Dq%-2E0n?LU_M9i$<C<eu43qEt&`#HFLcwnH)4ccwO;cD~?%bHtZ
zeB0(PUTEN5T*oHd<Z6w<f!8DQgJn@kB+1pv?RDhgYSre`zbMJS><eZp@>w_Sbg!9F
z?at5|udS|MXq{IUdL3<5Jc&`H+nE?IbvW3^yo6=c?2gfGiS-bFO4POAJvmRWG&qI+
z$jJ!5W~1{PzK-~JwDD2zL^taClPe;{z-kKDGB1zpJn83k5fgYcIx}A|lg>vS%Ybw3
zfyoyQ8FCG7T|qAlv-ZcrEQ|(9Pv2ldOlPvLL5aiZa88VTBFePUPgGrA6)QJzaDMK7
zX^$^*;fhhI0)A6Z$Z%&5{_|7?i3N}Jk*O#F_8RBGOcEzzi3)cO%zF_z2_Rr0aO!gP
zVHI?`1cZf6KaBv@b0i|`a`aD#R<kHy*h>-PVLzO<hB7p9a|gDUdvwU(en{QX6vSPU
zQ~+y%N@p&l+uh$2wQ<60jin7rY$trKRXa|@U;465#<!jy;Zn8;6@q(#ct*=UX)<Z(
znJ=fU&e6u=oZh^q!v8ln8RgI3Au<HpURi^F5E>(V0wf_fbN%4-e-|?-<}m}$fO`;t
z90DAcx?fh7EnsJId>j)=^lU(chK)6TvfZJV%EGgIwJQp}N?zb#V}4ZtP8C_t@RCs+
zh)q$t%mRuPlraaEfY8UE^K^Z^Kpc71F9vU`h#z5@_@BF1DH4J&i$5<?6w{%`8SRb0
zrayVxVogX7dUl=hX@gki%L8>9jSvzS6oy~1#=Cx8JJLqQqeR8`=2zDnraZU3fI-|t
zR2st6F9~jE@%2@YeN^KeGITd)r-+L_c8&YzHf1(KZ@tdi^IO-5*`quJvTA;#)Pa%D
zIP>ps$@-~W(ihuX-@;L9SXnna)!=WB(-Q;8pfP0f>Vy5Oc)k=ww5<|6oF@-1Ua)3=
z6<TAOPZy}66Vq!Y!B8`!0?%6G1J#q;oL7kto5Gbf^y5;;uqdu{ebKAAYs5wI?61QV
zXx<PM{Gx{DI%Me?CFfAqBIpQ4d}3Ni(OqM|o|;Lc<Gvvz<Om+CN<<!eHZ`y(LnuqO
zpg;&#zlYk~Zs$F}S-f>ER-vJNAh~YfXnPVGHTipJF>Cv{rRP3KojT<Ln>yp_i<qO{
zSM#qq7Tdag+z-BI?wC2Up4?sGO%!PlgLqOhlNh1F#t}k_8kf%Qpzh|9wE%%!cf#5r
z36HY5Da4IZFv|G_<!yfyRmFz%R|rha!7K+#TBPsvn#h*v+Xv)uG+>LGKC6rO)gs|k
z4jVKbY3+`k`^-vT1D?AC`BG{SVq;^!v`!A^AH)-3jQqoE_=jcv<FxA+>Uz=oZM>-E
zd1MUS)H6|yK<xot3bpUMPwZ#zuHIffH2Igu1MkHSAFrQCTDIe$Aq3)xS67ZA*jros
zipSrof|0AMjSalD90wb1SCB+Q5mH*jt0e*Gf9r7i+svpS8!Ka2csPud;zGJz(#^MT
z{mHZz{5$RUR3rUn_A#$G;x~st`ODl19Wyfu6oN+*ERXt8vNF{F7+}CQnZtd>mUQ3t
zGW4x#3xv}(+&dZ{wPKc%Qk?hvK>8)0&g%+WT{=tp$U?Vt#YW>;sMl$3_1D4RI<Dql
z@#z}G)4sv$yQ!-jtkkL{?xZSNLn)*64b5ftyswW&<t11L<7*tyu?D<Q{P_35R_njg
zToHKrk(QbVaJAcJMc9Uh+Xwqb?$ccB!DKC6drtG!i}`h%GStG?BYzBcBg&Fe(}Cw?
zJ=9YWDBVY55q1!B;$+<8P+;VnLX}rJFA*FvKWOd4eG6441&5<lI9~=C?RfRqDwLW(
zmKhSg$1&jFz+SHHcxJgLoo{dx;m+;qAg|0y?SmL>DBq7Nd{|)moj9P`sfR2Ck23%k
ziN;8{1Ro{fw?L0g=xs2)z|=F?yV8|+HA~XwXl+K?6QY;;WQ||LI`d#AL(q@%;mX~x
zZ`VG}LAY*)R6}He)cHqSpT{DcojO7`aWi3O_RSmoRLz3Yz#XoT2DSP;$CrCWyM`<4
zI<84%!G?s$l_mASE5#_XM)Dv1()$U^?#fRLk*>J~-cXh?xFOEw=_K2?9hI`iqUAgf
zdS=6ZQAUaBV7zrHpVGQ?uxaI<ucxTO<gc;Kn}`xYOwut!;`K5_@2TozA}MOpcw@;^
z$w3&{aNsV+v|tro?U490=jY23{O*ZtxP3w27M)PuI7@O>pc#16;8Mv<wu*97deVr>
zLG*m{#1YE<pC2w(*)>}Zn$)Y!)^ln#K>G<qSJ(qv)Ly#+A}How4^p?>?R2FI>p@EB
zu~94o3+4X(WK|Ld3Tc$TeZOk_hPf+LkMs?wd0}=rRLX}j@CJw&bE^Qjmb8-%?a=;Z
zQt(~LEyM)(<Ms#Xq5RL<I7dsh(0qXKw+tQI=<BlePI6s-cxfpe5b~ri!dY|RyG=Sw
zFy8LF&ok-`l_9K~HyRP|2L!|sjEo@nEvkWiVM4;H`VNVqy^_Z39(yfv4v+y|9{qR+
zcbUB!p<|+Z20&he^e)q|gcS0-yE_#x?(D&_p;&^)x-9x@ER9hTVr*>e@s7*Y7~*%H
zbm4_U(eyu0fkTKIdAV4=!$HX%YB0=zuEPow5WSG0ts(<`h%5}z6O?)|E8#Q)E@z`u
z<kSMj?&LJO1YX|e3Q8RSaVb7BNGzwh4fCGg7+=gR>m2=>Q^aIbU$_z0e7<bZn{O7*
zbwr%`75Ylr^J_v1^37XB*!a6;6q-yzCSq-kQmvLw@pN4bMc$A}sU8!-G9)&VwayK*
zIem9MzVNSQ#BMtO2(44XqKmgHWll<EaBZF;77`rhANF29Xyu}(;7S(kC!XBCiV0UY
zR!FOVs2~tDoC}29=mf7VL{Vvs*i``^JlZ}YkH9Rj*9{yRJs{bh!5tc(f9LPLSH`=l
z3S}TI6n2JzDF=7IaV90D1yeX%gFwYrOdU99SeJCnCXRBqDeUfH678C3U~!J`Rj*;?
zB&_j=&8*6GpSp{H_rE8D9EHsj|L*XPhjNZh<%8A#gQ{vWHwq;e&)(B~u0RZ?iDyX^
zrxpcu|A5kmS}0!vqn0dS{zCz}>e%{^+91L?gx{gZ9XVrGA>b6>O?zzT2lHhc7w;iv
z$zYw`b_bryaW@h3eRIYj!x3u@<HrWl5ooG}=+H1fMB{TJJ^h|;rtLNvotOv(NMSLL
z^o+!f#Rf(G^^X4I2}H_(9JqYkyvwiSA_dn4!sfq&93C#W;J!9HA9Mo&)m_@67I6(i
zEiEno#5WuVrw)LqKA{NG1RU^@JKjZ05`MFI1FX~}I+a|W*GW?tulYOh&Z?!K08J>W
zI?*V^BHYWc&D)a&;RZ(KR=4hw5P++Nu2<+IP?*A-%tkC6JA~d(gQJvxv9(3o1hRFa
zgXag3H9$;5I4LM92F;i2$m(r1d%eF7CwTPCbo><frwbtjArlGW3oVv-_@F^R`jG(@
zNtZ{7Ku?+Y9ya>@H&&U+Hte0N3hX-3yuTlgg5DS{`W8ea_{2-2_>(G>df(9a4K>KS
z3|XFd$gCHqte^N1ak*X=Z<Xj1os1ym+TF--kiQ?Y3{Az2s_tME{Gtwr3(Ml#@!2p%
z2D8+l3#c|JkLyn1Z}S$8Uo`Mw!$(>UNm|KWodpmsKa~kyaqvaa&`k*1JXD`p)ho%8
z*Z~&#3uY`PeYpZye%d7A|5$@C{|>^b?W6mEBh%L>L}q|?ZV^!Y9LwS^9TP)msY;|)
z98tD>Ube0bOibLu=F+qT*k`6{%@yw!zyXa;C<dJdr6(a!ajTMvIyyL*buarsl?qH@
zI=F8VF=&x@7aL54vgFl39MY7N%MQaiI8<HZ8c;Mc`8~J|uwW&(;CKSsc)@k*1pv+`
zcX`=y9d^z&2P#eg!0VrCl=H3tvY{?TL4cy{-3hcs8y65}%_?O0+d=?$KC|@Zb&L%T
z`xcLG^UpILG4<}u({NhABT)JbCjH^@@^+Q?aw57wo(kKOWDXQ)i%bdX=Qpi~p>3mA
zXE7~09Eg<h?~qgyR6yABb})j+WKKJMq@O9VdYR^MFfv1OK;CF%oWK*z`j-<1%DA|;
z-!oAOl#txWdMcNJ;A4{0;Bd6NQ-Erm$M5O4Dyv^s+_H-WyogIG;8>fZT6Gi3%SIa=
zK9@i?zy}k6C?7km`4gQf4!~oov8^2sD9?ctl@cgHTmdYaT|jyYsX6QlApgw5NmU8=
z?BL>palHBV3oIH4fr!>%1Y!dGtmbB>A_s7$fZB1D`6N+zbTr0OKE!`aj+o)bmCNDn
zs;L=!IT~BV8Aw1!!{)Xwu8l2i_qJ<9Xom71yAGjnNY&cQdb4KBOMWk2)NMjd2j{du
z5HfSSYQmz~tt!U-GjAUQfSd*C6bny?n}f-NL=5UbfDOt&AH-sLX|P`%3ep0w>RYWB
zD!Kt0Y!E+^VN#MV;*RHY9nB^OQUYE#f+=yxmMV{zt1Tsf@31+eZmr#`F$X^uAgK`s
zQqcUdLI0!%DV3_*3ZeTo+O2`<=;&DHD)L=HczAlk`J69Se_Pbmg(1w0=W^VJsAZeh
zEzts~V~fPUeBse;agmm`76(+L5wV%{gEQEzY5M_!Eu(qT4yaT2g^INVS#<h~`SMbi
zmqTMwBtR$8;XKP?;0d^$pn-qQaH}0Y_<+Rn_rm)NK@gv3{ZK%r;{)<@CZ8u-G$F6T
zPf^r=zjO_e0@~WV93EUkf14}#l!!uv3vI!^bkKKP#{8uGvl76RY_`(6n9zmw^@(W$
zC8+<4`I3N93i$`4Q-ahN>-pZV-H+K0DQ=#gmbrx35d%mxB4s(|@X(MyAWMCWna>39
zTfSw;Zz`(K9dqT!k%7IiVqJzU*>{d}s27QiPL%}HXKlI%&(n;-0>yNY&iPm5d3#9Q
z508(aZ~0#6qM!`!a=8McG<GwE5xb0H6JoLitY+Sf)X8Un!F|XUT;d503;W{=(4=u*
zAQvHt|Aip@ZI%C8a(}FV&i6O`%eemq87Y#?b2>VUy!*@;u)3=20WdC7Si|f$G&}A<
zwOx;B3S9-Ob2;zR%VlyPR@poE0!MWEO2h)C2H}3ghx0EUx&Zt1mo-L%w>bSAbtvuc
zT_ylW-VE*hn5g(WAQnJrjphW2p&w2Bo{^Q*03^=@0c@?L$mm@9w+{fe0ZK|r`o;A_
z(BBNRNO<#{pM}!^FUykn-!1m9vHS%-ra_eP@$(CMGl%I{OU7U!bJ(py0QV0H0RaNw
zw|s$)#zF=N&5WM!2rqwW7|1g6{ib!q1+Jqi(@}K?N5_D!E}^dsWDaVD7P`88^xAbW
zzOT2O{EfukYwG1h0sj6Vl-9tb1S$mIsffdNIWR7+F)KKkP6L#vw0d)YpSEcwJT}(o
zOdZdfEGZwwxHlA$z7p+Ixwe{<EZL`~+^#Q+7v{P0sZH0e0Jj|XzAw4lu!v*d``dkb
zg1Y2Ht{^hN&!n>YEiWXF$JMGA2+90X`yl`4!1vgM0pKJ*J3$9%F>op{%&%SJO_>hA
zkChjleUWYWIzSUx6X-UTXGl^1wVVHAZvJ5bkzqnbc<ff|bU78psR<PR=R{M+!oNy{
z<t)A;55^H=)01JCZP4ThDMP`b(`qyXhKK7ooGrV`!y|_rb+$EJU0)m1mkKK>eWgHX
zc00oZ_Nx}!&!mNqvrYdnw7m!+H#c=pJfxVAzb)VY|B_*$3yDJFILP+EMqMd`|Ft!d
zIYH4B_*M^cV{`uNSA@h#y5Om4HG;tlOn~kBzZ>)aVG9Tu!2kyy^IS3FpS}M7(pZV~
zPfL+32_Bfgy8VCKK93nfic1;CYA*D@j_!ZV`mfDfjPj=?sRB9Sf7}xPz4J;qU=&$2
z2<%qC5%(Wo{V$C_!2m6bQGUcD1^&PGmj(e?NQ_XtdeZ;5$rXa2g#cQ93ZIpN{ttiW
zzjq!Z6a<zUPBdouuUY#q<NMct!wdvk()L*v2K`?*`D@MLM1d<HBwxbzzxVH7zxStc
z0Gu$;5_6kvM)=?V@PFRN|M-~@QbWBoiT|w`$;A4%mSVOskHMEfE(fG$Vm7sE2gSHj
zK3E#j)31HibmIM<6Y)<wsD)``U&elNcMEBCzYvy~*9%u13)?whHJqsNkWv`sEJZF6
z`wz1bdL$L<iMV!Vw4nHF4*oUtG|qOsI?HW@WZI)%82E<S$wC4$q5t_n-W=>4d}El9
z0sfkADR`abF$5F;7UF2ykmEIHd<#qDe;!~;=YM>X)m$<>64ZY!%NV&*vr_<e1JK`$
z1%E3{I?&yB?c6JwT>RMbu$#t7I?G5DP-mDnff49s4p)vJw7&oo1kQ>!N4i7SeZmj-
zK!o-3V6ale$)>IZi!ws!2px#Y!D(6k^k1M1iB!yEK^H(eIYY8;pziJ1Iof;jKeIW_
z_sPCP*~NwMwevN!HYttf6ksRv)qek$@LlQ(9p=t0%$MQh1EKlngRV9P=wvpDv7h8@
zd4KKH0As34-AQ$n<C71!U+&Zq=ofvP((Z-U_`@Nz7mxy|jD$y~m?Zmqfbd2Vo5b=Q
zY`{Q%3lD%Z7~OoVj-ARQpa8Z$k^&fFz~6RZ3R-brN<mmih%lfe+V$%fCIJC~5SGI3
z-kvbvP4x{7^Z>zD5_0n1ne(5%q%fLlHG!eO@MswlXA-5j@~85`n;|6l)h}5@D*Sk<
zu(8Ty{P7!WNvQ;o?Zgj;#OoN$z=8%8!I|EzL@MdbeZc-;<DT9HgR_;wQfuG6u?Uvy
z2x4t@7<QElTwos5Dj~aF@jmd1lJ>`s(<QNqhYMMv!XQ+_`{a6Ii{P<=>+nLGHa?#6
zY6A&Ui`Abw2-bhcB`C&2CwBE!l6Oyz;(>YF<Vmo5;c$0>uj-a11*P9<gZ#$vk(N$v
zlseHa-%6jD42;1vXAi>v{59;Hk~39)+L*$>ApGuDB$?<YeFd9;D>zP*n(4hlpRgzh
z4$rZnF=zqGMJe`tbsXoxeM6d39+eDm`2@yKM0To#ijF6(??puL+Ub=2m4ab#NR^lt
ziC<PrrPzTud89a(@O>fbCbE?BXh!!`WCZmt%I;AKb(V#)Xc_wEmPijQE{^TL_7Gs;
zz~u^r$Vu7QKB3AKd(}5Ir1W9X6bm`_1N^xZppaSxN{I!(dxZ>VHir$Z^{T#HU+#%k
z?GI%*c`Y`H{2I>haza32Nqm&OV7oSMCbSpF*BsRs?at7#j2c|nIl5xb)nb@}OQux|
zwId%8F{N9hz@3+sZc?S{iTLs31w@z~UrJQI4IQ?2-CG4H^Uk?H&x$d$)!B5~KkX>5
z+WrwY>Mh3xLZ*}j@zlwM%7cJAzRGa)tW#sWG5sQ9)w6Tqi*yFf4=xx>jMTi8-rwwX
zT#5nP*S81umd%w5dqN7iPahXV{yq=-!Z)~iqUF0#n(rEM(AuuVtn`!%ljIBrz+ItG
zzh07+i8@?VBUFQ7(nPzu=b>^==Mc)y1@op`WXU3^#)KtZBLli>*N6f#gx6IR-4j%{
zGBJ6h@)w|6;ajLj-(Da+o4Xf%&yoUO>R(~9T2PA$iT9-*U!mTab1`|`{&|r20}JMF
z3{#$Zr7d5j58w#h<Ku|)6?&y=A=lwTAyg>)rL6{NGiW2X)$?%m=JySD;e!*?pEF`5
zminw3Pc0k<{}Cva$0^f=`(wC4neN?%fwh^EA5N<sS}!Z`O1wkW%8P1eRGZd|F;Qs@
zAg18t2lGwF@G!KCJWS@{9=u%?YmZfnt`$ibb{JR9Qu0fluwgjP&RmU$t~s8j_4-dR
zI>`x}T>RxJsQl?0CPv0-?R&pp@dZQJl$YmO?_`X`n;-0Vr<hRCtNSbU(Srr8aHs%K
zyJ7#Es>5Vi%BKhzjBKHHD_@i$^=*?&H`2zep@4JgLZycM$RNVthr@MzkJf7I8;PaZ
zpKYhv!RUK?a#LLYI)=%Vq`;)5rGYFgWFR8~)Ma+-><ke|aL1rmfq;Y*20(6#6ZDW(
zM0QqTl6QRpF=}zT{n&4bQa^3Ma4}0^npz`M;LrOGO01M>>R=bSxkTz)<TnSFOun?*
z@os)-=NqBX0du$03#cpfpaLEoWpeV-bSt3K>%_ER`T@Vvk~0>9O(sT%L*c{Rdz-;|
zNvb4(2;O(PCXWXiSMR{yyvejiqqPeIT2BnmDp(4N1J*6E?vI;2W;&TNUlVoSz8?g(
z2VzeBO#gX#M{NHAIMD;H#WtrUkKxhRt&ws9TJJ|T_|<aKrZvUD)RXB%<EZMB##Y<B
zHQf)h628L#w?&bx|M~FDp1fCW7I3rEn@ceKeRB38&Z|?!QyKLF!J(0aBtkn3CVZan
zy7PpCC{hWp4Oi+cMS(po0c+#vx?UK9E}Lh5d~HOkl+MZ7jl{!$bKdK8xc9`>%J)V#
zmVKSTEWy@D{HeC%t7JqCwZqjV(SySfxv3xuUbm>U;ls*o$j*eh@jO%R1-N6Qt8C-j
zqaCeWS|hH~XHsaFlWL=LPMc)Ejx6yN=rkcH=h}W~>yvAs@@9+*)s)kWYaX3b;ZpQF
z7b*=W#AT~vXUc8T)$T?+bSYAn`V0ms*gnePYyr|D^C+d$qRT1RZtceTpV%=CKA4MQ
z3ZnaR=_ABQ<v7<(T!0nYzZ{Fre6lK^XE#7Lf@o76h}SVYIXO`*5YSY81@E9JS1F48
z=UW$t#J{v}PwAVM4tI$S@e#jnwbj=|c}6u1X5hz>KY(JWhRoSB61?UT$DoU$YkFL)
z>pk4<fqu>XQA_jL)&!p63nJ>WN+1jn$3`|+%zqA^^B|RnB~#LeaWPj1JGF5+5ojdp
zgyA0327x3qWCZ;k$W^5VUc?h=pK?K2ody<6CYF~3JH@Xx(q-u$LYDWuuUx!87yh@K
zP%N(wHm?ZQS;WeUHV+@!-QB&YrL$AeP#~lL9p(xa6gvz|Fj>1jzciM2*u5??sSWRq
zy=$_)E63Tz7~}J2bD>6wwR{Cb!f@G`AkkFh?i}aVrN}hzeJ^GRp1Cs^*Pvq&88f)7
zc2}r*0xfXQM^70)CyK>ZyiX>6PK#c4$eFw46!o^c?XYu5Wr)q5+zzDIWLZY9SutGS
zmf}|Rt)q5+Vk*J+y!3QWjw_Zpk>5e-#&#eakWFOpxw+<!i)03TYfnt_VSj>KRcK=9
z=P&gT$^Gt=U!tMr;O-O_orTbphyni0bRI^o5eKtYS30ZDqac7Dr-LNGC@|Gw2hIJ#
zCjPyM=H{Fs-w0A+&Tbl%4?M7lJi5aTwIYkp;?kl$s6<p=!O+2bP+Lk-flZSb-l3rS
zB(YMef_c>ktZTX-@qGWF)(!S+1`hH8@_8`$36`+i_YO5e6T+}LYp8ndx-gV|<6dem
z-HhTk=N&j*epeWUQ(fq4)P-pF)DeKBzH5CN_mm*JYaWn&&8!O@9lZN+rhV@x5@8_F
zf_&U?UQk$1_Lg5yS|{9HXeD9ALa@@HU7C?(Zfgx4_nW9B$$-}ff~+!2bq2?BW>4AS
z=7WdZ5G0ZUqf=6KeaOU^N~rpfjADpS>H7?=%Ju5vqs8+f4B%csGwKU$?jDn7<A26>
zyu#4sc0^$$T!Z&)=9a-Pm-=BeDN0GTyaVp1*z)BWmw;N|`2fl0AQR5fWpKLK#J;Mg
z8uj|IFC?gyBt}m$CG>KjJWu`R4n_CJM~??c>2VV~-B4@u*sk<;9g?RO%Z=mP6*p)g
z%|K;^#_er_c$u<ar^b1uWO4^hgU%XXD!c`fbAm8z9Nsrr&drwZusc7J4q*Q?;Eo1A
zNd;pPQ-M2|ywr9pQ*k(>5|fl-WSDcEvvkRwwcC`s{9Q@qSXW&iHdcpmwB&d&ueR8@
z&(!2OQ6r7&{WfR4hS`J1Pu4sq<c>G&IDPs>5HU6O6?(9-GC7CxxO(VlAp03MSCA%}
z>t+M1S##0Mw6Gh%sq=WK>nxUSLA=%(u#SxiOe^yZP0XqHzKtTUe+g+}(QoYd)l+oZ
zwyHb+HfMXut=no!4TMb)Kb8MdYFV#cdbmsvntb`DqoL)ZxBYg)5{u(hTWdJk=_lpb
zX26T!iG}BOh*+WD;cpy27pxiH;s!cD@dlP)@~!C0gTZt6q|6?UqRF`%lC5s6aw4c;
z?Mv^m)U8tuiy@FnPqo5_fJtCOnCIyMzon!{*nd&^%csQJSFq<o2b+uu#`af)!yW(B
z2D#8ktZano1}MBh<tgBWoA2Z(vF1^Es9hP~Px9ZbF^Bpb@WJaS*u{6OlsqTQ(%e;`
zYhqhHgw<Z88~KYMzr=c<O{g7tQTe*dPs*g0p4j^6`s86fS45H0QLEyq#!2vlbb=qO
zjR%=%#Pv+D@)ljpo===l#rt#)u#}FdJ8a!~YWmsm_a&x@#aU~8MzCCwT4K-_mAxm>
znAw+D%_3a1CnknLzD)6Mes0kSs4KGxSC9%Q{diTiw<ta|HXX4PeS5OE4S^`~l23KQ
zG*>C)kC6?;5XqP7{pg?=CDYwdu{MuJDirN4IghlO9WJ*KKM-x7fWB(a1qm@}I5aex
zbh@i-p`Ex70yQ4lX$9Q$FUhk%jk=wQ=~kr`f>=3SCRN8J?pbwyl|Ui6L2l&R^;4x2
zv`S)17Gs}M6MEtBx>0-SG-0Opou~6UJbl5?jr#cF13xL8I3;At<v4uga4eCOz=2_@
z!I`8LN%KIIp6Q2um(^@lT+;m#i`dgWJ)!<#!|SeO=|IQwQ#2}p?Cd3p1r8brJ6PLd
zExn|%<EadUZVMrN(<$U=Ss7gHGhFL;6_y&g*gTp8$@4bbwc{~7<p5Kpw%E%rBC>>Q
z_zQt%He*C;S!u3ituxI6;}aXPs;PV5&1}ol-f7$1t)MYi<AhK3rA!9>xLIQLBtJTw
zj@U*`!~nvfbEWE+L|~9=UXxfa1HI1$KCjFk!FoF#c4~ztk*0%x${os9{gz1-Z8SPF
zI$eCdHF?`MuDtt;3cKqMA>88ndc@sgw^b1Q-blg+PPN_57x;)vxG=m^d-*=ErnlNZ
zeo0?yu6h^gW(}BJh=lfP70oW`h_>vmMXb!Wo<8MdYo%7yZMSvGIu^J}pD+HB=aT!}
z#4UU9`0xvc%Za;(gw>UJzc9*4al0C-<^&4-y{)#fKC}aPaxe_^uJorT13Hf5pSn(5
zdgE`X7{)LLU&#?8Uk{EyBR`zNU0s1NX;9x04#c-xx59Ippl`wP3O?u#T6a{b+rvGl
zhwfP6sb99L6Iti|$RtQ^c!)m0-na^RzzvfdC1bOigZV>NddidA&Z*tLe94QM??j50
z3>4!=++#rg&2vr@C&_GwD7xH4Ib3OEf`B~gAoyk-w=>A#xAl9I!0{;NcWSCHBtBg)
zx?AhSd7$UY0UqI$S6us`KFvbHF-0Mzf95y*%~4|kf;MlIhO9+|L@34m+M)*ll)Rjt
zv7CWN=x}gZ_&8PJ#!Go}+q|>YYc$(6F8yLeq0!}IBKQG!nQ3qLOH;oI(TW!VTiN{A
z$@!>C-WIHsGoA0L_B1B*@U@GPEM7mk$OOQ?(?5aaoZJ!A{rokrgx=+NBhY*h%|5YW
zC|R~imWh-0cHv^8Cev1?$7-JTti^6B2(Lli6(*SG`?HvhW`D@b&qi%*c&G2c%g5z=
z!mrlj+f)20+dfUo=lkJF{OsT7toycyTrLQio1EUr!`a!3%|!ctFC|%QO|DL^VHzE8
zI_X?<CE-k94R7qKEK!w=xgBq1ELy1q*x(CkQ()AhA2$o{Pb0n+alzpW=y++TQ@r|I
zJ2UUkE~((YxqHkCRvq5B17JXC`z`Kfa5KU8xMM2^Fbw$zaxZQIpsXJ#6G;JJ@Yxh%
zV`Hdn8U-4*_%7Hr*mgK7>|biiHq)LDH#THC&syCJlER}*7tu*n{*T@QZ+j`D-ZKSU
z3dO#+-UdOoV7(_j_=1%znz4|6lOFi7Hu^?&NCp<YVk}I4&Hk`dF6ivu%>;sVj=1zd
z9v%13X3TS9D(3Xn&U_dBH6K@WXm8Ov-RqkbMJ>Lq$$Mp@Z5oy@NAPRGw<#flmh1M{
znm;Oe!95g>q*~BnbNPNU*!4PPB@wgVQd5P)^%hS1PnJze-a}xRq`}#y!<cL?A}{hY
z_`Y4Ascc_##qEUQo?a})`33+?Bee2L4p(P%;K_A7Grm)-%$v#g$)~5$E@>~tZ?5<K
z`%xoJb_P7)8_d?2p*{Gu>M{k$^n>PWyld7tCA53rK=vMwoGIhe@*`<tpLTkyC2|kE
zSJo#xVD%*13O;W+v+~j<o|(r|h^WFf!Nj_r+2{7gQg%u==T`8LM$GThzI&A<3ZFX>
zu3j&o-Eo^LIY)^RdmD&Hygz!v)Y+XDx=dSiaSzdmF6hv>WCJ;sEJU(oG!s5s2L~}6
zo?czN3C!4Zr1u|LC1pi|;|X);pB3oblQMJRRk7s*4k=z?^)a;CI4#IBEiS(T_l%=%
zEyqN#$wKT=vXR6ERlAWzrjZKny!@!l>@!kUQVxVFwqgLTq7TxYoOgfN=_-BN?*$4e
zIoaJ>S&G<1I+N$4j@liohaVkt{GyIO&W@{jd|X`}z|3|v;AKAZ?fsmcuNU2{mvqgA
zeV#N3yHG!4@e1dH<!Lif#krL7`DT0B(hs|Gp>Yv-y2=;iN^HG`5?XI>Q$+wju^t`D
z^tLnr!5jLFJKq7zH{TL4Gg&Ig6eeKPQ|az}c45ZVkvo5`OcjzGdQX0{?x9jW5<f~6
zC+X9!l;N$hurtd=`qC>KluVzcl*45oldw-d<oJ03YpON<?qRp(dGYbl5)tn0VpwYg
zi~7{p+Y&}|0~_41doYSax-ChjWatt}9zquN%BBWS>*&71s#s>i+Y~0V&+U_wK~6J9
z!VF8Yi=~8v@l!9g7p$G=!)vb5!sLk055t+ua~X~tFO$IdZ7#v<39L5$1lXY}$*+9`
zf|V=q27;VQ%^ka6uCb_(uJ|&@`ASBp9yiPf_qJ&S?DskxqVC6ko9b+e1Yh-2JK?uc
z<(e&gC-}~&%cNEKxOqhss42lX$gr;1X}3rnE-+Ox9!#o7sT}70;*Ia>{TlClc`z?}
zY(p7ykF{<R0{ejQWgmYB%pJqIjkgdU-S81-6_V&6cLj-c+MlLl!OGwKMeVMv-@HP-
zt3yDm4L9dvDTCqZCz+b?$H^!`#_19}mP(p?igkR%v?fUK*c0iy%x|*a@R(b?==PS?
zkU?^z(D%zjX{b_E!?xS}ln_`83DMV_C-HCJc3rg1IOLwa$i<ki(wjjCwUZ|6%(m3F
z&V;ka*Ru87JKcx^enC$h?!}oeDA1iRcOUc=3NFCi&bca~+`YZHiV&Ja0P#rwu&}rL
z9s!>x9BVU2Tzyp>2kQro{QfnSe@0^dflyyd_&0I{n6v^<MNfRPm;(V&Z{ad5c|+yV
z%ajbD+7JE?F0>&_2<)b=r*4b*sGWKLWUIrRj~zUaFX+Lhy{R&j$(#F_F0laCCS09N
zfIvVVRrJu+jBMxD*B%E@Ds`?CQjQOd`%&+}wKsChXx=P}^O+Rw)gTMzPpUlqG=$rQ
z&iHQ%%N+$Dqmk|RXh7tTsm{$G3^~h?4YPsaN&IIZUGttl-I{4BY{bXLrN~2%=AljX
zH&jNAVw?KU`Ko_$0hm%sj{a&8*10Q~Mwo^`S_V>k^<Rx}UGVO7n|VTekf{92KfOB~
z`2syX?G&FR{gVY><xcD2X)z&SklPG~5J6SNug!sbe}-nJ*VUbMJ_3m6GG*<8s+-X@
zMUm$zS-dE|rvb9DulYE=-OXJIA^ET5CypBop@ReRYJISw$1NUDQa!0qXJ4$;uPU_l
zh6G#vGQX-*&#7bBEWLha!Ps%e5eEw0b&Nj&*|Wl<C?*20@+h8Z1k@U&g}$s*7CIJ6
zYyoOlo_IJFnO}KZ)Vu}mJ)YPrB+qEHbK@boG{MVzl9C})TT7&SL5T6sgf*sC?GRhL
zizg;6e19Y(<BB&~m11kov(<f&GvAPm0mhS4pUmF2e8BF}GD{<ehp4F`%N6ap5%Z?6
z$QF>D|MmVS5_!y>YzU>|CM?yL&E6hD$%n#eE^XI`9C`f=ph%PY0YL;Fqymb{#j*dj
z4z*n#Se?oioBDG_CgcDTCQi8w%%{dOd!XBdn-2rG){|xE9@cm64>Jsu#DmM4^#z(A
zcFEd5k%ik*GddQv&?vn5KKGbViK8!qQR_MO;An`JiaLG4@_xN=BYj@$)<aOR+o>*D
zv-a+z!ezje-}KxQN0&@j3#&nsuPf6+6u?~?%mc*RH?1zPy&6%uaAh$T9;cVX&@;2%
zUzQ{hf!@ixQbD9&2jAV3bxeYesf|RNKj8va=u?O1--A|WkcM)6(2sM^?xAOt3)BY}
zK?!X7PCEs01J)ZB7=t@`$Js*M@xC4XjU5ex2nQXg&b;K3{HQ!!XvBjWJI|%W#*$4K
zMLHe4iXEvBM+dcaud{mpdGdQbrEplabJ(OfC-v)risOc$M_eX(h7i%j7})SZw3nnA
zZhw|iR<7m#Y20zuMFzy*QGT&JW3(=54{GY{8A9rFV-piP05t4Y&c~0TMQV{|WxI&7
zV~a#{xLw&t&&*SnBJW2FStZWs7o$UJ;BfQb58a#ME8{*jn`elIeB5(Ea-MX&9*}Mt
zr{@WN3KeNDxlP7ic}T!95K&BHsz^F`_Gvz#>-lJc+p^!}d(iTGhd?hHVwH0t+LY!L
zXF&aBeB+UtY8(ml95gT-JdRK=bu*Wmbs_qk_fouxC(qKfKCM7ael6JD%B*BJLu?Ic
z_Pd<2b^V9)whYp3xU43z-qK%@UK>Tfh%<U6WzoHd4DCKDyf@-*liSw}dr)7(|NI~y
zTd)V|4A!E8^YKyV2rubmqjhl1h(-0aktr8a#|s*!VofT|0kKRO`KkSqsO-_TWmU{R
z>ie<dHliN#=B`n;B#*Qmg!UbyW`87NEQ>XYDQW}LTXM66CG{zu{Mn8y3xdZ>Y8pIh
z`PUqR%H;CYFrPlj^}xO~7$Hu~M^Dc&Flm@Mi+PE3i2hg7L0QT7M9orO;S+quoDLC=
ziy26brEi&V<qmthpyf7{$a)T|Ee<NuCJ^@_b|7%*Iq3ss>&y%E-c8Ook-IYf?Y^HG
zO#yJZae^OC-@SMJ4dE?|Bi6nEckl#yt=>>5747gGLa$+{0(Dn{ruc~eNnVrvM3p<L
z;U1Qc`^wsl>7)<xA$xyd>Dw5~n9-1-Tzim6*AFWkh-$CQTp>;<hu?#O;4ODsqB1>%
zO}_gywZ5p7{83Z=v8%*6xu}U9q4&@nznldFd*B4poM3|)oiB+J%XK%~gD3e+D!3lr
zqR{LCFjpuF+gm7#dO?vmq`34T9X_eVKM>lSQ?UqcUJ_f5bHb|fQiHaHOfT14i(7(T
z1RGEKFeNBkP=iUZ-3#f&ChMM|?)X0Vn$LPMKQ#xFxNH#G1->uL*6$?P-rLu*kNjd6
zuJtGOIY_GgXL!$|bSVYJl-10uXO}u>46!PUN6^mEpWxb7RTP`9FCHt@NmL%WROS@2
zDU=Smhb;28Yr+*aqq=hKb33McULW?q)x)^FW2NJKXdWyj)-`w_TK=g|&E*u*tkmMF
zeJ<e~^;%|nex{oil`wI8tD$qw--&IE6XZMo%!+;tN%eZgYpVrOKc!-gus=6#bx*RF
z|L9|H7HWWWINzP*>D_E+>PDzwl32<0u^*c4qc1xTlHICw5*3K!Ok+#skKy5&Zd*K=
z@0a}@Dw`P2iUHr}r~4(&NY>nubrIj@O|rLQHs1C!aiZ@nv}I{~llLv)_*qD`Sj6L~
zZXPc`|M<>)Rv7~n=NPy@(C0-#a{vDPn!f^V5>OepFslI0h%NA?q>+TLOJGv6PwE_Q
zid}?eXMuuV$y5KE)K>i)A&5BAu|sq-(xS_6u%W>y^ak`W*C6CirLm4^UTC8S;MxL0
zwJ#~5sD%BK505sGzFH7`>UB9}eu{%1H)$Wx7sx2@QGYG52Or=wIC*Fr{><Z=jLV2R
zjfA?H?gweXE*_(I-g?}p&cAw+%>SC7e8WZh&Q(j)6Bd0+Fg!9Evj}nNSl$!MFVwVA
zEfA?|SN*DumUFzS+mt(v2)C|yik3=GiBs#=eL?+^A&5|sMXZln*hU4fiRGhGQ)eoL
zP5epz!}j<fPdD}0b|?@1hL?!bWA{PhPxOK;zq*k?ESI{#kB#&+GGFX1G>V9A;(YRT
zkh~j~mX@Ug;atoCsGMQ0)0AJ+=Q28r(k8xMTPhF>T!Hn3`tG#FwkKGVhPlgnVYy_}
z{rglvNW^v<wWAz)Yn_sW|71<!Z@J-`U~*^5-NDuJMOLa%5$Sb74}CipSpns-akLhZ
z5%Z15*Ht|bJ&G-J2q=PgS)XN=(H~>3*`e$Ro~!-0>7gmQZrL3@=kX&>3klXVE+5FC
z>jYdf^`5ms*P_zUudhN`QS0c@(=Akv`=9LbWqn}kME~~YMhQqDnQHTN&R;2{xEb$)
zMf{L2ZFrXgmN?@?T9G4qPbdyMn<8hzl$J=bF(Sx!PtLV;M0NGH+>X+a4OA)}57UdW
znFPWju)kQP)sH5PVR*b(4kt7lHw%9?S2OGIj3g7ebh`@G9&-&(2?z0!`-UQd^w9hJ
z2clq)@;-G2GPpKUFen2Qjn*OOm!*!Pv0(G>3FfptI_sLQ7L;XNO(GV7WXS;x#6gUR
zEijL=?>c0KAFrfhB$HC%HH<5|Dl`42OI7t*pxm4>L!B-^w|uRDi9i~2=O?bn;sU8%
z$Llu#;F#6s^?UE0lzqBs(|Rt9HQ6~jW_tB~j5BwR^=!RukOb##!bQDt(^Pmc|C<ps
zI>{zPTfT$YhI*G94iJxIke~SieWb5&p(_B*_gaEyrEmObF{966&2+K*+UZV*{@grP
zK3|D0F)VIoU&}g6LPw5xSE&Vo|NemFwDh@zholqRY%By%euY*%uIATCEsnFRQY(G;
zH4}${$^>==9Mc$Ab?#@5$EUT$K<6M!gfk+1%4S^}sq}Zh^8GW=5EQ4bgO!;|>hA7a
z**$toUXK^asg}-jF8sO^(q=hnMUIR9^T!}w(6z-sFL{SOK?RvnP`#F~4kF+4S3=os
zeo}lT&hc^y%g0p0@m~OISzyK}nYSU)?e&=8oO}o6cztZ2>H|=609M3!`vp(cpd@zn
z(3;yDs5k(BYxC**n<~0|r*7M*_l@@2{aS3cCuCBaL(j-EzyN?ueA$x4d21@vNZ^fg
zJwQEGa<L;bKdb5+97nvcb}thUAO6xdE+ua~`SgRr2+DwP@+2{_!)TIl?SN1q@oI^L
zRkB+SxES$Wume*>0~a5Yz*{W28*G!a=x@({>5vUh2k{&2&DT65<)q~l->*S4gkLc(
zAnC3m(=FYXZ^K->b78Q)RGmYcap>(%mzY`OOdCObJ}`xEJ=u6s-g~CO`n>nKJ52U_
z&9KUvPqa@buOS#Z_QI#-*i$aFbsc75Ag%L~_jfESZy_1R#`U0YBy6PL29FM{sJcmu
z0Cm6eW`MEo7~QbL%d%}+$ESlFIsr9zrlDv4VJZ#zU-2jENel}9*G2)5=<7jgQvulW
zn>VkGG0%q2!=v7*Dg@M3`d)SIY?kF3Lo7B+GJ72i$FSlj$gHfdD@d@OO>kMcQ)13{
zT&TW**#^!cpS@YUs|@)!gKG#JuF*9%Mib9yCjJ4l?)7;c&}Qz6)m~hGT&Tn%ktf2>
zNQ3)4&-D;-abv@RD2{UMUm@yYji|-lJmc!I)o`BE$H9fmWh=(ip8-;_DyjNJ<E9+u
zse>fcd;F$?Pv1LyD49-|tOo6pdtlEp4J)|xxY2x4b#SWYszEhtQ4gkJIl8rdrWtOQ
zm}ZJfWU@ffNk%le5ZqjvzA}tp$~EN3Q#;~M2Jb8)oke`>TYpZ-7dzbRC545z`$WSy
z<Mb`a)!^`#b_JEK<2II_Y2INtvS@k~c$@p)B@cQ=+ik09t}Khm?$bx~i#*LpWEv&m
z69(K<?R`<Zbv<c+hvP34^h-Vn75x_P9DOIS<qkv7!tkUtW=c9Am%4+c9tNQ?(l*<}
zKrf1j({=D=d+EkZ6JPkc8ferXU53rtUx5mJPG~pv0q!<Y)y0vrk;_SJo484U@&~?S
z!x#@dGD<1BD0m!tGbVr#wEP1Gdr}|&huo;d(^a3>3nYGb*+Zn0bUTLIYuW8L;SL&a
ztzI!&{Mek-K4mMj+NFBI3O_FkRmpn+(0;m&vc;bjC52HZtcZfVW*<@Uh%Y_Ibz+vh
zPr-0%g!&qHc4Y4e%om<9Dd8cNj|~+FT{CMGPIf6x`O%gI|CTuvE>w;BC({#PK7@Zg
zTch)p#)A8xybo~+`7x4e*Ma;l6o6IRh!32BBqCF{F|ZJBqvL{~ffisZVtpHd8x1eC
zY{csdoYFnmd6iZI^c$UWz)NY5E`4aL?-pG~&3l-?@K%Y^R(kgall3<c%oljK6WDwk
ze7lRJTuWYQL2^qrIye8-H7kE#K+hZYs3TA+XsKt1+%pycxnM;xrz?11O*&4!{mrg>
z^#fB6Q1f?C8^WdV9Wr!5?b?C;CfeNV7<jgUX$vksEzlP+DjaV0<yBYNPEX1>S_END
z<-iK=Vyklr)TJoL_f(?igxnL`(rax`p~-JnZx^yFyxk<0k-BE`P2oUwzEv~7t-X)U
zqRShG>}|-S(tqA$FSMg`>7xX=N{sFbKLVqU(wKM=(+*+M5HF>}5Ch{{V$$*HLaQ4w
zlmbTWrNL-OmEX!boosZ~GxR~wP>s?8=p0Ij*hc#`PM$avH{0=$oNcLY$*29729tIm
zMAY2UZL1$^7l=Towf)p@_=5`WGJUXCtdzk+@A|%W6;i;<-hhXkn$nt4zUB9y@CsT1
z`DSl-+#&GY*W^TK%8vur_JSxaD=iM+zn<UCX#$hQgY2j8$!PL+)SmgctrEwykp%Pj
z*z(KGwfAhx&mO8Oxur-TiDhMLU<ZG*RL$Thg33V%2&D#Tn8%^h>*hT)0THDh4?+FA
zYLbjDkvbuc*NsUMejRGYOUK)I`eN7^wFq=hmkrs;)fv56&9k|2RhhF{&VH6SS|S-O
zX>kWIOn_-Yuv~403za-|N4-=*I;N8TsUKFt2$DXtuMhKLA3|4IpsL>P8gnHt8H!;V
zB4tYqJ5mJzg<w@!YMEtWxQs&7L3aJ;vE~3grB}LjgOl)UskBa387uYXZk;w;z?nk<
zaXH(iaE`~`4Rc2(I@YGxHo1*jZGN8HZ1q<7xqHznRJj1(u$J}L!D0ZL@xdT3W{`_M
zpO!h7S=>%^#LJwT7+sLh*eN8<aYk6noJ$bHRtbC!L*Haw&=%;9KFc+;gL_~$pmf_B
zm0^i3ZGA4*{U-P3Tn^00EBRpM+mhY9lFac-v3p0h{9EY-A;#{QZmVSR2>hpq!2GjJ
z7&07h->trKpsThiHNzTp+howEs<y7;jI0g)m^YOZ+7;9pT^uywLLUcM8kht&oeg(W
zZ;S?N%Av&3HHje=qTGr1GDURkz;tP7_QlFch_}{-tnm^TT??^nH|^r|WBnmlT<6s;
z)AQVXf^UgT8I>OnR^mq+#Q^RiV^Hc_&v-@QioN&LIsWFmDXj;aVJv<}h*%VH4M682
zTx)kqOPBuV^TFV+)~$ZxRH=FXse)+rF7wT?dara3D#Z^RZrRxP<{34!#?g882yeWR
z^X!%i*~SDa)h<QPyG$wP#pwU$%GFT$qyGYjLO{_clN1x{I$PO}O06NHJ~N>3{~rB_
zl3S2@*`2EP64|(ju@)T77cttXHfTSvh9QRQ{kSz6M#^c>cudyE8_cA>t(NWz$Gz#%
zkhMxiecM2XT#j-*bsJu^WxNZ?H3=(5Z)=cqa(}T6hi?|v`<<J8^YVJx!CQ^cVqr`R
z*GYe!-{as0#&RzzK}(p-y*c^LL#oNRlP3Rp$Wi2m(m-LZE`da2nfV^yD1oOq#V)x<
zH*90Q*%R}#H5gD{Ib|EHQ0DykrqlZu9O?lBDGo15*5^GvRFX_+?xtrb+TOu~6)H2^
zUL{Sz1G;>gw)neUf29b@hGMF~N2m2yP=VQLegsHD&?T#Yte|<}IZvl_ZXKIR9US5K
zpye5e4P^a`mA5CY;U4F{)~s%@TMv~n6op-uZVF<Voi@(nIgKSs{gci%UKzkUcuS*#
z!#Zv_E>jz~SPxVjtcA5d!yXF7E6_pFFGJI9&Ck&kw|kb#-E#W0TymkDUxk4dG5mPB
zm&Mz)pOVB}m&%)^r-6;cSUxWB+*@=3;=`*p_RPo22@g;fln}IXqq-0ewi=4kp(~H^
zhviqj&T-_2yN^;~tSVA`r=(q~&Vqy=Ys=1i_UVI9s~#IxxL-q<#gGZ}UtaF>wga1*
zgW=(TQB~J6(aWNr%{bM#cixw%V~(dx<*Y=dmn=H#d_M~25CN4v<#Lrqfyny>>&af%
z!kD}6w-vfB<IwCqnO+KX{He*(AQ3+e6G5O@BmTzpkVOcI#*oYV=zG?uhO?6pSo9K|
zSOYfN#pZFUq&R0XWCIQbQSFaepPtS3kW398(w_us4V7Zjqx@3PGdCe#CFOn_4>^U-
z1V}(ouT5u!5IFQaJADE~+I}%;BUKyGJ@5IGk%-z!PRWEV)B3N*Zlvr!Zr#^<EPNFB
z**9&A)KdEu+`e0EqSy9*fagT$A$w;fnfKAS{b9_tfCOC6Lle(eyEe?{&55|n%+1g)
zN)+23mLJL^X~O(bh{|cR_rBE4Qk(7Ti4B(%l9DbdbRB&j(jf;x+H`+H-+B3nGx!#X
zCUcx42HLa18>h)um(b!j)*h<F<-$Ovk6ZhZj<x?a{rhPW85Qhd3R`-a4CdeRvjC<6
z2rwW=4NOu}(zF;T;;3@mk)V{1zm^uVtw~ediGmXNd=N>c4J78K_vmN&Z=GCln|l;Z
z@Hau5+vS7~{Borm&?8)f$QQ>9qYXqkkoj#ot`>YPFs;Z@0hOc|W9TK@`;vXbV0+y)
zcd;^!*%Nrn5F*yU-*ap`e0fvAB_-czlW-)={V+6Yp6?cgG~%Em_(Y-0R|CyRz~LQ3
zo6Ju363mI^#oUOSP3))qQ!B#DR_Ex=X(OvlPH6T5N0-k#sU?)`$DPfmv0tNLpl#Id
z47t|D(jmi*4b_kvR$H4I?ce)Su&sXTq5ny)bNhZyc^m}R4N&@cbgVUdiUU~^7B8uB
zXNi5B*X*AMb-B~fW9@ZptF+0SnR=l&HXWLL2WnFNy`LkoB)7ocwr;~gFM5?#{UBT*
zgRn^H5lL?|VdXEKt7e(a>iuCAKU(l}X07!l9~`dljroN_1~;E_o6vqTv-|O&v?L>U
zW7>~8_`2kj!g5}X-FO%&Dqy!7=6!m7gLb2&L<uh%Xf-!TU)!6lqp`Kmy=LWCi(eD@
z!_79>Yz<mQ-r+qvl%Kj;b?aGZLD~a(6tr9?k3FvjsWx?>TQD=h@MU&=>RUFvN3%{4
z<_+TcxfSK>)`L~(V)t?lkp=9j-`ccmf+>t_%boK*cFBc6qpVaZdZwaXD1h0}Egf1-
zC<)PFdT(|bm~<>B6Zm$F=DJSYDR`?!rh<XmYnTh&+&eWTCc&B8ON>e<u2`*a*Jc>F
z+SXJ{K>CW{XrO#Eg%t&*eyDD<)cmT_KUf~Aym70Ex(1E|cMR)hFrTa5^@S__Y){2u
zeBP{d*0Dyv{g^vC0!TNDAc)nEn9BOR&){pQSC=u>Y}B+Ww>WYSFQ^scDZGB}FzR1~
zqKg`59Bp?`J)eDQOUa4pJt$bY0sryz1)D1RQ|p&%A#c^RS6u6F4Fgq)td^C(&S6Yu
zJM@dy;}bMy4xrtG6VENq29%`COl#<{-!c+TG|U!2a^vnLOSMT)A88k+Z1=2ToU3x^
zxk|dls8fPv<AG5Lr2G!4uzyK^#=sEbUOa->PF}i472t9*_4aif1n1KYX5`l+kY7)v
z>FM@@51OwH^6SV40e!@U(}~r?D4W75F{kM)JePL4G5Oh4!gfx)>pv-v(VCA><jrxj
z(9u3ZiQFPT?Uep$HP<q9LeX<Fm(P<00y;`W;`Y9ETL22E>EKj8j{95oovBow?Mj1E
zeaQq1h;O=XwK3%G-jQ5)^46urf&|R&{!y8LVLiP9LA;-0mY7Bq#btj5Puzx@oC-qj
zT-2b`JVVvg#+o9E!b9_szM=7Bb`o#XN4$jDM9eLS48ws`1S@OsP@b;T`4>1L(OX*W
zj?P9zzV!vdf*mKLw~^pTH;<VsAeJtI#xcY+<bZYo#E6Sv?*Sl_612Y=d?hAh>!6!U
z-Ek*z>Y%wXr0yq#!l&&*9jB}<ug}i~1{hnxs|KrQCtv?R#@;fhj&EE0O$Y=F4vPc`
z1a}MW4#C|Wg1h@7xI==wySux)1b265;d=YO_de%6b?ZHKZ&g><`nI}z_Ut+47|(cq
zaXO6&P4)!4PGK=6+DS$ckwOE%+LE&0af7&E_hA*-(NI-X*|E&g`~c(7KYx--gKZ`w
zpuaQKXX9s>nGFS=AI`X5isbp#+}kTzd_vL0Z;mb0>1eWFxJjx@j#_pOA|c~!a(-m^
zSEn%3e*35LS-C@4Vv5Y8yKZR02_-?=ZyV&ARb@3T3Cyg9FM|^TO)~D$n-;?5im|lk
zb8t^x`x$uyr$@vxwkbF$p}PpUa}zHbXfk>P6j%HSRGtSM=G+<nJa4a*xg%6QF}xLg
z+aLUzTYS>W`f23VkxDUdJt&W&`#j{mC&FczdF9iSlZK&rIDPy~uw?z7l)Ueh5J_hY
zezxn9qsx5W(NKT^JP^nnU+%_p1ecTqPltWkCajCgR5<u3%`MT@t#M;0z-+y<2d3F8
zYQZXXo5y4YVMN>>nyb)sx+vQR31GFSeg#%=du@rP_QaTAMSfj?aiGc{ShtY%iWcVL
z_xC2^{E~=){um1rsnSmXIMLh8Kx6g%6*4biWhJCNAh$HO_#SX~q6x_|g036E5VDda
z(&gFwn)dVAoxkdLksQuGxwzA5(Ln6*%BLX#5a*!T%3}%H;}mIcSljZ2vQ+=<i4+S(
zu`(K_cxE3iCSOrU&X=VI+NZB_I0B%e!6)~u1S6V1e9c}P8HUdgTIC+)KdtmD#(O&m
z*`W4OrB;%2aR(ZNq5;+DI~0V#=I;Uvzw0AN){eYzC6>Pv2E^NDH}Xw?I_+rPUvISg
za8bc5bhxsZ=O$cB|35-S?p)|(W-}<je^&)+E35-hU-R2nA3$vp_9>pBq_`yb_>GOs
zhiK1W*n57Ni&OPA(4y|m>$fnXb_+S&`WaDCQn5iM)P~NmChWby*o+T<F_|=f?R;Zg
z68K40hT2d64-N4g)4e;2`E!kKw*J%-bUk`0I&<kMT$%=_(5alqp{-VGnclFPH-E+f
zM#uM7s8a!++eF+1{kJ8N$>w#8Zo<qu-{0=id3>pGBPN2`76r&X+4N+eQ$2gdy;5uG
z%qv}r4V2h@N)i+?wlfh@;Np6+kVbY*1C~De&-%=R)jrPEKZ4|?zMAeDuw&=n%A@bT
z&RW2)ZV9&*{r(dTZN1hE|Fd=w&22Ze%h;u9ze$C()|J1D-N#K)HxLDMs$43gXXRNG
zp<;4TVK)C>0am<9-ty`h1?Uf{??QeNG{>P~YUo_5*MrH>A}C{1+M*F{balt|bRM!Q
zRq`SkNCA-!TOrnz^`}>fAemEt$$t!Mw|*dLULju#J3xmklhEV;lLDA1W+IYu%ven;
zM|Q71dmgS(e=+*3{%qxBs<bTdxvMMYu=3oMGqo+X&tK(kV?}v2H%9LAy{s@<A~>)Z
zWollz_7yY1d?^<!qr;ln$MUJ4CZ#9<<LG?SeDnKU#ptWPTm?=1_rnf!;$JcDwCwYr
z*}H<QX=vb0s|1l75jeP1?>r>N*<6k-ZOEn4uP`D5ANfmAJmD@JeTWkt@LpV7i;;Bw
z8n!z3E&A99Ix^wND_cFbHQc*HKrBww&NU0d2Thtw9b=!Gpr@89vbec0))6mLCI-B1
z{Lgi9O4UAhw*Q7ijjjsn_r!b^xr`um!3a2A|Lfeil!{U{w8he$pwG=a>&h`l838er
zVAnq?u?Vg(eSsOUGON7)5>97`fSZ22h|tVh{rsfA`vgKlY|(XC%A$r{TMgr|sy(`(
zBb>y6qeo`ke~3>@p;ki!Dyk|v;%hNzcH$Z>%*m<>cPMMe84*W_{m|BdAM;6hyPNwS
zl8jB)V=JUH4{VZZpYpW+$D}~@Q6P~6ped${)p?ZzfCT}+l2R-noDYiO7p=F0JRF$(
zK`EEnq9Rs>y$pyddabMo$Fs|zD@Ab#z@TU@9NZNBiM&A&IQEv;t?FQ)x1zW<n%iK#
zrDu!cl6a~4i6k$0PLv8NVRs$;4zQ#V%wRlcpoW2=W11NV$iMFaw8`R-h8{qx?g!X6
zl$88RiIPe53!tcPbic~f;ZgjuS9-<U<iJz=m0jToLBz~MH9kstEI)EA+TKJJMS4nD
zM&)B}CHyMT_F!xzv=7SCNbBE_%X55w)Ud~kpX-CS=KcBI0zF@_ewYVZ<^TsnW`jj2
z%M|)=494d6z;bt@tcj4aF{7{d;>caNZ#<a36&7#+^f~WG-U^Ftj45eBAAsYHQos-{
zArOR#=-u6Z3edtFxF}~WZVa1``^STLNdr?iw^zhMnYx~v&1T9S^Ls?A{ap5|ys)u2
z|2&%rJjJgsk9!3Y*gRrw?;(6(Wr=x<X=z&?Uu(x1LB%|MO3`FMcZ?z3`q}}f*3xrb
zlZP3kZqOnz#N3{&VKFdHm0*2H*4|)1z;VK)3zEq+s_Fh%XDgjXXW20`ZVzQj>*HNd
z|90-*mv({S*CbNgcyOfjZS)VUexHhE3c{g!_P60#c}zL8x&~pqtXZ9LNkh;(>+kcQ
zyGBJm1|EUaH#%vQHYDsm-4s7md5E%MT>~jmh4wk`g-DdQw3dGIu~6NR?=NmXbf`0s
zanox2x9<+U>jir!nB;x{I|6S~xvP9y<OwhOiRvWYB+_dq5fze145EmDD9#)!SP{M#
z5y7_6BtvDPT$4+SJrEw@^R5gV&|m}Zc*Et6!WfB+k>!Ie-t$v5@=cGD2i+pcxx$A#
zf8R>t1X>r#z%$jIjV+4MoiUDeQ#65Dsk8Bo`dnZwfF?NVitByx8z>@8=HEN8r|{7h
zyXTG;@<a9Rn~g{<sN2mT5P6ZBKFYZIgfZ!*fm1F-3PSCqccr7FtF4}fGFFNM8X$aB
zb=-hu$fn}N;AFw>_wR4z#mWej|8iDw<%b76as>f<lYpu7wKm*xo!PQM3<S!{Ni<t0
zdn_%R!uJb{!F;J0fQk7G_1lV4H-eLQqDmO;meLu2?b4vz(d;jKu*lkL<2O*?wPO(f
zx-WLzi3tqz|8Ozig3c^rJlAF<xIpPcqjg92*#N9?ruozoU3+<LiLQ!<*1MlRqzLLn
z-hbz074+=i{b}3@*qDE>I~I(qNPU2}ya#x-r#$t=94V(IxxRHrV49+r!lzT7J*%$2
z&{sOw4=w++7&s|Y^4u<q_#Q)#Nucl>Ywbwu$Np13*Pz}!Ad+dtcCuHqAV87SA>DhM
zU-^acvL1!|$&@sIwX+~gw5EPzqSUKU`&Q4JqMZMIU$Sn&u~Wup40xb<AnqB^{~H(-
z!bmhT{Bbl6fQDhVx4oQ!-`wH8QSmwvsblX#WSe>Fu3dWk5K1O-ltg*X$2L&u?bsAq
zbqZ8<^d~I{z8?$1WJKI(xX2f~xNVV=M*g{RXh;8R6vt1k;K}aExt)b3jj2Ks|C_8m
z$IfJ(X<H#YEa}9`DQ3ys1((}9l<zaNt$m@QAI`8|js2D0NL84`(#j7U47$OX@Mr&+
zrqc)asv*uQiVPc?vppIFU&QI4s#obaD^BP4>BmzNMRP^^?4^8KdT1pD!_ouIJ%IrZ
z>|cf|9MkKp>1zT_n|=#?2^NJ`os@OUF8CJTW!|Xa(LGsyvDuA;Qx<NL<>sm5S!1wH
zsThbB?xOZ7@5rKax=%d$2g?l0Id7L-+Fy3Qz*{S8@K0X~knq2};8T`c<!-L7XgWlv
z>bf&okpf<<_}spLEcs}p97nKheOqe-FzhI|YT(E>!iE*B9(wV@K)0;fnG(hZmYUIb
zKlM8tVtZevD~x!6A=bElFz%CKchg=*m`{mvLZ_kmVxR^HR|0PZ9+sd--vWwP)9pE+
z?z_0%uT25y34*IfijH<COCAM~geMi|_o7#+-{{kVM+#{s{iiD&liDXU^V<P{P?_8Z
zoZdE1)O+X!{fA>+Dd1c=aoOSyv#6pZ&}rj@Nkh$Cl)Y$!=_0ozu6wVA%gkd3(9~+Q
zJ-d{cgxM%Nm8oMW-p~~+-kr4zXe^RJYy&RVr`LVIOgIL)c+B}OVu&#@ooo#=IO0y3
z9XPmq?bgKkw<dPa{klPD3k(?SR30@AdG}VWH1`o<>T3!#GY#`)nM!j>;?5<T>AX;+
zMEiD!w^Q)HywX+GpXG4)^!`x9g&~2jmM62=i)pMfxv&wIps6&!=vENR23s`DjgJBC
zDzu2+zUnr-@QU~r$OOpN@E$79L#5-vWQ)t6K4&d<S;fV{INr$5{QitV=qR6KhD%r`
z<IiSIDs{HAy9YPH<m4rlf-cJ5^yRIz!};j<WLZs0!Ed^#5RXx-?j$eGxU9{60YDc=
z`Ue}~Z08rq&RUzBlzhZdlTGUR<kca-&c)1#bHTnEl9+3%Pm-=IrJK?k7ZPe+B=yTs
z-}lg#RPqCo5ETDQfsT`f_56a&Dt11u(sWbh_Xhf=waz&tXcr_4l(hE_D*Pj-yR_ve
zaUZ}gPR^)(oB!nbw6r76cz1r43roS!vr>)+4H7jXZ#*%wwWp}7ZjfUb&3|zH$_zj2
zr79~m^3Kp2DO-v9j;ADe!0601eAdH3kDQ^mRwWbVljUrunnT-n3uClgj~ERJFyNkk
zd=@4eJNiAi5C(d!*g}|x1XCpuA<qsh715>iaAPWuN{*N;RY!e#wZ~EnrNd><FNxe?
zeJ`uX?Bi7I9v08B>rC3zw~s2*JMz8{R|Lsazz<vKOEdPv%fh1CrFhKcmAh;_@J46p
z6n1~e=)!nYvj7BYSTD+Sp0WMKKkUHyMa}uS@KF8UUCE|WeMCOUUzcj)PTx$<xi@kO
zn_0o%;B%vY3;y^vLvpQ?=OV|S8-f6$fur!H2yVY$geeMDlatf+dXEc51x58O+mSL0
z296dLijc(LA5-w*>`Us<%HrY}nPs%}l@@qpMdy{Nre*PIl;dmcD5auKrrC79qJhDg
zanX*>Z>abCB$HV}u=Wr0CdVNd<P@x|a~$NM>OSw_e(_Th0lp?uE~`!n*F7FeN|>iW
zQ#+=7r@|?rT#f?Ll2`Ymll-ji8Z)QK{rjgC(#1C`<+oIVwb6chq3-immvM~6q=tvy
zqQ%b-Lk=TGAL#kKIIG9nbG|6J#6gALPSll#Q!jbiFRzq-#w(s}OZ#yh$rqwaoZntx
z8Cm3YIlXP{!#1Ln@ReH(jGo4(oJO1bWpo)<xk%u0AV<33ix$s*h~zYa^UrwNlm>$O
zMoE+m1dR!9UCnax#%z~9{xUF_xJg^};gpU3bn8=hNM|vNB`dvRKFuMm%t0R)D=vs1
z@M$?MQmw%23ghhcg+V+3_z>pRa#55aSNj2FcOTz|>-i*4(p)tp(1ErQ&X<Q5lk0Bm
z4n+OGWq0HDyF9Ut@^WY%rWG?zwl}tvX&JpkA6g1U{XiPi8W9?1b~Qgnbo_EHbM&NW
zcbZB-Uag<vWo9^!{;a=Q!hr5CqMC|P$Jr{Y%Z_9e>-QiWGmVA>R=nEh9??*OB_U2b
zmX4K12qy5mBm1La`?bfJ&x>a?5XXGC&mAsvrAjgN_>1OFp~|1uH6!AuN?B<FV3eU=
zOph2wCg4Rc_t-lA`Y2YL_TdYAY0MBim*|7eGA{Gf>&LinPr(HTib$>E_uKU^=HF$-
zZe1o)&dg2aTd1sBkyMdR+=W)<uCcn|*WhMsSc|s{2ae+GUtc#{*?Sc4%-ei9s~5H>
z4<Sk&OJ#R=RPWn|pNUJL#Z!8k7&*K)qlqHr_rH*>cptD`%sfBit8Yx!s*JB^JVW1G
zNY4Ka|Knl-m8_qZJoT!0iD?)#f|4%Qp@NjlQoe{q+oU>pu4U7(x)_#_N0%Jzw7jKD
zPoq|B6HjpfF=RE?fkgYWi@l{0FHGFJ#J1j^7e2E18fC3jv>-2^aB}y)_kR2QGQEIz
zsY2MoSwyuq!BNTb_0GOrP|EI9MW6R=UXw|$LD15xCt0s7x}xFsWom6R^(LJr_({yh
z>fkw#d3el9N)Kj{Gl?ZX@>QyaH8T19_IxcP**V@&{&|erJH-Wr-sgy)!ulct7|6*R
z6QH8<)1+?@L&0IXKxsESW)-C4Nal#~6}5gu!ckjE@PF|8XA)JBZ=9dYx~zLOTn|V(
zIx<@=+8?+4sM7rg+K_`vI~pn1x=yR{K3Ix#V2!wkjigTEz}?egqvle)N19;t`f@}d
zQJ?<N5^E|nbyvLe<d{R&MCrQvg}FRkQogq$cb|bS^fJOQU+cHGR73sHP)e+F_c3nD
zy2@ig)O!4qho)QfV|NmULR%KbuCszZ8W~-0TC8XV%?hF#;xn@oSg_d^EAwLlce6~>
zY-EO5D^|I&QL+5AVZ)QCMM_gXmgUd2#&igAhD%@en@3Ur>$6e|&a<yzp+cR8`QNRD
zvoqM*2sb(@S;?wGMYS(H9=EwFWg6<Of`V6XGv}w{Jd9_tGXb;~$Y~#=Vvp9Wi4Ir3
zgobf^bK2g{sPV}MrE&v|Myi44GOn0}iq=I^<x1kJhk-r?+WI{`$wAbq);6WLO4RTq
zm^ReW)#b;0p_|9C-~ghgfYI7iB)ka(a5O({L%oP{I;ux%^u&N!PtaU>L8G}m)4j(?
zGbur_cmY?wPScsAgMB@GnlvZ1bdgY7q{33-!F+W_tWm8RAr{f*HMBcCHoAKQ4$uQc
z2zs|ej>lwK%{NIZHW{DsN*6jN!BTlpYGHW1rBZK=hK7@?q8fQJ-(K0HLHKzx=uDa@
z_{*_hRb+ekwrFHe3p1O_kV`U~x7e*|S>68K1zX2M!~!QQ-(dyH+n2eRldACUbv@Wx
zt3no|%dx95d5vZY;(_rYl-c^oQaX6<YX=DAHq%@%H(HZo5E8Sz;6~ZuNGirY7|*=$
zJ)$PSzS}6Aw=%I)W8;{nB3^E${hH?b+{N6@dSC&u`eyuzbM=*{$c4BEs-Ej;wvsdA
z)yn>iz9h~OM#f7PhnF1h@-=_H`=HG4;J4{id3OLhqV5TNzsHL+-*mX)5#M%WX>>+I
zRj6Wa*p|&&wM^9&`gizO#)oNHzPygtM@@BkJ-tk#^o<B4XjF=E=oSBHwD-{b@1XfR
z-Qbi8<$QqmUfBIk2=I9-0HAoB6C{in1w<RvE5<V@OzR8nB@b!Q?@T6!c=8?AodnlR
zn;TZ!@^6Mi$@yXH@k!#!);n}0u#LCu`;Dv`hrw|}+HfMMC&a&hGVpls=U_<V-hy3y
z7k)T1(J~od#jNr=t5FqB7st#n)9q!(s$lSqdMJMvUuje%Kqytvrmc7XStYig6$MX?
z*sgNSUfp@m>~_o*l<cg_Qk}I>TVbUUuW5YskQzb$YS*Fvl-|VhXZQvrs>Z!>X7<_x
zZ}aia^@6g<N(cQ*bA+aIn7rD4=Nw*?*y-<3SRP0-@PC#=IZqc=<_a8VT2Fqlbf@s3
ztOHtZ|5-EPUFnsB3!a7gb1&!Z;#GE&m_C)9PPvCyS!s#N!f`s6$kWyQ-I`tBP5QQy
zJS!2`>2|lM_aJ4p+AM5(y8y--Y|WYNaJoBQ8PNoWWfgA=4b^pWL}HxUV|@*q3s;E6
zoZ3Ufo7XoZB)q#~Z6XRAU2mf`g>6A8%g4=*CDZ5EJz#EexN&lZR)7CnXD=K|;G>8w
zBX2HR%xV{9k3YkDg-lx(rF2oqUuHgX4%;F2QeNTf%1F%6sEuLO-x~6|s=MbMW*TQH
z{E9h8`nRUsoMl0ycjK1h#R8@o&gL`n>Ew)~ANYnZ$dRQlzi3OL*OSXgZNM0iWp!%^
z%KN8@$x5m)HnW6adc&?&^LIfwQXB#3->#);%9x$SwYUK_s(B&J=x{?Bv3Gm1QNN+z
zQCtAm2gsQBS}u6^b?xtZdf3~2kjz^P<>-EtHfdp(c4L6sr4D3*rw*CGEka8b$@?p}
z%ooo2kLF-`yrjCdYD8TdVvl;pwBZA;<)l4aCd8xX&jU@X*MB3f&S7P*n}pOb89ThM
z4Xda_$B`g+cfZ>SJhsRu$i-(hL{wt_J_>itAzhumirG{JbPN=#=wH7qhcZcmy_JOM
z_3Qf92Nb0>c&={d#4DLGzP&V_{+h9#{2CFkDmT(;#dV}5uQpdXYPaW6{p~DcCLFH|
zN%OIaEK<L#H@KXZ)<=EF?%E{T?sNUmY!qpWJvFGm`w9K7XXi?Je}=6}lh!*yv>L*e
zUcN$r=@~#iRhxQ7?6LY3kpJx+)W46s-~3JXyQYJ`36q~lL~W%L?TpzZHa9n$+SL|9
z<T&BE=il6lHATQng_=FqGab9D=)Y}VUo|93Lh@4L3*~ngs9ISfPB;~Y9k9w7@{zrg
zd|!O)JONopIh^+-Z-oO>w?Pi2pAIH3Y1+9NHc}!T5qO{CudQtfjjP#G9YNg@k6QAy
zb`+27>KOs;?xMseZ!@~Kt5p^EvuWj-Tu55J@`LzE*Y^7F;cOSn*uUn!v@$1)7ct37
z;9#%Ku=T=;L6bUeFOouYX`F{gsO0*icQ@WwBIc$>7z*qCXm-vX`nBc^mVX_Kj)C^Q
z$ws$zNjEp~-i+TF44xZ#95bbw-h|Z-RV67ut1e4EuFZhm*BU^wqw|&v(XZ#rW6nH_
z<+n!MN3=;7fj2b-Wx17utq)bKw{9(mHYU=4fERWt9^Y#lgL0xy%Psl&p+ZT(r0dtJ
zW9fruxe^L|c5JT$&PU#XZ9X+Rc)NwR@e$oO>Cu_=PTvwnhxo~5J~1@SxJ_wKLtBh&
zU-{_{RBNT@S|VrMY-~GI7^17)W7+8lU`=Kgt2dRU2iJ8ex%OEcFkI*-H#=fTYh7R<
zeP&W#j|1sG>8g8n#k<~fD)bqg*yp_PpeU@9>r5`$?i`eN44D=QmFd++UUr5#P~@s;
z*Qr&3uVz;AdVP^Sx-&+2b0o3tSs@F5`;SLlG_ZaGoa;Yio{hdb4`AFIT+(&&+wlED
zPH)<`3di>Am)G{44_?)S+Xj5lgapvx>wIE2ct(WjaHXii)1p!dz1y%8cqBO`QJ$Zo
z$V7xQg<dpvc6DTMy_Po>e;$X}lx4@kY2w@;By{BcB@|?5G%|Jh&Z|Biw@@|^WEk`}
z(>Y>DOf8%tP#QK;5(>)OMs`ysyQ6QqyA^FN$1Hc|8M1B<?XDp3o_t~EwcL<n%a8vu
zm(M1>*oW4A2juGEye8`{G24%FAZ7SiPtMkZ@u(HT_TfSN8Af)!q%p9mB=5oGuY+H+
z1nz{`7Tsj=SJ*tewWmv2iD@grYOJWPt>*;<(RoHmwpYUvpuXZ&W!=JT%%<P;bE}gs
z`50!+bl0LbBrPQ##tED&&iSqDPByiYB>Q7K=mDo{FVcU41<?q^%M>oUPO7=5@ML>^
zd9aA6knq9Z2xi-Dqh<ec&FauO{nq3T_3<K={f!&BWuTJ$;^SSiw>==ezwB!zhs9`-
z`Hnc696+VZ&6U~@7jG;WktSxCch?|i_w`k*(fRMh;Bp)H7})cdGU2bqh1C7gyPpCp
zd?yM*NYD5~cQsSR!Z#AH*IkK(z1`nD{BnS$cN^GltO<V9{UD3*9$Qn6>a?q__5(%m
zO^xeT%>=LF=oi3UCxlA5I5(Iauxyk`pxa#$hGArVgnp0u?q3JRB6MqO>);sez8Qi}
zS;@l25wKI!MvRJx$OBwsmzA;OM&T>NLf>#7L$7ma=YL8fK2By?!<x&t1n^3RoJXz7
zB7$EQh&nQv?xT)}?ppa(tILD=BEJtUuS!0@KcPdy{faFOPZ=+}Z=bhAJyZ)>kTF;1
z5+hu%0+XB5&wcTx)Or4_9tq_Il}8@jxO#Ou5>PRUi$@!Mu^N9~D4_Pi>cre<_Mi-Q
zP2sOQ8@@dG-CtOXP-h4!CFwxGd)dkL2Gch!u4)LqgtW{I>x(PIb|Kg0AiY2rP4+JT
zk1CA!kde>FMN$6>A!I_9<4HgI4q4*-waoCDkzrBlx37Ki$k(_TS_y1?C{{0iIr*C@
zNs5I&mF1bqMf+~IpI<SnxI(UHB!~Mc5#MvSdO^5#r{6>VxY0gQeO;;6SxU8>^?(C%
zTffS4Nn#2rJ@wDYs_QoAX&(}sk#R}qT#uQ2-74h*bXx^VdGj1uwh`L6C$HKL6GUnb
zsv1D%tE%N_;uUX|F?9U{3LGx7M%yi|1qmwY>w}>v>m+Lj${$*OeR<ooCoNjv*+bfn
zBIC_eiHRKEgKWp-a?2E2s3M+uStp}zww9CCZ9nEA9^CbD+&%T(Plv()EIRx2cctE9
zY{?JHXa-rZExh{kh(|Xi&e!|Z6MgG194Y7KU^Bk*2Ln1D2BZ2wpR&T%DtqiaZ3&`=
ztF!1}!IGcE-FM8e?a0e3P8C<p$#DXz!rssLyNBCi@3Zu`o(D5}ygi?aW_2FgmoILh
zhJ1hU|M)EZaL(DBoK(J&K)3Y-($v|sJB9bIc+RN&31L56#kq9qHDEl8>HFGm5e%dJ
z=3(JGd*=PR^OaByH@nX8_$$rYAS#`KbtsY`xP$rDtgglzQH}X(^l7BlytVyLg*VL_
zbq!X!QGmB0Tf<dvxj?v7ooE2w=F>?qYT^uw8nHq7^V*SA*Mu0T#K;)5>hjHGD|%Ur
zm0(S(XK9_BwZf~mm?qt|aYSg#V~^wN?v}isRsYl5@_ig5;-P`?M!U>d?qc<g&oYvw
z9ieEV0Sd~Ho8B)riZ?F1#%l4z^f=mAYhnac-n|=ND2we^n;sdQ<pw{MQC!K4h>i?b
z;+QfV|HrU%Te_=#6wQ=i?D(&tRL|8A)GA4!@%-EuH#-uiMta(k)MtLG&^_|0LI%lP
zQH;=89Bq!mwI+h?2FkOQh81p%a|cPMtt4=?Wd0!Sd|q8?3}mgb;51Mh^kkl4BjhiF
znvRG_8=hq(%wjM?WWIpq5U5c86WFk@U*%KjCeRXh*FMyuL-tg`emN7e;Qc?EEiS6o
zxk*ub+=X3&MQ<1?V%60Zly|7>e$S3z7+I8-vw@ZV5ep7YUv|4QqS;csOy=ElrPjl-
zJ2uS<J1i6(r7K8P;{b$nytz#*c>P>S61vrGeA~9s`6cky1qX4UA8bmOyMH$@9${{Q
zdp>%$c~)lHXe%C@8ZYB{ev#jnkq}hWIb=Dm`_>dDdSh0ARn?bRk?t*b81+;^(QDv_
z)VG=Lc>Mx7&F8s3y5PkrZdUd?oVL50D)J}kTY^PIyFORc5aA*MHrGtZ4?yxk@E{tZ
zzLF=;ei_C`f4`*Eqq<dd(Xbjc`!j?ObV_eW`k7u=P1o}>fGGW7sSXha7IqquzLo#H
z6(SP?lD$y$v|6go0@#a+KYkcB+wUTXh!NxiWF)KA=l7UjzGS7n>;SObAC=ErIm(kF
zfGKSux40%?1idT1e1GrC>2`&Ax=<zb^lM7FA$YDRCg)XJTs#XvgHb!VViW`R)R;Ip
z5~_WQLP=XfM}vQe4bG-w)6-pIqFS?NtBoWhgp7^J(s(>n^zH5|y=)lf_J%Fb8*|DU
z^QjO&8ih#LRH#+`H7GOxIFYB*=C0IWt&M<KB4KA|Vz%B+!Rbh$aiv^7ry6DXF@1s%
zwjF%aH82o#4dL?U72xW4bboBj$RJ>`SxYTeM$Gy3i(f*#N!Vn(cPgEyr4Eu=VI!M5
zp$gzAg)?RcdwS9UJ8KbG6nus8w8x%Go|jByxL-i#;T_ygz`Hlwk~jHz4b4}b9pyFq
z7{(vmw5kjG6{s-GMRp@nv=c*?I^^`Jxh~%IFFV)d9ki%?IE@O^IMQ{b7n~*cDJj>Q
zHxpEkR_7HOtJ%T52#|>sWUK5*ve)WWEo&<VNb3nl0SwPuq9O+wzFTP}>Qe^LW7t%t
z!<=&F1x}vfu~|8kKCcP6_6BRpoSxy+&DM~2rP#M#nqW#6TB+M!tS$I#wSdP7PR*0t
zcQ~gBPGn?TAx%Vsau7F26kAIgDNV*3=d8taoU4xcM#L+^`?#6hE4Hy}7u|fqiT0x1
zMcg3}?ojIxr(Wsq^u;6NNK&Kp1|zc7li%&z4K>Tjq$F<ia#b9%q23<(-J8(n*ck(8
zH<`D}2DXYN=FzG}ea6Tq3`b4MfL5twd8T~Ka?b)&(Kf?<@91+z`#nWO(hXm+4&Qzd
zaXarKr?2`#`yQ7;mAHK1@877?n;7V$Ft+(|h~FIM&#8+#DrGWV3OZ?&M-Y#G(^wwZ
zP6$1qBULdJYT05HQ|K7$PXuO|O{3^0Vwt&>@MQ>@CB(!vN!$gaqAyU#PjWu7U7am>
z9OS*d=o2C{9!CWT>b8E@Kr{RNBtLypY`Cs#QDireN?`cFh6M^c@H3bdZHy{IpW@H3
z!inM`@%Norqc7E`LG`UpjWBIjRcqZV)vs$@5AP0n@qXKLoJP8ua3dILcUBA*OS2A@
z;mVrt@QBd)%r1hqRUGs4k4;1-j=2JtP764KSL=zeRN7QHRM($v>O-&M6!75fau#jt
zXetI&u`99$-0MhhNh?rV?c(OgsKMrIy1^f=iBP}<$iNQCrL50Q$oduqx7JZ!7&${+
z&L7GB4vRa=(7=zKo{lEp`-v;!U@rP>hG%x%Vn0HCD<RD%qZa(*ItPWxTaCU+c`D)3
zcw3<=>xq9KFY7!^$m6dfftSrxAX~(Z58GWT<ET!%Px^sZkS%p|4Y@%o`CI(U^z8@7
zhDvumS=*V1DwERZIsK`@u(y{aozH(?=A0llVl?0MByq=4je{*Nz4Y4z=zkf6A#D*g
zB;wnAzr&{Ey5}8~)RXV&uG2g$0&@`2)U|=NH0R*T!_M8d`P5}F&JT&yPd9Go)}m$@
zOTV%S_fc$-w@DI%q*gS%WvHE3d*<L{J^09%nN<QvKCAwh7l788xY!zB&^G#ki~g9H
zja%@9q*dB4*?_+6s?~vs$*)cph3ZZCUjY#Vp5^Y`OQ@VLjNoJEeB)a8?<wEFc58uw
ze{wLXHV~M$W`zYl?**@i-Gt#i$GfxDSm^_7okS^1x2>z)Y{fKCZ_x(9D1rAg;}Kwe
ze>GDA{sbbiU1)KkZ@XLL7P+_pu*Fnv&$?1lpW2?U-ptHufUTt8VR_3VRm!&U?&9L&
z^}Mb(wY5U|@u=0&@zq#40UPUWEs^mTF6U292a{dbAEG7*pTgdDVq^hh0#|o;Dm;w_
zYuY5a`3YhcfFVo&Ccu5#BAP+lH@5e<6-FOwVUkS5J*jFe@1JDr8-RpCE<*z1Kk%D$
znEds=AvT@HQoY?1rc9$w0x(8#NNYK39wEwLI-0Mbui80&7$O%-nL|QE%pp&A)k14c
z^eS?_-weW(A2P}Cl7U6WV>s<eR0p&jI84UORlh_D)M|SOiHZF{bXvkdT6PYb82MlO
z=5KHpCS<-2=#B2D=I!LpH_5G=)+YzVmpxY)Jn5NxbsCA_{mp`B&`bMo>rn4{sJ9<H
zHnScxO#;|BYj%x9*$gEab}T|gF83$;H3rkImQyYdcwha@(w>dM?XOHr4hC#D)=MeH
zu*%qTjKi9?gTwV>3>}91d8@N0DUL6X(w96}b0~~A<}He88fT98u2VcLeJMT9!t^OY
z^ENca#|B}@kaT=0S`Q?JnpnfVI3>z5GFI^07bhI<Xx|dCh1%Cn!H`0}`N=y$;opCf
zvsoM5TT^5CYcdWbzlyAT1w5f@&fzwm*9>Hv4J;Yedc4SLWVnyKUsQiE0kbd(9V-$v
z#oERj^UekJx4otH<&)2EOV8LCxA9j6-5#W%X$DuaU5H*53AJFUzEdW~2_4gQu`3&q
z70|)HORl@<D>1~9{Mts4q<8b&OAwV06N8`K@(Dzs)~IiDZ+S#vzG_m)t{X+s{b{X|
z<+aR~Yrk{N?clg-IpQwkOR?IwgO^Fy>EpEHnmoTg8y-nm*0*w-v&qJ~rvdih#i$>E
z0wHI*Ko++I<o;NOrj0p5r0;~I89wH1Vx#+#Ms%&e>5o(0$H9Q;d0tsqAld_J3e8#&
z9E&1o6Zc>%XFVP!vWcn0sdnk1ayNK1QBqgyX4DCK{77S<=QGuRj(u2@$3E}o^aIyj
zsS!F9^^DK*=5A;w=s<18xu{KjYh*qh6c2utMN3MIt1;bbEBGj(LSh|CFmD9|Vrctb
zh*c#?;GFW)Gh?!0*JJy>J?;8#xZ-*-|8kVORX535kC=&W@7tx;_4&C)hwHp(SU3IA
zY!(#E{qFOOJ3wb~qj>(39F>@q_BH`juDqKQ-T&l!-atj1+)~t)OphPEIIxO)rkAHu
zrn`6iZ2zWxcC%cG5PJx{j^rdcq#Db%g!i?4^`qj8R-g-urE7)DN+4UsQw&SWVU(Ac
znXfIQ{&CTv!%$JJfh4B(5AkVP+0crW=BQgl{ehjX)lvldg~x96OW}KZE~9x21+j*t
z$rPoDvXTyzw9GSUd;D)Zj}|T>`*TuM`w@TX=T9^F?g$iFEgY6pBieqK&a5_`C(cYj
zx<!IsA+~ju!FCL{sY(Nh_h!og5BEch%|>U6bI!TBm_z(qR_;Rwr!uwtZYW2Jm*t-=
zt!l_wlV`JYSY@ES4}c6TX*`r;8>QDCLggNxwzvB__d0*&(>xf~edSZPQ3x?C^Y(x|
zEHz-sq|0U(_+tgY2Ds)IsBzhhY9e|@yb+fMRt5yF2<H2Nmz!hb1-3ynIVO)T(a`XZ
zmu@v4Q#P81^n|%b%f;_sp7xt}_V{(zX<p~MwjC9MeFL3M1#fz&VuC6;^?&|Z_F!$P
za`QUWIGW4^@yyjkG}4#8{p#M|-8gipwbT7{%7JgfN=kbE)Nw~er@T-d=`MXlO%7Lr
z_x5mv?QZD5Kwdo)eNY0r=Sd<R_sj9kInNO3u+H1wM>qQ!#TvcA&!-DsPoZ7wd2BGt
zoB+)UT6(K+Ju*r2u{$JwgXVbYO<nL(`O$|k?3C#}vG?eSf~mX_R1lGs`L;)kfre)G
zls3jroC^`r>kZzV$q_@zqt(Pu<b6p)Cr-b(xIjHl%5NkYLPEBgYrWr+WVV=-Dl4Yl
z^bd3GJ}hfkQ=(xrMY0r*j*j;KY=DrLrw(4+P4OCv?$fXU$(*crOcb;8mrxK{rU7E0
z0!s~3y#$(3AGZYz=kqmbCgUC3$p*$0>J~S%mBv5q$>{rayqCQcv>D614?7e`D@`@=
z37S6vBF**f@>PsK3NL#%9qS64=C12W)c|dv{`(<+`0YIU0Z`oQ*apD_fDkgE+L~-I
zTdqgq0bpUyHxB~@xJCB6dVNcQO9PE|6LJOy*~z_V(EQ&BpsTG7nJ5W*vfzOl88007
z(hH-3Dxvx3wheIu{f}YV$NqC@e1raB=PdJwrqA-6&aa7M=j`SL#si^iSd`yM6rT04
zh@|Rt3KkHnvO7LEN1MIC;@5zGCkW}yl5b+F3*Az>5gy`bw>n196=)aGgByQzSg~T0
z?p$x(e@;n^!c6&vHnvQOJ3L>mlh?!bn%l$0w(C)8?vx^@w%U*RnW~p&3*P1xf5e(l
zZKgBDJ?Suh{qXeb=;}yNcS?O;GLmL!I}fJ(WWY2z#cQuVXT3>^G$QCW^3S?^tAKir
zfJ3O|qED;WOPsX~!J-(~91Znfx5N1!kO)z7L&4EavVxo%ZQt%tUrp68o_ekVj-X!L
zk&;*=Od*XhFAXb)7kjAE9m{y-E2q=Z<VuqRZT{7aqU;n<p{KbDqato}XP-4&6mP63
z6!g?hkKz&4RQ0k-_%>`ge!`h!eLOzwG(^YfN}NWUdC@i&k2#(;`V!<^1D<XDt>F}R
zhwQA}lM!Q<K&RlF2!Yqv4}igQ1E4gE%@cZC?F+;39o|Q@vKK4+kze@tW&0LpX*Ewa
z>L5=z6-faWG_TbSZDj%r)d(FXR~{HGxBBnZx(^K<_Xfe2>7Iis(}L8777W{aUIh^e
zp1hH3IM#3H_!>g6qGyMjVm)WYKX`SFC@Zr|NRl`7!Ppt|hB^^W8^L)6CEvS8+zUGz
z>4b;|=ciQ@!^ZOy9kz71y;HBt=Oj@6MA!Y*FmSjp3wksU+lo*IQ?+G6*?g>?{ouSV
z&oU`%$6_aHc}0K?`iyP~K#KQzWc|fd;EC2IJE+o$_9IRYnD)OK)Am?OnG9`9ubB&A
zQEHX8`7-dFla+o<#TJACWiUuOcgQ9BR1mhu&oC%kp5bFyYlKQ}6g*b^)QKzoRXOzR
z<FfPo`nKSqtEskFS<h?2#W%Nic)VNA9irP}pLxXvy)JgSg=27xDMITB50YIC3i?QO
zj=ig`O)1a)&V%OFpj?o^!h-g|6NEX7j%N`BjXIIQ=01TKZxW+`iA|C^E?G#!I)*#{
z2@NDM5_Z?GwB$uIes&x+KskPwn{$?7->r?%AvX8vwgB}Fq1OQWHFXh8q7t&d>#0_9
zJUGE@VaP5C_WOurx+gWlGvj-ol5j`Pae>wyBG?Lr@45j7w#o_LiCQT18om}41-#`H
z<Rm=5K0zoL7$&nd+dIoc36w_SsL8GDYv8)(*#<CUXg7O-SFg9<#VD+uL#XLjUsOqd
z=NyV?6n;+Z@kqD<G|29=S8q)n!kXMhbN|J%O$VB$2m|6t^OhgVp62y{Q`uO|i1X=^
zmHRgC{xHM<EkvCGfjkiTs|0YB%q7L#MkiFf!eeuHrw!}y#~34Z&Ub4b^neA~J6bEt
zo@0d%8Pkl0{l((D3)M!5?q^N=x!f%JVME;kh-RzJH|ENRgDT8AZo63154sq#2X-4b
zhaWUECd1UfrA|%@;6Y!Bz3UEnwiBX8rI3P}1MnFfu;FohP@A(O)AWMe`d3a$hqhC9
z*k+I9^%;}H>w~5+P~YTI;Q)?P{Nv3rxpdO1An(&jjRHRUxX`aY_!vH2$rEE?r1=UX
z>UbHo%wKvbor#NKMb0s-8hIHYsho&)^@i6hWtz@G6C2fnNZK}Ou|~2L$66e8X|ulG
zBmYC9-|$c{!W(h0?if$MRC{oB-;Qc=V~+6b9O<BFekDB|(1s0j*EEJvUO#8Yjk64S
zj_&n&c%ZgaZFYh_h>i}gE-CT`3Sgkxvin54%W~pja*ks7*lqVurMaw8)`dhys?eND
zCL#YQd`k0-b@}{tlB2m&MsFxOZ<x#-(0dk{&r)@N@80q5!+7wH9)2_pQ2g$Cp@%pH
zZIfMN5vJYZY!;(;40{so!&Z5d4PWLf{_|o(0F)g9;FBJKAqvop?7&2O*J6CISQGS9
z{+G65I39;WFdi?{Aq%-Amh?s76AB-V>SL?zrmuoe8BRDpPx3ILQyR{K!64hZr{u|6
z_h&NM^q+*u3r!B>Rtp!fRYvgi^z;BQ4&&z31N-4=-Mu*c$#kvt3yb;8@7vRw7vd1A
z<c$<oDk_OXhhr76!Wo%zshWH;a#R)y!0%Gp8-wVhy$=GC;s}U1hQTld<_GH?9VDsu
zx63vmx_F6~IZ?dDDtSQb&{WHLdqG|Vn(@>1w5;SJ&Fey?{)aN%4goi)(6M3X!@nY}
zmp6YFc&-MCyZib<R^^W}WKxNGz@@f(wGf$Z9!Gu%b6sHhvEAPw)qNy_@z{<E`(N4j
zckfL|P#vhk@WGoTZC8$Pv*qy+ZKbr5$AQ%3eqgc7bVN6uD^2R_HW^Dc`V;hNpRf}|
zy%&BYHbJi?U2eS_8&Z{$YzJvCz<!)@N)O@Olv*$sE9)<-ORBQSksfKE{5y`hX(ClG
zqMgOY8ysZXoh0*VZ;KiFxs8W(3OdDSV$8~KS_&V-4hQPaDY^recCC_W-JxXTP(~Tb
z9{+08MXWh+zt1TxHo1Ich-dgN5O}6b;zjWus7-giIN#)$q4C^gL1PFE#Z2f7Pbn_9
zCyOw=%5dZecvak;fAe&y$%55L73<8Elev@nFqovYB?oEKm{|1qBdcRf5|ffBXLu(l
z%W<!n)*9_{P+?CnQcfN6r0u=FdZh+H0oM03CR0N(<XCJ3kE3HLY+=&3W6VxR-oaz_
zg;`=zXV(BHYxig%&D#}xS~nk3rgQKi3>_JtTNv2U{;8Lr0Aag+S}UA~1@Za^1s&Iz
z?hX?i0+6%0s|BiF`i^HJ8p_g~yLE3}IFNn%kIyXTm{nN*D^L?o<Ec%(P;g#)h`8o@
zK7KkUU4kJ19#S(H6}Y{e)B=FgCs#AMvAJ2^SjX;i*1DwK9z`t1OEl)U&ug{h$Z5Or
zYtF>elbcq%Ikw(%k!Z!gHP6mC3~lAL2ZitNk-dKaH5d$5Skv`>p{4Qi{I*+#i;N!@
zAWnlS@b8+;KWCpUQN59L>Y4q^&zC%9pIFL{1(bb9<YCUMmB!0Hc|j!Y?KF}15P{Fm
zJLvHEFY0;(*e0vqcJHO$Yw!8-8>~<!b3IxoH*Sy{OhLCC-@EtkcwQ@UCdbkq3!Z)q
z&s;+pq2oufe9*SbQ<%Zz)w1__U5gW?EMlWzeWgm{^oScLH^#oHW#ENlXYt9cb#w=U
zVExOx_&Qxy>Zo^6Zlo8BHp`|!AwSlb&EF_cr~vW?#LE4E)xVBTfnLpPyW-{bEnA0~
z)7kM#>e76PIIwe=KKDRY+*4jG6W<Nxz0S~YpouGqcx|x`!s$bUPEG$sd@f#~OGBnc
z0qx4i%FaH(iG`w}<_!^Km!~LD!}l)(tu)#RsSzAV>g($p7(TfrGaBX>k$z~(bI5a5
z)TmqPWZE9P1SIUUg3MXtoRpLy0OC%XP{~z!nM8FYe876OS)!bhPP>_;7mXgb#O$zP
z%{^sr%tN*Y+{LDxK$nJfjHy8yGng$BMk9=2&H^HNhD^{IBw&~qDwpI3*!t449DLAR
znhYbmHUe6Hum4KY!|T>MFn2*|{<yfk9arY=QQ;2HhWA>>GqD?nCGadXBH(tN1TF?t
zowyAsCA+soBG+qyZ1Qhne~dECeQx;fZCb6yAL!DB4jaUX276;EV%q~z^VL8yqP%Yw
zP8Z{`6T%!ycD?H<TlIvQBZBPpwO0Vp%>4W4OoFdWI!}9=j!R&gz;O8R9+g513JI4r
z_El%Eqi=saO|vnk)AWJN_Ejl-D?R79QvUk1lrlE%PXoCEgvXZAoc-zs26O5e*`E5G
z4$MbIJ@y<}Y24(wR-&LIPkQl1TWN>U+K$|oD`ln6>ol>$5U!FXs8z$!c69LeW{c>S
z?3!?LAPkDyb?SnS7C_@=|7i6L7>A#d%eN)f>03__e5U^KL|TO%eVCCr{YVFV^a{u}
zPVRCQdwO=H;4gG`f%;<I_ccZOPZk*5na}e<tT4g|$(?}QO_uNFI_A67&Cx8aXAJ22
zKJuW$<IY-v?dgu-n{%E%H6D+<(qd_Ya?nV#a~#{yqQ-|7_e#)x5K;YJ7Rm_@aYH8v
z(K4X0uuXvxQ9C@#T6-~<3=z)~rarjyjO#kfWFq}BS0r`5!EBl=%+v5=82my+$fH43
zXqg_j?rpPt)vSrBY2j9~a9NMakGTrn3Nq;^%T2#NMsvM+G64YrK)9n)q9QFJo5CtB
zfr~L}Ialh-wrq%pZT6p<>VMB-iXTwV4dVcEHg<lo#sup)5I|eLiI4cEQa`ei+X8X#
z<57gkw`7I^A#j{vVQNc3k?EG7$$8GqjxaUtAEf`NINXSBwbe=~MmteFKR&oC=HL*{
zP-Wu;Ag~dp7JLLL11(;D|JoV7gO(um0WxM3I`9ij?>j!C;7eiCX;EN;DuEf4NDI4(
zA|xwIU&hZOn{R~a2d6198PpS$b0c1Id2rC91OPKjcD3}Fxtc8!XqXu+M(GIB!H<-u
zVWRx}ztmZ1>4}MB7NGpg^e{oO*s@#)el0C6Kb^LdFKUvaqq8dvaNZyj(lf=%)Mcd_
zERq6&DilOCzbZ-brsnI&$L9&cNW%9g)9agN&Hm<ADfO)pTr99iv^cw%T3O7M7PX;0
z-ruWn%g6oxojF?v;s8H48o-OZ?M`cG@BAZ${6`HbPG-Bk7ZKgcU5fP26p+Ar@9cAb
zkP{VO%wkxTm-0?C=?AAvU^^O!Q|9aF%U#xAX~dF$FSLV*KBV5yLVV|gcJyfp^>atY
zU$pE_c+kY0N>sAn={t36=)E6^TE3ljNpV)(l;9{GgM0W#Km#ab_}S&5_tV(y#KJ!d
z6!(1uEBw4UVi948S;mcKtGUsiz+dF_YnLK0Q3U~U>5Peb?>}Mi?pP{^kc6h>0ox!C
zH+QMB;#EvE-4e}yH&9hdaS{|1%(YilRn@5eSruy%KRFRI;^07Tw=1zG?NZH<Z8#7a
zT7p&&)g|Qy2Eetmy`;ttEvv1WnGy=vmhz;0Qoeo;kBkUr3lX7ho5OL`q12cj$2s`_
zsoTUtLs2(WWOg9G<k9R(7~^QS&^^h~!dvv>{O79yJUB9+3KOaP(5|fEt-sOq3YN8A
z9c*z@IBHn`e$E2ujf6CA+7cragM_BjKHI}3sU?UaO7KL^tDE#X&kUzPQH~Se`%m=W
ztJf!Q9~qpqe~DEoN#AV>6K1&Pm~K5kKqvFQd>xV&Ae5zC?`djk61O_7qv;g<v*H^T
z7N*ok!TcMcj3gYwq|yR@xy@*0wmyJ-en={5XlSr=e~^LPW03PwLu1fFR)VHnOw+kg
zk)WWSX_I$@LOQ%<_(U7N-m0a@k$3HR;0>vsVvGG}+SwXIVJp(3ccA|Ft@39!q6PEe
zOFs+#XG;1+3vV3N9XoC)op}(GnvJO;{&UZmY*0pF%l=^yPdA8~jhQc-_qv;jdljbi
zh1&-C!%dc*;iAYtqinNOTf`gE_yHbZo=!bKobO9AZx)(Wc4&)1w=HxpkZX=rvNbmH
z6ByG|&j6p}|Nad8uRnbL{&>d~8sIn=kqr+<NT-!1AzgHak^eD0GS84eUl6^fERrLN
zWCqzAYr37y6+eRtJMQ+*TRZAaWHfX*omboJk63P?&_9_@WYw7X0n{J?jXtx=2#Xi+
z>C`%2P~2QJA^*Lm@S#E9XMC+q-tlCCaqEGMoE!k64v&xLdz`l=d_-;)JATan@SK5L
zaR?wj|7MG1m>DkMP9Zvkr&22;)HmRM*C?rMA*AyC_dNXnI>#bFp~_%(o3VzHp<`gY
zVM&u<bsxa6^-kr870RUju=*8<gllf6iRN)s^}DmDN9Z_TFaQA)7q=uYjTD`LfL^+9
zWTa$}Ciub$goZ{qwhx);$OIxK<>6^^s1F~m#e;h3wSN45)c@0yCz+7j+DaB~t=HPt
zc5>vK<m%e^k6`8h4F7+xmH)RN66EinPFE9TcpKWxftPlxFD%s5H>!`PRO2SB)*qm)
zx?c^+E2J|r+HKV+RT+pF){87P%CEJ$F@<rC|NfJdRHSAtx4(6CWUhZHKudjK2+&tU
zD%e;qSd1l^yKaDW{vW-s(eT1uyxxeisL~8?(Zt4vgaRjD$n~{j2vY?UH#hfu`H2%j
zjD=X?e@XWKE!_KG&vFLv3k{MQ1_`>Ah)khmK=KZA3R*Lj0^X+#?z1+9<Kf=`_nRZ5
z=GLb(Tv4D-@*PmTmg{!t4C659y?eO7|KZjTjmVZSlUCf;?0jlas_^ab;J~zK9f-2U
z&1!@J;%%MVRceW9g|!N;tQ!{9pl5Y;wPpPs1VRix^lK~U^z`z&8OwFm(!x7jwTz|L
zO$X8g?~5YUx7Iv@%%u_u8>WMD#G;O3uDcOqhQ`LEfni%&T{Y|WzkH<mAHmE2Z9x9d
zxOMuz^Tz=Fz>CqxlqMl3r_K&R#HM36en)<2G*`Ol2-%Z1V+A5^LCAgweW@(Bc<Yzf
z8AZdx7+GFI5Z?msT*W&7e1-0OF@)?s{L8u8D#iX4+nQ?{4s&5eoB3>UULF15AP{7b
zI86`*i^r6Pk#~1@A0(Odn?ZIsJlx$SymrXZa6L54LFnj$aa1tkZsyq%aa7l5Ee^A}
z&b7vNM1%s)9e+|L4UgxnG&1lG*E<MqP8NlLdu_Db==8zCsK*5M)<|Ah8ZFLcu>jpS
z|Lu97Pa&Q65`dkf>0-nEujBjwdJXi#ewCC7#_mS_l4tIU|B^539Tc82@o>D_q*3MM
zbKd?W14nWeM+O4=34k_&_^X*-fa+anv)*q0_j)iJ{_GBbV^0q+a(0Umc>VCWJ;@qN
zX_y4Ki-n>QI5YXu7Dv+sC{2xxrcUakRj!xlwA#P_0GzRDfUZsP{ksBgpmx}38duQm
z*{Y=XYg5S9_IBJAK2Nh^7>Jf60mss32Z(AlmY+ox6ct0Xg9;7aw<DX3CK9sK<U1YD
zQA1%nk4+UTOCBxNmGn|KFd7;}iYqVR^p>hK9R?A^W3(s(1USMr(zpq}x74LN3o(3r
zj_v^9zZD8((o6xOb}itlBl1}uh)hJ}6w5RcXWoDinRFgctI_KTdFwbrguuK|kvw|M
z&4iOyz1siwoR9xR5TH2shXx>mBES6;HT?fM_^qM8r4B~O;g6JskhwZE<p%ElKb*aF
zSXEuuJuHZHcOxlCD=j4*Qc5>ScSv`4NlCXzBi$WJmvnb`=eKy`zI}dA-0$^W`p4nG
zIeYK5)?91MF~^*<S4sB$`?69dW(jmC+=*UYf4=)kYPQ<=^_R(uRkTX?)NBhg(e5AS
zdV512^JN=C?{-GhT#xg}$c8qs^jy0_6HZ%UPAD(XK?7zg_p|-Ene8FafAND5t0L{{
zckQ*FSQfKMrXnl^LSna5xwRbqZ8AJOJb~H8j9%u5vYjxnLHv9Ljey$~=Avrck{KqK
zl{$uBez*q0vRL~pnnT5KP3&#$?Xfs&WZ$vTF&Ia3(->IjQ&~;pP|f;23z2}WD2wL9
z*DvE6ru)mC6!3_MO!T5u|F_|I0^6bx@U#R1?1{%~z01azc%SxXIbp(=lQq6S^NJ!T
zQJAGE^$XkGHPg>*@ERaQCgkA9pn4~(ZojJktbueOj&c{NL9WSaNq}_dvVEQkIj_6T
z`)K6_YRTMuWNfT3W8*1FXRtSDQ&Ui_+bMCqo@8lL@HGY$a``-77&WIg+dxy_J><aR
zaSwByjX9xqBa3jpAC?KcwGd@OUCTum{pF6J>9db!K-%c!e6{vau4+;EuokZcCy7hh
z%M)%LCiV}=_*auZOAMi$T*Kr3eh0{4-am%Nxv>#SU6AdEWmO>&Aet_hn|pf46Q4eP
znxmUxSBkF;dvrcCiiv<B=#QvK$MHqMz^f~q=#8(DF536N*3_1hetJEFbxqMdpE(8Y
zyHgH)79&(}5=VpM=@;47kCl7iP*#{tp#<L`<_$@-rPk(4sc>7L@2Yh62>HQdv4o(Q
zaE7QhJ>0uoA9bhEsTY2;>k9{MWEG3Ix=B1jC$SI^{A>_FAY1-RC@!=2bd|Yaaq+q(
zCorQ&Dr9)PXvSvevve{CDV+wlAU8_Z3`XVARQVCuxDH0PMsu;07)*Fcrc&S_|F0|I
z8&r>wkkIsGm14n?5ekI+w)^hn_eX`48B=#>=hSH7*sra*dYnh@Yr0P5kjZdBo!*?b
zt(Xh!vf>H_{xlZk(rMv2<f7s0KSz9u?uk^oAfxbE^FwMCa|qZis0r>xBf2oRyLdtf
zw#SPK`h1=}9UcxKB3q|XtD;lL#}v}<t)te3#fHsO6e(n0tpz#g!L?)Qk&!(e`#ie3
z;b>}2+Dnq|-bqPGHaug6Dj^LG+`=BrJ@_YNEI$WpjGjW~r0^?ZLy6_w;kR7>={x_&
z<0riaV=>_Jk@kjzNs|IHvC&I7I5^~e&WE|ilY!G)_NtLr^z>5Sp}vD=A*=iQ#be6|
z+qE01)wTBXRu79lSF0Nvxn~V#Q?GO&bQ0o3p#GlVQVX1jrP&Rb^1p<HKT<q3Idm-8
z`7U^6+u<SHZRQh%Fu41{SgIuK?djiKUym%ci+*!DF;Eq?Y`TJOJRR|%W@eV_{Xk9^
z_XXGwh>V0-_a|1GU=jYsv;IB+>9UV*&bJ!LdF?c?%~K>F9vx*koy=#I8xFp-z+ljl
zR-m&gHHEexZrR5_)dBlh$2je8Ap7_4`j4;EsbRqdFvk#_`a(m!kA%}wQl#?o@+vIm
zoPpXnsp=)RsC?dgVJG7Rs;F|q731?=PAbYDkpCA1{rA7|Y9p1UA|pFCSVHuZlX&F?
zPPdWrL1_vUlneFvpZlD^@MNw}NBugArT%f>!8l%ph2ChZSd8#r=>N(Z_^qj0ZpH~O
zVV8ugd84J-9B^=O>TdS$F^P$#Nl8gpL6Tl^adl{-dSjv#4Gm4j$8KcRaswnvN=nYD
zU1p-cI|43XkaZaI+DeqF%vAJ;!0N}mU&I9*?|&S!f4&KNPQ$(k9{$-T|Bnf6nR*<{
zQ$t_BAiDR6K<hFzBzt^xM9R+2uIr#eIGOnYbXV4BaEz+5n9C2u32`6)0`V8m$AJQ_
zk-VX<P4y30BD?#yYvk^xy6k5xE^61mu(`dop02Sb*JyP9wa@kq_8-i|e}gfU31A^x
z_omv4YtoNH|M|x`$@~D5e$#4p&q;=iL;3R;|M81JY101kC_r)k0g7Y^VY72`h5@0n
z367?okU2Z~Lggs1b4Y>{bu<nY6I19>*a=8`W2eBsJo`~&g8~B^;86eker-mGn(fkf
z`PN?uC@3#vWMsH(R$=uG3{;7}0n(^roNCPK?%GbZ#wz0<gv<Y!JPCS;#sXyJWa`Rz
z2<*QLiykQjb<noBW0Lg@03<nZO0)K2fD#<Ri)1`JbH(T1pniMUKc4!x7dc-1QzNBf
zg}*Hu334y6mWKQgaI$j(e0{}?DgMVzJ^m`a0>jfPvqB3(neU$qgFlZfJ&~AJA*4(9
zFZPWVXs}kyTHd1l^P|9fHiRrLE(QinX$%(>6!ab+?k_xF>OClR$v005N&Z~>5@Zly
z0dIqbZ%1-S#>U2<u8#FtgUJ89$bX(p&*x8;pctP1c|GbbsGb-a!Ag@~?-gZ%ojqEH
zhlfYLN;#FaD$;J|N6?Ge1pS|c!GHJ5J%F)#N&Y=U@o%OW%nSjHetS48pdU+5Uw=4}
z)pQdCIN5eGQ2%_2|2Xgx<Y2@kR#dtZ{}@^cBro7$jewx)*6r0vjzPaN^<O;csvm#&
z-FicXfX1KC`UE1Ew8esBEZ+J(Sp8Wp`?Ude4hI%=0{DM%NBsP#)IdGrgz?)-Y0-pK
zQAs#g6mBGYzPP_H4FLf$1{wmuBO%2aSRJo|QcA#)34r>G+l&!`yyYi@;jIfK8P`&H
ze~I$vo$Njbro;NiBtt?Dt;T*2Kj-V$kw-U!l+=rijI1K>ky6R~kW0<OqtPq)_mlIV
zd*HthtHc{%r__5&Psab)Lx5wP%<GnznVFe=R%tP(3Woi!Y$*jenK^gxzu^K27O%UT
z3(1`V<?or`S^m8Hf4>Fr4!8?2vo~0tXMf<$7$eBtDnSz9*q@63mA9Kd_GpJ=T98lv
zFmTz=a6ls|(M$W`Yv}*q>x1;Zk?WC>k!%+9KR32NuJHQ{+3Ck~f4by1OH5Zr`=(m?
zlGS*`S6xHHHl@0xgt5|mMls(3tO1&^znp)2$l8Zx&1pEDyFahJC<Nv0<C6!tOyF@6
zaM`XS?kzN@0d9x}%ym*uef^tCqhW7=mH9;`2#1G<Re6N|<8c4}X5jPW7KPuQr8Dvg
z0vT}P0W<yRBYxVOW(A#w<mfUOEJ2-ynB?R_D(gQ|p8lKJqXIXuMgO;NrSyCfLODA-
zTUh+)=vIIjM8O*MfBW=5-uD`j0MdaG=k@Ov|1?!EUGe8sRQ@2%>KlM^t1BzfJNUqr
zHeTrpiva|VsfPStey3RaJ0YRf{*fB1LcD*j%I6+XWo55UCQyqArCWaeiUnC-Li6+U
zJt5Dqc8h)HtSKldX}W=z77!7F{KwYw`yl@L8X#Y7oJjz1LNGe-%yjSnn7o|0Cm|FA
zsXS^X6A^xYtn&Y|8I!}t*a^MZ%vwd;1Yvnri`kl0dPG`CFI_Ru1L39@Xn$Vszgsr=
z8$y{U#ax7gW5zD0XJ<Je*cu78^sK(47O$tLz*iJMIXgU*-3HW?=1)F{eL|j_U7<YW
z$F=S!sy&cAg^7-yiTGpvJk8aHMPE-3a~_Hb9rg>VX8|$>^<QI3YDK8U{4C`ZhHj~G
zz+PcUS(WJbs^Sykz0zaK%Y-ZbP-~+P`j`?EaeWGmmd0`voLX4WN*Yb&aoL=6SQs6-
z3hPUIXj*=uX-<NLC2YIirx4BI&7Xm0G?d;%mALr!ikO(&5%uoCBLu-585j1SbNN39
zM1l)q;&T&!A)_S}*jVWCK?;i6DkoPvNc%_xkwUwAurTXfugc=sLZF^Kiz+Z3pq#C<
zGZj9KijCD*oGWesIvP0;#F1BG9EgOEeBuR3wYavX&+M&|Dom;OpC|L*T<1xt=Y|tg
z`&8eQbAn-zaAj2>j|TbTjb^I!Xk?^n>f$m6Ql8Sh8cFi@>HQ!p>-4=<D~>^<M^Upo
zTq7gp4Wrz<cldJ+c~vhHSE?7>B>`DAPWPcy(sOUd0rOI?D-=(vKaq8`D}nvMZMsZ9
zB(Ca38-v(mQ2@z!hRWPJ<CM2P(248h7*N69PZnIZwzgKcoFs=j*1emq)@L%mz<2$n
zbwApe7rG=cPS<2rEiI+(p|@2MkzX8t$#Z~%=Lr(td!RVzRS8|)+7igf*q3i^LODCo
zO2DS)65bitDE+4N1uvdKBXc;bTNcO~X<omMcE7*c5Wv&4<XpCg-kon$Yx2YJ^74|;
zk%*naBQ}5AvIKSMzB^GuQd?g?3TQc-%8unjxOBmPZVUg@y`f$Ln-O&j#%!YtD$lvH
zUA-uW)$?Ebb<b3yH1uY}fBAbSt68{}6ZlX`;g14pzgD4=+GEk{hW<Db0#aD&`I|RM
zalk^xMq4ibFy{aD0vw+)^xtV|m;L+#T!!0GlwPNFf<g>5v^)OtagmY28w2_hPGYMO
zEu}i`$Fq@ht`$HLG`KhPKNs%57<{@ThG%CGB$tOq9n|LnQ@p$j!GQOEd3Pt6L@5$m
zTN6JA2gC9e&(h=Q@2JUF>g21bF)B?bux%aWzD6b{iU9oGZ^uPUOgvU$`~h?gMvDd9
zGhhJT171BiB&2-03W!CI&(0KjczAenoPi1`Jv%!@bsi8;foToZFRau^NJu24Di^#(
zOEh^p6D=R?VS)Dqf)VH>Zmtb90EbAY@e01N-%Y1gDxQ4pmM1+`rk@8Au)NJN;E|EP
ze#q4|ez?E;bh;^5XDx`mAciD`9=;n=e{p`UIN*@NW%o^2n2*bT7k6)}JRUT{lM)%^
z3E7wcM_#^WBbT4AyrLt>GQ*yb!~BkbhfHS`6dF3jB`Gb99ct@fxw5`awO<~my0Gi-
zUt+rdaJba2>fsc$x{)|2`Cy`9PqMPNmqW3qQIa)S$%XTObMDhA(EkSW$|)EMpHDol
zXQ>obQGDIbV8`q88N#TR(=DWLs;nqQ15$6DPB(dUUq2+qDNRN_Mm`?yoTf_ykcl!u
zdWWE7K@_DVHZ8$evh=%m+14wmav^l#bM+2cK;s~bCaH`W9GaxN^l*EE(w}lu+$r(^
zICpBur{(rt4L}$++?P<Ey<5_BJ(54E1GIM)fEdhcDuS}r;WhAj2Js=c$xJbO4M4U;
zkx*P|5MEbJ<!vJbDjqQsj|P67e8$%y6NM_#K>d{sE2&JUjXjVWmJ8T?K@6-fzm~W~
z&pYn`zZ&9?LLyBk!i3N;o}Eo`4Z^~kEnYqb3fbKAs~)#U-QPf1RdH}*zR_i?@nStH
zBm}|jdh3Pi&6h8@j}+qQNEa-EO^qcl-|RSDDTmS3F^Lff^cr+xJ5}5Et9>#M?Sdic
zdjVXDob|JviB7xo^k0hMyc3Er0&nwPM8-Zt5YM?Md-CKjY@2!=%26x&DalfPmZ!8q
zj>H<h^L>21u)B3XE}whDWQ_Z4zLEDtXVU#`_5)!23c2^v7AniI5Y)Wr-yD7|!{_>B
zR3c)_Q)UO-Xyjd__l;e=I84}2l-TJ@s++yH!Z6fDD<J?<&!H%6smaK?b-h&{+^$bE
z0CoC7nc`>^iq7CnKv2-={`LYuZE1r}iB$3%U0UMNuZ{HMH-X^uC_Sb~u&}7Q(RpJf
zT6_hzE09&wE$=|2$V35zv_Q3B0R(K<LKW(zhFJly&tdX9%vuNh?YePqiJdn|g};4P
zOY?K;PwMv*rW*GqAFQloj{F0o{|2r8eJ`Sn@;uY1`CKzCp#H(N;g*Gg0LgJXFHtx8
z{Cw^$=JKmT<TH?sBs)`Oo^69oQ0jvCIv%ru^R9=sOy9GxkWM&Vo9g`{_g%=&H2iLr
z?!`WjDi*eCg{5VhqweJ)Ooct6O4Tk5jX7=WIHL2#zPW0rnZ_>iYUP9`<@^{s!c*v3
zDHOijNIz{da`F$~>2!9Zi>O2KUaOXir5}t&xmh<eHgWiwz_L?!wSWYkmtD2ijWEPD
zTHhUY%(A{tZ3p5Z>`ONCj@6khEw9Dr=8GqZVmtLEvVK4_z@<&>kKO_5`%o&WM7_e|
z93ty}(-cmQ<xShY#jT7tf3ar%jt#9$ASplMEWn|O3g-kOeUvdakV?D^&fOsxuCv40
ztX@F(?e#Bs?_@15U!WMaJr<=ATS^<oX}fNsNHQr5sV1O(ft4QuRmIT4fKg?+P)w(A
zpu3b4ubB;)GGo|z4-a1RsWM^784Q&&y`WNyVSxfJqapt5n}g=c3Kd`W6#_Q1Z&-i`
zdASl!a8VIwNZ&^04fIsvoxA5cd()K_I_=P%8p5C>!Z+IuX?TQRYtSUQ@0`4-q+O*=
zdV@giL`f$z@f9%GO4rMfRUD7K=A4&<y7NHjS5?D4{&?Qyz}PsPqpSpEM<PIUfC!Z_
zAV(@J7kK-TdgmN2ax(-2OvcF_i(HW!j=GXYX2-6!=-sR|B_!b8j(_HMOhn^zIqVk(
zieFwIfis}ooOr4~XgK!AK+2m=rz=5NGyCZH_;?%X>+?oQ^b{7$`FH98NS%r2l6P;m
z6XUt;wA-RKroBc5l>U8P{)cyD>0n!yg&<PCV$m*3`JttzGK@8Q=nL~R8@!W(N3vr~
z$HP>wE>f%h%*AK7jS0jck^o2Q0A8+0rQF}3?+eW@eP+S8evhfdKt4F`2GmAU7kKJX
z?AHo9FuCmJ(;YDNkoD%Wov5>(!Z<+DgNaQWXDkpP7=R4NPKjW2v`qOvjZVl2$Pr?c
z^4>>QOnCr@2cOT~dmKl}pckL+$)ancDSD%}?+#}f<G$tU57EnXzsIfaX0O^9$axcu
zyb-{z_(Eq(r%Ew`d|W-cG#1LOrt^SPoTYUQ&`H@FX=&NYl|vKN*oI4jAg(UoV6zs%
z;&M)yV_C%!6&EMce0v;1rm6Eigf|qQRU%D(dBC~<WR=jZm>xR<@&B}>0mRX^&h(VF
zQXEHe-bl$howcpZv(cBd_6?E5+n!|h<oX1QN>H<5yfyM#_vy6(M1R-!IeZP;jt;_d
zuE(m(WjcHN?jfxpv7vC>PN+2)i`M9L^F?Lxq(X<wK|k2i#Y!|AE9mBBAFg*SD=La$
z>%G6Jb1E0Kk@@F+&{AYut$e59OaFT8o18}S0kZ18hQpk=%lT>z4jd9FWnxXie3Th8
z{z6%=C63zL$FiT4lT%!a4vI5;C*+O61*OM*0{P3S2B&hCRNhuyc>9SqMIsJddOj=S
z5RucXzWZ1uO$8`+bqhogoeBO0Z*QB4Q-Hf;UFY#||DH{)<nnr_B!`=|b)R3;d5e-%
zFELByr#3AvaNtI2Kdqb24{xaI`}`#V_BWUwgAEB3UY>?r3=D#1Ur93g?!~fAC;EiZ
z+M*%O_6X=wzoFn*;0k5p`hqx&M7h~SF%g~y!zOL1pD!rQCF#`J*|`-$NNl(R)qq#*
zA4jjII%j0)K<?~-V<zlHuRn>g-%uVQA2zdIRRvf^Gz6$IR6M*qk=T``_JEvER#ucI
zK%yLzEAuGJTX9}&dFzJuxa_{%d>AApnL73>vO3D7TOA6asL{CCFAIsjyFrmPGb=1&
z2%6}{=C(lqRA_8|=?;n-DTrlQFJzRAmK(~reNMhgbU3Yz!w&x|*5U6SObq0s?&MHh
zTBcbV_<rwe6a&#M5C`N;wpmBflGx62h<Uu<^(NEX0*%8+3^(`e)||t}$m-ANz)o0U
zA~wtUOsQ7jMT4`UDCaB+?0i~j*_4uT62@vlKg66;0#Hc4D`?Psd@E{WQ>IwrdUdRt
zOb%kUJ(B%;z3_dfK;-_OP9cWg^kHxNN7LBVq^+KpkgP1~)wN=&${ckCrz^*_fm<aL
zmnwGrx2x?a`lL-^{M~)vqzi+BV`FNgixR)`{lx83t`ZsZZRsHd{)&D2JGchCWX<-E
z?w=oN(Yn&BDYWTUKH1n*S>aguH$Cu%PgkR)>$K-brllpx+qHP2UY|`s(G22Y0EQJ4
zt1<!~7`oJ8XQ%M@@D^<JNpoQV0Z1YaD^JDZTe+HKv9WC|5#PC2KvSYp&N5tWsRe=>
zVJsB^0WiWMB1TT}j9Onejc(WuYNOK9O2*^J9Tw)aY63T3tR+x}T2M`{iJF)IK!0-(
zKkS1NJ~Tp@2Uu91voU4-H};`qkQ{(ozq>to*$L?*KOAYLr*&OCWiFh=R+J}~B_aSi
z332oA_*KS~_4L;8y1j8ro+v^A0)}5Nin^xuy3*f1EsA?&yY=ak!IAZ-qhlJV2hjFC
zt6}px!nV33YUE##D*uQap+C|!uF1+;S}KPv8l_BasVxj|*eu><UtYd*K2w;=;qMH#
zSl!!`Fg9LSq}knSF5P~Y#1{4yoNfRP=`vG<P&+<N(&BMGl@-D)P`o1(B5hV3qYp&H
zew)ng^d61S>cPtk0uvisBv&SF+@FB!(>JQZ#Xit%!9@RD2yjAl`FQLL^e?~YmD)i!
zS}n(Gxyza0bz&s{yt}!&k^_r1b^?e9jDQC0bm750FHj+L?hUZ6q`5?J67F=g1vNlt
zRU$Sj!0zt=GTGkF2?Xnt&R!}No5`i7oh<L|nGZ+2);a-T6+1)}`Y#CFf0&Xs<oV1!
zV=L-$T}ArysZPjh8L=NdAJ|31vq2i!7Ph%Ehn#xb>DIxJBqK-;1Nnfv=&h=YVdp>`
zfToC%TBg{!bhY4m5;nFGh}NFNqLwZDRPD#*Q8&piy$s@hwlgOT*S;^`Pl1traIRZp
z&6JMpBzP<U$!TjKxlc1@!^@Rl0-XOLps|~wO#IP*4L=wnOmaO`WBt)>#H0aKp;hdK
z&uU31aS~10X<H0r{ufX4zxkvs39y)H8qO~=*0)vt>+F##zVu(6lv$B+)HGOW$cg~a
zC#Rxk#mCG0>OM4dXZh#NyYg-6B!}e=xJRYAE>Z?SIc<J|YWZ5t#7EH&B69oz$a}F!
zCyY&(nJp9L4wf;cvr$xZj<aQiEd&o{YmZL2YL(gB-F!hL_4rN<C%A^A!Eur?CZKEx
zHbrMOKZq*&_{9$}9K%3#M^gd_JXw(5?2GQcfB4T@0H!fr@*sTzAqooN!&jL!;8R{S
zs3@%lHl=#pa~i8-ixL830?rZz6o2<to1c)59i<B14rn0BVm>`155$A!yveyJKuh=%
zTYRhmpuLylug5AXKSonkJ;N3W!35#TwpTqN<8|eU9%tJM1^SQ2xG#})aS;RIv;P2n
z{vE>03c&q%b3yqj>PkZqL~Z;Ef+Tc5UIvqSYD;4HK>G#f?(2tO<mF9JGt12z?Tt`I
zLL<VW5%lI&m`+e~xv)hqFTdLA3QN*$pG>*FD4|mqi;4bfzdMPAely(p>QLkwV8K`%
zM$b9BQ=p^(?z#x5YI|6>5?&>b+Xk1~UT3${!HL@<r_T$7<LsbcL#RI@Ugm1v1HER0
za@e$6!zUU)<)L(cAUYUb@OUVqB61E53CSvHz87(_?xrJlTn>6c{rovU!3!1^`K9Do
zN(9FW_y>{WQJi{cYX^skI^C$BA&gBFwY<ad4`JWDu|75>@;aZw{>sD1qsr51_g9@&
zq^Nd2Iy!o9Th-I5>+KCY;Ml)2k&tFvWEsKnZ}!H&Mb5Na9K3qqva`{a#+E&lV0(O^
zQ5EQ`#3;ivqad44$QvcTQ~h;1fB%zy;~T|v3v;(`Hl74mH?@%w@d!EDnz;}kBRJ>O
znMwa2l+_Kw32o3Hs_>az9Tf;zEwJ29q>@XOpVJcKv(}vj=-yrPwn6&H6uar^&!u;U
z46dq{)W|RPpZzMB7^*U#F`jR@z+8eHYy_A*aScYzlo`lA6(&@tj@M`dJJC(F=vK8a
zaDZliB9VfE0#>e9h29(>%P8`(^tWzB&VT@^aC|E|DbO`469ICku4T)dTOk9alGxUa
z9bK;BQBdNq0V`P`1>}n7Lm^x>)>CC=O6dv(?iucP*T#3y(9k2%GU1ue5O{}=L!*K)
z(sBTx!!OVIWMJ@BSHX9q<?(dBy}JV|Ry<z`HE5=B9YI(6ns<+L;`%!9-?`}+kQj&W
zXe;ooYV%I?^)W><?rd)aF^O}pM1iA4AlIzN7X}IyhrN6x`Hm=tqDJHKnEch9JzeH#
z35d(BF-Z7V|FWl~`=Ym0dl0-BH&SUU+&)@SGHUlncpsIUi}0&(ixQMJEX4|z;o}j{
zmCl*TU&qv^6Ts!W$1`VmENBX{k;Ekl$QyK0qM|Zt`xb3TNYd2V%Y3})<}z?^2I%|8
zasDP<gZ6$J!Zx|)%Uh`YT_COEO_TGP2|mXmaS?9_!ep!nK)i8=p-lB~7+ulv6Z99P
zh6Bk_g_g5m-M4j$myXZ@^t5Es9}A-t92OSq3%E#5Y-+-(`08p``rI51W(Fw<hl6<y
zjDl~^M3jiko_WuiluF{Tg5zCS*@06WK*55<9HN7IOI#2>m5`hX77`T=v7Hwyc;$4Q
ztv+X0x|yw1qN$n$s2qveh}@V@IvOX_i%y{&$Lbr_M)H5;v{6$)eh6qNgp-@t$6j8|
znt?agn`syF6_U-`4$BMnz{=mGM^KM9R}q1cKB%7a!icvoTnO4XPC0Q~;P|z}UOY;x
z^+2Mp-p_;`yZNcJ^coX$-n+pkKe}FKV1cAzlboO_yJMwZ^7J~z$@<KhM_O}PbJc2T
zl7XwT{d!?*paHqB$O!J82Saz+dS1Db@#sJWx0KQO2Hfco55!~c6x=~2i=_$f9N&>p
z>NWLl5BG!<V?Y#0_z(GiHaFS2N6E&@?F_nfsbtvM4&zYuLYGR-#Nh>FZp}F?QopsO
zw)vMw#f&;r2OK+b=L!tFz044(@YL@ul*DEZB55X%Dz>kZdOOI@)kw4RyIUR~HGz2Y
zF%wPdrcZMHGo>W(;;JjDoOj?rH5Gx=;{e6DcrgH+CNKF);D{V;Q`k4nYfHbdY&kum
zY_`zm=GzsU-Z**+&^&jhDhIG}XcO@@lZamQFUJa$WO~Aaf`&)JcXxJGra-Z2wxX?G
z#%4?lLkpvoyeOb@8x}<2`9@WlHM|Uk1L%n)gMnnyAUct7S0QD%t&$p7acSvH(DPs^
zF*^@+W)?lkh-f<S7UVsCw(>4%1xav0-whJ0-~n-Jn2MLHF{=J^bo4`kn(V~w=CI6r
z5NeA(JD91K>9dTZ`Cv|_NEXgLq3F-g2C_GpDP)V)IhQO71FD95BsrW<sfl=9YjBI9
zKR`pEe#26i^ciYUJR!r8cC2+7{@|ASwN7E%<m8oziBhpfp&tgs{Js3J<b9KcdRBds
zOCFkZjnk#<2`S@ek26BAvZw&9ST0m)+zd=zE}=lTo(Ed(W8^~UB_ZBP6vD}<>r-Re
z%G=E>tO~<HIhvAes;*fQAuKmrI)-;CNe(;7Kx&%(nB|}4Kj)15RbNoX<o$%txyYLX
zOU;XmlXxKvGn$XFR&r%d7g)hz%@TP^#qnbw!tEXl-T(F<7l>wbo@C1G&p4=<&37Z{
zc;-&l*yZ%~?ZiYzQnK}x`|5jP9(6Qdk+>TU=)v|v-_THWXjqT7LL$0<PbXt#Ron8p
z;j~$W|K1tAj15$LZ=E3^E${1UYDU0${^+*%h<IEbuVJy{ITs){NT1QTuO!N(1jm+v
z0D7Rt>(Wv$VR&n6YtVfy?=w+Q^b47h&JY}Wby2I)=7)JRQIzolAm)t+DB`R6ZGBD6
z5J<Xyto?<~AW=08ygp2JG{E?ykJCV_nB9Av{d&kAsJ)LQ6|CU4cWAvU@5Qi>XtkhL
z_8h9Sqs8ZOu2?=6D(WMP1X-H-;`(NyXO(U@_Df~!5Ji@Je0<IqbG2<nU6A_k92^{U
zGkS>}Dip$1JJrctrJHZ|-_(I@?VQAheFhCKNhcFs!1as)|AN)ndA8cJxu!Z?R!=Wm
z@lk4@_{JgJ#tj5os7TF%m3mxGH;elc{1{ENO-TSf{XV*9czD7UlrsaoQ!*=?`E<-a
zDDk#@w#LeFT=#Ql@*ChD7aO1^gHaILPf6+Nk=o#RP&*`%yyBrB0(xrWK8)ADHh{Ui
z9UROt*n3tvB*&9hL6b=R&06w(GtstvI<b_qiDcq^J4;XBz}UzDwz19N$;05hQ;Vpa
zxyNnfyo-#O0KQk`&>OK5iH!(P?_l_AD6H??ZrkPD2=?;ws05jwNZHgx*%!!gsF31f
z2aN#_JQxP{;GaXZ*>$b^@~n-;%>V_di-&Ev^stbvnx(C}%*OW!FWVdZBNuDwm&sRq
zDeE<TY>i)4%0;}AlCpeTcc;i_e68C03W?|%7BnVr!qoJwPSxjlORfW*QXI8|X_ZyS
zZd2}#Lfn~dz1C@Yw}z)wC)o{nuNjaO3wvY6<h*|Cjws{_i|SSN*3%b*Yu{E^7p@R^
zz3l=HA0#AbHk<^i6?#qYcFPARTd!VtYd>)qD$&x~M_3pr$<K#;{d!NdpsWlX<hk2+
zBBgQJp|AJVYQ3WJH&|?coy=(q4F+fGqvx_`rUZ9r>KljRZ_pgp-9Y9|X;(?F{S6Uu
zirM|vF@tuWzz_ZM3=sCPXUB-}q*gM^z%THyS|Vf0hD{qv>h^wiQp<=bnw|^iB(M$;
zoKJ_E7jw6SjLZh|Gzhm)zY9x!uIYZIAD*TBsf9rM3nu2^rX=7i^@zo6YVK&l+Aq3!
z_Gd0oZf{Ri8{6P^eFl4u*U}`%J$2q5n)ZERzAaT%aur!{bI4O{{GN6Nbo(a#Uh`br
zWXVkHjpM4A3aAidLu7E5*Vko{Iz+0g)5gO>>7=kwF3<=MU40CF7J)R=V_)ufrOw4X
z!X_YY9j1Toym-z_PAt*O3iB{5&P<=!tCjoU&4Y6xcFy#DLI{_bQ{cVQgn&!+xhLI~
zUYGBtY-@bt#4j%=Zflf%QabnpCzDgsA2N-|vHFQt(Njk_Py{_j7*<H3kZ<f4m{s05
z8xhD#MWb6;mHq;))4l6H4LjZ%k33^LTs`^v%XeZiSEY)}XK?%)m>Zkfd=kQF_n70J
z@qsx+ig(fT>$-IZp&}Ub7Ub6ZkwFGU%XAM~mgg4uiT}DNSWF?Q`kn16Y7E4m^YHli
z@j4RQ*xFW(2LvogWCo3m$phT%7nxkRyN%Y};bUFt%h0`(2v8)l<8#pW{fdl_PfJ}P
zm)ki^8L0P*t}_EX^?P|0c27Vh62W(&#{qp3nQ)lY4fodsbY`Kaf*ORgUp_7o;z|po
z#&jTq{MRLJu0ZqHHs`~=&Aio&fc4h%y_s4=_-ABaWIcT@Hb-(K55cL_4)Wiw7@SLl
zg@tGDV^ifS2Ywvq#NW3&u}96|-X!ojpMG(LU+-K`R!qsj>S~zq9}u?(E1pFLax(!|
z@RKarW0xNmOfT36hR+$zb0<iywRe(>e$doxEhRC8YaSPpT<j|XPWqgyI2)2p60|*u
zN5KRZ#ujhqD1Edh8xRNXzhf>VKS0Cf-lI3czs8`nmp4*}oPvu_r(jIE>5=^9Yi%~G
zP%%42B~AFP#*vm5VZBIpyHj$w)K7``2e;5+Uc)k**<5@#&d#Sh*D!g<qg(P+JN#T`
zt|?VhUVQyJCTf}ji%?@@WHNrJf9XG*ND5(I{iNS2s)Aw#H8KPS5wEhLL46pposRqd
zvRV87_Ns4Gh_AG)40C>U<;`M}7_PxnKgdnAw_0sJN2jMO16iIaDJdO<-Jf4r6A?QX
zP*%LLUWP)T9M)n|sg|yugh07wKJ_OB8Wp~&jEiRjAEBM~WzjJf@t2pECzl>3=sG05
zw@Y!up9;gb`y=_Olp8?U$l{k|XG7_JENKVXCLMl<viL(_Qm+@>Z-{Ch?r*d&50|vf
z&5KwmgE5<~O`hQ(uYlqc<0cadUKc27Xl{c+NorEb^6qqg-QJeoK*+6JV}<rEg)7$S
z7`O8~CcZFUvI_t{o~Z;KgE2pRd+|>a7OE{tPF$JsL1I|#_u&GV0j&wWJ{OG%R#`qU
zV2Lmgw;BPYG1O=f;3xcG&xrB}y-jkZaIqeFBR8ns*_?o`pE&1LO;T0fL>XWF-p|1y
z5_~<%CnM4CiK*A#8cAFIRrHk*&j4wkAu$35CG}<D#r)@ym(MA)ARFdP8w`*)bzrd9
z_nrvj^>Zq`w#1A1mni~27}Z0uc;HoPK${zEIF|C5j+-^!r10GEHnKH91QQ)1pj`NP
zdq3yk_+l!+2;n%SKI2OUb=$^-a!bk?j63wvj~fJ3JsTt{Z?|&OAl&g1_nSS!GrlGh
z1(V4hdTNqFLP9<fG^?qtEwjsI_7W`2&qb;f2gy1xmwrEcd!uV%!t?}?F#;oGJb~O$
zqRqxigzMh0@B4V+72F}hfec7^XqlRN2KY=;E-rtJmxsNMN1gGPg>oevxg2Zj>wzJv
zPN%9zpkjiJ)+P5dXlPGRS+x5AfDx-b)x!KkA=A<~SY6KRQBheRrEb+RoxV}Jy37uN
z88F{W))R#a<Ub)@+}-VS*D{)iYIePP1@cI0ujnEbK}R|Mg6E4S2V}cXA5t{klIHuc
zJS#>*V}0sN%V&Nmyfb@uq5ec5LGkUAhjn<wQ}lCmk~H}FdAd)2!u=T@3r#7$RpVb&
zZqr#lh0dx8X<XcPhpRg-HzlT#Q0+Y-)?MNU2VLQg)!6TSfFDmfu#+!BiE#`s2F`Rr
zU4Fd>q1;-=kGr^yPsW5DbwX=*UPJpQ@Ml1|<I!eZLN<p+g|cGLljK-oRI04xD`+8D
z3a^}$>-{Y6TM?_<M!nP-2lO%JUR{HO7@`U(P=wro(y%cNdD8kHxlih#Fm5wD=6OE(
zaWCy%6@1@k<s;Sz0&C(P3dmi^>5hR;ZFW!|T^d#lpJioZnz+sFjX<dq(`EfLE8@`Q
z*UL+)Jqk6ERuE<IW%3&+R)*e^=bgDVV>^*CMQW}lruqmx-p<Dwla~oroJVD{U5Md9
zA5XSqPv1&!PEVD*{<JfcQp8U9QkmMD_NUU)`(?@+*Bx|uMRCETBe!40Uc_EQ!!Q>_
zkebr0Fw!*#%Ijpj*W>zPh72pF(avQ&Q>BeM=(bjs4t_^G`~K$^d#zLBc)`6Pq&)0M
z;hH?~xy#wj6EJr8g=<BUyN$i=txusHnk21N@;GUBQ#C%Anf{QtWtSGZVc4aGY-?z5
znQlv*i>I|ZUsti$VubJy{U+IF%~f_oxJ?A#n)((j1!%mht=)U|0Mp$jt#>uB)l(jI
z=)5oX!$+R7vJaDTl_{(^El*oh7s*B#9%!#Txof|+U3l#nk+PRuYj~)rNH#0h3^6gq
zwKB4t9!xa0BRMzq+T23Xwk7C-DOXlQJ!G(`JB26XhvGfrR#E}O-o3>=YRfv-izCn+
z`{ICuKX!uoyl~=-6Lrv7Y@YHtx>+(S%#X?L^??iaiRKizOFM!b4*BghA6XU6%wOwx
z<2dj7OavI$XM_DmT+e(yh#sJ_HM6seu-0D~GY3?5y)LhKRwDh>WP54>jVAtF5bK8b
zdxfo6I>d+8pgZ+4J;*d0Y!k`|o}Ikmfag2wPDR$IN)=Bx&X*Q9F}k`CpSswiSd-u)
zXHoB9CtW<zD?cF5StXv0R`aRp_vSfqeWkzh&AO0|R>ze0N775pq7?4da2_R-yi5ub
zo9N<itOeubYKZ-92QzKcsr6d5;!30ecd0)ctdT90cJ4KX9WO-f2r4abnKN@&9lA3F
zanemEPy+)uTf){>^-zk7kwKbPiLDu7cYAw6`Okp?!zJnnpXg|!P~2ezXyo0tpx0&P
z2#d>|94(yE$$`V1#B3mb3(NHO7lh>S@R8N|F6()jKTatAF9Z-xf!f~>-z|@R$6>pU
z?{c-w0?Ng;O^vU6Xtc8uQ_|8}w)+)KFLYPpMO5F}sf7atW}VzqLNSik_6%CkmGAFX
z`;Wt~|ML^L7l~`;8Nz5@<1&jqu?0g}0aTjD5BC>T4ImeW!`jF7LRwn-5ad~XM@dQc
zrNU$|o2k;EuI_plLCnK(KzuvTbc#gzc$j*kdx3(_tszLkg-jH(iz!z866f-UgpiI*
zjhCsNsBOq!*M4?)1`zq4ZwO(Uq7?gSY&i5t)s*>!k#n=`l4c;Gh{oR@B4Wm3!`U78
z*<z$c2huaid#iIWzcQgfgeRf+#M6zuq?L5U#W7{#9<NIdPbXqW^lZv+>aeS%M3DE5
z(O7(+RR2<tH3I3&=MueRgTGLq{U<tt9(GO@FZX^}s<N42MTELS(e;}O^v~)Bd@d<=
zc~)w{-<^1L>0Z1Dzn7q#V`#-_F*kT$>TBuk)V=}dl!G{r!)*DzUx7-|(V@M5IUjm(
zMrEqCcT@`v`S=QsXDVY;<K3cM8*+x0`iW)J^rGp)P}AY&kE`8MsqI?$XYfl+yZy#r
z>&5$}{Bj851T?LSw`*QQ&m(y4d*$y@C(EvEb)@d~zhE~#6VB*d<&EY<3sod9I5Y@Y
zZxp<?0w3}-3p?1x!r)=H&nQ*GgmkOfdYY3_TW5Ut)s_s4Zn60V$-ThE>ntu=dVG=6
zgYMRMV_CHQ_$-o@cxnACRM;k=n7lT`>5gydmv|x?HpDv(Fd5YOYBURqZccGBQpBZj
zJNjx~TP<%WRhnG}m+IKo`nb^9KFoWVk}XiEn`<;snlhDFcxCQlZnA#hDrUv_v8Z|L
z5*~0Ft+sSrRpQHhs=qsXmvK=z(c1GC|0U{8Mrj8tQ!qhw;d26pgG*J(O;qN4Ezgqz
zN=$8FVfoaf_%giG6G0)ZQ+xuN^f8h)qdE&4C<yw3uc*Ila<1sVU2VJguFp52@#fP?
zu>QN4PiAM$cn5k-Dm&A-7ow&k&WfP~6Ed&b;^+e)o*_3_K@u>lcjqgpQP>~1wfT)s
zHg}sqd3JW@>^=)L!`8IT5Q_043r&Ac@`b}1RlUg-Bh}R=K|10y0=7{Tj4aD=r708l
zVGGC4F%GKYv-=y-_UX#{#hsE$k8=sGK=^R`uZt~BmoYJ#t%f^pomNCx?*er!6v=O4
zceGUwn2n!2F8n9ITNS?`dZhd3@yOT1lYg@`w7=yP%R`n{R~s(L$F;(cG@wNAR6Q{m
zOhp2`l{e6CA~ap<a(>zzdaLUJcok|ox|p#_e@OoWfE{p_K!GFAjZ_!KvK+N)3-KQL
zzZvjz2m%6v&6(<wCo3I67@nzK)U0$6r>KWVf@##jR2{EZNLO}S%XNMVZ4G{!Ul+J_
znzYqn*MdT@|MJx!L<GY{=5rvGO|Z>k5>J8ey-C8vft#Qt3u%>|4os@#ffhWq>rm_=
z|AP+<uRNyIkDHA6z=?e~4OGD&GiR}B2AP<(MgsFNJhByIt9!do5Bi<7z=!8if^FxM
z&-kok2e^Y(vBNyju|wV8p`w4Y<7Xs27<41yx?(03ewuCH_uA{dz#y6bJUeDw1M`Vg
z5UiN-J8L5MK{*qANdHpyj;~b(4!Xo1&ht0H0~QdC`~F~2ewscEqn^iY(5}ri@~&Pg
z*_>)?&OJp<vNRQ+I7CBvdoX2b6hyV^QmU7#1I>4jb@>VJrR95if}8tq(()1hfr0!P
z4%W;V#Z0a3Rp#BkTz#{4N@0#d@AI+%e*Sr1<t9Lu7?}jL&#*h=ja~QHRZ;9Tal@Jn
ziID^YiLB`J&ZbQbs+F!6rHO}84Xsm~y1b?_J4NzgsO{4uPz|#t4Nvj(t;msdO^eXN
zagD|B{r}bXL-oRz@Z^@R7$OkurGlhSdE!4X+312|tHz~13GW`cy|dHn1{VvTu)2y#
zMRzHdk+Y`6`R0wFynOb!$YEGLD6r+h^z~QN%SQlw1_feHl!TGkI5@9y1`O5iQj?s0
z!r7z``+N;40!TNvR$SYhY7*R|;hxde9>S8+`94cyLTs<uUs*hO?Qx>ec9wg`XPtpB
z8{-MLa4724@fE`Zo=v?`^!deCUacV8rjzbBTnqAR=0sC74_}6|I-RJ-#dL{@yp=DZ
zF+C48;f7|O64x~!uAI2C7wxQkynlAyXIIamV}v}*eouVR(SVn(1jDNn=#BT(pe5p=
zaJ>Mr?wU!?OS!|#rC*O!{IK^|_*JrYDn{SC%7>V@O~-;)?mCI=K?oA?HA55<AuWfv
zVF}o;N{AG(S&7-KG;cLL68t#crf%Ai_V5Lp#-EH=b~%x+L--e=zBrZlT+tQ7L8Kj}
zFHK@%e5KB^FYb6eBOIKeid@bFm&cj6y!8CDpG~R${w?!TVuVICF~e~eZoY_C+f8C*
zY)b=8cA4QTxO@vGpWLh$Cmh2`2rAxpN41IU%R1o*&OeQUw$dbTo(R(~Q>+J`;l9ew
zd~e%AUG;0tOT^4D)OF;FhYnHrvmW(DWUBUn5Z#x<)Q?7pIldW$iDXWqW4;Tmm1||J
ztKXRzH}BeB7e)xdqD~s3tIu3u%m`L)zhZV3Ic#}|u23px5~&quj_htz(56O*S?_FX
zE%%X*K>vO-0k4UF*=m*2V71DIAo#gWAc;E1hDcM}@us4nJN>iMSJW5P$QsWEiI<(-
zoG{rwZSpDTDz-K>>S^-z`)!r#>wLB{<DG@yCpB3fjdb6Gl8?)C5nYC1S-)HAW?5%_
z^$NGIpS4+rL93}1DT0`sY1Tg^<f+p6ncd3n%a<>a5{Wqz631a{;o*aqZm)JC)3l&~
z)cEbqIld)@g++K@{j!<k8rGf1j*7C8d$_hEvO4X!u<$dV^73^D+lPBJb?S(eH!|BA
zJDwJ-e1lHyKDnn0ALhp+cdlqVhgt^(n20!Ah{w%(uzUJRKN=RGUB|vg`7bUXQI!UC
zg)P`^69Zd-@_P{!S1)xudaZ3<#K|G6hU|_DR6y?1{GL};pPBB@BlzxNx3(%nuoe_A
zhj@edL3?maOejrFO-OH0kOkhUhlS8fRFvl>q5Be@_>}lzYZ{4>A9u^sZNC+4xHc$6
zw8OzQkMx>%*K8Z+HT`~pE!7WB%uoDZagca~V^Ay-N~BUN?rA<txWbz>lkG8NKG3?q
z;`3ZWx%7qED!E@MXlvL<-X9vyC8rL8^=|Zr@I!TNTj=bqc0<lxkv>tFwL@3Cp`f~5
z9E}_hRQ?gJRa=VTn$kqexX%9uGt!K^Np7SwruHsv)({>sVhomPcyXe=S!}n|Q-}7l
zy=TXGLT7CNOO-851Ffg6KApo`CK=YCea0$<=<+z|g3W85A5na>HPiB&2!;2>M(&-d
z_FyN^=lx5%jKde9bB6Dz=lQLB2VvafCUxG@bo4dn-l}b?bs~G1_LgTi;2x^Xx*HG>
zc;Lv(8;3k|pS<DeBjM31O9O!8`-XY#IKG;Iu)1n8_6x**=KLKaovRwdql>RYLq8HO
zF_IvfJMs=@9a=h@5tRI3?l(a5Tnh{AtNi2l9Cg>ve#nGjjDP$ofPv(`i@?-Oe*Q{7
zla0GWrm04z6wR=-@#M?1<(EGUFZM4J<1@U2idTOYj6Rp<e_qmkTx45c!)Tr4ql7xi
zj0Q=CsXZ335|%~qq`AZRa<m{pJNsPIk*P3{V<|Pl^@33Tbp}yd;TL7|q1!>II9%tP
zmBU)Atpi3Uj1;Ahvm_}PV_DWcF|D8H-#DbA_T<WFff^Yu*7~<R-lRNi=I^l^U{mxG
z3Y0LGv>vV_g9uqYnlqIGMM+YgD<k6$`8lDMLt>iZeg;KRkZ2XnK7Y{_i?o;%@T&_T
zNqyoE`(jojhXi51h7xNP_USmYZHV6v>I*HIuuDPp1^KJItYlwVvKs#}#CBh1sY=bn
z`2Y8)@TW|VQefZZX5o6o75q^xKq593AQI6A3M@k6x|35<`q?r^=tA7Sq-mWjH7<2J
z!G7d*T+e>N7i(IVD#`|>a>zdSng9$%8A`o<8+imb{7m(M(X;w2dQ=E9?RSs{1_n%^
zScc9IUtg&6lQR9LFnY7hXL^S%_2pWIIyu6-<}>W>P8yOdUeJb?seX0=<8W2f&|l`Y
zuBl!xeCeKNx)-pgzMak9;B1AO=4L*JTcY=%BZ=Ta7A+xeEo|Lt-nlQZV{)OTMQfU`
zeE+Je(Z@id$5m$_veq@O{@(qRoqiaK?e?b-@`gn!hMC=-8q@oq4b|3paYm3*M=it~
z9?Pa%UTHl{{l(7X=~JIs?+yo1(7{LIN_~DQO*FPOE-^AI($L}3^Bmr7waBPu!tDlY
ziq1crxCKS(3$2RLN5H-u9jkX<3y(cKt(LK#SBeqB;D87YQruI0rjL~<*zv>joAaR5
z(+W*U!+S>=vc#5@IIOj{*v10NB#|R;Re@os;1`$jE!<m#*Vi<{!%)-NA|$?ZBnv1L
zD8(D~6*aWZNmknP0hjWf4a$U?mCE27sz$u&I4;kk8}J;=7u*oPs7#A(kHL4<@R@v^
zsBSVG3~xiF=9sC!2$j9RvCI=qVg7gxYwoWnA<?6Z+k-*@o}t=)kAcJKl?X1RFkS@D
zS2RL+B>037oRtb845RbD*J)3ks}`dJ0x&)u5O?7ylnfw`Fk$5-bYUT98;W<ISef&-
z!JWDvt&j4evw0j0M#tp+8#bLGdmbBCUDP;g@kpCcLCHS<uH$nmHDXX!A)+OsqeIGl
zHZ~f@%P1uV_@rKPrcax){6|n!u4--|Rz`1$L2uQ0aoQkSwp~)?k#pI_ZRu;dE2F!=
zbTtI6Grt{xOI<P9t$vLXhTCH&8u1jD>!~pMvfxT`CSg(a#MRYUF<b&%@G^1*AD#>P
zOA$p_m<`;QLNt|z^E8*f0g{{a{PcHDy5ygbc3-l5yzln#&3v0sK=(-m(KccM|AVKC
zXDR*dJrAL+7<I_&%@im>&BJ-p4)bMh{|Gdfr{aT>0X#VNAyO1hn5pRw;kAM!i`z#-
z$b!|>PWVxuSOg%1(fldYKe~!ElscToybXe-Mx&<f^9ofCi+}PR$)9-Z)jeEB&$Ju{
z+1qao(My67hi5o!j4S2&N~hV8b|(!cF1D73;gQa2VqDE?tTE!o?o_LwDIht5f;U{F
zbPcq~+v(UWu4?1Ln=ISUTx`xR_1=w*BDX-<`!qIIq0Pu}p!ATg(9A%QoB<Z;3}YJc
z=k81{n$C|s5WQpE{6(w&ZGVBJv2GJ*>GrUlEhB=v+;l?x%d0hp4CmzzFHe`D*j=-n
zwxCeDyZ~4YHzZ@p_^^%j*-s>b#ZG*vR_+9*7*^ISPbEVVWnbR%GIYnabuZ+e2-l%M
zGPS?CC_~V2EOT0P=BRAu3BT<;UC%w2I6+dWUj_(iKg-EUWH0xF?!is*jHhmZMBdju
zfb@A|icHgik;vZ<bG*sv3Bt;o92M<NeEVwsP8ExLWYeNg+>hW;rs6Fe<1u;<?flhI
zL`Y;=+kJK=;czn40`|R;h&!@y5P7FwD_ywOAQaZ8;`cf+EY7S=B<)I>pLVq#5Zp|#
z-CYhwRPK$C?XJ<u6?&3ERQfJyoWi|;oV}x*lbd|?ZB+Xw&kEAz#>hZVc*$}xky|@~
zFb8Qu3>MQayno=4)hU$H`Q2D?N|3fLsq+m9tsJ)(@oT_WGkZ1Yo%!e>vU@EFA4ZZy
zS7z1M6hyM?48~2)2<aG*y+B7rR5kAM_q#;PP3q3kQSC7QBEwy-fhw&%HLlPc*@Alk
zvtbelishpIEbWfaii`P<N|M%d-@n%TE6X!eCQaJv*0CZk<$Y%&>zkPT+Pck6$8*bS
zo6@p;G{31CwSwtmq_s6HtL-tYrf+t4R~sqlOTO{(_p&nB2JeqNsWSt|FYWTEUlzxG
zDldx}cwua|D6mjmrTTi&9VL~{mxN8P)!jZv==Z4v^U6O%#orcG<@R8FA@nyk_VGOg
za?gMXP%;c#QA1t5&yNfJCG}`JRI*tL#R?xFTEtbfTKmQj4;LHKv-yWHg%J;KkB}Sq
zF5LLloUZK$**)i>Op-=yMnBpA)V4$qiLNe>7vfl2Tcxz{KXtt`{XyG<;ft~UbzQp+
zxud{R5=EB6Cm7!GFfAs9BHx%tg|oNs7BMAB@~8OlRCt)KC5H0(r(<70rs#|>`Vzmu
zr(G&%qR@ps>3W4nSV)AJ8t01von`XDzmv1BU0y*+(KAmt%&Ki{Rw62_@tv!$4%f6m
znGPRqN1pQFU{YqGnyziBT@*YcMVQ0m<|?s*pJg$WF7}g2t%?xLiPhnv(_0R&HSuU@
zJi25t@t<uB`FW+KLa5STl1v{4;vIxsG-zmP(-00i5QsE1i0l$<&Hdg@E*fc_+<9S*
z$5F|?H<&yyY4myh)X6A3ncFTSopc3nrptGW1Nx%uDZ;uN8CwS8XV7QVx_xpd=jb=f
z`kR><DMKbsIN{q9<EQ*)T|zCeP}k>s2;<|4)#yMnWbP|x3@Zq`m_ZN!WIKtjpUw{1
zE0wru^4>45e~Q3x@epfIkceK;FZdmHnx;|@O-~$)OIh_pr}(}xx#XbZBzuW6K7bi(
zQkF;Du1yu0XU?)w<$VSjN}qCe1-2UH%Fb*}OXM{QxIS{v_`eIx3?C#>LALepD~dIO
z>}F%m;L}3VnH@J{^7Sp&6LZ9cDbfCkDy&lUp@wpbf>!wzBcrRpAmL>WZR`(U7dD3Z
zy1rUA0Gk@4$68yuy5PBaSV5b1<nQ07FWh#<$v+R*+atxs{DNPOBr##Tx)K(^2qse3
zutWF>?AEF@|7F-_>wxshfv^sl3RSbL^PpSf_QL_;5#~O_`?q4w_Bl1RawjOwm?#lV
zgeWEMiI5)q1Af6hi9>RTJf|P$sqH;T;Lpp3D8uUb6GML=)W<+O)r;qM2w#833nKiD
z7y<a^Z__X&{2Y`iHxjYLP*70V_3_vuWyj~>6z3u5c=HCqe)7fZ4;OEvnc(!HAZ;u$
za9=I<g^dc-XCy2i>o$H3XPdSRn*K#P`;1S{I$@u)Kp7U*+9t+n+$zTD*$_K%IB4?f
zj6Jk*<*ntT{;74M+P@$rXH0>^d15FwSb`PC)WqJV1W8F{6S5Xpq=-?A#Fo~7kZtl;
z*9bJI?pfj$>vvk@fw=QID!z3*`RTGDLi^Z{<^y~)YZj{z%Jc)5ACX}}&!CL7G_&Cp
z^u!+GOg{ENc?qEV{Y2Z=O9)0crhaOx@`EISQ;DVPP7c4i$?jryRO=O#v+LzrJUfM*
z#4`c{Nm$s!WdTR($`iXwOL{kPIvaj9Oq=ux*h+czLM?gfb@M<RgjyI_Mt0l4FvbsR
z0!2HGv)LqXz8bKkh{9M?hgYgSnb$~wo@s)E5Ut0LATXda`{^=x)wWVXIp&-;_HTNJ
z@wfcfIPZ2QG4{NFo1vn(CkO6$>_#6yJ_XttHlq@dZ0c>UuTSZE($5ZkMoy08)d!h3
z35DXQw5y!K%=CU>q7!Gmtomq;rh^u++)nIfJe3Ob+10y7JJfKEqzBr@3}@a^^e5D$
z3-zP{Q#Rj)zou5Vb(-e?e~g`FKwL|<w(-W@H9)Z75FCQLLkRA{LxA9}jRpzs?ykXI
zLvRT0?(X{S%$YN1=G^<;d;f-X_ujQ@SJhhUUC&!;*~F#Ndte^y(ZujJ2%L0W?~Y=a
z*0~IYc7uW!-@LQ_ncM5ALFqG7Qq@wQj2KqlR$isY!k30v7iGH;q<%&}Qegq?g?%jx
z%WOMo{TbFm{ca2vWq9Q&+Zqdrc=yCg)3wlfkz#``23fvuE+V7(j7M)t3CC(nmFoM6
z1-dybE`l*yUtesrS1c~piict5@PRER13M(i%G50}_Zb)*UOq{R%E}fEmuWYNasj$D
z_>B^io)-lM`blP$hHvlTpxw-2JeT;iyE|1?e80}?1Wq|4M<Z^PFHbQ)vwYMsp8dG}
zzU$(Isxy@95xhnrl6QbZNGtmH-5}+aP@BR+k9EHMe{B0x2|^qfgFc{EkFNTi@H7^k
zu8SCbh_lWhmk1!L69tXFvWpXTRi86VXo(3c6`<l0H;SeRb3b9INx)yB;~r=+&E$fV
z>1g?!E5pLQAcICh6<!Jyn5Ziz-q4s*$?R|5s7}lVfFakQ!E<M2yEERN@@j8=1M#PG
zzW<PmWC4m3jo(F!7uau(V=W~!(?|^i@>;Eq;NC_%dReA^e65W~Cf!(vD<e+9^Vmvx
zCX`iaK{R)ht7DrzmZ$k4DY4c+GqY)B<N2w1cM0!&3QtdpSO(ggI#kq|R^Gs-;$?-z
z)RfRJvF*$@g3&$Cu#V*;m{rvU6pju_!f+&D$*&y9I^DQq4jHR%&M(NrV}46u>_O=N
zZ}ar`*6ABB{yRfg`XF9H^;eBVs1+f2iF?Mql9N;DgCTCFB)lB%P;X;iBTlTEc@Oqg
z?^#a+*nk=FhaFId+vZutA0n$0!oP0}8SRWFOZSaF$IMdDryiq>0^{)HSZ+I;DYgg~
zAKD6XaE05fmwPdJMOU|sq0al(q;30XF>rrd;541n8O^dbE~QFy4FbZ(ndBX59hwnP
z6DT+=^zQbni*#$`p_dF{O6BUu90c;%PJWwRq@{J!RdP3RH6D%RDdLeIuzcr7ytCW`
zCCE$(gKax3xe5v-D-AQmlfUF5vx}yai|Oe*rn0wLCR8GAd!t?ZEkfU?rZFT<|ESN&
z{d6e8CjdoeJX*l12Z*J(-GbnUBian3NW7J4f3l-eXn&%Qwu@QdnmJ$X)a{&le?h8j
zXox_}^F?~+i)6$hT`(cAsdjXBeyA8DXJdmONefdW!Rud*Azvm}GWRt?#{Tjqud?zw
zdcTyRh*o66rNH*wi1mF9nUtJtS6&1~mVdOT^*+lbIHy%2IO>}&f*Q9byKLi~+UlCt
z#aSV&Hv2zHP5+*8pJ#%^RH$8YSLCDl*K^Z)<%>g)jD#{?Wh{vg^oLY-10CocfbKnj
z&17F<71zBc15aTUe)2&vDC4@KXu+UbubWa*=)F*^lJ@%#F#4Y#pxzX}(P;2XAER%;
zn=v&pgdLUBfU<dd7VP|>zg<2eYS3MU5^75O3~y>EbQ{o>OtIajo2o?Y2jX~KsCjp2
z{Yl-aFpbJhTl3QjUoBTKn%_m}71?s|0}*@Vqtd3IbcQp?c%+2$1E7Qfa(*>@6sX=@
z-jy}g{#`0t^|oh?V+ojm_=Os}3$9}xT5v{2hms)E7tu)Z%@+(mkHOBgll1`UbGN)N
zkj6oytkl@-g;av-f|cJZKUhs`XQWaJ==5j6a!uOo9~FFzQcYwma&o@(nck1fYvInY
zt7sIAcOpFd3Ijnu%kG<yl(+p#b9p&xYoWd*%TGXZ`_LUD2G%{|u_+=zd&h~uS_|3A
zaOZ=4rM26RE64n*BXJ?^L42;+n9m+BAR`s%mp$Biq6!~wupJeEeqFLqwZZN2d`A||
z>zXABvVlh!hhL&rBt<S!w~0xS9<<;7s*IxmR5FQrmdVf0W4%GaAhD|cTxn=P`47Er
zNe&Q5G{_?fJhKE{HhN;ez@HY~351A%WW$`4KInP-c4wwL$$jb?g|gjOsmdSw`eh4e
zP$bs0R!j@=-^(z+XGpl15M`B3E`kN&-$Ec2gh!`ME_C-p{AH7do*KXTHYHn@C@@{6
z3J*g!^wI;|3eDd0bH<5%HbSXRqdhEkEH?a6r(P#Z)(lKmDYJjjkF*8n4{wQ9j8ji>
z83{9iCIW~1J`3rquaNAoP1+15Mqu(UlLqk`57NWjUvKp>Y$j|XO}g^97A-?}7GkjV
zC*on)CC|ENH_&eSYiQu2Ic1hJ$FUjy1axk&>>kV8$Vv3EjwUR`ff|)LKfkwG!{#NM
z&8CFdxCn=N=wJ&E5p%2Rm1&JI4&ux!;g63?&S`g)3fI6kH+_t*j(NQVltmfoX7Z!D
zmM`%N(&dPMX{pj(Om)*>OEkdH2J!5^y;oi?l`fyTmKL{7lMsZ8|GqDRrt{j(O2`*X
zj?l_?iXbk=1o_RQ>PLA<K_2Mkv#>zN{J5^2z;UNQ=Y$@XR$;WO!H*_8h4Jr=>VRE~
zaCOgc3YzSo4EX6G&z<C5OHg!DZaGi^7dpX~K@i7TueF#Yw^Qa2w3?=+Ho`8#IMy)2
zk9_CJD}4|2@9L_2pdaXV97_6_8pVSqH_gw?eX}pfA&4|JEpqjHY5tE0);Iq(5b@;a
zD%xZH`@h%HLhTwF&fKMSC7+!hJn@iq3=}Ghq;dP}5s(sJqkC|8!}9a5W5D0UkXmLk
zl9CDv-ob{rtVQOui~7+%Lb=hp*lehTm>bKi6rod`W0R+=)3tx>szE;{VzLlf>krVI
z5Pi4`nwI`_3+2XwUa(B=xk~<>%T9zDk@;nX-Y4kHql<;4d6ej+%-Tywv|`;BotF0Y
zW(u!!q4But2qjHDfdtXE2O%TlOd!|h3jl)6D|*35*&Fh%-_ah4fwh@pE+uQ>+~5#5
zL<>~uynY#WLt1V;(e)R{eVlb{r4C!X&ymEuOzm<HUF{b`BPJ8LRW9Qf)sb%Ma^5M&
zKbK(O?tF-FOv7$_c};SKJz+mdl`d>s2Api51ZS=d21S@p^#|1TWd`Hh_5^`)`qzD4
zne`&^6@11#UDErk{>y}pzFuvOcY$RcyfYoNS><$WXEgO9A+)imq5OeN_i#!quN0{d
z&2$r*@w$A11mQ9U49`t_zX;#UOM8w2hU$Hv`+H2~<7DPeYNyPHeFdHsh#qGX{LGNO
zbV&_8vv!7F&c%=2tXC8domGCis|xb-LohH}wa~9h3=R&Gztf|%{Ps!Z{cMxkn{xA&
zWzlt3k&kaaj*Ir}{{mjOpc<v1Bt=0_#K*_CP&hi>_gBqSoR+X$T#_1%=dPX5*z-KR
zfE<RSLTcLn%97$Wl}RxQWzowQYdE}e|B6)CdWTjIPwNWLW=sBok6RzQejp7`Zirdm
zh+qGGdI1SR(=unPTK4~3F$_GQ+KHcG;T#DWh!5AZ4uRq-qyWn%?v9AK32b6Yl07+e
z&)S=*57p+6F*=2CZBG(f#GiQTz|4s19t)l%SR6w@LB3F%%?^S8;)xv&{ILU?72DhZ
z9vz!~R&&mhM63UGuTazOs#0RG3CmXqH;z@&Km(#cRebz+@G4(axgmp7T2sUz{5Xjs
zYz#nb^3Dy{2jBF`vpr#$z_Kp0Pt%9>4g7&;tCM#rI|g^(w>+wZD_jqGc<eWj9Ztq{
z6V2RSUi?E^Y3$O)mE??VteI;GqUj86ykFcl@vc40Ti)C@gF1rHJbIQch;gYQG9>w|
z_$sZlZQ+R`o*<bOJf&w95*6`1u20RP5|bc445`8dG87%P*;TeH*lY#R+<rCgvQt9$
zTZzOs>gyd5KWN-Uwz_LyuqE;`h04Cm*+vp@ujINslTF3cl*)K1cURNNi<89o@X50D
zl~-5YMr${-j{UErH(8_JUe9PBx6R<U;^Ra39*GR#;h&!qYs?<X`_+XAkkr34HzAf1
zFM_}4FE1pmBy{<>k|F+NF<c32HEo6a#n6Kq`er^U(U<3ebY0X9J`nCB=IE!Oh;A|n
zReRYHLNEb0XTBwMgfUBlhqyHPq2@J2g8KbR=3NG>>1QqZbq-C|3Jl5&-4YXj<CmI8
zWoggLh>FgVNuey%8LrzZ=FC*E#+x5MA+*)?Sz^Eq!ZuiEG@MADS}LZ$YYAJ~9UW1z
zF{%(i1iZScL<!fi<GMMZS81Ix<saq2U}Yt%QGd))&U{@}Q#0+h%=MYSqwNF*EgS=T
z6PnN23kH9=8xR584FR<)@iy#VY=K+cZu#(VmxXggfk(FXoc=?^*E-Xz@}zq`&y2Yk
z-=11{3L+>uJnGj~P~25jhm(Q9PW~@}*|tRHo}RV&=hx-}|2fw?AfVI^Gf%)|89^mK
zCh8Z*7oZS9EorTdCFI!%9^E<~h593?JMZStzwN(qN?#yP!dsd4c3Q6~zV_(mp+;QA
zB2CVrLB30Q=3@WcMWg+0dl<U{pG}N(5E@L`#?-c2ZhPB!HT9u`gUdu@lmwI=x6!#F
zu-?A^#Xvv9)3Z~IkoG+W4Yu5BD@Mf@AW*0Z8F?JB=UY3_rKd`#sf1p(M+W()3nc^m
zz=MYPFDTc#^Ff;AYd7+sZC&Vgo1O<I<2A{Mep0+c2NR{Y6l8d4v}x99Jn4_Vo|k3j
zKwKw1qvW;#=<1+?jNaPp(mS%mo)zorBdxjgY^>g3zv!(0ijC9$Qp`Xf*fZ%Z``zcJ
zCsg2IngJWd+q?R6dJv$A!EEkh+N9D4Q?3Xg;bf0VHNasj%~qd~6PZ=;hEUrgW9#cI
z-t(B&VY*dz@SOhq8Zz%d#YY`1@-5&|b`g{`xKLI4x<RM{tKZuVtexS4jD)+6Ao^`U
z9Lq#5z|rN`B;&*a%yEUYP0>zXt2>JK_DDuMlLX90-&I^}FL+|&ivmOEOx7w?x5eow
zpMK;8U|}D^yx)?a`%zd;ExZG+-|kEG3?Wu`NS68fU>r=E@eiVv7ixKxt4-o?Nn~k%
zUvN-?RhMTb^=66Vu=-<Md=ZB7`Ze#Z1%EVtgDxB8zYfcPq_8sM(9P#EI%=a+gcklS
zmEu!{@czA&APndAt+i)M*M!J#71Sa*hno!`5ji^hS<eI=irN#jI(>+;oCM9WOlkXd
z^!Xk+R3^*;1@!Yf6Ey$(Z7fpW91ybZ-p?cb4!UhdD75#n6KnKAYs31>5ZIr0W$@WH
zRXJbK9=yhQQ}J$qgmK>2(G$r$a=ISQa}U@yyCornZViv?nS#_^m^nH-+7eo;%(=KA
zaY)oa{W*KX`gJ$ka9WkSk3VS!p$n%-8@~j&l4}lyu*F`}9mfwZ->!H$5qVVZdD_)=
z-Zi;kY7VETom_hr(BiMsNC^LkCW|+B6%@8%vfS(U{?JV}lmpfZl@1L=<MMuG(dVv|
za5;Rews;X>MCrNm($pt;!W7o-p6m{Hs<%3dnD<^U>)}DANKy1xR#0$LuB^8=g8I!<
z;XIBw7L8ZD+g{;;PH{|S;G6ML1&(GN+<TLoe*3lQxwKSCWDY(Z{RwcZt>I5L4y>~K
z&9H~nj!>Fc9NR23BTDldNBe;fnuT?ld^nn1BVEgiJHkM)oQ!Z|kJ#;&sr!xgFv2p3
z_bvVx?|qiivEHGfSS%uV9EKXtW<w~(!;2Yx$zEM@?pZ|@T)fkVJ73VUUumg_U0qav
z#;Cq`E5WkIh5PT&l#!7L=zErBY6*^J4CP37-L{`?(X4NfEjsD7qO#oz++M+*?C13d
zyDqgbJ0Ms4*#e5$a6bF27Lhxkbx>Ya4@)Ii(0IkG4^M9Y`&IrT+_3!Lk`g``@U=)N
zC{}IWt@wuiZ(;s*N;lAfGBHU;Qw!%~3zvY=VuHL}9_yrxa<?aKg{#D(mNE{?E@B7}
z_i*F4KV4~f*-QsS8TdUS=BImAI7onrP}`4Xpu!I04z3iPe=`EzaaDUz4EpZjT~|_*
z#vb4r<coKK>k~AFK!9K?!1$r!R@A!XyOs@bHiw$Mm;{5dh3#ZSOewJ5iP_5?{Os{>
z9Vgo)Kz?^fnl%O~E@;tcfu2EtcGo)ya=S{KjC#KH#Ox6hggiWQWu{^NUQWS8+*{P3
zx=4sZAo`;(zO{^OFkPCMNE4Uc24tqG5j*53M`d4Z^$`j`zq`@X%=R3`m=yI*rr*-d
zrB#3CYp&LB>PEK?@eEU8G5QUwo>_n_6}vLSk+xEZ8MBNr>jp{kM9C?G*B1e4L0K;r
z#1oQ`<@3a3+`g!_;1u4JfkLzlC)rOJNe&3zfUt|%b|a@C#IV~<$RHEX;HlFe?-ezi
z>%OA<wRr%K*{I$|0LJXkg#{dm$m8Md8vm&&hS~NP;%3tWGNmAKDIcoGI<^4U-a=Nb
zR#u|rM+$LCw5|MbeHc+Osc>5;Sga))NiM53u~B#;jT<}A4^!KvAA2}aDf+Ox-;CB$
z0>KX7kVRns^TZ?sqXh%`+)LRKZJRB=$fouBpO4*lTNLPw8s5<xlL_`AgydKYNEZ0@
z*Gc}0GLt&BaJ0~}E9CxbQOU_5*OQ@!zWYdS^*N`5aduGkmu^^gpy|e7GNH2zTee-n
zU#*?fdyNp0MoB0u_6>f}$Obb#hcd~(CYjJ5v$4#_M}u29i&v`?W$0TV_n$0)yx#@!
zfBu*M+#Y{tgznK@K3ia7C%lIarDj1nHc>BG+g>^7yXt+eSNW+OU=GD~JJ!Cjwlh38
zJkKss_8ErYuN(Q}+mvXaOda>d)Bav1__qZXsKau=oFkTG9^~%wo|v62)En5PxpV3E
zM^{_ko|w@sCKRObIH1(SnSoR*tJr)G5KQFjS(5*~cK7?Yd?l!Wut=g;KIR{-8UMc@
z93w`^HTlpH;g2(HXHiT2_j@NygaGfG8+5$o|N8*`m(ls#xQ%%rMA>HFEfZ-G{O3nm
z5PkO-en}7n!IA%K$GOBREM|K?Sqcq(^Mn-x`=1~9$Jk6I2{n(6RW3Ll%aZ`5>OaQI
zms2vcw6u2kD2Y=JMvD+q-CZ4!({IG<zSn{WR6LB<NVR%@-VtM{(9VeO>aKZz84o!*
zPINTeLF=>E6GbM#&s*fiW9|d6cy_J*xsd<ONC}CqULO$_!RSeIXRV3w{P~q)z>(>7
zDhmW=68hh6Ug&R2-tP+@PX1%YC0~_g_x_L1<iGngigZUQImkxVI7L&--(L|_>Ewj>
zT~|*Bf{KS=QC*Fvkpr(o>F*-L|K+NL*vWw@!n+*oL`}U)NQ@A1B-$~~g@3r{=>wbo
zo}}!pAQ4+dI`}eiQYkUM&{7iRe|zSCzi^=q40Aj}LZ{}ld@B<6MmT3*RA+e@BD_&v
z>q1&eg7xP)c%C!${izJzKgYvd2G{~N#f#|fCKvw?zb5pAu-K+c8P`FNKx5fCIWmdn
z7bpiwvuz@hia7aMxbGLcQgjMJo~!1fx}zGE24AB;3eu9{Fbpme32%)OsqgydD90y?
zp5r@|!E^i9SAS?}frmMk`g`*7tdM9C{d21QPeW+{4<sD%MWju!xNZ4wZ-|C1t-9<M
z%gc?7LTaKsOa(V-R$?{j@s0$ZIt%)BSI4VBwd@>QUkAgGRwn}El%kR|7eg$6>n}dQ
z+ylVKFg#}5=~}NRx7mg>#Vk1jiZNVx;A$8bP3Ch_JEn?M8;jT1jb^`Fr?eyu{%?ac
z)&(C7#xiC6bR=KBn3)yRS+T=nc-(dQI(Ye!amP@k@a-$rsCWqVXFce%pl3e?EK(?U
zX79?%s-W_lcL?L!-ae(XNN`_O1Y-c+1iFrn4l-eGZ7nv?o=#4^jmU?;44;&g<o3X*
za|;8&Lu4z`nEaiWT|wnKjm1C3N{)cecnB*itIFEi&G~d!Q-s{yT=TiTVju-e%YVBH
z-6YrWy}0;Igsh$(X>LJ5H^7p!YSp{bxs`7OT7aU`(#o8@bm0Jqv%mXE8ab;luFS^t
zwq_KvOM#M}9^}Q&sJf-)FGo_+33P#cXECKRx5?VS-p;=#ivIQp$3lT;EHXNL#Ny&7
z_V(MCXBM562he-<54(Fs%R0#!C}uOBP@UcReu^`~21cf+X~$mZBW3#2tLeYpwmOG~
zDi<OsU?e3aPp_`P7?gqRkmAS;y7#1+nIepLcXtTuupC65S06rnxR-l<1R&2rG&D5Q
zO8{AQ?P4@RcK;Fwu&hDRYYq=badB}GGB>A1CgzU9QX%HHMV~I!g#PvG*L^-zULzn2
zS3BVNNt4WN=Qm9{g?epu!7#AXSq%n*RXBeA`QH4o9{%kP|Mog+VME5?*3C=km0Bsm
z)Sj@5Byu?2*w|X{xT%c?fXko*BAOB|USaS%ASP;RA$e{kEeu%+AC~Jko>dM9gb?s5
zy203f-A)EPk=9Bo+BSQzhb_Xfs26kUQt#bb#|V`a!D(qEUx~PI<C$NGm7<gqrT`pM
zlLOX$X0RyJD-1%qzgMUJT*m+V%MOJ>win2pt#ee@n&%Ojoqd?4Ua%vQZ?%Pq9wk*;
zstsv`bx66x*5GNh<Bag?T*XF*Gn@8+|D_gJ{50kdE^B7Kbs&OSOwBRt>P4YfI|`rk
zStAGLWj4phW~U==yMUY=EF^F8t7jiQ+GV!`?@IIWn2vsraYCW@-(q8PCq=;n?*{;3
z9D=JSfsUeqL1sL`wDZ9<3V`Y^`DJP@?&bCF<HwIuL*wrL{{GOj^YfOjPC}yCOdgMC
zlBdrPC*6RB29@U(&d~6%;Z)%_hRc2?&-~D%8q?wTrChm~Cnh>NspR>7@_;8mQ~~n;
zVVU{!ac1UWzFG?yOuIM{1UMXk0JG~-8@+kQ8RuuRWqp*C@Y_zJ`KCJ`SzEk;mg0xg
z=leFnj^&>j4_^%Rm{|0qk~`2Q4b+k8&H!THE^#{mDLvhc345K64AAK3AYW)_tBiw2
z+GZO(?(l2@gSA#CM~;S_^kzsfsf-0csK3HgAm(+z|4^Y<_V%rM5L74uyJ?56GYTBG
zz$rp6j%+-GZ$GI!F~AGHv-B?qOsfiGY@xbSG9{y$s6B9jF7mi0rvk74ZQ1(sUVk5C
zaAkc&9BCJM=_S=q_f@bs*Eso<B9<T1EL~9Bnzb}g?Mn#HU~LKjjtL1jNRRdIhA8Lb
z^lL`|b6*LxxYN?neH)7O18+wGU?XY<=vHcM92|tL%1Ra?3{g?4OQ|Y=vYaUB4G9o;
zWb%c{d&8KYwN=cdAiF()esn^kH&scT*2Tp>Vn$N`<wX1692NdrbfVCKrvxJ@-&x;}
zZf>SxznYHYPAc<-9j7!`jfcy)R^&@2ItABR@sv{DdtkL8aOPKSU}MH{BCQkTS0`v%
z{-ySbEW`7<@gp(diXq)dhe%3#?6b^#8=L5Ygi7{q2#<%nGm#aAS%i*}5satj;tLk|
zwtN7<J$C^wxJpt{_M0WH1trza&p=PGNL$`V0J5KH+|RNmdst_Dy4uNNv&=tY-#?Ue
zBO)dSlbA^R(okJrALI)S`f{x(aE1Nb9v+E96%W<P$;pR-%;Qw}^D)qZEDUtC;&fL}
znRx8~-(P2;3re9ZUhLx#ZK+tL6p!o7sF^rnJMkfXL6O<rB%fuP;x~h9^W|4c(J@&i
zDY=YyhhC?<Q!ynM$GrIEM>;eXHiKP&xi6#u@2Mf{SPZmRR$+G01W-eGtqRBxi4@ZL
ze}FO8h*)w502j+%Jfh2cz>TX5Xk347$VV;L00OoZ^%B>d>}<>4??BUxfw8e_2~V>B
zZ~u9y2K9HXr(Nxk;^@pRr!4`70J++5B3C+fCI(>D!UI;;J&skiwE+Ms7#Y}{Dfts-
ze-j#9cC$cPrKQM#e;E?D*CUJ|cpqm+x8W2a`0Ll$udriS)C#E`0z2L>Ph7vD2)|eh
z|DK5Z$D$`BOM|{Ohx3W?u)$hKrXBvy#Ff!gw$=+cVb0@2+GE-8ZfS4GH`P{SkL0FW
z8pCK!J2ktA`KE-YtY?SOhpxIzu=aAcRks?u!#kmFg=x)*hJdoNi*-uUe|LubV^g5T
z0H)zrL^roe2itASuo{)5{$MLMq$?xp3;b`6Pf!{)N@RJib6TXdQ|{BXz)>XtSWbo(
z0?4>sK)dWVQ%>0OnNnRtau)*{+S;OkEqG43D8J^(GRF%<AFmD>B8_c0;MDC$gUHOR
zIPxH*r`P?G6`4*mU9O8{zcYdpKL=D?$t&owu&|&3+l*8MM3vJ@ukOI`rY3mnn`J)H
z0psoYIt_Rfly6gY0e&?#?EDXhm_OL5^|;>I0QzRK+tY5ewe?<EIqWLpN(IKO%5|Vo
zJMd=Z1!5$XC&v^HP>@tQ>@^#hnB-ad-)sVQN^4?-zyhyQmjm~&gZf`@<tr%0IH4$e
zmKM%K@2+z^8*Q;J1YbB4V6@EXV07llAMK$z$Yb@FpD1)j8fI1ESGK2l*uQW(I7KQg
zItyz;60c+~@YxHtL$c7Hd-XnRxV}4L_?Ymq<hv^LpG!C^<S<=B!*`UOqgH6}lG(~v
z-19(F7Jf-Pr>3lJEhiqXY@W4%@D#knL~THYp)*d5NlF|hjz#<4TxMMC<3~Iv^Kzcu
zi11b>m-g9qZ$Y^vHt~+Ybh@^uYwfJXs3a0Tr!Ii~0aF1xfZXl4d%;`fc<=$YIy+|!
zP4p{1MXIf>t&a~x_y9E*7oLhrw05qo(b;+d)hK?b!D(Ym0iYch0dQaO<|02x1#<as
z7HdvtjUz?9yxKfynPB?ePZ-sZdwn<5)YWBM^fL#bTJ`@xIH3Q>F6}#y!NSF5?0u2M
zX5(j4cOW$#F0mT&P7%>Q&D6%ce`gtc(2~I0*{q=;a=W9Xp_I67#ZkxTb8vVrG(A7i
z10V+H_Ok^1Mdbr&ORHCbQn{k(@#*sF(Rv4p-LVAQCqA`@QRoA9!7C~#>u(*kzPg>0
zKlEnr1@Vm6R6L56`i2}#H?sOACe{?l>sVk>sfYu7pZyz>Y3|=4Ak{PYEF89PC$r?9
z0V@D_3-FcWvt1AHVr~)vf#pQM7O|kH{dsIMR|8tr$(z$YpfZV|xP^};5I^~KPA`Gv
zh8Q|}rjX@^hcweYS;zg0z*N}z)Lmt&?pG+3wF$VJws%fPa@>&OUMi_$)3HearByng
znbCS4jTZn=Giag(Dz8ogydT5!%^!a7SwJUBICW}A_jON?*y+v9P69N*t8@cnfx+VF
zKYPep3gCfbWIUS5GNpq%e-e*<ex+h6IuEe@AlldGBD)25IIMO+-U8m=QL(Www8%-U
z#&Cc+A<!u{f976VS{jhybx)wgpb8w$Z$X_;H!C2(U=-(2nSZ?5nR)x$$4I4qvvikr
zeLxnUdINy=0vZ~UPXz4k?GpvuaWfNP`>X5fwwfp7eiv59KEfOx9vTcpkw>pU-sAeW
z=k&BQU(KoV{W-gVcWPg>qbHZdy~+R?XuKp_Tp|H`*RO`*)20KwQB0ugKw_IiMSD{(
z!?nm}3I5VX5S^DBgplUV{Sf|p-B<2eg_mzH-d~vSLO?5$H&LsL5BG?;{;aTSR6rU(
z)z_u7oHw%doCekT<9lCDUPXy<3A(~+R&By=2f^B-+bKitPLX>A$*)$*fV&1+ZqgPH
z=#eF<=-<p8eE$yf>lU6_bG^`?2BY~p+`gl^v(y6hLO&&}8LdV<nc-<#j#>;|#-wIR
z%!sSv=2NeV`V&rimTkk&?u<phYGw!!PT+}_JQ7?48E7e$KeLB%@uIhr$<1maW>D}q
zK?J^J{wcW4WcodIa{7YyI`*qu7&J?q#@Vx(T^z@WCoDB9(O@iN2G6Ymux9&5hC#{x
zwoqthJ!>?!*6QUwtKv2Q)--!P<=K*CG(!+DLEDeuGcz*k>e4b7F<4!@13a4o$j=}I
zsHku}JS>;xI<5c=D~q8>sljAa5<s*LvF%#Yy_YPQUp$zpFwUaY!%aS`e7>4lK_8S!
zf`q<D`sMN}F#8)U(l(M~plQ@ziz^y|<;WbsG9!tOiLv@6nQ;c7Ue*8v5c<%V>~A~U
z%)-K8Bz=mvmB`0808|+a&|wgN?S`z!D8_fnGPlBi`}R#lV0)_z0o&yAcuBjmQ_j>B
z_d@B6AMYM)Q&?E&L*}J196<cz^tAip*76UDd2%cS;^E`tqh%c&f9~&L1A_J0#s|@v
zAF=_yMoyj}Ad8J?GWgGRg{7*Q$m4!*a`mv(H6?M!&(DF#NrTf!OpzMqsIQB)-2Z4H
zj}*~GyNMGOlHWFY<-*Re8jB&_!$>b%DPL|9!{w>X&cIM_Bm6=`j{g(CTW4nP;v^qb
zDMK#V11_Bl^cu*jpKaH*d+5FWZLl?uIMwUaRr2vVaSSPX8ULrVht+bQti>j>V^*@~
z#zwq1CG^@;@8;)?kbWW=JoVPq&2zfpW84ssary>e)lo?G{c(PMMg8gtueKpCd|Q5)
z5uBEQ|0=cNyD^E*LSwpX+G*f%O@^-%^?Vj=03^yl?6y^ljz+T!{#eeMTxnUEAz=5X
zGmB(50K@NccYmM;C(qz@u@Z$!%Qi-niVqlDzYY*}sQr%A3%EekaA_ao<)?C5zX1Zw
zbfwP&$fRvyF(oA>4TZ_=4ts3a*w{X;p2Hwn{3htQzP!A=P)|5CQiij5+wCC&rrLn)
zs&tvhRlw0h*{w8pnCtT*OR+8BhNnxBj6Qk|Aj&KdXjm9RHGqcSm!})S*Igk1p3aUv
zK@tsfJphUryS$Ku;ds6dsmUQE%B2SVrr@t+;20;o#w@pwe*sVy;8aL|^)#cuuqxF2
z8VVSoLJT40o=}`ocDsP>3mgt@<fXI6iyCs8pk5Zi@~8S%Ex}?gCf|2$PaWff%J`R&
zyDI@6swU6%pMzfEug;wA53#Ox^NZBxVefBHyIB1gVJ@GU2086#?(gNe2WP~aXY0i%
zn^BA*!#~>HaS3x9nwY}+LkD&&6E&xF4w@tUE5s182Qr}uB+h+3@7v+mua7J{PR+p<
z^_krC;YbTv#!{{F_}l)9_~kj|SfS*AnX`5;9Sgs&1_L=Kufs0-M>8uJ()I6s1CgXa
zcM-r#tC_Clb3Wb_;mmvmp$gd5)P5o?rr_dIXM5|`!t&O7r41Uuzx5?;%(J$e4l9N(
z707)Hq`y1s=LmIT%)<mzS|YT*3l^s`4<Z+sistVL2@n77J__(TrJHQ#YYEQJ&tE&9
zL%G#x)ND)sIzed^i2FynGh7_PTOm7vR2M<u>fbkHAyF)sgEGlFF)RQy&7$}XFG(mH
z9RNr`={5(#2X)@opAgyb59uwsw2d%Bzr9S?dbo}0DuCA>q969BPYQG;z~SW(%Fk_q
zI+aa*Q!-~}ixOpoIr(Z+Avl!CqD&pt!ps`sNYgy72RXc6o0KL{9(a?rh<pQDTm~3M
zAh=QpZ91^{6sXt4teSt+lKpw$k^q_z5D3N=ekF^-%7XA{<+%7GGUikEtLYqY%hEUu
zN#6X76F}J|&WsOVpS8GeT7N#Rya#ec6J}aF*I&OPr+JPOL6iAGqx>8kT<rpfX?dPP
zAhcotE%Clq-HD%_mmKj9SK9S|PS4_;<2wK*pm2&+7L(N5YsS^KEP_BMoA_ElP!OMs
z`%C~uCm^6zfe_$)Ybv8S<5^+Z9KX@;*lgPCK1kz%JH7$dDmEp{&lEuPnTiHHZgTg!
zV7nJ}w>LKd!&^f=vDa8i|2Vmi`M@Ymxd0}BaH+n5)W4_q9}Aa{7ZiRrv^d84<*1;U
zCjQ__K=F$A3dkSiY~pwkz>9=rk4t#=d3#Cap%=b0m<>gwV{#gcw+W17d=k3Aw7DQ-
zI+q{#Qd-zpNxVQw+_vl`R!yuL<1|LqA*mt>OEIPe|0(i`=r}C-r!`Fn9r`K#yBkxh
zIntxQ)T%6OK=yIK2iGLuN84Pzd^!|?hLBH_&msV;cdjU0pmpB^0U_iR07DB~S|%5V
zt8@cEX~`YPdKEHVN7Vw$Wj~?j8na&;(l)^MK<fR-YRHYuHvw>ek+~=oG&KX=cRISg
z_&ZLf%ZRvO++=o_Tloy|QSFii+`l)#0}Qy>SS#(0`lyq3Zw2dSf?sV_t%(ETIA54?
zEK>mI9qP3JLgM1TbeMlcC7JSAE~lMm(N6^hJAn4uW5XAEXLVE%tt(gB|MpD-VEg(y
z72W);p6RFErRX0{x+~;#s##lDv?l3%rHR}Ks_mx`jB8>iO5Q*(TK;<Vm&&Tz)$>b1
ziZMd?L&Gc{mo=DUGvbG&n_nSYWrkL@pg*UjSSBQpNfm+P5Y)WDZH_bEXjfyp=2jjO
zBSuL&Eqj`s)hMGIlQ)$LzC`&(!uNef>unZCCB_>#RAO3!JjIN6rvQOoYX2=bS@8b0
zy1iZScSK~(FLdf@Wq);j9i3=qIz7S;9k{&;#^N6PO7KF1p|JY2H&;`@0&-g#!}%`4
zlKVBlhZ`G(?d=r!2_Pepzj>p=hKuuOtX7K+<pf}WelQcKdUSPk(!(=+O3MVW8KKoN
z<OhA4Qf;?rwpqK#vr#$D@C~=lYkf72S6gnI1$sfL+N_^S?Uhn<URJ6Bp`O78z#b{c
z9?~wgk@s*Pjd;rRykRvs+C-qv-&O(yJ3Ju(4*m=M`*@<`;gYlvy4xFkq=+_>M%U6q
zovfx}s6oV<tk@&Ii+eh$@OLn3aa*B$-#>aRin`0r18ff}6F?EBW;zFSadB%4f`0fo
z(%xPZfJ~=3*4Ef^B7Iw((P5C2AQd3f$oa03UlY&6TkO27NnG!75I)|^L+qe_Q;H%+
zlJ0*AyoGKjdRtN#hS%V{4`Rv^Xn5Y{jEKr`z^N`z^ZP0rM1HeP<=?j!K3_HFOA<H?
zwUb$Hu(O8tVI*BiR~a?Wbq~lGpzh&ai%x`CE2$wVdi0S_c5=m@HGvNCRf*KefS4D2
zp3OgC>^>a9hsHBADx_z0#Q&VQ!0n@6Z@4;cg5D6|;2)apA=T~xuQGbHag67l*}#c4
znJhSC|5?YU+T*EwBiz&b^qs3SS?4q__9p?Th9_tw8qN5OAIFM>n>}e8>1EX|a?kM-
zYGSWw2ZElK(1(6)?%;K&3lxZzO)$7=;|sQBD7l^)5kF|_w%`1$GJfdtfz<8z`4dM+
z=df`M4;HqUq1F@<FgAwpeyqxHrJi#7!7P^>wKqWp?{<S4G?F%_-3Y12;Lv9+B_##E
z*x4{xX=ArNi2tk@B;Xz>EwR-4kekcER0;?ue@B0nux4iNxFb12pWwnfF?S^5cNr<)
zPNC`Ok^uOu1lLQMfXRZ2>eh^H4Jq9G93KjFVywv|_8GuFG5zPmgL_wttFtIjH0I`=
zuNtKpd<EzMoQ`-AwCgQfARP9wJKo{JZ{4rH0FLw(2?Fz)HA=`aG-!Pc2?}XVUFl%4
zwnCSqt(-dnbsc3G3-LO4LkYVvQ=PrehKDAeqVmej25ci$%NKhTFo?1VEF4_V=fXSZ
zUz5i1{=J&$XG7La?D&pGB5B)08U9#xOa7%nJl40EqO(#~XY8-uxmKS<8Y)kW9^8K4
zJoISDK7UFY_F^(fL<JGiD_~>vc$xO(S$b7`#RTthJ5dQcqIxmi{Yrj9J~%vqC3)hX
zeO~HFV^#Rc=wtPR06iuVb!To_Gj>BOFP;1-%e|7>g@?z7{y|SfSCX`ut0Cdw@cFRa
zf#f_?28DDI0L}0x<&@zd?-RrLk}|Dsn<FtfaVq^dc7{Uo|B_bK+uBcUCZfjJ^>dYw
z5_;|=0`=WkQ7er`r8kYPso}?wo+ZC9F4YDz&`DZO8ApArLmxLCy<!VPuZL`dU?>uo
ziiv_W=SLhfzY>5CYovIhCqbALXn_QC%3yf8J1*kF>NN`FGdHhdf`rw7uVzB@l)w%<
zhcc|#hHxv4^PIO%h>2kLz*%Wz{o=|@G}Vy}q{kcJ#BHa6;#VCameDFUCOfj(>3+#e
z+|(Hu@b>ce)X2Ou{sbgZ4*k<x!~6X7gKi1&@!|1{MN?1Fq#i+E$q}q+<Psr%yU>tt
zJAVHbrVt%tbz|tNqJn8KfVpfhE+ho;(9tU#tSjhrsL?S->A~xAik^{YMS_qB7~w2V
zF6wkIuPS^5T8ICUi^>c^0D7QBZY-F6w3VF8;xzc&Y}Y|6g=+v02%*8%150PAS?gy+
z1q*A959y>n%nkYx8p)9WR411uj2WTxEmuSJ4yY|<ox@|3UkDP8nxA;(u2T;Gc7Vob
zBN!``o?qla=(J<ccJpB;i-l5nu{06wkPo3Na0C(%`;|HA?XFFlz>CSd!L2KP^8LA>
zZa$Z_N^zb}Q@7uXvy9;k=|z`E-`pP5K-o^uK~Pt|lOx*+G)1iRxQ4K<&gyM^S?U{3
z;JX!UT-WUI*s%x$H&z`IaKIcUaj&j7IfLEGkRO~KrVd|(PIp1I$)5z~?Sl?xZ4YKY
za5owuESfG4UFJoxq6zQpg@GNzj*eRRY<sVtXoN=ZPDB^W$<`JlZGz>oFZzgU4pLwI
zUNY$nOx5g9>C({~vuLRd243ub0n1ls=MAaP-~>fgk`XB^z5h$ihl553)KI?&EYhH_
zyE(Rw7YQt<jVA%mE+?31FLbeWY$&$g{1k9Pk&?@>R(LjLdjOE+{73+|Y4HIHE25_(
zJ%Pr2uI?(dNHs{R2VH&E*Fq)w+_1E{nUeo*(*bgBB#mY*&Djfk@O&tWe97Q!ouI3;
zrGW$ta^YSn(}u@dLo;I*`q+IqR}ltWe8l1ENsMCpW)J2UXu#YX=wT)%bu%Xh;MS<u
z=Uw_=u*yG~nj$J3c4(vmrZ|*v=rhLe=;_Hq=Y$JU_=dJ73zb`ER}S6pD4eaO;<-Cx
z>HH1Xx-7JUC<b09k}PHyZk_ehbOJsOw)|9Ks&uPQn=ejchCQX472VAz@8CS|9ilHg
zcmPHxcV}Ntq=G?qP(s6Xa4@Qm$-AoqJV-@>y06T|dS)ZUkU-A?#ylmZ|7u>s2SgLs
zzQG|x50b}#{lp=B@)a%i$Q1$ft|xxA`h;)l@QUTPqIJ4Oh8`6oEXKB6mG5s`I{JHk
z57;X0LANtY{ss?w__tmOUkWE+H{fVdn5XX8ghwB%206zMeV)SW_6<Lvim&+C30S4K
zvkG*t{Ve0iph`+gwhg*`eEp&mToz|*Bvc^uy`s~vAJL1Li`psJzzA^{<dYr2HDhf?
z5slfVc|}ODiZTG%i+R3jx3eR=5&_BLZmy`1d)noE-~E7p@Vx4#)WGJc#HBz>u1^;4
zIV-S_M>@cP!)7>jaG1VmM8V+sV`LC>Ihl|2R^a@ads&KlptCAntI>CEahR)fJTWDc
zc}NaeiMj#_S+HUVP@tcz#7t;2E9+~6{Md@5Dj*9Avb0%z0c*c*KUkz%Cm&|kHXyC0
zb@g8OkC&S<!)L7k%;;SKcLX6=31G1jS>6ZPXI@5X`NI|Ed^6iwKJ@1yDtDgW!g3_;
z<z9OC^2i<{)ip5zuy`6qx&3GCV)rHsepMCZFH{<ea)99m3^h=y3L(Y0`XlLIgiEdN
z<x}2z-)5~E1B7<JyCvsHymRhnz?cH)-$AB%b<N^y$ahM>^%@oymcU4Y^Y`)GmzvzC
z-QSWD&MI1bA~#$CqLu5bMvIp6TXKEmP-LhFxma~16QI)!|9Z1NG#jCFSAp8R!vX(x
zm(7W#oCiH-Vc@6dvAgPT43;qDK!;>JWGI(IUgq;;=47E{Eo#B9dv2F$;;E9l`dqgv
zbCH%~J*0P0!PGt0SsSEqvhG_fU|LN4r{&M$;{h(nLl0N2M15YhWTj$jpe;@f)Yb>(
z;MAw+Y#<H0Jg)z;^0AM!=BYy(xRAUn9*{G*DuZ~n2V3UIBTcb_m1VQNeb0kwJO_k`
zi!6^~=WQzpooFj6{WhzXiLYY%;wh)Ly=nS~eh0dHOUXgvEE+5_;2@9*e7S`Vpo!13
zlwPVd6j+_nUjgu4!6;`olMg3k(DWbpY07cWcZ-Bm2NQpKb5z0G;9*hXbb$k>;q7mo
zS~#&~WpN``Clxb{{DSv@<l)(4q9hu&;PWjaGN}&MyxMYkMT^HBJMb4*GWUn%QU6NP
zR`B~Ofb1}pCkqk|?wq01?T<WRE_!}`Xs0r9C0~@kzqnGl7jHy}yFyPK<AT~oKFOm^
zR@x_AT`PURwCc#GppUV=i$(Zq6A1KQ@xSZ>`Tklt^T{|?Gm#=H)xged1ZN8X>-D6>
ze?I4Df!^6NyDPI>w%$uX3Fs?jo?6nZ#OP$KJ<_U96f-Iz0M|r88gFrCvJ-)~kbw>e
z+a=f)dY{OC;>wL<$_IzrmF9h75LK0J6bw8rXmd(nXOa#KzARiA{qp10zoa05ZjB1k
z%~5OZyQz)<()Z(cI$_Q;zEPeV)qZhRCG);EH{@NJd*l1Z46r$HL%9WJEY7h7ROI9U
zfE2p@<r(BoncDzq_JNESXg{8C*_$xg29qnQ6ujSE(ZA^Qjfug!y}cCz_^{Cytq0qq
z-tXD^hEupuP$9{W8?0uS68W4_9}Id@OZo%=$BJmrD4dRWm3BCC8|&+tm6b}gs(rRl
zTMT^#b#+B!<ox`^K&6W&_7~gj<3G8}Tu}IfmOwJMD<~ZY2WRmFbZOvlI9o;iu(Y(u
zUDtbMP#AVRsgIeCk}j+#!?0OXvA+1W(kzSSFv(Wvc+0mQN57f10tc6Y-=Evi1%)`Q
z@e}k6D#Ioe5~zy?=n{n|J44sGe*n16SD{cy$V<LOr7WQ84Q3%%J5ufkNr;GU8f1N+
zb<|7qtk@w2>&%T{5S4r$L#+@Xb5-iPwzB-(drjDJlyu`n&Welk1(R8H;%<q7*LQoA
zn(yX1`f9VF$~)5Jb*P&~b)$5$D5AV|_fB<rdO$2Yt&<CSspc(`UDp^xmA5zaXA*aR
zvzaWB7@L)|p_*>OtRb_&mUAR55tmc(<IoK=UA|#g1Un!vlFkq-%7@zpi8X)yJj2F)
zdi|-K;e{*^dyj3yRoYS732{d`i*^GSkU;qR+u(D<IY7~HekU&?@53GqOMg99A|ib5
zc#PDl#C;nGfk@6mj7)8B<&OV2p*8!cQBQ~#xDKfSxS(CS8YOigq?EiF)ZmVWjw13-
zI^uxhr#vyrer4|ui^LsRb%GW#=RE%92QR&B*xK~CypB}#f?8Z^5GJzWI_|RMtl+iP
z*WV(b5T({~dnWDg$k!(;`ZLG!^CxlYq*0G@6@`T#+Ygw#uMU1J3cClPE|0aff-YiL
zDXSj5uScNYg<3vrfTE+8rKM=er^bYZ=q7SC(3OP6l{=q>Je?{ZJQO`<m8+h_J^lPb
zL#32MFPE)+(53u^FoDlVb-kn`u=6>8r~V`&;<a-@uzlTl!<VvTa$+-5#kqHSYT$PD
zD?~*b_YE;mv{Y49!9aHohTSauwNVx!(raqPHgMbHIa-|*k29v?)B)oPB-i~RhN#W`
z!S2rzN&(ON?w%~^%RW7p?3|4_bef@P0Zv<598SEmkI(cKi;~8D#MI9(xjDFRI0sYS
zvW841G6zwvS;2;&Z23TtnS6S3IV6wm{!~c%Mx*x2!;$E2KiSJPSIoo^6ZdTGx1pIz
zynM=HJCMa!d>WTj7DU}#B%LAdi9QuUv)H3|UZJ7AE8)vcwVy1VFZ5UR<n7@D5d7VX
zG`CW}#VDqr_A4i!>U5IQYQ06pUL%Goii58*7>z#+=3Iz1Q^YCWf=6Qni4VZZ_L0(j
z(j06g#$d}83P3-jh?FSD{>2b$6g?SxN@3aV2)cbpHRjZG0q<I)^PX|Ic<uQKi%Gq@
zvRu&7DOo=W642&n4#15Zy4OUoFx-1Hy4bfuLujrhPL)@CCzZOcnJpK9V#x#}H&o*f
zZ`^6fc$idk5_#svUyxfX$4fcwdHxAEPM4MjSNIZ#l(i**B`kb~-F36hK`!8!o08u~
zqk5-bub^(n?fHTGO;`D;fXOI{z`|Q~kuuwP<r1Wu{svsHl^U}+1kY@;Fad?#@Rf(}
zsf)SHB7}e0rDH?o>q9__QAV|xk#HRFXguCh8BNt4i!FzzATneBsu?fWd;7XLD40O|
zOjPW%Om;AV`-ifoPdk8DSG4Kqv&@4ck|6oT?MCFd`$?<*hW-9ZdpkA7YM7ac$@t~o
zBuTPljzsut$bkmC4Rb*8gnCsbm-BFv@!IP&YUAT?0U4X9ly$xJ0(H7+ku7EaGWu_?
za%eam`Z^$+nvu)T7J(%tFP}9qAXNtKj#NdHYCs;=-rk~_i{kSSJ3}1_sNyk&G^ibD
zXy`b9QK>4Ib->@=l4Im5xI@jjz+z>~WiGGxu683xJp_y;VZ0_*!Ka@iu^caW03|ky
z*y`i!J+<_3;7!M2n)3F2voKcSQD$>pHLm*7D-ow5wem8Yd8taJwT|^j@h~K<63&@r
z;iHO_!Y%Eq#$Uy@A}Bc7oC-YEN!QQU-;?7;NZUG%%CQ2JM3);>iPD&daP04-hTrUD
z#_JZ2da~D6=jwV-{Ai`GecVz=9UaX_u~9o!oNo!1@Tyizo|vEM3x2W6ov1R=A0JSx
zw@Rn(svtC_PBnM$eu_5tgN4yv_Ld5!c9J!|e;bl3T=7&I-kXh#dKHD+DsI`I6c61e
zWAcM9VKPGTg)Xj$0N2x@;Yj+;VD*!C&OUxkElVU~?+aukL$Y{*vu0a6!z})NMsIFl
zxxtAq#>}#WbP8^<?AQp&XIC9eg4j)ykW<{8SobVWqX^LgW~W&!NykO9YlAGjg;Oh&
zU$twYQW9weZl+aOL6QiT?r~c0kIamB`-=4{%e@MA!tGks{T3IYnhwgj3Y8jcxsnT9
zc<-`;KIfy7$SKAXE!aMXbCJfrqnVf(31N9vvpbZ8Ty%%Rr6W3-FF!WFY}fDD^{{4n
z=4~Gn)h-<)RHSHE<!LAUeO6~WB_rd<fnVF=++JZJ{28BcEGL6^{%~4z>h_Rkd7PbJ
zcW|Y8=yVx9%q2s%%Np2ycbKa^W`1sPm&-4KVNQ<Sj43MFUMjL6qs>1M^@uLc`{_zW
zp1TvLevz#s-*z2<bVc7YYnwikGH{?L35~ugqODPCJ5kAt8*01#==PBCOUqiK+;uh^
z`mEsS`#4<Tc8?0V!m6l^KED?T*2R54j93Qkc>aTBy>7tf-EQQSN>VZcrXSc2x@iGf
zoz*+-@ovzQXUgxMkk^Yh?VWCuGD-Esj(pID#U)2toY&0Fp%8-6WJW80;dh0AJ@^UN
zcgjD*%}@y@^j(UT!e6|eX}Tgy=ZSJ~>CA8=T5KO!7_s5QXpb?-Ik!uf>FPF+!=Mts
zStf~Wo_&RvS60!=$F<mz=vsgcS}~tt5Tmb&wY`2?v%-c~<Yh2en;H9p;k4BPzVmGL
zpci0u%k0@L7gir165p-}caj$kb}jB>xI5Vs^4oJZzb0iho}evCn+I%F%NH|l@XF(0
zD1#L96B+wwsd;}?+YXfGWUcCCJ?aV$oGzQ0M=<>9=_4dSt#qcLBmie%v1dZn>+nUg
zH;_w^=a=2()B2BEiTGq0lh1hFpLUUmf@#(dlgtd@>)MyGL&;t1@9-?#jo(Xp0wO%1
zVOWANnJb~YyF0HsdEhIdV~s-+;E5*fs+}bGtihmmvrqMcPp<ZX^#YKRV7YIOX`7l-
z1J=O``tOS_AMXTZj{3ui=+gsP1soGnQfSfxzP;2iI|}tt`-T&3&5T{mM4~Gyi_acj
zRCu?RKN%R-kiQWI{0}p6F;>S&4jXs#Q#Q#at;Vrg<18uA=iAWkxU4I}^_bGJ^&ifl
zamBF~X}K7Er#<h{kF;;grzJCX`OjHB<0Hz_tf-S$;i`zXRkcd@Kz3dff|iBSm#<Ka
z2Cz-@bg|zgieW8o_H66#dVI66A0GZWIyM=LVm?0-i&3;e<Q;u}FQ@z&jzo(y%xGqG
z5^rYjvhh}Q{xPg(GNcu@u&)cW46n{e-#InCv{Gx=b;SU+TY7<PC(JM2_$=t07((4(
zt!L?%6cj=l^W3dwiaXns@*el1zd%JVW3BP{=^BT(S_!vecfq!aw@>H!&_IhZ0A(7;
z)$8J_e@eT9r{M_0w@r!vfOSZfH;i&qqPf*_9lnt3-U%METab*&bDC!3aP-EUe)^>R
zw)0}0C4p784IP=Zj#ECCFG&b62hYO*ETN2nKZa|_o$VDM?S;^o%6MKTwR!TzylatA
zRz{FdzSL(2{MI$Aj6lOF^(qG=M2(~G`1F3-`-#K3+4pRSIel;WF+$;&%!2BiUEgT0
z{`;=lgg!+nB%MRr&0_otMBXD85tx4om$I%%2c%&{z}L-G%|zWSKPY>srxbIljr4=f
z0_2vk_75BV1OhZ_yq?~0_B5t*>F*3bENH2g@sEk(HgCplS~^BhpZ8c<x1%c-_7`0;
z)Rec3mrh^IsSwpDIA&&scZT(JF@j1*lEDx)y@B`4Dc73Ts!KTZy%Oz~hbTr-@Z?#c
zY?vzSMPtH>Zx|5A7Mx3l#j$io(*>6AUE?S?l@?ZB!4NUPuq5ksbUIpH_iJIx+meLQ
z;ac-aojg&$nEr5dD~Wix*ozLoj8w!!cL!CyPF_8@sGl88u%^CF%+k8~Fg%s(kpA}2
zl1|Whm<ceMj`K)M*kRy6(thnYWwJl`6oRA2eR+Zu??Si`yDx&j7ypSXNt>a)9u|N3
z;Skja?q61vSAh@#SRX!L?RlmYzGl`gx<a%Ru?||Xs4@`}b60i-Ig)UJ7lGu9?U$e^
zr=_BcvPfF%*`v~NLPTMS0#-DOstnZ}XQg>%dmu%oFTb@jltllGW#c9j@FIEznA1#8
zZN(h`nrEqW$Oc=$XB%~toRjmzqxt*7I<pfL1_-;rtD^<U$I~-%6e7;|gc07kE&v@U
zuX@mQwnPF@G)*%CHj)o$jCkc*YUIb`gj3OCfN!4xn<_s7d&cj?!dbu&N8Lx$^S2t<
zJvY)EUe@hreeFGH2FI4)9NKo$5xSPFiHeX3etSDM{6F^IGN`U@-4ad+BoG1wcXxLU
z7Tn!kg1b8ecL>4V-Q6L$ySuyF#-UeUJNI<o+o!tf`}tL^+O=v2!jd^39nToc;CCKj
zUDB0(SdQ#%K)4N*Ff**5&0lKpLc7?u5ldb^8_(P-nN(seX4Q0Gr-~F!8%*js?c3(%
zSQR{d)7_LhTI-8|zVKV+TVe-!tj{+!K3K|eJa^+zkEJh_5nOu{PkFW3d59!y#U*K0
z8n}?#OfHHE%p=ZRXF<_W4zraik!O<Bgo#w_fx}{Es&y`=laaD3jU=VAhY23OIH)x$
z8$*MnOLu0#q3Nzs7A<~otLNG~gps$AaWJ83IVGN+4N}g#>k}1dO5=C4dh`vmqw_-$
zPz4j~(_$Y3O!A6L&*bsx$1n%eW2*|LHJ&{o$TcokyW-ptILsC}v-@B)7kWahyS;RX
zvDluQ0;*4A$+xcF-)&l~+MlCUG&0p5LGY$>>~1cJT6-El(yd+@`}S?JNc<3Wb-(_6
z<J|*gxBEm~DwwXT>#ODWEB$M$oA5#MykuWbYMx|riB*w0CQvjSk(=>_8-$B3h<*3L
zF}@oM%d}^<RpIg84ZJ{fCq<h8S~W-P+c0FzQH#Ef!EI=o=rG3YPcYcbjt`h_zB*@c
zMWyUI&x~3?^7jT;8s3!%z-++d>nfc_aY-7-5_DuD@0Q26ccBX+EVnJ6H!iUgNbpF+
zPR`hPVLdv^RG!``OuY^y)DxSPBCc8QN4DRp8V=}1J$KrLauti;_N}U=sA@ZAO8Cjq
zd-OrkwcN5_si8st9S3JvB33+=mRgn%kXO^va!CiqKSegJTr^zz>PAZ`%YPLLITygE
z1g&^H^+dZP^APN%OV&ACz~L9HckO%l2qIz&uafe4D>z%PU+62p>e+-1DfVXtuX$+;
z0CN(7ED)>q2eYNg{50)nZI3i!lFVE)c`$l}9dr6tFhwf>E!IyRpam0dYj^URPypJy
zD${JPsX$F>--%N<2C%OwHKxajop;&cq0RtX5SvN^Hyj=cgUZr3Knw_%j5yc!sE#R0
z+w<NZz(ulGQ>=bgsWFaHby0+7`!oc|6si=S0?OpqU2s>!51bd>Thk3TJ&2*lB%T0n
ztwuj^2L`QrlvzbaK|uhZ%ZcIicXoB9(A7YpQptEi8?qoEBs>6swkVYrlB?XN)=3RW
zza6^@(XUQOP#Y2=B7bgf9%<rrxO$E8S3;q%AAFj?hL$k@Gz?EaF3E#&@QCMO0Dlf!
zVof;;q(rc!EYBJ{5G<FM@okX?sT^Vkd!eNfeVM%T{C>%Sk&}5*FmUh>Uq^A)a>v9D
ze5mf5V~uzbd&C2#MZVd}Z55y=3Y1#BU;dgX8c0UDa0xfj`{KY=eoNP3HnBzu`kYZe
zsW+9E7y5Pk1b0GqO#zB=!nWez75qUAG})JjT56rBT@8w{6WdKob@mepVo(Uh;PPjP
zIL#SGRP+L?=jc_~%THVA@^vy6zk~`!^10WkRbj7YMZH;2wKQT{JD-)4-Rxb<X`#0>
z95cn&i1L^2WtnmCszS)h6}Op3PJ<5gD1-q4ZTPtW6OB4{EDj`E&EziOWzWaolHm?=
zjoFDLk`l@3%YhIOPHSAtdba^ElzuXTf<4<CvKtn^CwEPcOr1kohP_FB!#z}DWL9Qt
zi=S8r9&5My;0PVUAC8I*-o9OZ(8EvJ$9oxbmZ7MQy<dNKv>IuCvt>;dO|nt|pn}lG
zXY{U`PccYhmk@mRF`JtE_2Qx5<9~0Xp4<gTkoRYs*xvWGJXwm3NRuG+6l<$n4B#g<
zHh;Aoyq+F$e|cI(^XSYZub&Jiq2SQSz$f??oXewmbG9(Y@0sdgI^h?Q64O4{109L#
zdPKJP>3CUfSRBRgaA{tAuKU>re)XB}ojV!TxHJ@N*511AXL0Kwc#nN}o{d~#gKjf+
ziiG*gf(p<to5P7kjf}!QnfTL4&sF9q8q`ghm*?n_6-7_U+3p*g@Fr0mK&I+?R^2N2
z3=;WuO;$PT$BzsW8$jpsw^8r>EfcvFu$vN*Pbl7=EmhA+)Yi|Eqx4QVTH4r-qi$39
z<U{{-*O%bP!6YM{f^(*e@1G?Vo-#DG)UqI%2gj1rRtt_3W@cV)*Stt!V>fmT9^kD9
zV+J}kck~@;7i!IvD>uyVc|fxq)%{;-QyNa2@a3jz&E~{hgc(9np7Ehb7wfI^-Bs&q
zZMr*yHoB-^jlZ2FwYb~>Vh@vT9*VCU$~+)oCnH;-w`7*HdM2ryK?!Ip&)6Hx4Zc>g
zd?W?1`b-mk9B|Uoa63?Y0BW?hU^ZnTTWqb(Llk#wer`?}K1v1gClM*Be6?ZSYqpvh
zN>DJc_cSWORpt$7HKqolNlg~24D63e^F~-b(+$TEFD@>7hmfI*(r8Pf>f41fh<HMs
z?dpqmEu2Hz)|b(n`H`WeKNMMKWttK0Jl0Gwe)s(RVrir0_p`#V<$Y^oQ*vAK;gGz3
zom}9?({rod)yT|B@&ng-+a=O#V|3s_$+<>Ul=b&ZMyZ2lP5Oh$O)wK`*Gj)tMljaN
zP%4e(Z>W!+Ba5P20<h@P?h3s=OPU5GDQvB7#14&*f;%_A^c!6sCfDb@;8$O&V(9P+
zKd{I=L|MeR^<ISkJVcA$+dVws$F_3&sRomZ=MuKgVb-h59=5ChS!z3X;YCZs8kA!L
zS?%tylJ0Z;ZAXjg5^B6`;b`KvpzqxjIpqspF3z%u$wYE+SBu7XNNIfq`QYwuBx3Nu
z{CtzHy~;kzY++n%e$pPplQxga8V9o)TN-3((j`W1?R$^wC}E+cBZ8Uc1}3D}*Q@;N
zYxCTcF5i7g9%+w8ZVPvn%!a#`wkEYnS=p-mPblA?ws7?+97;ha>TJttJZtms1QbgI
z{G@>SYVe!=38jNke7^bS?%wdn+Kq-1{tr`00GYnYo>X5;(Kl4(<u49&a{*-vYFamE
z(1&a{J1vYX!KbZd@u1W$@#WChWj92dyPpZ$Og;R(_HrLnM}M$uOK}(9Vo&)Y9&&EV
zG2~Prm^S9xiThgnK)icxC~VIKblewNVCaj#B&X(EUrn^PuW)|HY0Sh;6%oyU*SXZ$
z;m6pmg*DIUOQ@uIo1b|X!CoTl*7Ur1+P(QfxHRgs+`d2Jh>zsjj7u0($FI0t!v(LP
z5}FlUb+gh44%YaO6S$G7nhI_&B*prrXj3lWclDki$M^64*og%^;KN=sg*;|X#<}RE
zuoD;Us4~s)PUI*2S!HtFu)=X8_+~gH=5Wj3`M!X19J~5L&#{ns95p_N%q6t%lH*XD
z-?qBf+U<GLa(;N?Pv+(2{q8LH>I%PSpR1&V4TVBm5%^)|?n7Yvi&~i>Hg`4VRZ0rh
z<yEmWL4cPC5cOfk!Vm|3sGRt*=K#PhAI`fHyYX34Ot9p9S}pfS$W+GXG)I|2+2=8X
z%FD}HU|xI*;n=ejr+vWJ>W$J|;#NIwH7|VA4;&0FOx-}o@I21g#IQ?mf8U#T6Yuv{
z?n;p?#bTvJdwxDXyp(ZcjYg=|Fw60Z&0q>G16j)lV(MA46tZEd>MuCZr0y8WEO9Mh
zU1U5{O`*Cd2ulnv%Z}Y2t0$4pFf2YOxqB%;(nXJhJYsx@<`Lfo60=urQc|!4F-&ti
zT$m&2X@5?;R$!bxNMvoeV`^Mff~w6lEOK_N{4C|qx~u<km%_39;KxK^H65tUEWzI3
zBZy-JD$9I#l_zggcQR+?5VnxDW_)-PdCTk_$fT-{-Zf>sJe@C^GoAe_B%iNV_G_Mp
zuAIXPZdw;eHFD}ZYJ2?bXr_?Q(yda2)K(h)3y*nkr6yAA`m^{YN>&-VQ6JRPZTs4k
z*NZ+vpp7(WalA;e!FJhk39si--2Dmtq5bu->+pS3{QNPatDChuN?zRRYFd)D59{&G
z?umsL|HRsw`WnE%Ednv~Lsu!@RH!4c^g`vynjF;r`Ya0QdFQZn`$2UPZ**fjY2;fh
z+hw=E)}6MBVs7gZG>g1EcaE(@GC=Q;zJ`1JV1-{FdGS|=n`{Wh!J5WceL9<|^S8BD
zt%SU-+Uq7ys&@Tgu!mYWLNmn9SpI#o`@OsI_XDTona4<W&iJ5l-oPa_vwg>lLN9$p
zKNa=Axd5I6LuV(<oHS`$(^k44)dP1WW41=UmC3V$6XXl8rvh3Xx!e@`o^><(!$eu5
zg$Y@=u1|I~Kdsd!y&nK*xv`djk5FADbIpR^yXDB*F*UIG$t6aSsHNu@FHk`E^Y{h!
z7Lt^TmmVdRy&`tG#hv_eF)FL*tqTNerWRuUM5AAJOp6hhK`*pZwc|4SC7h%rhc^F6
z8HPaG*UUxYL9vj7^G&OL4ZScWrBo<kFKd=jZ~Z*GhKLNjXv(ol{k|k9(vn7K)(9iY
z^mrrJN$dUbOt~q5d^MOY^)ixP?j2?#Pzn*#MSr+C0*0tZl{=R{lvh_&hy>ABnJm>=
z)O;J56dM_GE`4&JN(vXh15oD1fFk{(7uM9&RL_*aY&st$6;q=IOGNIN@=a|<gl<@Q
zahzQO0%-P^uEczHACO0oG+HPvp>r7`A@xfO7oAMoi3XpHAl0VkR$r(+unZpo13f5Z
zs(n*HrKJMR)BkLYb<LeJZFP~Nr95oX3Dw5UVocpM?9=byQsX^XzEtW@KSWcu+#xz-
zjjH!h&Ub@8zkY%}N*637r8U<-5xNw@jD0?2>t#89+ZAWc=dLT$taZum_{=#d&Lf&?
zl~Ur&RKbMj#RGT7^dm{&COh>?JAb&_7s$_K4Px(K_DEW&_fMwlavw_g5A19{P}P08
zeC+GY?uI(_Tx%COTi{(w5JVk$T$Ye@)09qLbNfCSX*s8yoSVu{0u4?TO!Cn`Ba@CF
zYfsLvqO0a&rsd3-xFvfbhXw_$D+7(o3+<8FSO<X%{b<_VVKx0a`-|~NvHpG%DL1};
z0{qPb)v)PuX5=O{k!y#Wz4?N&De~xy#P=@#r>k__2>{Dm;Otgm&+aMnz00}fY7~h$
ztZy&<)pE8(6tU~E>0GAL>(!>(5%jUjL0V)Fjpc^()9F2R_|6$^`y3Kd!b=@ht&>pV
zMG_Um!0>S4^!V{gm+a7x-SO-GZ0{H6bHBS2d~HrhIeZ3PE7ao={+n}pQw6WWBd4`z
z@*N9<s!yFz+K{B?8&xW|M|mEd*#anBbS-cPt;GA7b|PV(*aQcMj_^!d@$Cl{=X^Ho
z7OBpXE9@143=l7t755cetNTwdI4BVx;rR_McRW#bX|dwMx|~|hSL9q>hw)5J&wDfK
zj4r<B2hsIZ_eCDvj&Gg>PE&*$8Li@i$n->kOh$q47{-Sk2`SmL`49tL%A32&2=|$Y
z3uAz12zBWKNr4DQsmjRV<YitxvieXJDUWr_Exira<abo~`|y5{<b4THYFC}t@R+QN
zjfr&*Tl|D6+$Kq(f%jg>5s&-hSnfn)j=n-ntd!tFXKN}OMhLDR*R$^cKUSJIKGJet
z=s6vJu{tz^+<t#mqvExOu3eK7C8<=(x7tyyo~=k8-EyebheI>RC55~WX`W{Rcebv!
zM@!fX-4T_HU&4|q24y{`^Q00DeH$hV>iHbwxh*Ku^i-(;CZ8<LbD_Ym8qo0jq>8B0
z0<@0fn$)TF$3Dka4wghh;QXF;k3gYTlL2J!gVOtVM}!>x$5zD@)SK+dFaGjLe0YR}
z{7FTJ9-<TiyCH-!I_Jmh2Xl8nXH|e=Y^LKaOw|`HLaXRvFU#RHJk!Zh0V_Q2r>-SA
z=lBk!>8$8GoVBE|OeD57vnR8f2VbaoVC;}&P6=_2VswD0ymzEV{3MMle9&Q)vL=Lr
zL?x(0Sf{vby5)?lC)(RfK$!6@AHOo|;qCD2L{(pTotuYI_`*q=GLaSZf~c@@pOLhz
zR>)3xE-;%~`jHn+x?@3J09!JH)3=kHhk8IkN2JkZ0COO~lvsV`mUK_y)AREt%x0!{
z-t^|8I&zeN&QTePzews?iWvFhT(ZAGCDWNWwR(llTV~U5wzZlw7u@&Th<an5wLKV$
zmjgRpfr#C{Fy-=ByP5V&7Viqh<7WwwlnXw4Cs#K<gYauCSF|>{UAM+@T(>0e3gvm`
zP!%~mo}8<u`=+Mcx#iwP(TAYXD1KXq9Gae%5LC$;H5m9gQe!+J#C&vJO{gn>tZ9FL
zd9s<N%&F4Znb3TOBLs->=HGca>3@V__E@!Li!UkRbn7y?F}nOFEkpf8Kt@mbwOF{5
z9!x!g=re9<mrtQrpHk-+J~ChgL>Ycm$SNhB1H|F_ZFWpSO{uKBXyO`o33l>w<>@n;
zY~yFC{Vw78WRW6g4+jRpfXrAoJ>#PZaJLn#G9DKY7T4_v?z9S||9eMENo;?Stnl^0
zEQstCt_ISRaB-4T{h<^GFCon-)k`K>qLzVSjhZxAqJA&oLyfdniy(qH*{fc=L3Y)7
ztZ$I%-^|A(j#V{Vfb3>F>;dvMZjz4N1=Q*$iv8p5pPT6I=K@x6yp)3O(oyzk-p5@J
z5y__OTp+m$#to<N9KZbZ33)R}CQw+f{#UTNvdrbFLrAE6;Fm0X$Z34Afq~0NLkEMy
z<B_g7;mD>c*kQ!qo=^cSEiDbGGpQrih=%_tyaFE-n1_b#8XvFS6gCw0gRMhJji+Jp
zblBba{<&)fFNJI{R*<u4qlh`tW0&nBQ%&b80*U$Q?Pj%U+3`xoqqW##wFY(3tq}?o
z5WRv}9*aL7Ydn43<gd+e<SIP6Lk$`$YIJp$AM)NJ^DNc(ITS~aE=T^nAlS-;yk|Js
z<P}*>zG!_Fm##O>p)IkU*DWfjh0piHR)OLt!|-C-%=9yPKbs_dD33C1TC}o=-J$bR
z^mNuM_0NW!q13UdI5^x&))Vov+lxwC3Y%?$)m0E{Iu?39gN3<&Pf(DtTw-QTUA|QA
zM2RZNh1XD=E|bAvsr}6iHdCbk^4&#WU&t1JDK4oqV>-V`0pB~2j&-5q{*NcM+lvb#
zSQ8*ABd;(#=K5+S97%FmjWQKK_!9!>`62OTG<=nnO6!^dbu_iv=Ng|~DB?IDl9WWU
zNi=EU>E27+#Vyg7{4tjVo1bGMF9${r9cZBji4Wj$E10cO`JJLqCf}7{1UjQF*HV|R
zI!RC$T`-0ce=J7hBcYds-9b41W$3Ahl0ef^@<h{_ao&MK(J~c=IiC97(UiKiUGnp0
zFu>MvGEPi$^YRIS4|Zl=zE9jPPIi!e%9q77)fE<1m&;t$R;W$^``GNUdH{ab;r>O0
zE+ypvZBiBEg16{tl~j@79oS!WXqj@T{>eSp@XpGfE7YwRUv-l`)~SQLLv3=#ji4^+
zyq#R)so>i7sfdNwO!+U${7f5Ywl!dXFVO~Yu-<Vjqp`GBzlrf$8hA1U%(kLNm%AU$
zksh@0rfys8Jn|?44*^0L$!M1_{av&wl$6xu)06REY)+@)7eOmbV#|#JNg>+KU&yVP
z?Y@@D_K@3}tc>lX{A9I%N)n#w&tlNO9e+3g<T{HQCvU*~j6#ak40@RY^4MDK8YL&d
zp`kFCDxTL4Tc$1z0mWEfbDCV6Kr{1MyPcgTo?|ZkTjeR^qYqUgo%M;nUObM<jyp_j
zM$SJQT<oTL3vFVfqI7$+D0UW>eudI{idwbav`+JIE?+*juQI+3g>Pv!sLW*wdWWu6
zz1j@sCWOW@P2|G>J0a7sY_&Ljt=e%@taQS_LTFUYX)AzYRI#2@hZ#u6?#d*ZY$)?1
z9kK^S>fL+$sX>*DD$^M$>N61ncGkqv_(VQvdj@kF4hA8~I&up7VC!WKv)5{!zMo^0
z?YqypE>1G4mB4)_6c?Y2B^QOME^tG=-w?R!C5a@B#V%$znG#URppCOYAqZxct2b2Q
za}^0M`9|U91!k|yI$!Mzs61&`Ri;~1t}PsEm>9Zxhb!37Pf=GD=IRw5i#72~cGA#i
zds$I7%LtJ&NM;?1V_~cuz4iW0Zt(Ja<|W?eal4`nrxZc#^9J%e?=z9i<7>RE_?ftg
z4Swosy(~K$ca@d1_@(7?ObdT!?GG%}!65;($m*DMPoV}qF5+dx{JF^)9kqWN9m)jW
z04c=B+m$?03YTy!At)st$n8`~qH^9TLz%r~lBqQ97xmnp_*f+JthM(rnlUfj;ezfC
zuQC+Fahk2gzJX2{87|H1RhyhkG%+)t%r4w*7e=NoH^wJFPq`zW&$SZ>LnB+jia<FH
zjvH!8Y^YAWNviS9c@v3T#W_`n!`)98=(Xtdvdw;kT2eK=N(d2Q1Nf*nN<V3NV2aAO
z?CagMm{AgU#(IXRk~KXDPf+khsQkGvAR+NzQLu-5=}<IIAERBZ-vMxf89t}^t0vtP
zFU70&XAtK7!-G<7^X%DpCcj!!6T*OAmx5KxK&!6r4yi_Y^Jr58FHb=B0kfH7Xa%N|
zN#>Ulm*{nC?95E>#fmW=ulRYSyY#qnF#;A4lEbmFZ7{dJF|AsqUSLn=!|fRb7yD=y
zG>RA6$O2V%_ExSq0Ok<&`*e|aeC%G>QfII`swu^22&C(?*9Vb50t3n2JL0Gn-869}
zzKC#jxsh+xeF`Fq2Z|g@mI!3Vs3j0ks|8A|@tS_;0bQ&>Xy=Dps}q8f|4R$e^4Q?g
z9(jGIK_s}#xB+^M+8o4*pwiM14IMqXeP;j8??X^yvD56l$2@L&iH11L%0}rUX2GEx
zb}P>&aXxw=Ab2?EU`E;LI{&iJTJi+86HF({jmq@`4tasm-ljUPI}qSlO)J-ea2837
z5=*WRuf3#$*t~^aNgyEUVi3T)<SL~DP-Pf`6A%#WKb{$67O4^<0a*xeOpAimwRg-6
z5YIg2uwM%)P15fa+!t?!{Ij-hg1<L6f2lQJ_^GF_AIzn@!0-acT|cL;36q<n{cbV>
zp6%iGm8`}Cx6~%Oz!Paci!k+zivT4f35LtPyuewMy?a+=FNIk6f{-qD`OIK;02l8g
zN?SJ22;%Wrv+Qp*RbnSSd5|AeHtJ=>i&5DgPHw6TQ{AV2v@hW{W7dqJeoerhtV6|C
zy{Vl6In-`WNAMIbwU$Rc3Xb7(OA-_=Ftf^DMzkN(kmtzr0P!7?7QEi@qU~MeWG818
zsR*R0a%FHntToL>MiSGPFLuMnME7UeqV*m2cXMzfWdjf|)LCRtMY<?Q*ZzX4MhC|m
zrQI6yD&MC)HZf~%mz1wZV(iBP*H|d46=XDT`vm<;FFwNNFEiT2(G<rvy4)iKGRvO0
zdqyMyT~r|5lP}%+Vt3x%tzgoSY<Vbbw@Vd2$kvrffdw<Ov9t5_xN&p7GTLx!A6f-G
zBVc{~GK*jc(;X-h6emm#B{}PkXPi!#sOpPJ)jf}YaLY&g;`sUbX3lYNgnC>%DUN1^
z0E*Q0HX;j$YjL8@<I=69dHy_&<HoYEyp|4o)NsIVwf?LjL0Nt0p`{RXSRCE$&K<w2
zPd-&=!Pqn93s5J-Eq<vse*|?Y$jC@&X(6wjbawgXZnWPUCdN21Rdef>lBBG2w<d$~
zPV(#67h8pvQV08gma*npp+1;A;}n*VFya%q3+P_B3{q0mxh#N2_;Mc_ke0mkA9~q4
zmmswRsU`e8&yg~@i!coNc`OyD+)qyEgQrQ0`0#qb;ywspXG+Ig)_frv<KY~S2lWys
z*BaPB24=BYKx*rn_xnH@W~h0uTaBc6c-i{*cSyIuRafRir`c8d%K#dr4Yy6Jvw6g^
z)y7+GnR#{cLR#WeFZF(-&>dl`WoPKQP*m4Dz4n?-JiU#|%584ZINOuI1Tj7JH(ja2
z{{T|`x#H2FG(2&wdeQOW{`Sys!0>cp--MEsHJ@_0?gMnE{_vTZncGEnio;qY08Nxh
zryrCaV_qxM=tQ<~&-=iWk#B|X7#xz`1kSP5TE*4`v_-Gx*7<ISQ`CMH7{fH#pRy}(
zXtx2nwA@v;bumWe2%5rN<gv{5Ho2Z~p1iAHNt8RW^19Ga_z$<YCFW$MC(ieF<<o;1
z$r=>lLbD%PEu^_DlPP8lNH{<_rw|u@N!-^#PS$q*zR7#JJP@>!`?f}YbY^>~V<OcJ
zyBE?0bJ=GIZp(~G#et}T;c0w?JS$S~v=YQEtQywl1qN>2jo+_4-P2&)UAlifSzgmi
z{x!R@f7oXz=5QcfC+_0Wo2Va$vLl~JQzOAUBsFbwJjHjC;Wn(G!KwF4rRj8}=fPxN
z0{3o1vXI;MJau|+U~J$_F9>=q&!XTJ81-(Y!&$_evG-EbbV7yka)StWc0v{e%HuE^
z5|}WDwF{KJKUh)3@Wn=t@6}6t?+LsSNq-W1>l+)t0nja9H@nhcxt|qYzC>f7G2AXQ
z`T&qimj^)bCwPiVhYrIk4}dR)CZYKpIh{q&v&dim4mXpS^CXQ>J`blpQgGd^i-eve
zv%(RBY|rPk&!)Bq>L+XGk^;x?kIF56CiwKZ->#5%n<<9-6I27p$5sB8X#)S5FmxVc
z7mq9sm6yl0H96J9gWxT#)-2=ImO12&pqIsz-5&({eXw}|AqA@kG2aX)XkJA>8e<3;
zE2jya6B8dIXiHbDq$Xt*-{26cX{@B^nifg75Z<AqtiL|s+j?+9#D{P3&kqY&lqHOY
zN4@V0e>MR{Zynq;TV<3{cTsEANjmGh+FtV(o}P=Ust_w;FpxJ@@KDJ)dvwAK=Cx+3
zh8wo4wZ)1#c=60RnhG+KglFLa_!kcRm+S3^TihmpLvCA2E@uzzS}_i|qt!I-hIvEd
zTgOeU!Sv>3wqJeGt4VBfu3k&%W*>D4VaOOp+j#OPB|EWMFJ2xuvAc#_#A-glWR2x5
zmpSv(kM_xV_M{R1yz}WHKI35v;HWdsqC39@Wh{NT&iD|J+&v!GI}tw<`<R_>=a45{
z)A$uLt;@b7xX%d%1`^>PPhkkYZqxY*>f^s^f*Bx0YxrbUYz})F*fa|lmqy!tL8J#o
zfVgU+HyrauP-N~MSfKI~uD=rwk%fIdCX@FfY)f*8K!5OMm7FcIbOP%oEZs9C^&pih
z01?W?TA*@CHD1*RXFg(yxn%qqJC2n`U=CsR^MKlMg|iaha4}_aPElB`)l)_QwP`nv
zMl1*(7Fo{vG^~ogFAG+GKJY0_J|+?A<lKI<?n&$<Fky3%;RE+P^sqm}RCJ`Uk_W$N
z^Q*n{^5X1|R-zn1t0-{T-?%~QhcyCDv2UM4Khea*{WP+c-|+ZV^VZZ18>YJ#MSZKF
zxbUKeeejulPz*5>CR(5g7<wfbU=&$(*E{=g&_`v3a;Y+kb9Hz5Dm$If=WN`=v3$u^
z+vrKKlNv$DitBaxS=SUxvz$Xn%C-d3;gZ$=7OM<Jc1nvdhM%(FTbApobdM0H8(QO`
z_rdhm%d3p277B6-7jcW<x2X8L#|w*Dr6lrK4_xgF9smrIb+t+U4K_6c6?NHJ9~XnW
zr5+M0DnID`wH7{>ZZGDYc}IsQA1}KYB$j1fXD7no@NnMK6TwF$OiQZqam;pFo1hP7
zpws3nlV9J<)KuU+;aYE3G51fKg(2SxaL2~QL3<1FUtU~Pkxf@HoqoW560mBy$WZD5
zgM+2-u-mZ40&s4y#xMeUD@`5*DJlVNBI3#)#9@anwj#YkYqiQX0|iOfyk3*e$7QpY
z316gks9C6QHt1@4<H;{poV+IYC!R;R&EjcRG<MK!R3dizUb7}->&f)3=V57CX(`yW
zWp?O`i?>uS>Z?zT!ER1I7i#*j#@>%F{luPN@>;R<i2CWd=RJYarMch5RROtmM0&<>
zluX+q#(6VyCfE278_3%DB?1?pFGVAxqy<cDWDvRB3G{iR*jaYmNiXuFFeQFULc1sH
zNDx*o3_Ll@uBzX!yj!sf)>EVrjT$X8<y0ux$WC`s*k-k6iEq&#J9yjf9tS?3VTX6G
zwU+09I9M<ZrzV=dWkrGIwB_e<Re_|M?|Qdp2il*QAM2B#>pUa(I^{IitqCD8T1$t(
zyq&<jP4E-MPJ)J?=Q+#ju94`0ejm6j!zHJZ8k6ax&A3*+l3Su&`Vr<_v761bt!l5y
z){COKtf<Dx$tK?{DY=^i6Jb_X)<jk@fDiYd@}Mi<8ywQZf$(02-w3}yjxuwwW0TG#
zV**ObP@wvj14&tC{!t}0>P=vb`s+e=j0cHQ(PlWkbmjdJ0hm)dZ#4{BVI@tq*TiEC
zN;AK*9K7Q%QX(Iq?=#%XUU`oyHh&Q~-Im9Qh2rgx@Rhn*&iWfG<Ai{!D7?k9Wl}=i
z{D$@TCd(^@9~!w~X`&hboX}!NR!oy60Py`GRgywT?b}u9d>8oHs_cry)j$yZq2unQ
zLMF>5kXwulI@>s_rr<k^1TL**<ksz;Tp#DtlEk32<g|43e71;A^66mG&C$*{j*HP|
zZrv=y5_cLO)RAYMQfW*z<i>nexq01$veM%-{O#fjYtTG2q+1tV2#GVzlHrT*$I0lM
zDZU2+Z`Eqg=oSoX`cOz8|4=7IfNanU*VFjXK^KOseb0LSJqR2g8Ce%VHhNmMb4C9A
zDOU=U3CVfddMg<c`h~jI#>PbCt=?6cjlS28`9QP(^w;=>3SFL&bXqsgP1Ce;;)(8;
z=e~o|`rShzI%%a3LsspYLI4e3^8%M%rT}6k)G%1=B2khKg{rCx60VmJSa*3Q1oW(!
zLF@?C7ZSH|bOiRAD*kDe#|6r|sFwjRaa2${npB6%T$auEs;IH#`v?BD2<`j_4rc6a
zvyaj_R^`&w@!+tm6XXP89QB_V5hamgV}N9rw!E7aHp_2XLe1&C;e|mhsTHT-LnxBz
z<jbOmAGdm)=p|>zoRJnhzPFePyp;0H9d`w!H<zQm)y%L2Q^!_Yy)||2-u4&wVDVNS
z`T>*c+cy2l8;u?};<3s?XYILAk~=Lct|YwL+Bj9}-Y4?|5<v~aQkeK^>n_>i(A&O=
zTE#rg*Pyp@2@yT?p%hct7GJ+F)|webfxY&E{n=Y>V1VLfvoTmzF8TO(FKPWFu{G#e
zRZLXWMg&}zA`M)--IMG2>1u3qVBnZC1~SedlGjFy#NvKeHRR<8S`Xi!dPssp;LBdS
zWi6Cj!Tj@8vi<(p7?Kt8EJhs4-W2FeJ4@fp!pcwe=uCti8iz{tsZKBkX!8$>i&H6@
z836fp%x3~K?j(^tXiC)10M>fd9|+YCUj`+`Wy*Rmm4&7PujytLmD_5_%EkEO)9Z&r
z*|8H?Q)k;eL-~`p7Dyu}J8+H0Gt*b=*dph5)+QGSmyX*|?wd%JMsnNJ4$GZ6E7<0H
zIuFsV&f=}I8rs|IT~!@C&A?HgJ?eU8v5n7OwQ{-E+9Xti1AC5ow^MV-9;s3n>tbeG
z7(#5vQe=`T_c}kh@T+Sd96v@^c~KLeX;{XykKx~}zgJ^-K+8SW&QC{}<Nz}<+1vO2
zU?`GFX+INk>tDb2;te{DW!?PPBR?A#*2-|a<fP%8SfNpVhKLwV)FRg+36xi+QPm}k
zzHN_p!L?@xL5hh<l#7dp-?!4RfMOu&t9~ezvv_4`pIqI{i67L?wbeB_)@l~bBYEy7
zsyepMu_foaKCgMI3p=gc&<e8Y9e8M1^zC6)ejVb>mwJ}aHm4s+V=fx1GiN7*@z@q2
zSZKDA`v9F-^Tf26QX^W7zGmQ4vrzE6Rm~&GbF<WQ4fJEWS23@(P)%K3ha9o<_H&S$
z?R3h)C_z}cecZ49msod?%w=1zFN=J*Pi=7#kkZI4_*MtCYE&)D`=uItCqpXvRz|d%
z=3894^7dGg@MauTXevq3p2wdqZmT7n1D%hI>|~Mam)tgyEFwkigT`I})VrGV>pFK`
z3CHOeD`owJ@=*PJ%ii$T1+AwdXXO5#la}*&r6Dj>Gts_Ft*j;egrQt2a?bO^I%yS^
zAZmxNB&%LxW2HN82K1<Jb~;*M#tUQ2H|JKH37d18-CY7s9SIJ}#;0><9bM1n@i@j^
z{i?~khVy4P$GeF?<14`PH{!KX{N<`o;va);n!syQxid0|k@lX36w=SnPew-Ohc)3z
zDb}$A0V!$V<kVDbc16YKloSD-<M|NhU0`Ok#{J%wG~CrCz{cU0;5F}roEIyt)9j6#
zR6kd;fa-uSB{iOoG^{r@N0hX+UFCtI7(4leB1V3bNCoMqwQ-S41bhLF<?iT&&LNLX
zNa(0|Pr2b6zm<{4!z5)*oO*9a#O<{#-*eva)a7R%q%s$i;E=!optV?7(tUA@-EMf&
zUoME`!fYv3cG~$R(77pw3w1k<`>QI{L@b6lP%Ed$ya$(&X--2LuVQq0A0W5U$VA`1
zWp8*(k-UlTzzrJJA{Z7G^{hhx30N$dEHla#{K%Deow)bGs$JY&NWASM#1mNF!`a53
z)PU-fBj8)Lc1CIAIX3a_s{MsU_={%$i<6~btD6&^mltmCRHeS?=GC`m=d+SUX$Ao1
zIbCh!W;#nH;G6`h0RGX%#Xp4Ahd*$0|9GK@2kPMDL{wRGCZfsS#A9Ns6N1BqK{5z>
zbo}MHGB(YwFM>Mu2eGbhNB7m~G`SpDz3B`M{9sp;jObbehst4})k;%g6{x@8T5z}n
z2L}OBJ~*+;Ih$qPX{}WP9$vDhu;p$uzDB<fo?3fG;D^!Y=d}bY=8o?8X723Rz9W!R
zT2WPjSo>~gvY>#-8~?k<pUsfMgxr%cbch3d%N<&TG=eQMvG*Dg+*nCD7S2JN9+?_J
zCAQEZWIGx(#5o2sb&#an1rT@66kC2Fx8ks=o%ml=crz-Hbm?uo8)BJ_)^K43C+kcg
zYY|pWI(?szI)sxTDXaKf>Xikt^fe+Q1Dg>@$i-XAi)YnZ0^67`44I1|*=BJnj>84a
za>S>1AG4G5rhfXW!Di+^a^;8L&QA)H6H9~UvlVB31XNVeJRVQ#7bSkfOyGM>Q-O+G
z7DsQ%Am{N-BA^&}h%~8crsUW`#LcOkAR0;IDN|e>(@?s_mNb6CT{@WiRdAoZc720~
zL^cmCpMu2=WPYJpoH%_05cpnSPf3d#^#4_=vH&ZBOc*P3a3fFP`dz#F>uYVWV-FuV
zG)RR2UK5+Q2Hj`!5rfy&({*H|sX$|}LP3#o@X`;@4=&*fQiF_AUI2#5yg^||G=i8r
z#bgwxnus=34pb%!Ycwj4UHr?36$&;q6T>aWT7jv<BgMrlq-u0Bkt;6!lhR&bwLZ8C
zmd&|NiY?o0muGQIjKss$m<0$^DHC8(#<y6s=VdP%Unzlh6Ikc31?F#}d&3%)MkWCT
zRsT2BzFHm*bxMZRve;BNbDKYidn<?^9)?m4qr$Y9WMyQIktV>)Ls?@{uvJC2I94*L
z?DTFQO&pfj6iED{=pMn@+=E&_6M%#Zm#9^UI{I=kLLnS`IBp-4tIwo^&nddni0=wu
zhbS3tsivhMnXetIeu6bFx_ez8*$O4`w@Msdd}o=yoaZsCHRekuL-_c%^}J(6Flg;0
z!Hi#7^4cihB)1r7$ePaXb;0p4QS!h2<LUm2<<HoNtwt&V|JybH9Zmv4<sr@6v0o%e
ziw588zIP5EF8r9F0S49pWCN~8%`YlHk=GZ^{fj=zmM@wC<THulZJ<RWld=duy(o_P
zfhR}jx4FCdavk^Xxdz{Ob5d~%0L)_nIhg+AkzeelNxwY0;w_beyj`2d+`)VUVq<d?
z<(UCG!~xUU`tlGnvc}w7uwz9Z9w#d7KE{*Kk}Gkl+ntNM7t}OX7fTx*4z=jhm1gL(
zubm!0MzgZB$;k&AJ84$VMSd6DfubiE*g2alv?W*`Q2P1b4r>F%efPer-`(Jl$HxyL
z+F!K&T7T$AyRn*xzRMel!ovazA>@&tAT`Lr4TtZ%msc<+GQO_F5}z!gQfkD|Hp|8B
zT|3m6qYJ@t*;gZ63Sy_M^m_s$Sj<N;cCse$lB$;#^1YpSz~7C4-=EKd;^F~uETUlx
zi#rL(yGr?6i=K>RYNxds(A~QvrnP8$?fXG$gIUp05N_R{FBmu7);EXs^v}tG;hMYL
z{xk#`9m{QYEwBJwVJ0Fk%g^h+a5)U${tEdy!9GiAxZEO9{?ktS3qJrnY6Eai-{hal
zTZYp+WvB&LcZCWGHUXD%2ti$YcPtkC+`3Vlg)GtX{VCD(_J(JNYIPqaK7gkPuZOd?
zA=7uB<+Qp*PCVQ^rm&tPGsvl^{P-N*LbQr10-uN$Uu!smvspnw_ZwX%`AZv;pvCXU
zaX=b&459dwX1?LhWaBcJDZ;w=2<C?$$;F{{{gYL;NzJbLal&B0IFjohzRsqS+<X*(
zmXZ-etgaUYvIs%^hCM9uzv&EKw4<d%{5#e8yHEDU+m-h_1Oipode=|n9MY-TNK*A8
zK6FTczK6~H!!U!lQ1~)1-5b>-1{%MZRk!A{f`|S1H6sEM@*G6OO{IEqFZXa4d843W
zyDG;#2t2<O5r9-f%XZTk?a#0@qwMo{>#VY6@;@8Be?H;AJ~KuUM7}h5V+h}njAd9C
zn>EO23H8Oj;9_gt!ADtt`1D7h%jNCkL$FwPLMNF{6L>RG{}mWf&9H=LOHJg@pR6uW
zt!O`|Bh(mH0mc9at_L<@K1-@>`0D-ZKCRya0IQU*@cRE)zJHy3hXE5!Muo?v3Fjm$
zI8oe2$C66()}7ACgf<|>&Mdj}RdA-6>4hu+)<J<Z_-M*NhO$;-DOKWDk+5)|e3|tM
z9B_#ZRggrfT*C70ni5or#>glV8(%$<wzmYeI=3Wjg;;uWzm22Y1f*OJHl2Z#<W=^c
zWF%(j^I9D;aQ-q5hZx@PPZn$YZp)e+=jgQmy7Y!HaDYUeW^2aA<Z}Zjcy9!Du|`8i
z#`ic{ZBG{x@8UnV<iG9(07uz?103#!{DH88O{3{N()9H7@h!bT@cfh1|Lxz890frq
zlLIq-!zK%56;A@{zp+pM_KMaANoCa3!~$WlZ4dd1^(FG9KKpwA=|Xs^iN-5XMxo^Y
z&t3A*cKL5kyfN_KYzTzw^a}plANnr_^1uDwln{80rdygFDgW(1|4(0<`T?^{%s%L-
z|9}_%n@jp<GyHv05dItB5bgwF_y2Tn1@M63n1(de`0vdA|8#}C87v6E4q;hE9{!JS
z<G((n3?TsJE=!nT1OKnJ{-5v7dr{=KDR5S%BmIB+wg3O6{rgV&|L~<1u!F&1FyXPX
z)+aUNm4W{sp7q}ytwX|hGwif4d7cmmcZbF0{lF}MswyxB%k^|lsJu>5N%YriwWfKi
ztgL*vSW8)JwU!3(@D}KHeY7|R=)VhUYGMGM5aGTE>}-JYkb<1t=Cp?%<6n{Cf3+$9
zoKM^QUfUO#&bgB9vV>Dpl`xo18YV-4!q}gS^49@4Fb`xhU!mK*36))#M#{&}9}MT@
z<g{3A6j_OW`M<{t|9)3^0NNwrwNtCyM(5(Uhey~4_$DFVzo!_ft{R<qdH#TP65{yh
ze<4LMUZ(j40}%1<%EosO>?#=l{O_;kzitxXJOc;*yLG2^^~y6?;mmj00J*+uV6uqZ
zaRw|D8;oEv+UtsCdjnSj$Mb8q1vKMS0Ul#4!)8_?5$%#550VeB1&|-DYr7r@TBrd$
z_W)2wUkwN9k7w+CNV<M@W(AbG#<8&C2#JaP0cj9G$wn)rKfF~=<x)iUxw;$qf86$e
zUM5iL|9y3l8Y``2HTqWkg<A`gSzwGC0y;xvAuS-oOBgE?Zkb{!F;z4CEVf1u<kZF5
zxWOT@k)=#<a8vlVj?b`vm4jNq%NlnvOu%+_c50k2^u#13V+UtGx#g2lQ7Kfj`TiaD
z|MNosw-XH_z$!DhBk?WXW<+G4l2%nu9B=MQMRiUIZh@31+Hj5JTn_F{)6fGx{9`4H
z!7-Rk1xnRwC-bxcCjl_ULGNsD8yoZrn46bWLc07%3-k3&Csfzay1On8@tLX>8L{d1
zmNb>mxVq^zECqF3`Z5)db{6x6*<uLCGN&wpWK4XV45*N8ki#JbgT)@-5)p0T>(LhC
zV%Q>VYidO4lPo1a5DESL{;$DZZw`r>5=qW@9&gX;$&<!!1^)}Z#XmpyZzsGYZ#Mjf
zeZ?-T4!Rfp1LO$W4NFJ-5Ji`ifvmgQ&|=1C99B=BKZsCaNK!QG8QL&POQXZ#D}jb^
z{1VO#IEt?3<K)3}G8yen&SLH2C?F~}U92p9IG#y}jEXu1^g#~*4vLuASjAkkfWScc
zdP~hh)#_a_i5q~nOiWrjA0X+Lx3#s6?cJ85p`l^=)~{o_z;L<Q;1UxTCw4Svl`%X#
zEEajRyDQY{c8juAn{$3nM?pc6HI*+NdebK(ArZ#EB`8=sw`gEw6zY75TsFba&u=oG
z;XMr~4^dE3$|nE;{@5Ysf`jYcXet>4gIut9J3utV;eH2clkzZ#W|eU<)yJuHG;0yG
zfXnGD(wN@TCeCa)+vLzQHA3|;k({4Tdf>9XyGzb_V-aR@I+ZO9_uI-eHaAaQY*p%&
zeV{#X&}(`B$A-7gMc5zjAZpqkgMK*<_$zMspI4$nIN+=mw{~S{Uw18X9P@827!W0`
zeTVP5VqBd`nGeiE6i?@vs?_`uBe_`o0mQm+S=puddecz=nVn($8Z-)32C;Y?g^Sy(
zb;^y~X(BHbM#Z=KHP7bx{;_NTjT-|xD_`Cn-Ji%de!9B|aqeUTr8=#O1_uXUFPfE4
z-Cu#alAT>#CV*5<fKwYqUxi`y8fabmU(aa|Q7cj!0DZ=-aMqfKoSf+EPH5V3%JLQo
z%_jSaL3VnbUvG%pJsusCn2+QIB|0FeFr1Go`+i&JLgm*+U=js+LO??UtM%ofJxG6c
ziGhcQ$Mt?Eo{WHi&-EeU@e?k$#=&4#!b<b)_+GkKndaJTLfl~zvl&UL>RNz5oGXq7
ztIZ}+=<T=picI@8k6Us*sAn`lRZ709<!yu8tz{DX6=Ad4+^z5*EBp}gE$j@y#e*m=
zCV^AlkkVrr;Z9Sezy9ezIG3Bm?=5Cp>7ojKi;_4su@jp1$ymKZxqYXkthCSXn=-2_
z`H`=<xw)@*ldXW{1u>bhB0~@8@`p6&JzUopWMup@bweTegvl~&+N#zuXK3@bPX~B_
zf~J)tcCRnbu`ctb-CBgJE_)WPr;WgeiH>aFlGPX<$X;hirJv4bQ=kX2v-zyesJKvp
z)#Z|BSOD<>;Ptzf<>ceMnVw>@TxM%}2H8BAl8<zTu~;nrCfUtJ)pj2^Y*In9d3}y9
z3E`dosyhFx(+|jj#(7@vb2c>vN{h?vx&mNE0z3~3^9!ujxD9t6z_h-&y}Q30q6JzF
zt8#wy53V_XkUF#>(s@Qy8j*UAodCSO=N!|CoSd9U0#q$SV`KRMGxf&331+1e5!!$7
zmfyd#zl~pCUuPW-mDM9!KSdSM)qD`^$-lMCm?Svz0b3)X?ia=?x(}$$De2Bu_?cb|
zuyJ(SnZ!7Lt9RVaBQkXu6+6!x1a1wVPZL~(-<B;Hm~84%_nvqssH1~dYq1muq^@{3
zvW$Q_bOK~1y}*d65kRG-MR}Lh0$+xa?;;=Ar4KND$y3jc)~~u2??QBqj3_z>G^ibp
z+3nC@>)RS>Yik>H8Q&Z-FRDC%&v^l|Rfbxy4KQOfY&h|D^HH;<>c1r{*eKEKjV^pm
zj|Y5~ihA{{(E9+Y<2*n=fPDDcVRrHH@sTo(sLpaF54JQF81%*WBb!3%RomzRx7(x-
z--JMssSpkWMk6tr=SQlILN~f3!O)+d8mpV$J7fS%a{QN;z}|R8&|+ySo*7JhtRO}3
zEZt8}+ZA)V6|z66otwn<qKbRK15lyX_fUY{)Orz}-a-c!f{Ncfga2Vrc(~#!E&Fx!
zi(SfE{=Eke9v<)gu>l-XVIi_^?jd~}1#PQ-Uxb+Ut~0RXDI$F%{_k-}ZR8tHDTOUA
zQT7^5zqNgS7(eIlBO_DEuB%^SM|+QRWA;yCV(r6d=ApXQhYu<P-${>!<jc5dtk%5T
z@1^I49{~DG7>tHBD4X6(4u{jS7n3q7D*dV>&Qn4#{Fx}WB0*>EuW8p{0e}^r0_2DI
z00&{pxbd9PZhY&zlCSMD6}Z=EyCYV)&@Oew{c9C1Ps$@rMI}S6Sg8~#Dlm5>%w#H$
z!g6S)&V9AkES_N(pkxe&fbo3~la*|RLk>LRv0@}zm=AC`lTOUy)#COnC~u$6yEqqX
zMEwllZ{rrYZkO$T#)n$2G?_eSXTw3mVL_9T>?RP{>L`tIUez!uJ7fzT+0$S26T*oL
zwnSY`N%KH|9faM?k6f6q?njj7%ycf7!L0rqa3%<-$f#|Pvy+pHI=?mun+)kndERZf
zm1-*~p-3iPCd9Flu!V^L%nS-GMq@a?XYZ04e0oUT;ecKs&WP`O9>oz|MQ2H%+5yB9
z-XFoJzD;3zIid|+-=yr0$-_?coYfwCfW7|@77I^@K&CR=YLIY80E|6<i`=pmpU8i{
z0rFrxx+x-=&x5pG)S?Vid=-Br#aZ!)|A6(lapotnIPnB{d@7e)T-*Jw`T*futGWtO
z$n58<bZHU6<DK6Hj5vUNMF%ihdRH&$_JHhJDOV)BZs&^Hs?z3Bd3)wrTXHr)HgXb-
zNNRk!O|GD#LgawWen~<;h7K#;q4&1664e)u`|gMHmDY{xIbhKztH-#78-XF$JihCT
zf|&X^-HHC`!YSkDhno<z?|lZk-O<wA2J}qt?Gm{?nh28C=~az82qKiVTof-?e`UdD
z??HOHCZtm-g_rl}Qai&G8T%Z`$;lneC~G6`A=MVz&bmeXpeQ2mO5?wdOGpqoYrSm)
zB2y0757j_#gCRf|{R@c2L-|i5w~9y?LNv|kg#w5T^19c(eg!<I40mKm$o81%3ysdF
z8`(2&u>aXj|Bf7aTS?zUBF;P^h^$tph1gXW+^nnjck!q+B_-#>{bmbezm$`fT@K(u
zqD7J;BsIKVMR!(N&8auE+a1pB3XC+Kc?6wIO{VBXLb$>qXn^kbw8s+}jo3^KTN1C%
zyj}x;Gl)TJcSyH+Ui8EpTHHVYRn|OaGpfL~bw_AanjFBrXE<z}V+dh#xz;Fj>jeXt
zBT))@Mk-Hdz^|I@4#P1!?Hwbm^z{i}kYv_X1I0L~W0wx&V}Bpks<O64A{?El0YLjg
z-@IsBRi~5hg99}cgYHEikZaU{ILF4gA2o*3xjm9LH#ciq=sSEuKH$2`P{P7l73G={
zz++%gXzt!!AOdVTx=K{07v}}%5eT@r<>f+u`d_ZMu<g1`C~K8E1k}`$#T-tjDF||#
zfY!zwC)0(|AP@s0OG~No6a8E4`FG&@uP-yw5Wn{YV>rLf={wEWe0`+tDODGMK#$W8
zePl9`S~+!2SzNPbWwtj{pswcdP(xu}_If3vCi1!PX`vt6Aer`MeZ66Ey(aTex_Dn{
zFoaS#oG<|RF(4EQ14^r`I|*EmX8MTLPrD<@BZJovUmVTnjQoFfC=c2R;eJTF()M6Z
zmR1VqVnGum1_&G~7SkxF^W96C7psL)3emWD(H?D7KD9ENAmojGl*aU5Y~67CCeGA>
z9f=(p`|x<@EPj7DidH_BsiyKnZ-gx@<Y5tz1gM++wDa2t%g{nu8<S*Xv)c+FNEX}x
zswKco4hM5_3Lrj1vlI0n>NVaEQUFxLbRStpOGzx>v0M>0orJnTG{2Y}$f9hoVpuD>
znyz;=ojK|ztAzc;6HnVb+zQp}%N9RVtJfjn;29!9<Dk&)<|~YuI)D)1;o;??8`%0<
zz~&K^MSMesJA6Nc3(Bps87V8H7N)hLG&DAv7_@lD0E(nLrNn^iC36V^203&~3+2)P
zq<-}(8D}M_{rYE2*JkTXjr3B5q*enzKR<<{$ZAYLSRow8wSW7fb85<$`@wiuF#a-B
zu;C|~kv78C@0j=(viPr`)_Oobt~58K#|68P>3X>_CJ5r}$m02rfyNtnKg9SA#UJsm
zKktA<G<?Z1yZ<d~w9$7H{VyeEJYtbtyoncqsT|FK6P^HK9WhfXdz=*3ia;35BCKNr
zAAauR<;GC9ns<Aps=#=)g2P>f-QJ+@)eU=&Ki3uu4Na8}-$`~rv&>alSs9bp3n#PL
z%`m2zEA*#N(?%nc5D@-`26Z0?2PsJXjK_a9*`ckzIa;bOXM2!2nk|hDr`IB7q%Z55
zO)07_BhVQ5D%#L>)qGe~9OHY2-y9zq5rI;+i;C#>{Qb}5K!rr-$=y&^M^rR;rx#Tm
z(5PbG07tdCqY>Z8HHY;P`wtmq10R5ikd<VOV=cjK=yx6xH<(*Q?KZqvNN9~gcS>-T
zOcBC)n>P;O9fh4jld_&K`CB;)a7}RiWbQhjuozo`Y3@OrKJ0qR4O~wkAgWBXpb0q#
z#c>$`mh#sD(a;d>v*>&U9eX!~bQOgj7-&%j(*hWWwFk_tf~%yWu65y2I-t(g3djOZ
z0}a*cOcj9+0#xn*INY)zvN-C;Xr(d@lUWpqKQ_P`6dDBF)4k;wn?~H~<7Y28x(I!%
zPt*S)RsR($#=E-EE~o5*KD&dACDcmNTF`t6vB-G@K|x7>yD8(?mLLafftW@rWOCBV
zpJZZUL;}e5nheJDA)SHi_lEsuObksvZK+(%lf-o0iB;ZzeL164Yxitr3cs{n&<BHt
z1~SkbmVO0V?|3a&(aUw2R%N@<ePEI|f@Jsr$n`3XK8d4XV2HtSTJr$QDuVm*m{D9(
z<_}+e6Zf5-Gp6=djw?eb9OIx`Y#+Ap%^zG#|Ci!qLEryk?=6Gs3b$-gAP_9LySoK<
z3GVI=2_D?tg9dkZcXziykl?PteIsF`cja{7dZ%yS*WKsmt9n&bLBRs{UhDhjH|LmR
zjseYhsk``@bV}FjlR199RK$B-xQO?^x2nEtu%H9z{D;&Y7kk8Ski};$wrde6$Ttp?
zoJ%tcT7OE)%4pe@Fd6gG1i&P_<@3%>{=Gjcp*x=!!)gJql1%giu?}gbF$aD3ZlEGY
ztOcr5K!<P5Iq+hJRPn3J1k-1r#sGZSnrxO7cjzc{058dM0hz4ybQ#7J6D8y`EAi$D
zyd|LI$pN~wf)aIe#c~!WbEPamau>hMAN~ttBmi;=U6|@+!+on<Z4~b>{BR-&$(fXl
zUlJ)Oxx!vpN?Z6aVCetfKUR4Fn6>Wc1V}ZsmtWby-y|%xEV)eu&YzAc=%;u~0R=<u
zC^7!qgmEV&8foy!c$Tn#4wwCA6`>E(J)z^0!JZW`+dWHtAC5*rxdV-edb`-;iwV%+
zoqScQrE__mB{N{{2@T+De$@89dRZ9&m<Y}Nf$=2ZMP^!k(vaNfvA5kXHr}7OjnsEq
zOY&)NG*)Y1qznV_7-I>+p#PBdw?5h?51gM@w_a^3PuROeiysJ97ZnYX0GibU)6+_o
zpKDc~!GBvK|HY#QepE*K7i#K3kEwo$_ga79Xy>T#K%d{>4yf_G;*=Hk3jobcD_f}u
zaf0p(w_7&GHdvH1e}p3LC!yg~@7u7&r>05)Vs1zhQY0lbxzD9;R><jjtw7fUElgLr
z+Mu(=diEfl`#F;fsT7#*QI(aYe*toHt~DcTs!`v=NwWK@{*jBH!9hXcf~@mqbM^uC
z5P-)0W^;QM5cTEmB&U&8&9K;F1om7vSN^va!1-7EWwxFC&|&Vi*2_F4A+R=@sso83
z!<O(@&<aJk*Wb}%@ok{<4k#Qf`2ux|E|%h7r!;i2h9%nnHiid80JsM=wxZI0X>Lj3
z#DVgm9*IdS`uGE32L<H`{eGQWKZcE8Vb<LBVnwC;lu`lUSIi`9R6ngq0JuI0df#gk
zO=w%J;~KR)C11%qrnaDA5E9A*r0_uCV7GVu`TFuS_YP&fcA>HI`UG3?YB+{ikUl~H
zQ0TJe)`tya`Q`2U05}%Yv9hXUKJ6=(U95N#KmV?)o*`gN0NiAwIL!3Ui@zb8|2@VZ
z9szgQB26M394Wx4{1<2>1m7^EJGboM^i=O~nE6B(=(hpS-vTu}B7*Ey-^?EU>vN9h
zVYd5hfkc!viD9G!hF3mC>;5Igzh(aa)ndVbJnhUb;gU9hg1jfJx7dWmTzR8Lu-;fX
zkcLSwPinG-DJEL6Z8XrJUl|kwlC`E9!1yp<r%|XFIOHwO9*1mOH%g`xSUF(5oup-D
z3xIOg`W%Q#5@E;^QE|ji&1{@ImzPQam?Qy6u>!GQ2G~}NIt}8h9J{<q*?h^H-j{+=
zsb7B;gznmku_#`FKn=_HPFUDjSc#>jVNRYohd?IBWEWDuZ8j49mcZK5%^8cKqN2j#
z3HpM7Xd?<hY#3y02Qx85{6ABEY?5jF<i`vWlL504KXCCw`JMOyF<4K~=|^(%AfcCA
z_D09{fXi4zj{cX^jxf|HL<zFLFoQmMAP{6{k+|3MzN6#fN&})q!uyAZ42E8Sap&V^
zCD$%0$&VjDtg$Wrn|%iX`4?}6HF__hbL`@CSF3t@1LLW>sY}grM@jVf!T>^wB7MU?
zADa_S6M(``jIyDiAOE2qvz{bAF5oy;atL9w$FDl21a1t2?LLIVW&`rINC1SXYX4&%
zI0zK8vVz`*R7jnkjqQEAK=o4uKoiny0*A;fT_3*#XoAw;wEgzh#Z(DW?Ar%wY||rd
zdyhTe{ve|w8+EM%AovV1Pp-Av*BS&ZaXTM`MUH(2d}7DH2`{0L2u1(Ja;qbj9Dk3Y
zRomN2*I820k2mGesZpx|g~3s2t{*vebKOIpQm)OAmt?rNF=*Y`{z6IMnuim>3amy5
z92g7g0MEboK151NO15LIn;DA2fL0(Nf5zZSqm(m$vb(oe4xq2PIR@jMZEdpvx|r<U
zw+rWI8-vF#*`;Z>u<BUA<@p##{q5hBD9oYY;o+NHj#cq_or=(*qDlvYxVj(Yg(a{*
z0pi7~Mj;&kEk*>y!H{5<;Dl#FzV6FeeZ9jHN;HzxiG!(^9AeMkCg&i=FKyt1%;ezE
z4`00;gID8n@89-uoZ|-pGvs5yk+=vRgSt#187cF$hCtM3xnVd8he2s@)q3w|hx?Xq
zEO0EV$?%|KV^a$-gvcnJ;@9c`DE;4Ky#Ar#u=nYL|MAj)YZjWgOT}#vX^8<g3RPVR
z^+X&I5s@lBShq&FaS2X?BR{243lZBy8=a*Nx767p5eExf1t>FKthF+D924APEhaN0
zNPH=yzAm4_lL#33z33qP>3?2fNBHm$D87#k@}9WgbeO=t>sN(w(3S-+^b&y0F`@*i
z{x{3D><}7%5ui_2?$_!xeiH(JNoh&1HWEOj1~fL7*ZMG&p64oPq5;5nR?EoOtl7{X
zN%7_YDa^8r&K~3BZp9X?rX&cstLs?DZ?JnG0ac-vb+MeY-}u8McPR!UVzfD?LY+l8
z9{XlW#<lOqRq)Lr9bn@}e{j9h8A_E2;HeT<#^o^+JOa_yKn^A0kz|DpzVTs-pa$x0
zfS{9`2Vm}%ga3}H8V8C<O1=lA`(w?ga})rkctJM5J3XxToyiVGsu+g}Bw^(LQ`Y_G
zLhm0(E9Bf1b=*866kt(ZOs7U%n3nb#8wT@3VD77u(zG%(au=_iRiXik&H1Y9?emS=
z-%f(&S_51l_qOMa&&|Q)<Av(#W^>U9HXGoGhb_wxxh%mOC4$ZToDBk1h3V|HzXAp5
zZQnbT1flhig+K|IKlNrUH5Qe*x)$ZaVJMyeB%Az^qGA-aSui)9sxe2vGjj6o<jLpl
z1!Yy&L;k?{Jf{wKf5jrV7=uP}8B@7z??&y{^XlG`oQX;Nup?NPmzTH6bQr<wAl)Ll
zX_e&P<Ix)Q_{0PqC#S|Wb3ZXPaP-KYagMJ(wVnS`M*MHkox3oRV7K$tOkpoW|3#xq
zt??Z^KGzdzVE##itMSkIn#C`MfWo|G8<;RR%M~`!5MMYnGGg?Qyj{}zrQlU_!W440
z1}aYb%`A^bIv|BJ{T#bA-p)5r0~ndl1HRNw&d$Z3M@^IOt~x4A1r`DP0h2lA9t8nG
zbs+G{CLq_(+$5Cgvl0fNkW&H#I@(Eq5@l2Dj-qEHLIgLj1vNa}d@0!7vx!*Mc>otp
z#IM<|{pk}VlTlCC0dq9Nf8Fj-M})lV7ZVcWQDF*arTzC%q2CVh4%(b9nKaF_fs|lz
zCGY(|Hqrle!2pRSIb^p3R6gIyF453G(zE}U>;Ch~%Mt}nf>Pt5zjUhq`G;#f@S<F=
zYfPs8=f4A7sR$50hTa<8iMBN`4Q`>xzH<O30}%Ot42#^A>t>1&A|Hck-O%bG$?3xj
z3YPh4fs`JKo_rQizGVtc5ET{WLw!E{y6nsUbe~Ll2?_81Fre5zH+3<!w&8tXnA$h?
z{UcN~1Vta*zw}AOQ9K|5WB9u2It>p}G62mO8uwrM)JFyP(Q$z4qZ7ry{;we@lnK#{
zcf}nAYy`~z^?x0J<^T^RpXC4_y$<)UzU#lY2~!F>jYoxW8b3DuUwzkqZ<Bry1O|;h
z6b1Ldzjnj_?FkK|K~gJXjy8^bHviXd_`f}&RMNg7`2YWr|Euf$|J#pzdnZA&4ekH7
zQ36kqA%&Ivt+6~4Cmqj~R^=knBe*8o|Igh_%MAD64OW|g^SftaK8zau0oR5fNDa*8
zW|ij7p7jiMy9jYlE*R*~-H)d*%T?1iYmUS@(}lTZt@tU74ra4MQT<)DNkfg}&Zhr)
z)ryd!?vQ+nZS@_e#=f-oOMT_NZk=>u{yzgsBq9{n%bD=g)TTfbx>6M_^W2Uj8&tFi
zP!Fs0P%9kYS7`2)3zIN74n?4DA>7J`9X9bQ>R$_(utUQF@7;mu@17@0Sx5gL?|Bh;
z(L9&q+28vbDGiOzax+!3i|WKyFKt};{-IRg(&jChY#C;23^}b08yhrzZspNm?k>rg
zzDqwnE|lpYMg5GQlWFn^V=S!wSSO~2fC5@-(7Y6seKOr`<{%FakxzSvS3Zy|?lXd?
zOVSy`C+@25L~M1#BiQl#)1%V!-rsm!^9hKtHU05=CjWHXwkt?cv9Tqq^$s)l8RWy-
z+uMQh3($c2J|7TDm7!3VeViyHN^@q+ojCTxv3q|}+&v0Q`t4{?;oh@kN$AMX6btwk
zNXDXJ>Q}Z4MeTAuOTv3EN_%Ftv7%lfz~!fW-po@iHn=ILaywVTY<0Z;4oN)SpiPE~
zsvMK!Z3pe?k@RciCHKMb4K!h-qNy2^Vu5|UP{|31bE-1vcDPVf8+NP78C}K$O7yCu
zG2e?#n2mZA1dQyHLAMbxM48H4Jw&%UE)NcbzOP_(x>yWuWGEDYnK0evio*o>!~K1L
zKG1uf&>|~JQD4r=VgHBww+f%XF9L{JsoQ!(7rkV}xosTo;pu61P6?&Z>#l&7b}Uvv
zaDtxVLFswhpv@s(RgK+pBIO+*HpR#1_k62COyq7Mo@bDZtlsT|#N<6S#nRN)Eq%(T
zGOrm&Gq21`ITOj_sAj7}&BoKm?6{k9;7ZrGq-UFuFw0gIj=@dv1zl~f`b*RM5ApWy
zzSU?n<RQt~7o1+Rk$cbC(?BrC3lyc;&S(XTx=&;M$FmS2NCXfJFIO#=g()ZhVc6rN
zBkLRloB;^m0*ov%InUpkG>^Bpj8s4oyM<ReMBR~G*+7w+OMwk-y~URy(B;d7NAAXY
zDscX2UIDmb$tD+!3>p>95`#%p7M`=_DXA69jMt5&w&J7_?AKS!8mD-iyOuF%py(G$
zG*P;XO&b0@EzvoW)PBMzUE)!#HPp!9I5xD!1W?;dHOg;eV+ivtwqn&e_?{0tkQ~kj
z?$)!nJYS^UD+~oi8RX>UT`QET2RLKa{k-`r4AvS>F$c>H1!tKZO@F2dskb|&ae(MG
z2GV%Q$ecb?@wwYkZywXHYbUyWTuU|V$UT`aFOa69&M7R-$vDsZ=ILl>$o$gfAE>F#
zn}>iw!@<F``vIz0E|okk^F7juq}g~<ONFXz*E@hfqUz!C@$Pu;6PVwbIvwbnTu&KW
zLiPr~Jnriuiu@8onFPvU#^Cv8C7=m|sNV9m=h0zrr2F>u39<Gi?`w3POZhBE$-Z{A
z%W3%}W-4}Rv79a?8GGR3P*uT{Mkl=*!Gh_B>KH?rRAwW3E46*_N2n!e$kXJvj1R&5
zX8*L)0?^v<;q==acC1|neLq4`VM8iyK_I}@=D&d7ho&yKgNDNCThBjZe2bjy(21x1
zir@@M;Sfx|eQcBiRd{0K-;)oPttY^YIkj6QBZI_5Lo0aEs3FuXV%>C_P{>FqmPW#A
z9PeZ0;23k6-ya9V!Fc|1;IvI+#|uRNCgN*?U}O+`viP0eq;c;UlLop(9!!Env^to?
zVPZoZ7`XoxOJ_gWr_}J2$IHtw*E{pmmD(tL!Tuegu9mf2;AY?|Dh~03OjPRp*uYB)
zua~!nT4{xW?1{RkVRWB{)b^u(axLG7b+UgBhr{mz0hv62K-Dl8jD&!I&hm`SJ|2cb
z;?}{82*g?l3Wq|9?PDBq$mG*maN?rS*PW8!cNBS2+oI<9#luAN7BY_0PJzEMzOGp1
zx|3zHp_@|T`I0kDJ$B5cI%lD^ZK4L8#;6ot<N?seofkpI+9<ov!{qHnr?BoFyQQ+$
zz{MBj=m6rtVA#)R^k##D6LL$FD~(nFNRZP5&t%77gt7fMW#jqYSKZozb&-}K4Qg-4
z3DL;6bvaUIEG{;qPf;-@f?*ce?uZ<0mdZ2ghFm3`b(%ez(OH|`%P?k*9V!`~S*fC|
z*v?d%I@4<vt`?{-NSlrfn}*XT0W#9vM;;UbgnvFNvqVYx_%f~zzqTFbcmsSSQ!hWD
z{+`k_<Nf!m0!1b>FY}3v6q4#_so<<kkj(t=5+G>oq@md`J|E{sv{WaFHyz2?<~~Rd
zQiHGDbl(nMbTcTTMPx+s{NG}3k4vMDK>Kg911?!PVuw=-3K1CHUd?VDNZ4JDs2=Cd
z?QS$r6D)Jm!1|A%*`#WN+WvboTu1=Jcdx3jZ?E2I)bbC?j|xE5+e$sx?Jc)sT}a~T
zQD@?glvGIw&w``q$}m6Y_44$<#$-54F%k3ni6SFfy+ntz41b4(nzN%wDf4g?u8j!N
z@Ye=1tNTCK0e#J%NEsRB$rXx<ij*}M?+*EIR`UkC|FIN|2?FJK({)XXxmv9pInh@@
z*z_8FTN%^CXD*zXvH!^G*RS9_yi$sH2JPF)93BAX1_uMg{=^dl_2eA}3IeDw5-T{F
zacnpC-M_8DzPkvBDyauB*fN;kUuZ6pBOl8!0+_ya!)N=#w&A*@{u!;b79FbFW{dgm
z_D_9pk&BGt^XIycj+Ky62?Fjp1Qgqf(963a{J-{F{y7e}eS-te0?`xSKXwySaOD9Q
z+#jI)uqu?5_q{MNb;6+N7fGj`J|$)5h^Et((t(E*`MTYkAIkh!=melBtW_M;DT=$D
z$dZ%z4goK&_C#0-y-wQGb-b{1Xf0d$o_z*-r*sRY$PU;f508x&^<qyJ5IjQZtl7Bg
z$ci=}j(dP<D^s!DKvQ=kWaN1nb~jy}szEV{eJ^T9mV3MtyDF{J&!@Bcb4-6@!F_`c
z<JF?nKANU`1=Vz;vNLDiB3+EkwBn(Q;wsEh9%&+dsR)F-Rps`pXK+cbkR+YdtA-@b
zuU+$sO;<RuW|@5PgqO-=IYpAs7k(lm*4W#ScNQh++QrQIx!byvbamG6(AU~&In7C^
zNH!(mJC~F-K~|OK+d>ot`;)qUvzvD%P8k8;rQ?oR>U715Ik-7x62^s6MUF-%gww_!
zAJo7n-;dWL1T&&H6-JMl{8bm2gPYkb$ccsgFzFA7R7<gvYgdwd#K`H`>0(r4F7keh
znO=A=CA8ILS;;0wSZ)T>bDhfW4^+^f!<)nI=LpNCO|<WI(z?CWCS|&5Cc0Daj&pTG
zF(@ay`NFq7X_kp^?!Jz^co?>|@VNV+6cet=91d;mcganCP>BE0`ur<?fWRGnNyTR0
zOTgQKefUyWLgtA}c{7x7f87%%gcj6?yVOv)9dol+Ha(E^1g%vx^Jq)g=7wmNW9Iwr
z__=&={3RS*DtXzsQsu5p8_IoNk!+DGC=pQ*QyAc^y*ej{*6DK%HEgS0q|wh?vs{&#
zB1uWwkdidwVf!+bCD<0qcHYJuk5B(TVzYZq`RV?9$gV(0Q1A;@<J0l6PEtaGVi?Nk
z>_DguE$g*@p!sZ>3R1^$iPwBy;If8xb3wy9E-tPdw@V>KU>-Uzkp{!I1qWL*$LrRT
zE?KM6+>t0a$b8aTuG9K%Ad~yDbZ@kJ>C0GI2*d)_Fknb}v}SM6x`#2&XuQ&7#S~=!
z5Em!H=gp;&rVvYU_TI4h#AwcOP(gB~0h}v@LK0JWzJ_@5`hF<PZUdBCeggtg{((<>
z+U%x*wgWGL!_iu2ex`4c>A{PIxoH);><-~YMk3&JCNMGIHi;6TjkQ?K1?V=FiMgIi
z(hWub{7J~?c9z6*D0O_<+lo<B9uyK62Z7Jqz^ze^u9%<y>G$QO*vd+KB-m3wmO<+x
zZ=upXZP%)jL_Zb~&MN^@kMZ_v5c;$o-b%sbhsY?oJYbkx2^M+TO|Hm(X>>HouCtnm
z)80@Ij|7em$PG#!9x(a5Zj1V!cx+dkMDS{Ratb{rQe4Z`N~uG<;cQ2Sh5&=JCwN(<
zw*I~s=(#62<&<47cWTW29G4Pbtuf5|SCyxp)0!OXBxe0KapAWvS-G{yJ}9|j*?isW
zTz|U~=R-zuwJHhi#M@7`btBESms%`gHa6G0fTVCtCuHDa^(n(2j*O8<pqHSM*{xnf
zC|Rw$urRJw^Srbp80j3%iE#?6KL-u{plY~jR!m%jwH_>&YNx(PQ*8npUr>`S=ry*b
z<aWlhd#elQPHdj<xQ9R9QOHthXz+SI{20-^!N{oFr1;g3l_j{Va`9)rn78urY=a)%
z9XHX7dKv1Mo1CG$daJ~93&nXU+7s{(`{Bno&3JCBbR8UaIx_Z8a;djt?Pr*>Q+#q{
zJy=QQEzy=5MRe|$n+EGqkg5bSGBQnmg0=1FfTH>}-0xn&qz5Yy^nVDG^{7`@SEwWw
zObDA3qIjM_U!DLFI;Z+uK$sS<wa}GLg>qqgN~xp|)F38EteASEe8)Cc`8H+i=xV&(
zx_+U)DU7BW_f{ZuvB8h-4@#wEa>lLl3E|ci2GOHMjE1kTWOvRR1?orCyls6UXIxiY
z!Kj%Sp#Xg}%}&mRvyb6ieu9B)38r_$CD+!rk1E+Uf0Xg^m$~03AEB+3A#xsb$C$P-
z=f6w{u}0E`M2)x$*d^Cahg&YEUs+%yS3hLL*gvmSm1+Ox>^bE{s92Q7J1x#))CD;p
zp1gv{5m3Lt`qJWPhSGCgD!M)jh}#(A(POs8EM+wGyw2OLTVSf{Y3}A5yva6~$v*i-
zI=N1FEgda8fxQ?{2}GD)xfKWoewi7~<$!AeFq>lXBD*3EoAhmKU%(ORKvqM^PG6qW
zzFq4_CE2>`*Eg3Sbe40K6wwo1p_$>Tmv)h%h;iG?JWZ6Tc}C5$>>zoFVm5ds6g&&X
znbjpJ<(R;k{PB}m6Qnh@s9&{-N_Ed@*lax9aLINj3g5p8$yo&z8BZsNkTbqIn`M$F
z&y!q1gOgCSGE-w-(KyRgPkkzhaoAL?&YN}=4a9Qxp~_E_jGA~Wz87?#Y+R5x-7T>T
zhWr$54p+1VXSeuVg`{vrwLLzk-KqTUQY|j~afQ=-s<uTu#S6y*2N0EuZF2<_-r&t@
zSw((reEmHUa;k%5Q@W)<nzM|6^!|Hchwq5>@JbLacI!3w_um-$h2<{x)<GR`SHrnF
z%bnXud<{S+uD~>TsaTHP>!h5l#BVyk4$x1CyeAXuU>M)t88mX^5l%bH<vewiXt%*c
zMnptMsPuAqdug5R^7Q|eYV>M{sWPkFBYYL0ZF~kzn|f`54fXEj2+;E3WKaby)@&#!
zr;tB9dcjM0(LC<se1c*y72%H+;+u)AgOImgtfEXhv$Z-~_PbsF+=wY~xA7fsPK$z`
zlDcHJ&II5uWJijn&(|7BDcsMOQ!>Sj4TM&5?urAYD%GxdEOClOaj_hCxFd4h$*P=4
z`ojppXPA`D1l*eZ@nkXhr4=!hyV6v{$62~iEXF{2z-NbS^C;QGk}&cP@O2I4nW_Jb
z0W@}s+BW@M%Cg?CZ11POmFmyUl1e}wmZ}ybM5;Dv)pCjM_^Id@&e?WkLRcNPA4+P|
z%`LdGUOwJcs^$t2VHQkvUcOSo0UGC~nNqY+7E?arWH85}GsKTRSN%N&Td~76Ahe*{
z_*%xG1W*ir&O(&luz{nJF6YU&=z?|O6Nihg#zxU_l{rou$w(XLo{T2G7MrDTpn}Lv
ziQUS)JN+X)1iwDlH=`L4w6N&q3gp*=HglStS(gG(KsQ&qJxt}@AN$MAJzLG5{S-}?
zKO5amPN>;ubhD0juqYQL)zi8XXppSPki8Np!U7_w?QW5-2MkoxoBlQ0?4OWlVB=gO
z@xLLR%ABuqHm&`<+TmVf-0HXsApM@*K<|E+5z#zj*w^^2+8ez{*87m)ykqw{?fdlF
zU?x3``eGz<j$qlaebQKeBW#(NI*nNesq$a=$*U%`OcRxGB(}9@Ix#UZoks-~Ri{Oq
zRJlX^XAn*Qe?U`7$&`Eje2?EbySOwhGdb!c><oPmgs9@a^{}p?vl<A8kbb|QyY_0S
z%FL6{A^2Jhd~aFv`+acP;JZszJSA{&uZm)>o!~AO!)!<oA#@ya;TBe;kdkkUMwet~
zp!(YZp#KZcU=ojpYPi9edGi6zCF|oTkg(zentiiV!{HqgtWuHcxZAh`F7x#+4jB%i
zc2_Dup7yDpF8Mj6J>F?a#@jb5Vj?P%%%|IYtG3vA6!Z2{tx3Ex3u0|^>J&2do%Bx@
zB5@CA{!(J?bWh&ayDD^zw!v{v1iYg993yeple<N01lyS@ZOUSk>Vg+`qx1x7%6<m;
z-pH6*SFKhZnKsUPiHwgiXqrMDy)7XHd>dAb3A27X3r8ufn!54Sx1zFowQ$8fiTy-}
zqd#g8Dc=W8GTB#sq*A~os8~O6J9)XsH`y3$IMqrHyo;Z_6s)37{`^!bOc9syQ`BM7
z9Nh})OCe{_Z*q<_^Ih(*#Bd)HX|^n6Gd{j677g`*iPuTbfVF`IIO>sfR-(!MXyXpF
zHGsr8p6|Uz6wo`3&De)`@w)78#V)sJVNn9UqJbtejk}e%S)|3Z-ST0V(Z(F3u`6Tq
zN)WRw`&_l)_4v6^GQ|}G!C2d32KJ#Nj2s6N8afUh)p+ugU~gHg$Mt)vt@Jmb@vE32
z_$2f9HZfOO$!BtXBfX^cdD!6@Kz5?A8mJ=vQURD(G0cMUZeNcIOBG}=GUAw_b|u@L
zggOX$SBqp6GK=7K*xq#gK|lI$PbyKg&*K&+Oli1k5NUC3VSc)<Ho*?J-!xO1CL0l6
z$Y=rEZRnG15ETSxUxwmZ%R!{^`a89f_1Z}KQGmf5YWf+YNI(&j1v*QIJ1ZLv&Zv$W
z$|;&1@{5>MzlM#ue%9A!_>jR<&bH5!E=&3bu6{p9v}#3t>Aa104e5L-DDP>`6H8Wj
z<o&P{5P1JCaz(N}Y?`c~h|quTx6m5G{pIxIUjc)O#T+ztAE38S3cz_dRYD1+*}Src
z!$z9cP+-I*jMpF@<0g>tH)VE{<^i>|pe5M0B@w+{cCJu$dszqAf^Pv=`0BNzFHM)R
zvGa_XQmBmE9q-7v_XvxJ&him;tki`n@=3YoXHJrt_wwWTjeiX=dU$|UH;DhpNbn9A
z^p^`V(CPhbmDjOnU8)$*(y+lvsAG0ywiC`??G~kNXR1~3%hxEn&QjuGW;7l;w$>>q
zFGbct9~L;+Ij?M+@8fWqO*lFWoQ%v&MHm2y8Yk@sW4YB1$`0-n=VnadBCOx<^`b5n
zg$|;?d>yD+aAEdB2_(cIUq|k{3&0=1cg<UE{a!-R>tAF33%neh(G2%CmZ96zh}MQl
zyJw}cO-ZyYt})!c5EdO`X>v`bLYqAZcN6CNp^dV9(>0A6yZb<j>4Fxj5*3ZfOV;%0
z9Wz!#NM=X?{ar|Lz(qmrGf`R}x_DG^?7Da=i$T&!c?4IiFR2Oq1St*o3pJx0A-d*!
zX82R0W;&7QKz*ns&M9d3rt<qJ=WJ~60Jh!2<L4iPK{M_VB0**IkD9|&2)`X{n+OHP
z+P<xj{Z=f~D5h|LRFOh*c!~4TPSeAwAqGmRkk0Un$V#lZ4_QbTJi=4=2B_`KiP*GD
zMLo#+Ym|sue33TjCREg2I$Gx)eRtk-gO~Iv0=KTHVR9I#A=bBDdUOMVzf7LBnygPq
zWiXfg!{CkNJnQ-rl3i5C2YF1Fn2J;fh7<6iLSXP-@B?rBH$%#x!Ol`qZ;j(cGJg=x
z<jUtt0j3h&!AL9-e>E+!Ne%%5aJVi`SYdsL4-ZE*`_pTPE$h)H$m8^z($m|UzVqrX
zlB%u2<0#*6fG=eDJ3>b2$_<m=Jz^_tN;5<a)=U`wRF+K1T<N62<1+hP%;U#u<W{_j
zVFX%blNkTu$aCu(7`~pz6HA7hgC9Q*t+skFBBL;j;W3Vs$0+);2cuXv#eAPGwA`d9
z><_03@#7(J2R4TD#p-FD`1(46@n?GRwBVM@Zit1tXcTf^tG~<=c7|#=g|4Ple|~$-
zw%qPxR%Mm%8>E7(DI6O^4U}_5Kxn86j0>}Ret9Y^_OjlM;a^qzjvo)`=?_#R>Kjs0
z6~hmR#svZ2LsRWkg%R5g#gU|6%FXzGihgK5O?<6S>1OqgTR*jpc)_`7oX<JrDf;2z
zOTL3r(fquNW42}<wSu)}=dWMy*INO5U0C1y71KFt6R?E8uNW;EnM6OjW1AmjJIoUD
zYZiP>7ftqYZ5>-poBw=|i68_vb&kK#TPqZ}j)TqP>dSC-1bx^Z|D`}l`{*Zp8>p%V
z+`&IvwQ>6Vd4#gouGNEgAsyyqoScJ<PaV_21e3r7)Gw+%LawiA55BDaTrM)OcGl3n
zh+^Md5_Q9D2mwhKdz3Ln?X|)Jdh11IN|VG8hNYj`{ISx4+kXCkO`h+T4zav2##wr+
z&}{Pd4bX`=zG@rj3jaCdEotkI=j%<F>1<<V(7K82FlW|lk)U`gx2@>4k+v|~kF<!j
zY?kI*^%ip22gmbuCzR>s=Op=#!C=#Xe)=618-_IhoPeP~=5LIktBoVbHg*&x3Hb4?
z%@ruP*#9<m(Bibtp)}1M{~3<M4Ln5&+}<|csa*!Ka`N-*`Cuw^yuKf&aN>uWyv)k;
z4G_0Tbz--gXvKgZg8vNRSg;=_1AX(yoUBaMAmU>HN(R4Qh9rC#m&|T6KT4@?_T?<7
zg5#1(A8;gpTx2^J7g1k+S?d%X0I?RBhxMzMu1QyG-f_MBz;+aM#VSA;CDB&m_wzGQ
zkd?B3LuFmu2`Y;x->-~_S~)glY@9E0`cShPzPiqCFcGzJ&p&*wT~aLP1ugsQJXe_J
zoUPV*RBYbiYHoGj=I%9DVOM;DbwDCCh6A#d_;jmnX`Bj1-@nQCSxjMN%i+o+(y%#z
z**sh8QD(VQkwURgHNak)(u^v1ab%koeX%Z>5(>s?VJf&-fD&lpl*DnNhB@(an)fcU
zfVN8p0R>i4_oEFAkzc(}ndL4%!vY+IFtjzF7$M1EASojy2XhKHwt5PFl%d5z-TGSO
z%H{22c+rnLYe)(PrKwjgz5HztWte%nNM+(QveW+YVIu<XIrH^A6a3H(=L-k$&Z10W
zFTDY{rTK%E*b4Ghv=o%>DG8)Lr@@~pNwhWaoZA^k_n_K@EM0Rqmr*e5X=#~fv)2Yq
zJT>$F7kX#dd?^wU$zy?ISP%$Bv%yiY|3$Wd^cZ)r#=cZldoKnd5XP*INA>WYbyjfw
z;5wE=6y=Meoo>Qq!8>?^wzzc3HDPbfR0<zc#977CL#8F(8t{>Zurxs3fuySM?KNBS
z^72Y?Kw=#p7lk}P+@C2^X;tg?(l}QnIk?b}Acw}ln1<&jZLD4=x;<IYZNtZ{`7r>^
zhneUFLy^QXE%+y5-Y5+D`*E_Cq>X3qTaQZHlXgupBEIL-If?ko58Y;1k~1yZU1&ID
zuTZ2MUVw6zc<>XfW<!A1Rv(~&kc<fd^U^pSgX;XK8?V=F9roM&-3=3*Ba|jqowE@V
z>HC1MrXPe~+f)fy)-g%@lE2|+InqJuob|mwmLL&vOXoO73=JuqCgHX#bD;TUI5E)7
z_9Yy~yIMqidsCET+sUjyDEX0*X|v0d$m|2@;WDB^rml1pkMQTw9ti+(O4khB{cu5?
zkT@ql5f8slH%3Lkb*7;|AfjWB{T}&@p7HC4nMi=4_eD0V&okHz&iCQG^=<&>2b6Eh
zZV&W@Ocv7LFm&FS=Ty_-fBOP7@RA+g$}T*N&!H(JR0<iVmkXt~@@cylytLo#ydP!+
zM&u9%a)kh<(*!~UtS5lUAE#Rg&Ew!awdLmKYCka*Z4}5$zjZ1nxz)IBd<yQ6HV9hh
zvRnU3r=$?j1R)1QM+csMweER6Issr5<Qlyfd(Y{d>JZLC>L%MYGTkQ2Y#!oylztOJ
z&<Gz(505Gtc11Fv^QT)C+j3YwejHn4$ZqkoPN1^<rAnJs&buZ&Mo4Yjdv@VaiYWC}
zdz0o(M{82<hoWYoA_-2_noK3MrvwtK%wn(b)L7Y_V^+HZ75F5F<bHJcG%C4G#oXu&
zj{(nuZOUw74~ffoSDt`z5XijPpr(FV?ek^*dk>rTJ>0fL1uzp6^kY2_H##M347jF7
z9HLX_)&!V*d!!t-M};0ZY0B>#<6Hg8618#2u+_bl!~vOqJ7lSQ_e#6keuY#WBQ$%}
z5_TuU*X2}$Wd#K#wfM7ih(eE3=gg^gZ9~*+20@;D#njzjNTpviBVf7yPIz{haN?q&
zp$C$>`KB?5+(yn!YRQkK_%0&r_RDIg3m1`&?MuEi%jmTav@zBvl}LQI9YRA8s{tm0
z8mGr&s#f7FYmp*@glDCB!Bj=+d+m5?W#ZmFl2vy94EhRGT6|=@+TuO;9|*b1Cdmb)
zkg{KVc^DWK(?a(cdKMZebZ_&@V%~A=!b)SNLeur7L;N9pgdh)z=LiIKA+9v}jYvaT
zNg<Jb4S+NLux~RKNlaU4;@HPX`Zlv0Yq`h&`DbLafO}K>-Jav^(`Q?(C^9b`2Hn!|
za2xBV(rHvi^D?q784FH&qMaTIlKY?D3gilTA6}}m*hDzIby%#~FJf*!1Eno?--*~D
z8Aj7;+S*BZFct%??m;pfV|rC60g{2G+oigJEDqMPn5O+gQ6OnGw8o@=SlO@7Aud}%
zd5!046WwJt$KPU2|8xlTK?VG(4%Ur%{<CEy9V<j%i)76k^D#7b<I#HTM?2}dk$fZY
z0topf06%j%EDcN|<tn3dh$t+tO4#MetrCU)EvcOgaT36?!CWFk#1rU-7u1DGyytW|
zUzMleH^yO1dbGCO)c2EAzOg0Br(Fc5hVG9NbqP}l02H#U=;hf5bKeOJdX>e0dAlAp
zS6DQJK9sl5hNMJ^Gcax+!WB^sTtMT5I0dNi6*9-#^#v03(5Z+m(imlcs-KD1RX;Zt
zBDN|;2XvCjBS5E$WSWJpczHb4#peZa4%0`};L#zZZ+7Qm+Y$F*rci&OiZcX;DMO31
z_DY)>jf_|(E5cLg0LAh9)GBER1_~=EP$G^0PSZd`+j`>Po$o;|<a(lou37its_&gI
zCTm>Zw%;eDwu@XJkYFiOb=lp6b_3eS1eo4ur}9boy+2=eho<3dva7daIB$}*4zyii
z$+7)VHa$L9k-nQkw>eVZk+dca)OW8As$7zH|2YU$o;*{aO^~<62+Rb3lFFjyV>IdE
z8K0vpaJMxRqx<pje6uM^6Pxa5?uQweyU%{;&$f%tPVh#S9*#RBvl;J}38ezLLI5W~
z?x-6HamIy&0gzhz0${$h7GPtrG``|dOKy8fLhw%>{sd=?MB`Bya!}7k<FVHq?tqqo
z5~?p0E{WMd_w2Tuxw*|E7A$2b6OKWJ9C%{;B<CCy`b|!h?v$32c*T@{m&Cli=8BcW
z{M1y9_X{!BZ+Kt0$_?GzCOqLT>zc`i#?jY>aS`O(nRcBS1aa|N(ocStlPQm;F*uNc
zFT&ksjcx-u&ANDuvSk<4P4Z~vYlmdM2`xSkMdf#p8b`~Zc672r(QF@v546JWKCMNV
zC^n=RWOWlSEi0Kxy?R>)EbC4lm6P;RZ5zt(;K)d^(_xZ!P#_mc@we`>sIeQp0<l|h
z0=?0@D}#Q9;0_B0RrBFa^pI@ML<Z7SLEyeyH#`!v40e0`lD~Ulsg^}sIuhhrI&wDm
z<*r5@cscMDIlY+#p17A0$y>)!%{*h|5uHnxR(fde*(7=|SX{ytgAhSa*qq|E&xUPX
zJO$L%F~_B`@Hjk`O+H(7^jE<J#dq-lC1LfsXSf5lrafkQN~30t`j56--8=g@#@C6&
zT0vhuZl`t2Z|y3D_!2>%e~%fezHo0nE1nIsph6dk#y@~2w%~swaL$)w6ie2gTvxY#
z8Q3k1MP^ifQwE)GFc`O9XYu+ke|=XJ<azVDIDQ=sm}VL<WhW(73<LAsWy5HJApc(l
z$AIVJhy7{G{5)5i^xJy#NxSkMp?r4+pu5|xi#CQbVk5@DA>QF?Q?tMAY5x3x(%hu;
zyEwHcu3@d&hPHSi<aGs(na(&qkG8*Ut=n`MmEK_0$Cpl8I5nHYHzs@QQMoiG)VSy%
z_;()4J!VrBPVG|EYBWw5aNPWfCH|0=J4%vU+(x8&6NYs9X)<G>B%PgP(XFKLY!JmC
zVE#^(nfhSD8M6-pdc>i6k#`cWoi0C~+wZ(!S3P2JhE}6i*4OLJ2l$|?Ku1dozFXRF
zBI*Pm^VnZN6C97vHx_gp9MUXK3%im6wytMCGps7@R6rY!e$jjIw<-10U2#^Jbl1mS
zZy-2-YdALJf`glQfN+u})i>y=lJW)GjuCobV4xWO^d;Z~antXKDM-eJvoGwqO6RiT
zhbYOGzdu)hbSA#r<tCGMON)D9nUl{K=zu=J2Pf1>W+H5%tc*UA{B9@$;{z(tv`un=
zK3S}05YpFes|Qp-b}78=;Bz^ZrauHa?Nc;=^?BfJnYy<lQkan(n&Vb}#Le&m<r#!>
z>j(CUitAiHTi_}2W0T(+P!nyGD9K(|%|p|jV_?>3|A=Fg*!3B3tPtO5KFc72Rg*n4
zloh1%|FQ(lv&#W>-Kn{jG|6YPa)*%bl%Gt;q&Tu(TTmr_3m=hJVeme)rM%-NATz8%
zYkf2cvDP{sYstmj=L1;cH-=X<Gi?DMGG#5`S1nW^p)}kbkdaRtUrU*Qvet7!ir)FE
zRk3u5CZVfw@VV9h?9r&E$@mRbT|;y8nPz=P{hSgrqN7>Y_EUCiX>OM{f_PjbteL8s
zbyMh<fJcW>)P?+BHpAxbAmWW*C5|78Cp_ZpEwOg+3+TacI1I%uJOEN6y-V74RBgGP
zRe}2nHSLIrN;+AB+-p(^bF-<ERZq6_^jSK)jWnNTE00(E#?j^NNcizxYk;il(X$M=
zM?LI40}E-s`lVZHLg-V?6GLzL@HiT_1wb??7EshiUGCKKTMBv#2NJAVCE@A@I4n|Z
zVmt6ufVFb?iMz{brfTvcFK>Is)-BMh>mJjH64OD5f~a_kmQAKdm8SImL+oz-;XA=Z
zFV?o<U#5vVYwZ+3C(fF8tJJ&;F?EVffJMYLF#+4qSA7a#%-0PAlwgX#B)r_Ot;wWd
zpDbd96f!^_tevB284rKbSR5n|#y4KwNDnx4@76=59omi*%P#Ce@+H1-P96g`ky)1)
z7_h8CfU7fxj)KOZ_K^m>Nf!W#Ygio^e}|=j0PsNQ@M-O|T2%ngMjX+npR8<b>iSY>
z>cz5YM}r`EetLTOit^k{T~yp7pxab$x7lSRM?m3V<GkhDir-j0JG_(Qa`*BX8d4L&
zeCk=zF(Q~v-y4|UD5Gp~K12&LLq%qT0xZsokLOA!(z&%y0J)F(4p(2>#g|9dyz@1b
z*~MxYXaB(W>+R;If?G{iy>%IEX~qh&2A`V)PstyugQF^r=X#U<gk8wBsC4H!=N5up
z4#B@-7b>Guh3GaLhQtPuaG4RE8Y?<Mpg2}KIKpY5@#tX~mrJ6i`c*HGUV4pj0uG?|
zFe+saTg?k-N^bLsl5%jUdj;BTbToUc+|ef_Q~)zsnCPb9nW*EFA9zc@Zarz2=%9Lf
zKvEVT=BB4X`M>#yxKN^iO|Bmxl1QykqzN$osfu|W_ei%rC03&GjK<`f+Y2}G#K%L`
z6NVb5csD<#WI6%`WzzkXdQ$fN&x5_ew_(CHe({g6zE@WbKB!BFG=!_tcV02GLJpoD
z$%Srzrq%UHvZB_MWColhoNn#L<%P;?M;u|{w$}}Q^4Y7=(<o^6cs%^hq+QawVrF6B
z(|w-ajTB?CV2IhcH+<~}xD{{L)W_S@-+3U>-(&u$7!J9j&Mq>iZ*4cAP!xfz*6N`-
zYf*svMDa^By$YRXUQ$izEO}kF3~Vk{IIzajh2M<((ve;^*|m+oh)rV*zb7h5@A;_X
zrrS(-L(SRwrXed>A7%_g>A2-3`+f7YDHOuJDMDsvUHz0V=>)|?pS)=~>na(F!f`-Y
zRI|*SYNa<eTLlE{Hl7T<PZRIx7g8!9l%BCDL+0)55_tmM+@?GujJqYs=?spy=To-m
z>;?;hT-*nL0BvT58eShCMv^KLKaYSqsO8k%U3B>Iq3;BL=tkwJsWZO^9Q#%k%5z58
zCp9L2GlM*f6!hkrObK5DSxi300|RmJ)xNa3lCe4Y#pe>yi>M+Ho<K|IzCt_s7#{j`
z@jSoAAk&7;fvCaF_VtD}9OF^Bw<ji#27z9^uBuilcGbw<!O!G+aBWS^2HlP|g=MP(
z_&c|DI;3GYS~H$up*ka#mo@;1re2w{uY-&&*aJ34FD@xzVCKprT?g7<03&ZstC2w1
z<73LLtk)T#QCD02>`0E_C{{7W7(#mbirX41w%hS+G_hA137!msB(JY-Y<otnJJqh`
z2h!PXeMo2Td>$Y@?D7A36<|Z!#`Lif8zSge<Fwyb&F?q3kdLRe)zA!7^k|S@>hah|
z=zFtC*8@fBt>%O}Yy8!5H`>h$Vwabp@wqR2LrE7)m0%saxl1xQ8DzfjyE2l-DrE7f
z0y;GA%m$M^^io>Y={3Yvozt;=n@##)ywSoYSc49I0j7pBXZoM@U-2dyrF3JWWj?L$
zU53GYiZYX90}?^np_OX&A7PJoiIY#ZTRF0s+?l<`9v(>r%m(zz*?fMx{abQr_8|1g
zyV+fs{Q{8tnKm^b2qY^NYtCac+=N<qK(B=eDe$}jj9m^4kGh9mfTs9iF*}&G{vL(E
z_#lg0XVZeAB%p+D1sEiLK>oLr5bE7KI@&Q%KZjD<tdQS&`-U$SVFrPnms#j6exxkt
z@1hA=Th6VO!g!we?3ANA`fv<CEJl73-wCavpGk9Erv^P=SXu0-i?(=eHERycN~!4=
zIjvpsOU&t{jL|hqzk|Y}yQ12mTPa~vd}Z6;tA10D$3TEeg)ww{*8;r;UpKE@QYDdY
zDK&4Wf~QT{1`=fRTcWph7YIlFw17{~EFe;Ih5R9T^;c&-oXz|v`bG<xcR?$M=tIm;
zJoK<yuv!BV8Vz(_oLgtO%EdK0Zh;`#wLZI>GpVvY=PhY*)NMl5(qzz*@wOU5I<zL|
zJyV(t-KZPi+0ue-5bdn(No~o69wAamQk`NxiXR&1oy>ScV~NN|{+0WTLayIaH-+~*
zk%gPGvL<V4OeM=zEEjvtb5hE+ty*%uWTXtXPY+g^3vGQteN9$dGxO!xAY$1(Wq@uf
z3J$iif6nQrAEe1;Y-pcYTw2mAx3Fq=sCU};seyNdTBI_bgjl3Tt)sxf<@ww};v|7o
zK?U8^Xt!Zk-ri!%Gz3qf0#$?)jrVyp?Jm;A8yj&R*?8BWR$j>Cqh#B0-P=>yqV4j>
zt)PSq=ASC|u8Kx)VI-O}=dG>9<H=@FpOxc!mtQtSz~0Z-pOVO)J8F%3GlBVGSSRs|
zbOErlZk=(3xhvGmjyEnG%EReOV=^1GcBgimLv!4VlrUu_4`vxKZ0!SR*jrPaFzaz5
z4a8NXNf>%{d<MN|v`qR%mowio|Jkvf#=!Tj?1r1TR35CVo$T=)>Kzk-OI?fL-Tc?#
zfiRVvxo8Mfh<=A32}sbuu&eR;Fn+kOwtxR4pjgEEsUpojab|ytQ%#tw3Q2qLDhw6#
zH%-rzdkMh7mQC@gJCILz5*EB3@_szAi|TZmbQvYBT?ETa$RvLw*~Su~Tj5R#g|<go
zp)#|MX^&Bbio^i;d&W4BV1^I_6=robxDU6eETUupAf6-W-JitstKB*L<D|As-8@qj
zOLIZ3J)Vi%R3<*h6%NV=tm7yaQ_JB<%I37#VcbAs!48}Z9+iAinCk+&6?o-nlkI#X
zF=%v*#G{=s5;PJiI}CmSw&AH*swD@GbxvR_=`%t96>f8NJzHj_n~WfUg|znv>)eSh
zVktP2kzLVi8CH1yh%tlHn4x`#h<hK7QS$|rL`N`|ZE8eia1#X$4#OOBd_VksHf@(3
z|0<t98_>F9#n|g&fO|eH+8xC<-u%QCPj)HFl?`?eWpc~}<G3z4&GsNA=xZ0oAUGDN
zp6WIGXy-vhj16{XIUuQgXG1TbYx2{pel|7FFp$HqF#frk3r7hJt-Zz5?pUw;`|5}&
zt(Hd}=9B4|VuV(rB2gmpSGMHf%1D3e`{Kpe9w|wi57sb0dqums=FLE{K?2v*M23&$
zx?j9p%rebFGl|(}p&h1CnMs_W=_KrbKp)QVOKYAT!yfN2>1F(wnEZvKH_WncuCtHF
zzV7K4?TbZausEtz;pe2*pL;n?l!`T`8mxs*d?e-byaZd7N_we3)p_l9b?oRsjr<1{
z=;zBh>Ot&R>jXH#$a<bNgc8J}2tN<YG779;buuJLce)WZCpag?r=;vi583VmG|k43
z2CsRGuYdXVQY5}o08tA1{rD2!7&aYU3lnjA^Se_N>i|xGD$LFalUngJZ~<n44-T`Z
zqJRjYJ670GJe!YGB~v-(?fIrQiA%0;KR74-=6URYYXR`oJM7@Iv(9zRD1*IZ<R&l)
zs?PM<KXQGsFTL^oqoB6V;BvXCN*;2w7Qm2b*uDCfRu|eF#Z4!)*#d&!BVdC*I3}Ug
z=2gC)YYpS6GVTk4_SuLfdP=F+mIHdW9t^Y4RU%n}nX+k1;2Z7f8yVX8c&sXEQe81}
zsDU^kk!ziKWqqJ=yCvM>5NxBZq@+_FVAHqUTm6{jzej#G#g9nK_ZVF#IxnRc{M|CZ
zVHp5fhhau0Sp3Z-0)o3bm*n@-=3T6<-}{31FULv36COE9?8<929riPhV_1!<ZxXFZ
z6(6<&hT!8QZu`R{dZPD$-Ly>z1;U7NcGVu2f%dwED^@A|!tQ@xaj~Y=gtB_SdeBfA
zB?2gyg`hN1?+$+3Ls1)vM<U6&R9j4&wvx=tgDWa2iA;?K!&HxefWM|JkJcAfvD$3L
zzRB;-x2dBqUpg`977*Zw)1nkm)#j?aQNhE{^l5xB#!srhQ9q6nN)A<vJ!_@)+Z7J3
zN)$Q1YyLJp(wK19`(&;&W2uh)8JVWt>YXY~mp%A#Ss|)sWT>IVSWpC<>L*BaPaG#&
zDSa*A@rHzp_4-Q3S9@7ipQQ_b&sZ0fk<qeS3PXP7%M7aEUL4P^?}OMGloQJT>_4e;
z^5PC=%eS`>GZ(EA)mPq+eS2ZbUhh&@zy^D~{w8~TYB&5%fG(rKcdPYCZ&X-MXH~Wn
zX90)Jr95irppn^ZPei4Y0g-PFoI!Msmwa;<YXZzuMiZF|6LIP3s1(UyXsx8#k&xKF
zAr*%|V8{91#{Kp~wXxQqP~+a0MtB$Stb|1+KNW0{cqz^SB23xW8secspnsglS&Qsk
zkxgJ=`SxllksrPB0#FjkX;ljf2152#PLVi+-@6uTRJx&_9KF-`J`!_tV-~#m8TMFp
zDuj%P<bY9tE{)GoCP~V`g8&athfpt`tk>ls_!oBL)G6DGr=Te}oA5amKEb_cE9_px
zhC^}RSWuH`wcnB^Q{=EQ_pF(k?A}h=N6s1*^39=m$dC$HgR&5FX_7B{XEl&~NSMM>
zqV%S@(!WuuWh1cyt9IfLYDy{CM>SkoE3`e+jWC7*?B5nq^#IP~6sA+!!>OZLDBJ*j
zNGKR-x)F$~!h(V3uc$fzCQ036@oZ)dHa(glcH2n9z03`Oh|++r#t?&!)b;LPKDhHz
z>ezc_9o(;OC1%y|Qpy$j_8uiiKhI{X>Lnp<sZ52!(Wv_*p&W@=KwJCX;hbGW<$Xyj
zXiuKM_qieE3OE8UH*L%OUTCkMl=~y+VJd|k0)Mq$-aw;g3AK4o&i^rE0IVURaHeN2
zV5*Aiq#>O``Gfx=f6;f=*}3d^rNuj1@Zkl(Bo$q45lsP<*~@32k@N&1vm6qNZ8zxO
zttPGR?t3oEm72UAe>Q37;P=d^xc@Y$0|IRfY3oz|K8f_syB*@jfNl#6F%EH^9l))H
zTG~VS2l*VBW)+#t;2aKnKLOhdC{Nb&pAx=v4knMI0gx~QBOWoAI#`X7l|<G0Rt)hE
zEbko2X#{nw_pGUArwEIKCwlXcjD!>>N>K6?jFj@6X;7p$yy3XflQRz(<cpvb+dc%o
zg`ARhV<j~79HfXKtddo6mywlOzoWv}?+kT<E+_X|K#2^6`y$@b5xQL=;x9~j=BS7V
zJAs8O{A$cpNJ_?Zkw<xfq3^<e`!{;)3^2ijQvglC)D(gFpp@^IlJ%$lzYb~_tvJ4P
z;k$Y;T4$;d!CLzEsg92Sc(F~OCOy)s&!D!)mJw#sQ*{cV8l#LESl|<m8QCclpm+_T
z+_k(&s7nO+3EeCkB#+i)&3dXELZ9z+2;Bqvek4Y4c;8QtPrc~b`+mFV_2>J`sa;P5
zcOER9#0of-;xEK}RIAZKFHb?^2sA|x<VW|#<(|5BPbic!E68>%?d=h?*vsTPUlPyX
zMnpm?Kqg|O>>%-bkZQD6DOW8M^$E~G<s2Fr7sm$D$+YzJYTECJq8TFmo$eE-dSFlu
zIGZEpx`FiV<$9Fb>v~uTD@X|-n+>}@CMFjU+|+9SVpYLD|2zdK&&oT_&D3t)3`D;~
ziPCk9MBdH-#JxR-q+5XhT=YCGY$WP@@NA-Cgf*K>z^UXvM0i&txotkE;vk+y%lxN^
z|AK_VjY8@kdoi&RuQ9o))I!HmP|!-(t<d5<EG!}eQ4TYhJt2Gjdv)O}y{3zNBs;-g
z3{e<N{wcv<2)zS*P<qsUC{(hnon9AfV?7pkp}A1|zbJd>=sKgVZ?sWk+qP|6jqRkd
zlg75$*tVU<Y1G(B8{4+;)AOG5^84<4?_YalWbCo`v)5X4&Nb%`iy4*+^$cJ<IVQuq
z8*~d5317zdlr(D783^+%E`g2Bf7Ma61-ShB5hk(7x)=Cbh+2krpnjDr68QpbN`Dn7
zcP{cl5eSJq>m`_e!eX2C>)wEG+CSI=5D4T-tE%|=gy?AH#-4y}FANB#X>1DUDuE!{
z0+K9wfQSbyi)0PfityFX79A#171#yuWE!;ryGV)P!k(VoOVJc5M@Pz#jmhfBj!%*?
z1v$0$-O~KtWL%CUA3I2|Y_7-i(vJgG3>l9KodYTPq>{1I-99e^W7W2E0WHrrH#evP
zcsj5WUP*>aVbefcB)R=!qsO4HPrWN}SEEv0-f)vqUm&}c%xR3CGwP(|u+>y)D(E*~
zfLavB#Nc@VPEt~m7$gE-9w4r)^yNz*v|x=5>_LO$&XDngh#rlBfD~UHK_Q^*5CM6n
z*=Wf%{<C=z5YegtxPOMcum-376N7z0VMQ;XjBqZ;ny$G*%+O0%v7mC;EmjLM*0{@i
z23}!@)5I?w?|99&>iU)H^fA>wfPQ4@xiBFiVPLtR;ql%cxm*wdvhxP1cjqW0sM(t%
z!QYxv2Rz!2=MwkV){q2|<YUnTy@3))epM@>#}kB#okU-5=CqJm<SXwcp}M@~(!F2t
z2ygE-$eA(-`b5hLy(hF3Dv<))A$w@W`n;qy6A@_7nV*$qCbHIscrkyK8`4UZR}iKU
zG@&B(2R01&=Qh2zq@7ngUDihw*V=rUYI~K)Q5ZKS2k8L48>lPZk9^=Bm*jg51)*9l
z3s9*PEq=Pnq(2+HP9|H;+YZlTMfD?OKN|G)+T!b5a?u`<*#dxK2igX)dW^h#jih(j
zKP6W1;6CQ$L)10O^NwlwKB9CO=;NcTA+Q8KP&I41xlNHj@4^Zlswd+L9kIuza{1(*
zpTJdXWYhcCA}U2<2uP_qEj6m!b+2$6?wdQxhMP9f-8iW%m@M$f&o_h)V$nB)sshOJ
z)^oKbL&8<7G?n6!3D7nmcDsZC;S$bjy%Rj_3ZylRb{OvtQEG4v=w;!`&~PZ{JvP^>
z(2!(}fxP*U7Z9p4J?y;O8Az%!U2OHLWd_|;xcSwuO%_UFC@80>UWj<%389M3R_~3`
zNm{)F6>1-|q;YW5RxanOa^9^lDzi^^L@bss_o5<>Zr_c4@?}%^x4mL(DLyWGYWxhA
zaC%U<ohh`47s_B{7L>!3CKoK*>U$?I#G@AHUY{7LYuM)na5!r$m-NDD%=xzeKv+W6
zSnQ8`D0v^y6o&U6!)$vhgTV-?&p;w+ord7BlboW{nx?07_uGnf7efQHvB3rjr)!Tn
zPtG;fDYlI?5B76ulUxY-j-B_JxP0HY3gbdUdwN(grnXIwx4W<=ug{C34jVf-R5ps$
zEodzQOSC+oT3RU=UB~=3m1-JDtJ54KA&;4CM*@RgKo_UWQ^`t|SHF^71-Caje2ZC9
z=OWtaxhX+NYkEW9tt$QbDt!=N4{V4><K#6<Mo=8{hC%T+%hSa!JRBM5PMeIew%`HK
z<UiDu>C@{dZ;Qra7CGcQE|cDadK(1%<bifDz*oc%D6qDW<q-+VGN{&WP>^^HpUiNP
zqne@jy;D|UgbC~y&-do=b71_s^hM3<ajSkFFb1F{_W?xJlb=%=^a>zgF`%4PWV5Ug
z$$~pB2#7UbuE%1vJ;u`@gO7f_^^<K-_IGY+v9BC+d0dkPlHh@u03^AD?LrZ^=Z%l^
zRM(k;*Zs^JHwY0W0h1xzFUV*@U)^tKB+-iNo>?MW!nI)<4Sc8+PJ>@|;sgiAw%wk7
zi$4;c{X8B31Ygg;(YmcVhRrpY1=jE&TCH?<cW)cH6cik$UXlDbYk5VSC&K8wndA)|
zAn`*|Ur~$$B8~0+u?y_hFy2>ipHH9N)?8Ar`#_2^;sl;Yww4tM3D+dz2#S%uMeim9
z^1al0r+_loUs1X}?JO44$i%RZzp7pi8CAtG$m967CN|G&o1X2rw{TbW#`$gUS&GYt
zw0|NLvY#8woKOeCu6A<ksn-f6-5h(?3ggLdMb1_ZXfZDp|B9G9)|ex^+B*OY_J9*u
zkhXA8WJUNk^K`EK0>>Q!)<k2rZE!^k_Y=|Ei?}%$2&h#Q!(kt4VSVw-O2rU>T|vc5
zKhx9|{u!TKMA$CWhdjcP)NYdR$30{O*VZ0o2S)vZ&%H-F-4QODoovz#JXBU3ZxJ%3
zA^<FM|8qB?8l>8nc-5gHiw>0MO0vT>21Nr3wl6BgUwYq!f_UjWh=eN~inp~+mXV~R
z_=)z!Tn;6@_IqR;G@RH)`g7R7G4tv<uPL=;okF%UnK=BAzxq-X8r82I)}`1yW*8!8
zqVPFImf>qr;z9Du0xwgNp%K~MNKeT^g$uTEM(tGR;(??fhS!zzu$$~)OsISw>jy*X
zHB9EG{PJJ?DG%71kXjGVQZj<hS?_P#5LQpUaMee#sQc4|3a&-6zbDi4CuI^QAYMY%
z7yr=MfRowBuf-74)1UnSsLnfY2f1hc5I>nFT*BzBQ5@j&P$(7MULTFX4K8ZnN)^U7
z%vCutYEHpYzzDo-;%CXaX}KDV>+Cn6%U?Kbaj0M%+Cr#o{QLPR4?sP<4rtW@C`>^Y
zt^G=hLZl`DF%iiUA}o{~+b~nFSyfuDfmLNBCDl<8_}L}aYDaIeCv$UGEd<X?oMj(j
zT&NhiQ6Y_a=jp!<#~^vUP+8H8jfY3Xkux$CVmh`DlqFCX%=g{gLevJ0B|eGxe<Gq}
zk(T7)#ghG<c}#}9*{Sg_+DlWDT9Vsv9*U~FvnSk!-wN+znyvQ7C7Zk;pEi77QkON+
z3pH_{<l5qud+_^R#sGfPfW(g=E0?h0+grJqHWkGsL<HO(1n@c~<c%y_A56Ltq^pV5
zwXM_Ns#`Gg*O@WRyaMYP!H6NA)!G=`8qp_(alQ%Rs1ANc7{G`zu*rlBJ>#x=U#*&^
z2iADP87(n!7rt_#LL6yP);x%JQLeH3=9<A;EIyCOj}^JY1Aw2J;h#&diqey4(}=4D
zRVby;5+u3(etQW2ty$wru(+yC{Dg}-{V=mj`b~>(7?T5tM3V7(dv4;SGo^L5&ioR2
zT*O3kH&JsVwKw&lAs$*WNV^f%_(C%NiMWfn(W6Fh%ZeP{j}93eXY58G{rwF~V`Wz_
z=N%e+M1q#z*+97Iw&8I((0qDq_x$v1hfkLQQwH%Zn~Qvul3#+)hoXIotsmQHfH(r6
zC(6KXIV<KB&v_r=E2N*seu7VILg$hd8Ui2BI1i9CAlZ*Ep=goOX;i0o^9~tC5WiPW
zfmNXcKygUbYHjvRccVJRMW7k2lvO(OXE_F0qXpu640xWy?w4}_6LR=6$PP(PGPEBa
z4@wK$#vvSE=Vq|!`MUc(Zg9*kubZ~RQP=IFM^J~D=66S|QNAg_reZS+v~>zvi^W63
zfd<N6${cqQZofJvBic_2nq!ZTJ8|eFG4$M%=0Mo64)UM*GXMxG)zIdaE`3HnzuVks
za3Tj9S~Ld5-Fk+6K49hQ2OV;zC<wNR*C+RF1~Qe<RHfFypiQ1;c-gi`*3yl_JFuS(
zqQ1*FTC*ryz*s?-c1-$v1ZsZswcxA;C|-R;Z#RT}<blpuSk|#|ScgL0PWC|Y0IR3!
zFmH%5zu!SwchG86V<K#PFU?bj1f#(ZsS4b<WtSccHPAx3hu$a61HpZ3cr+5w2ZGWT
z?U8ySB6j?z1{M0J5RJk}9@<aOGIf8p2#u6rj>c{s+r(!~+?eM$95)th^`%;=hF?iT
zWT~0W8b6(o#$0%=SB=mho=e?=$oR0*erESvuSTZ3y&h`on2f8>Ehtg2d&+j2(h;cG
z`BOIkr(m;b$rpe!^l!`PsU)!Etj`~XJZ)!BU3*wuJg^?V{_-|;I{gvy&1@K^nxUo`
zVW($)HkRb~FLSblOA0-JH7wJMFO<!rhW7=!WAm;<*4c?6W6|SbEw{)XG@F+beS@EF
z15S=MLXN6F6z-^mdein7F=3>kkN?Iu4M<Jak<n3?A6ji~%k4L16mf1d5vUgnv-c#;
zR%$4_Vd^C$o;Mes*F%ZqC+JTAo_O%axf_@?WBG3%UT$&Cap+|~O>mACQ4soh$3LEL
z5$~mw=c%%>n%0i?R|m45^=9}BU_m21H<ZX*AART8Nl3V6&rCFa!!4q`-1G*NoiAJ$
zI0ZbeeV&UZ9=$H!=#l~54H-?v<~9Q*SR=KcT651DJ2|SuYRiQk=Y-J*XRU<f{4=l&
zFx}5IAJ`v{S97;}sj|gJJ<rEr8O_+`y%Hk!F`t)&hhyb!q%fvzG~Iv>Z_DF8U*(A3
z{fKyt$gor*7P|~ZQu!MoT4$T#q&Ly%5)46XzKYarXX~LasUsPi_8nQb%dDSfvcc4z
z7DF|w{`saCOp!%rT|sD?*F}bcEW-#HAD_|m;ZUjWK^iD-X8mi(SXdgGPN%1ZN^@wN
zU`V!)Zwl>o2o3PNlyi&J6ZWS-5*4AP+2HLZOl7o2!mLfyQ{&UG*noo(<-a%a_$Rh-
z;LdknE|!h*s*`dYR2@^0Db~QfD3U?WQ1Z<S;F2uAv7n+v`to)5sf983vJbU6?nM9A
z#_2fpx;ri|zC&g$7EGFD?BNq<3jcXqP~u3Hp6g-OS=1z%X?7;ExXzW2<hv7tZR{4%
zs%DV(F&K3n1``c*{(aROVp%RXf0zt^k%xP8J>10eFdhis(&iWQefP*uYDsmt^YG7v
z(WGUfnGHZ)RX+SheB5SOzqzR6RVjUTINCCOcrzs^xlo}t_eX=Yje$v^@x<iuvZJQW
zL#cR=v<AM>8pU?2d%6`G6tv2L3svYkjr&Ia%GmNPKy#y{yBg3VjXGK92cSoSR^FpY
zsb#i09<3NdpD|hMD2(BV+&ga*O*u2_vw&#<se>(&e+P+=e+V8z^ruzptkrg1(1Nor
z`(-i-vF1bhwcIRG_CN4R$7K;<em*4<$)r^>Y~4GK)V1HR5v?A2TFZ3n_I|RhejBjS
zqx;p)I`bGyS#~gYQ$8_rgr?k;ZmAKF;8OPc)6)Y7xmj&_6*Fq2U)M<jK$J(v8+}Ie
z#*D2$OUwzaj0IYO3nkFvwzaM5N)wrqRvypc0FIgcW5as>VUB+^_5t8z-wkT7wxJS2
zP)mL+j5bcfpw^^YYHP=ko$8fJtog29?ZJYxgyB>)ortcLFtAX@hNns<J!IWOuDuR9
z2{)t_sDF=L=zuTGsby68TH%5(LzIRU1Q5DivKthYBXge~><iOUTwOAcO6f-x;&FNS
zZi<uDpyRbXr?d~ywxGfI?;mtW=h{C&0`kIoD@62+j13Go(KQ2r(Q#nL`b{DSqa?Ch
z7NMjMMw>2Qq5az-b-DJ5<a!~XmBU0H>mRM$I;HvJ>}_KH>UTSUo%T`IW1qQ?h$9Px
zu5!bBQ=yQsdE0~@oDI{aY*TlxSo%<6w|s!I7AGn#1NoYZQCK4DQ(-#z#$`M(5ojTh
z11M*s8{s3{aaCVPQ|$sOo7_jdkh)@NApk-ADA$k98XGOb`QQs02KP<1AkN8ODzc*L
z`_-_V=VAW)wvL!dVYnL32Gb^m8oVM}*Zm)?!RmmFgUFqS4V@9r$)*QDw<q!fA(edw
z=pF)$%kT0Lq|5l;2ibauFBb+S3L#zvVT9c(m8EfMTX3n!UiWxQ1LIIA5_|a+r=h@2
znv6o*l_cnEqs7d(%mWk#3Wo{6BE51uYvn!kZjv`{=Ax&Ex;rYSxt;a(yu%(@odwsT
zvEL2k?XDC(94aZ-DpNs_U#^X$WgQ*?g6w&Y799|LY;>9na7DzAT;OD^*_lx%gS-u}
z?u~vWQtM9at+8(#RsuVhG+b!4mmEBU5B~zRYf)fMhl^g6k~w+xW4vaoHUjtCcisb>
zI_=h|Y^gLkhhn@8WJy`<*PXVGIV8rww9M~MDVv)LN3M2C$r3OPIwc)#zkVAdgLdq<
zg|b;~Q?Tj)?4ag5T3_FgQgqLMRF;yNGhS^+ktW|A-%RBeGw6+P%+;+6KJ6lvW4B!}
z!2*Eeu_S7Gy1*n1Ya^fMt+3Ri2~I-wZOy4$VgR5;%{sYeaV2gbNyu5_vG#)<v*)bU
zI;HHk!OYRbN24m;?2U|EYd!Z8E|6Wd2O(`?=Aixg^>Afzm~)_7W7Vb1gLA2AQK8I~
z{LI~1K1v_Kj^~}*=!L(wXd?UICsZ41fOYAh+d)-LP>b8e7t}~?14}ab%+HaSQA16}
z;wbb6IaIppy78lH*;s5Ad5W9b;b892z?UQ(kX^RdUUFy#Nk!-P(kAc(`q;HpzKxBI
z?A&4%(0lBw7KdP~@N_yYa%m{K(hlGMvM8^J=F<TKhN`ac&9M9SgB*0kWrdSU?Lp$w
z^Xb2e$-TA^ee{r^RkC^TT_J#|5Y!-gKcEy`^~ZBJA*@>JQyq}_!U$)scAgl2DTa&o
zA&@{lhmwc%2Lp<sQQ1!zC5PE=2zhrWH*QSJR){{FR`XJ{p%-N_xSTM~DY1eQ?K^yY
zkDFL$-bRW<h@E$fI@>{k;`yIs2_M#Zl^cj=TkQ>KHBf78Xh}%=BR>T&)9d|Ejkb+5
zn?zo^-0bV0uO&Jr+Vt*E9tZ5EDvItt;PJQ=f5a+&My>s;UjOz|yGN=9+;)?m0>QVc
z2B9_Mn6y2YTWmAi1l6GfClK~<es(zmKGRAL4s{$=81xyiZY(imoy{Vc5(NbX17NjP
zHiKC}xsD%$2NuPOMS7`nA!+!jmDKDZ12$|}o*C%)eTVYTD>1MZB8iGg78Kz5jTV(G
z1b)x>5=?^Qnv!JoZ$y;y0=zA!ZKrkeYb4%Y{xJwG-xu*5tr2O3l1H$Ua^p7yZO1(`
zP8EQ6PtE$2w4L!&vaP!JqDBBui(MfeiGCE(C!KfO>Z4C7rtB_UA~FiO4dxe*n*_0F
z;QSW8qVO>f>l0b=z$hUkIf&@?V`y&KmnE+z-A#W%K7)@`b0r~s&3A}FyAQqZJ5YdI
zotfgoBp5q6cNHUByB7*O&OP2<5zL8gzt3m1Q$^oQEo7#jOhy;l{jr`tT<w+-0@7C<
zOH{zU+w7IW!!5CUe8I78Z<%&~{p)~O^-*30eAxr9HM+8-s|;WAJ=)DZt%B(ogcZv@
zNyZ7DFrJ0)N9Fu!cX^}}FVOAM8<8V7aIAjOs32z#@VYu|s4e32>0hut|2V=w=DYH$
zj*920KD<Y4L0&a+e|)4Kb!PM%bFQPXpagZp_u5xLz3~zMPJ^i~UZ0U?ipI1Zd!y1z
z%tfBl<VQ+=z9Iy$?5(er@INai-@l<*qY+WPQjWX5K+PhDqsD?t$r{D*SQ)1}HCX&y
zDQs@S>GNr~8<G;fe^RTuDo(bES7E}?u~VM^!9}3|OwEpELF}V?#wS$;7L>H{nLi)u
z;BG*0zvTArto)=?;KDOpG$0NM1x08%9hO|m^&aBNmP|f=)_H(o<<kUQ7mxm{-FUWj
zy;R|T<uK=Z8l$To=VB7|(?v^HaKW*eu<I0>j78cE1HEp}a|R0gyz41`D#IET+DJBg
zg6kO$%`RfJyn?>Jw6B-R0uEEec<x84dugXuLz59niD@7Gu-nEP{qbtSUck5O3C{0m
zskoMw*rPAL?M~|%FYo{+6P$rDT83eVVSjI|RZEL-xsmdNHz~$UF9*K(0g^C!?oWtU
zf`&eJH4=id@+^9B4j|dhbs(TVrK?RY3cduN6aWZdsJshdar+6Vc&Ey#T*4wU*6Nv9
zE#ULUN)_R-6H4A`4=>yGbY)+sW_k(RjE*8@+RhG^)H|VJV;i$~6Z$eyPJ2JB!QgP!
zRl36etN=l)1O{rx*#M(*N%r@V?zGp(1ZR&5+JhB;JY|lzQ{8oGu7dD3P~g&yxQ~AY
z5EE=xs-izIXAWc;eW(}n=qk^FBMm0bT=QeFT$x<1&ug)Yu=;BZ_RapA{Lj$4`5G{)
zO3E*I<*!Ec{TadW+1a!l9sKrHla`pIb+#+Qd%o)QVw(aPOh#>w>imlJB;dxW*uvB6
zO!LiP;AMcQnE`icTWlRhAHM|PJT2BDqC>UP`TO201Gp>SMm+@%1PFp_lJz%3&L;ov
ztpEHa`?;Cq<WNvksGm?5kvNa>b$x5<apk2K45)vYMmnq~#8#d!0oAgQF{?2N=vM^4
zTcvIR$R1LwPe!}trDm1VM~5{xg%{v<-0ytPkay*o3Piyx2pbLENiH*<F|$jw=Z>{3
z`tv^;OilVS4%L#JrPs&xRu4vY%)x8WL7(h9mnt4mRxfIMa+t{_9-mY41$=tP?c_{`
z)iD`SFi3(rw)~@Dd^9`VBg8U<w3L-md;qT?m@DDr!8kX7!Lm@~8tmbhR1PxgtLgIy
zcmSZ!f?p%zaS<(t=Rz&kzg~gCI239*HskMH0iJWHGN%gcv*4q`o`0SD&>>p&yY+a-
z;zBYId*nFRzJ1S7jWwU5h|+sQWt#<O$+yS=F1Jkd<}acJ^Wibz<AuY+lorJa2?@ZY
zQV1#1SB*O67C=ZlI?%N3@Tu15Y8`uB@1|BIJrdOu83-=r<q=&?n;Yd70vB_akGBWu
z9Y7rh;7YN^)HQ0`mz=k5V8F^E+DkV8axE#dRs{w<-BzmH`v$`bvPIBnRr+1pk4Zj5
zqdXC+TB)C|Kp13hLCA^$qc<H(T*Q8CV0$hNU%*5_6_NU2v6@8-9HqFQEMEH{qoR^x
z&9MTH$uluJS^$)0DyL{3DmY+J!gv6eVDnk%Q;OB?)<^>BU-pj!c;2b@TOXDTFR1~h
zd*}@`oC=+&kW!^zNh9R%8Uu6XZRGSK81YI#3h*hV)?#52AonQWrikBXeDlH{f-Deo
zSQtW6u8u&rB)JGAs`BL*jwbyusbU4=>3*ja9tdwmfru^U=W7;>SLPal@~^sCdOZJj
zKdoM#*CeTRU9BkX$RAMHSOm?MSm&HPkAXtT`N6O^SPg(BgM<vt%0*C|9JiMZoGn%;
zcgV+34?)Eu{ApaEQ&6+W<<sEdVQk}(Mwcu^wqkg70E&?L94{gYodXwc<R7!^gtKqP
zdv3~ZTuWG_bcl!2sEU7bfx&)ab23-`wb!5ftGVr+1|Q|c_uP&8g<!RA0Klgf7Barf
zbmQ0WG=^8sG5Ouiu*?ZQfNlrQ5;R2sC(d2T${b(^L6M;}erf<{3+6K7_(Oi;4iGz3
z0C@@8lwwFL!f3T^X+aQ?@PLD{m!(8YN~*3iEHl~QjPI2~XbV;rX*nM{B%ZnR{h3eP
z!+2a{PH}$K=Ye*6WzdpcmRkfG!EdJyDWEVNMY6(>@~RKAhia6$5NasSbwQ9S3I;b1
z>E&+81)>6>@dGO}r!(MlUOYS^qB;~!h0|hsXdD5*sp**^0IXDAFdb{L7}aV9tUvUu
zZY%JBK}J5%%Te%VjOS$B;@iXlWggzxSUOIxBnlGM>FWcDw8o}7kM1bnDlq8}j)R#k
zn*BT}3vdz9$B2f^Wi@MoqqR_C8#r)vzapraoX_8;7O()*%<nC$)ne0_T%|Si{x;M9
ze8C&pKUbwY!RxpkeZ-%aauNr`!TAS`<+jRm!qta5yn^kxtJkLkv;2{Ddmc8b6a)7y
zm2x<Bfj>=_M1Q*s0OkVq=HYXd$FX*i8>aCh!a+Miz?5KW#E1p<qX~ZhlTa_WK~tIG
zNr$r1YuE|Q17|pzLvvB9A{h3ny~*&Tsua2vaMZ1;(hpHFRG9=^)}I{>vjEq-1nP7t
z#?m;zzE(rMN16(f;<!211W=vgIyw1a4WIx5xWa=Z#z-roeWM@c8_;VOpR_!e8<??7
zj<l;gs)>`+UhkFg$vN?R@Dn%OU|E%H^4LOQF>B8E?M*(i%)o0P{wlYk9=ErrS`I~%
zij><-Uel<Qpt&5Qkt8L>1Vazg;OMN#|5VCgKTjNvb<+U>4+NAK6kh;TMm-q}Cb(xR
zp~D)${vZ=ari0d(?j`B{;c_iH513n6QPAw20WLRr;H~K0Z>~A2s`bX=)G@&`$s^?T
zVCLHc5$cRTtp<BO-gP=ZaXp}vEHV@Ly{WzD2a>~jZKdeg%|u?IJia|FGDc_kGi=w~
z<Y`+8X<)^5Wsd>k_H#AgAJ#K%$xlXGHoL|A^tx|n(eQDc(7wWSRYJen*#P|_d>?`R
zNDg5PCfK?HP=Ms`jP`tcL>keX2#~sUTvv`@jb?U2F!hlT$5ZgT>q@o{%x%w=4Qk6A
z3%!6@yzNC%Ul-JDSmej)?+eUkubL@<fyf~AiE&}b%LDMvV6aHfq>_f(H7lA9WgMF6
z78Fo+y;;fB0q7I}F0MfynX0Sx;}YiV?G0>DJA}SZwmrS+Df8e6&~s`Li_Ajo57OeQ
zKhltiU8hf)yEnKr5+Gm@drxOiWH8I5g_-yxNs!b`RD`E}#a>J)LF<#wPk5;3xolNg
zw0|OhgL~jkOq#s-1-B+1>hxDW!6d3{v;B)Z9{FiYz5}<57zrs=4R^z&>>9<nPHj`M
znc2|rrdWma-eWG4eMM-e?#+R4^XfYCQcpEfs}b_sm6#WgmqViy{_jLlU)ND=p6g-E
zruUc^xj{qbo%uyUa!i<#KoVA?DV*n%bON*<>tuRl@(q03^H)!nH(K3f{}EH#PjP~|
z$7D$-^@$^<ye``u?-GCtl#Dbahx7weO}W@ssOel)7$ExO0S}1Y5jES(wOzkrtw{Wt
zxwBIrP7Cuge(2P&+}rj2l3+NyjWC;YQ8KrFVUU^;7=?g@Iq&f8_tL0KdC5eqWQs4v
z>ZWElsej&#@hu#y5;da9yR``7pTFuzgl<yp7~@im9)Wy2au$F!N-~zfvGLqsGaR4+
zR|HV+X=KPGcl^`OlnV7R7o|*5(zUvFcW>CVH{nnM)~iF)>3pLM#X&m6Vv0Vo0xlP*
z{hNK?EdW07D1zT93Hyuu*ksG=IS)>lmVtqH{eY_USBlDg;D%095B5eL!ez`sp@twy
zmFR!KI^~@=m9l+x^-K9VPLM;|lFCjPM-l9qEhBvCqCssB#<|m>@A}=o3ei;U<DD^F
zUY=KODny^)0Mt&3LjGAdmwphFL08^<l8n~|_9mD0K*1>H&eYO5az0Ipj4TUv<Ixos
z7Bx0Ew@wESreDJ#+r&mfMil$wwDBH2uCC~l@-G8F+waF_W}{@NKE%3`{@#Fzlu|@A
zs0f0tJ)P!doD<{mFH&sm6l=YW6dbn){s`Z^aC$3;!8fodM9)AJ-Cw=Op<RI68nSRw
zB4@CCj(2VsjW+fOdmP_&i&J-AJZHzn#44mUyu&~-lwpkbUNW~jI7c(8W)v2wZfGB9
zqQLSGO21df;$<vLdE>byal8Ycg$jH&i)pg{w|%NMtBLW^(R{!rMB`{hN}m-M%onk)
z8=y>q|LJ&WOAnvmLuv_yOQ+*FK2!DW8Lx3s4IQLu+^k`rTV9G{^rgAg*r4wDshK)H
zbaa^Bs|GL~Ied7SSrZnAwZAEd;=-p&L3sX7L}C;#ws7C+Xf8kfvMkM9KBN7E30bpv
z@x*bS1B0H0vZ;IzAYjRmfEHUV)sXtp(?m3WyUO~Dw2gf5W|g;^t7ED+47i)b*Gy}B
zIj8AwG7i^tmnq*?AI|2T8$fs}bj40mPlidm0(3N0zEi|BYcK1)Z%3gPukC5)2aUuN
z2Zc}%gJjI-i-uVM{X~EYH!wC91*mVxhHytXQAJ&JT=+`g0_K~^NrQEOPQm9E(4=+e
z18x28$y`B&zZRWj2$-l2JNcm@uztv9lzyt;IpToZaLiYTZNO9p<@7N`{Tfj7(Rfjc
zh>OE4DIcO{0r1ethO1uGj#LAZv7Jk|TcCn6DkYso&0b=sXrbhge;Wgq?tT4WBh=3h
z&67U?ztO6y(8FOPMmxSzamz7%K{HcUvvDL0rV0yjF338%g3!`j0?KjK7Ul1eYVewM
z4rmne8B*{#n#<R9-prPXRbTsE$|+6xZl^VAVX23Ff$oq@Lu`X#U)=2&V-MC~)|Zpo
z+<^hHtAH)(at7V&Xq-DidPKs03b{0*s=cg*Yp#B%G~)P7>-TLliZKsBx>a~{lJ`Qj
z1k?$i?h5T-b8Al)XogZry*`EGkJe?y=b*^~vNkfKlIHtRvIu*XY(zcrqubo~DA{p>
zN@cEDN0m%0b-`PN>M`CSun8=tU4s||`Oz5XL;!|4qMo3!a)e&aZ^<P453!5I(1g9T
zXwZiW`}jIr6d+-&{C#N`YR_7+c}TU}40X^2PGH28Vn8vpEoV~vqM3wC_q*_q@;Rq1
zHR?7AmFu`F>Tvv22<YvsG&i>5q4UyJwu9VXok1cY=wW863{4H&B_L-)(!jMTZ5xC1
zp|gtan;B1yU1M}<E0&3hV+}5hHR=L-zhsF6t&`^pOX&z<?9eGSom&#a3AJuFnPtIV
zC1**E3f+YRk;6ch>nlSU$7aP%Vaq|RNjZxtRh<k!gifu$p=tG)RJ780zVq;d;yT0%
zjJR9$fmKsP48CVn%%L+NV=%h0aJZ2!P$%0h9>rsP;8RA_o}%HJF9HoF4xL0REnPmz
zW<sM<lZE(K6SD24%27Q3iEt25&?z3m&bL7mV=-FGFZz5cGqhT%7Nv;x;sB3~`aRFE
zf|4((>1hY2zY~|Es)mY5*ug*j;b+(mR0>-be6j3LJxRSSQ1(PaCw!2S8x!O0WY@e^
zn!`J=DDXOpPpNRo$bH*78|30ge%k|<Mj;#$?fcpIxim|F+~!ty)8~aMEotHv|67oP
z&-*&_p8~;G!#DNk!_aBXEH^eB;zT@-Z2%D3Zj95%JY0=<?FOF;uaBwBFW!4|`y6pv
zg{tXM?rkiPRZdOb%Z|?{ghal!Yo0={_}_GYhk{ql&DRo=pAReUwZdhJOlEP@hNG8S
zKAf8vtLSX?@U~k`4A^tiNf`N5s+I>jw4aKWDp0C?yTz_I%Te`pyTgdLm0LLbeXh&8
z#_X<<O}Mih=o5JKz1zSlI0BH`7xKfWU*E8cc2=Fsu5>M?T;Z>#INBmNp%M^%*PDaM
zj^=wlEc~`&+bTUfy|JZ}hHWH)vJ3uKU0$))8IND4*SqF~`m5<4G$-neh?1X-rT|o_
z-5L$lchAK-PHPM){*S43wO&a_?+?lFjxZ=`C}bkQQE#=niA!8Y2PULtek}&a<)Y`=
znz~6UStNgY`y2xlIwd%m%8~PNYNgJL*UKw$mtn}uI|bk4#%v$>Gd267n{za(zNB%S
zBNy=2a~yz<j(9(7-RK7_oYOVJdax?>Z~T8v6ZQWj<w_0?Zq(JM590jO*~zz$Fs)aH
zAq`>m!}#~sPsxFzV{Fd81WP&rwgh|CDEQU2wSgjs*qE5T>mMv09#7+Ere}nSKfc{2
zU#xY+RX;EZL;UtUd=jxOG`+W3#|8A<Y46haj>nr3e*H>aCfvm_?xk;C1qF<Vg8-kK
z25uW;`)RC?%Za3xwqGZ|HeLLUM0Itu?kqrb3>0bvi2K?IU$3s9@f-tL`&n9ATJS7E
zBUm9IAY|C9UnjFWxVD3{Zu5(60t4S(9-IfD0fn2tli_7TD#{Qh0jY2jVsI!B5q~5L
zA1KvE&Ld}(I9N$ha}9lWh}j)ij``@{e=u1^pa{tLK(8T3QZWAbWnTW-pE3&ne9PrO
z977?6)K{1v_%-0R@PmCGZfSj<V@5Wbd#Sxa?B$`w%R<5KOGtU>hg~u!)57zJZ3d4|
z%o~4JE*d3XNy{4E834`FdVVp$BMjBitrz*goi4C5$!2A7($bVz&kQJk9^&+HM8%H7
zm1p`I!D90(#vde6gee+|03LaDQxp+Lh7kw8J|Z)7r3K$M9J;#Y5FZrL87lEhQV}#<
zX;5ZMK~V|Lhd0_vQ_|FK%=J@!FOwonLvUNmw;Dpw$M)Zil<Hi^=E5E5o<V&-@r*0H
zD11|QW>yEY9^{<I*Hljm@pSC87^=8$AmvV+DivMKA36-j1}7AM>R(#O2X1IMdyRiD
zX}Ves{rsI`8q0HEeH6fLM6l(9hg@@lgUWv-RYCOAz0lLg=zlGgf`}B;*GG4r%Z2HA
zbH)CQaO<DW`u2OM2ECNsGO<=G0`;)n=z8}T9YLxYD>kQ$WGo&ro|KK0tgMO6%+FKA
zSNK3lC_Dd#=*r3{I!NH|0iMRRg;66%Px>JWe!@I2rlgdRQ6UsQtww3@@Anun0PWG9
zrk+SWT^Ph1sL2-06<~x7m@m@2UAf#$a9Sf%o}Qj+%Kc)p<T_*~6<BYZ@Ur<@<I)@U
zrM9aj?I*hQ=fC+70WKgRDQRFe;w)IN!~MZ)_G=BLoTaQCuHM}6z^$o0u^4kL3SA9P
zR9}d_!e)Nw<nGz7W#{{@)9WL&hq^h=Pdh-)Qrx_&wsz<zG!3!i=Pp4kl)bjK)m1ol
zOGO_?M`lv#0jFS^SGv2?-zr@3Nx?ZZfW0#~34}+11=8w#8WPbzHzx`>jWtbvQ>0ri
zEuoa?hFro*0UPo3DpGjbtv?$X9K6y%|Bv`48*qtetbBG5xEZ6v^k{Wbnt!}~lLu6R
zkNNx0e%&JY8r0D=_<)KGn(Q7Q>t)uj&u7*ghrgJJr+1-VeV;M0(AdDUs_;YV!8<<x
z4AH$oy2`L>$mZ|xk139E$fd2M3CcA|P5(+Y`UdCisIIZ>`2Cxd1XO@o^e1G><9aRz
z2EHv2c_QY1tn!-fA&$)7nI1=bbbO+eHNYlChgC89Wqh6<1`%d&1VlrVze5Zt`yJ=(
zMmSG@0C67Vu<Cj8ZD_lPY5*!Ginm(Tw5A-dX*4ObTN{Q3LSJ8>Cjzy^^OBfSjfi_-
zS<@X0N0i`?nCYWuR6KaVF6aOngf!OKN~<{o8+#3eeb=43-FLz+?s;(_u(aLRc3xK?
ziHOm+px@(SV^iZjtTx7XK|6q^FuW<T4+K%$5_3qs0=UDav<{VvA424ZB;_IuGRpF1
zCGTm&#yW7n3KW3mS*e;{?o?Qz$ypp9y$J=KX2Vx#KEP^r8gSO7uYCO7M=0-ZsEJ6X
zRAtZ;fZX}MFk1`?gqD9TVh)sH)!d3-?gAgAWFZOoafH9Q7~$c=@{)t)L$1Sn?uW4D
z7aa5Q>Sp`_zDMe1t_4rtfl=9xcf&1N8E*d3CO+^a`=3To^d=&XEuHDJ;m{x=dHGPA
zta<Rb>mk9xXqw&LsCWWZZv_DEb9FQ)ELcWw?*Nm1xiRc(G>Uwnkg_ky+r2HyZn=s`
z-VriYEkl_22?pDn&^TA%+;2yUo?&rGNoOxruGhV>)J#W=uNg=d>rhCJ1q3HMd!~g8
zG_;i>m2w7szZ(a~*>$N`R9g?`$ECA+W8<k?EN0&5PDS8uP?(VegMymvBFn-uJMnp4
zgE95pLAu|caV74T0|qHlpKT~OzaovsIQz6zRpGo}3AsrC#^zP?6KAbc0pzmlDc6Sy
zB4}jas`NV4$2pF*Z1Ll{Sp44C9OmSA3~vu-w2kNoKuGFAdvrToPCf&wQhd6A2S`=o
zWJyEF*BJ90j||u#VwVCbqALkoeJA$YEaHdWK<D0R_E52>y2*H7=UTs)GdHq+G|x*#
z(y>jv_$pwesRy{fd^YgD5_itUh>82xa{Xh~@{&mmcebI`UB65_-e&hJ>Bqy9Yo+G#
zF{0vig7y6pg!`jy`EJ*vtp`Er=UbRu;AkR0HZ>KOc?tM2jO<a1LLq?$`-l67h~w6^
zv>4~eh;FXAVG5g?qVMjaiI|xYz@8oV>Z4p4=BrnWyKKF#dsVjanf@am0UsZ*7%SxN
z&UN4;z{rTWSfw@hr&Rui6#N^>^kueDc8QL8NU<p{mcXitwNrXJpJV^<aA*je1*v<=
zw6Yn5#qh6)upXeye{*NlP~r6W4fx1^LiFD0w%_QUE>*Ax+`^}?#R71r9@g9#cMlGj
zYe6#})7!RAkB@0$PHv`pkXD~$AtWfKX@lA!prH$vptBe~7lo!!L&?a<2I3?8JO|)@
z5{Ku2IqVP)E2^nMba_dFg&re8xWwFr61Olv@N9Acz7CXl3=9lRhP|I85)a938cZzU
z+BZAbeZ8RRH0u=64OEsruYXZ;&4MSA#wR&G-(pLM{eb%YTO;iumCv<nA1u^Ct6`Tu
z0FNvdb!=BzQ<KbH1!=6H;0KO))?YK_WwE=eTPY<)#a<}3sq*7v+N!Fmc@5jyAHdz?
zo@k3dz-G4DnhZ8*7V*coBe+9;QE4G;HVdMtEiF*lR0j4VtPw0?p}%YN>0d93gy1%M
zou3fd%ggD4f^r4NJLL}%v<eqvM>7aP7Z(=;Atm{CHe4UwHh#FAWNZjoiUIGPrb8A&
zfk-63RD=;Q&~CLuJY8{<(GvIg*V)fgBlS1BxFiBfjR0-%$80Z=5YgVDp}_Xi2Q%CT
za!?RZetEg<<Kgumi=FL(@R5-fTH&C+LC(ue3TbS=Qf&`0`eq8B;#1To*9REQ{Z<W3
z1gC9{`h#6h;eB%!ythQ4qsD&0_nl&|j;}YG$2l09xAh5HFUs|{<zG)I-*ORAe%U?1
z^zZ5EVe8)9B>EMqx-5q>Le<)6O&e39Qu;;20=isCQsjvu3V}UnP^ZPlXsMq}7!exp
z@Cd*-_=N$y1!r5o_a}1(d$|(kB@oV!kEa8|t=@WK0k;kQT-zGAgwV(wnE3EU>m`PA
zIeH~R9gC&KMRk@iGSpiKVniPjHGPHfV06>=G(op>I#RfhC@sLow=!ulm8mE-Cufp<
zc$(r-v6dW4fG#|SpB#@%zte0u8XKO~d=gDcavSgY;X-l%8X1lU^*=3@5EL5?=-?4%
z{^d2d!}ZC?yWQT;t6z|b9>%<Quh-0F474ejDnCL<{0FW9#A9tpY)+^=u+}j#p9F&B
zzf2lVF?KD(+GHFAjymq{W3a?^Y&66Zq$a5)QT|)f{b$&2>q8>i4$gs)tVMR-2S1!C
ztJdy%X1PJ@WhE#m$O;){(92pLYWOaUi;k|bb&#t9f1IuZ(nSi4;XcwH!sjjlGk58=
zd~4tKEPgKx5>j^D{ln^lb{R9X&j&7ffLO+7p!DGf;ipRzd4F||5lTUdplXBe0*Z7f
z7?{Lyb5m1hC;5ydPL7$R6aO8bw>!?w`e6d}5tQvT6Jt13N-@1Fo9OE4X+<SHuD{e0
zMoZA8>7PM<Q9{@irf<*i4rBDKQm*{`{9Axj0&@SHR7m6ifDZp`XJ;3wETE&W&)|;U
z$DBu$Kd`oj5BN`d3}VEK2964T*aU+?BJ}_DvGuU;L!#soBr{0(&nM;YxrvDo5|#nA
z@$lsvN&|1*tl3;<z_MBM?j2pnj+|u>@-?PIGbIx#>`9+aBT_W@=PC0<7Mfza*{4VT
zCL;RwJBl@6b7yBLXR3`UuGqujSe3-fa<>4fU$mCEg6zL8gwa11qFCKCMNy^8y&k;9
zc5J`m^lYU;@iT&MdN&+PUe6mxM17v@T{(Lh0~Z$-g+dJgDAuQ+CheUmlyv!{x@hDM
z+n#q20J!wZino=oRqJqac_^b!idJ;y2yOQQmcgJ12(cp4R#r50w%{5c9j<5l;iyu&
z%RgLbb$=9PO23cNGCC7*COMbO68sFz;z1uardjl4?S(go<0ejh9*Sle=7Gaz0S9<R
z)NqLW+C;*{0s{I1x(qSavFk))j;@PHU*s&uW)eQ+&@oTknt7derK;IgLyv_Rk+9Uk
zekz5t*eo;cn^Hi(zdab#OYszPrU>{vOL_P}575!j$S8X}AC<y|o(SOq$Ah$4tJ|Bq
zgON<uLxtk<=5d4+QI>*HzmqEXYXS@!G?`CQa<a6MdEK91zskiEh0#<B>HZbw{t@(q
zWX1j895aWdP~7AHePw?jarwQoYzm9~m#`=Vbtvi|j_Nr*Bbg<1-M3i%`*MsiwOQZT
z(XACj#Ov|NvLEK~cz-0pTeJC?1$IZNM0SvD@3F*3PA>Xur9ltY<7wlR(Zza~aylQg
z=_r~922)d@Ze(QSa;P)Kio-o}q$4T@XXstX7x&|GN{}x8@a^++3W^C&iNpb*G)Ul>
zajdHCeukmb{w7FNE==vbzxo*{FH|u&sd@l|S4|*E{0d$50`0Evv0ZU3uVH|8t^y3$
z`&OG-0Q8H5yGL|LVS51&8{7^_>R2j!jtb8=rtIn_Hi1_N&lb%Vn{=cV^>x9LggQsS
z7@R6f_{b3yeckT^%>AOvt@s3NY=5F7$^$x`D7bQDYz%^tkrBu~kfbp4iN1=%@rG4;
z+>W69(R_FFDpj=)s+leJ8~T^mf%(j0^{uU#-)FIZ!2rh3;K5;G^{pf{Mn6OSmVFK}
z%h#8|Lw66?I$C#yK`#&k0s=0d4h+gNdauSra}8fo4uwTsoK&U$+dBOFLj6b1`ez1n
z5G55FfaV_~#MOZU8iJD?sAs=J%gK{cmxR>SAxPm=nWkVM#!UiveiO4dM|+@gL3DSw
zh@>Hq8EysyM-~*&^nL!r?bQN4Z6a<0)h!=O2GV{I4glD|iHY$IAI|yXlak2bz<#Q%
zI#2N@4ud$_c->o|(g{2tlDfZ~k<W&*+C6sPEoM3ZS$u!-<J0L%s{)k5bhQrJ%@<}h
z>p737>s+xLGk%k0@LK{V*Hg`MLS9~83A`t{Wd|T@A?mC+_0bNV{%$0nLP~6aMhUn7
z@+DUN5Q?oj)K>2Y+Z~V1dMCtC3@#-+$P&6Vp%i$pwfHLCaLg^hs8=PK3Ww*goprZj
zDy|NKL~NMmZjD&;udJl?e!Y^Us~TDovB1{R(Fu=@4F$aCq0Oadgto8u#x754d-?(G
zIxcy*8)lnj#TvPBpmZm&12kTkD?MXl_y+}c%(453bt@zl2nc;{^O0!G4kq=Y4U-w>
zNx310V~Yrs;>(=&$FZ4dvlGD4kd>@a1*Z<5Abtt|2&Y#TO%^jYCK-|D10v~HF&Nq9
zdXq3F2{K7TLcp(hmv20e+S#LD5t{-X`M;#K|N9dEU1>A%zXx$sUYa^+q4MNnh@PK;
zZW{hyS^!<Tmwfr9QGk_7iw!rOZky0CD(8UX4Q5<M22Q^2drL=IIPP9seH9v<OF%x!
zP@H+aX>C+-F*)pSWOBUg?g7uM=q*CP9iGB$!WTe5ngZ-lK_TOCszd(G^Ns`9Fii@<
zozNdZCDB<XY`JRF0}zI|aod=?oc3gDs%o%RYQZLPMVkQySXmqxPaGj-Xo5pxuqCbT
zUyL-{KS-p-&{Y16j*bQf2ZKxCgd<JB<`C%vh4=p5UdFL|(pTd0e3Gk!Tx%?1GQ{()
z2Ld(T0-pOupBDtpdgEf@ZSWQVRQ|9T#VBw9C5wdtj>w%L*~FMrSy_oqeT2_EmhE*v
zUlpav3<$SB9+l<}R?V1`A^N;t4X<X+;KCDdX>>AfYSTgthY?sy{j13S+xz)vrvJaa
z1T6adi(99GPxNttUsm5L2)@ZJKdQF~^#|ivf^J;<UG{|q%d48=ju$S4FH~w&svXgZ
zDxd+9j^&e{&Z?UfmnL!ilk1~X%%glLkPbnsNdSM70!SI{n>sHcAtBcVp2hNA2mr%E
zfOODCRnLu<me#HiA2RxJ8*6@XA*ls}(KjY!YC6`SN@82H_1wO%FbHqDQloaXQ5UC+
zZakBd5b%Nqe|mbFJplg&)+XWT=olClW8eK0YF)~xqO1%G%x}sJ6>@Vr5q=Q>f?1%j
z8--thdF6YSuAbD=lC`wDItMJ_b<^=9k_!8*7+@RDci9^hpOR9-j__|Sg#Yy?`nO+E
zn*{VvElTTv)^u8o#3yN3z{dV-X0Zaa5sw3^E_ItyR%$9Dpetx>M0QVA*?eui_&R7a
z)Q|7B%HR&BxH2#l;{t~XAgeYSkSJ4|Y{DU~V{B(&Lp4iJqQ8PSdr;ktjgAJ#TmU4F
z{xs%7ZpKdq40hi>0LOS(BMH0qJ&bxyuGFL?ClBTzXH*EzE*I!ye4cONA&G~K<yG3n
zx!(fa%aFCnz#4+7mp~=}ZEZL}*K3f;OALy+fCB-z-2?(FS`*`|@<#-2!_yktuq_gq
zRN_;pt`bZl0WiR^CY}cm#VU{5^#0p4;JR(TxxL-3FiriW5t|+u2pZtc=5nmM^+WUm
z-zv}tK+tSlzFhc~p{NgVv@sA969+z^4eTt}@AwmQ9@DnjMPaNl1|JI7(zUd3R1BmQ
z6p(B=2R!~q9{wNU{hv|(KfP2#2XGh}ZDr_fEV8j?L@7ZLZRN?PPHr9?K$@EFIlMkP
zF0@X?unZ+l>nkcEfq(uSSXv7C_3PJuU>uaWw{iqDOTvJo4zop|tfB%D2U>FZZb+xT
zKhHYM!^O=l4BX!OCMM*GWV3i&U;xMT6Lxr&-wpNk0RW+)j=7z+L4hHQ8<i0W{g}Os
zhYg3<6>imKNlzJ;YyjZ=NGj_afJ$Tb^$8;(A$^jH7M}gt?tE|(UEI;ZtE#Rp;^<gE
zd9GfgOT0kb2hnAKg+eAk%nT-oOLb@|N=Q8v&tGAm4W+6&f6=(XGn1#aMg>I#f>7Ml
zga(KlyBEr3?o0n~c~PiRT*zCPU`i~@qIpaXl@zEYO^_Y|0CjpQgpM$}eI$^Qi-h22
z78d*aLAxKfogG|Ul2v^_-rNA~=8a-+XQ|D{?$_&&qI{yKtzVS6iPuR);5dOmrwb>L
zpxL(kZ)c>q1}`S_e+wTVF5tTZ(6BD(G~|El+07v#BI2zoBm@Z21Wj%2eq8&`$<E@-
zd@eDv_-Ow-r&;iIMNYd_vI@4$n<_2V_Iki7(8*);|2--Ex7{K{51IlF{*PjhlLb`p
z^%4w-$SQ%KeujHLA5n_9W5cnkXljBJ5D;vhti*;aLw$xbB~C4rj5~%;C0=58`{DI)
z&ScaNe);gQGlIWt@BNDH?51!JG@SlFMgph+j0oVD(%x;D$phZis|uyt?gY_d^BV?W
z$j8f(aQAO)7;qJdB#UWl^8gk+VKnUWD)T_CASU5DbKF^0h6U8Wg4Is{zrqg`$S0Tu
zVGR)AxdEd@-~#4$xu|0=tfkeiq-p35>~z=OIR!y@<5SW?9F72GX=&)ceAfxzEcs9H
zF8}L(`u7%r5EK+t{4n$nq<^FkL#TnFoWKxR%zi+_6ObBA3faGeaC393YpUv!S65dT
z78VA<<M{>!>{}?nS$G1WwXJP#y2sD2tgP(QZIR>lfb`?bMNj4$m!;5uTgCtMiT`8u
zg`7q5<TW)PoA=p>aA5zVtY@<ar=f|ynVju37cL|PKMw7kFINfqTwGiX8c<_bE&adm
zR*}4RVj|C!Vb+ji3%g3uoqx_p{%^_g|F|UrBt-p1T-b2t=aK*8tNo8>__ybqfDEt`
zSnKQiqlBfXyGTt{MP(rnRQUI*DO4%iJK7K9`SO6iucohuFgzRA^n-gg_@Aj;n*kI!
z+wInpr2qB8{(tzUdHPVnZ7#vUP>Z<P$7V-VEGvFG@9+6Y0|P<yQgFB0Y)m}DY~_P2
zZB&r<koos-D*tyAXQ22T|CgT)m2|qrR;Sn9Mx$1rz21~X@^2^-8k5XB=v?Y!Z>wZV
zpuK`5cHK)%5v0!eyBq)hI|#{rD}=XiYD%TfaaW2DP<9Xf{M%YOhVbyEj%~H@wEANA
zm5jQUcBV&#>Gl+hNG(@kD%3BILdru9?hp@-Uxbb4V76ha$D|Ws$)81n`0^QlC*L-c
zBk+79Y}@c6oviRr0t&IB26zelDS|-F7v)C$(n(QWr_iL~fo~-{wnAan4*cJhvJku&
z&O!qMf`StvjR`^_Ke{n%>ix+6wey5jfICD)i9X12?tcnv0iTIBH#a|leTMsFZ*O1M
z+6oB^3)`pd;=&HdQwRZ<Wjrp2PZbpvIMcA~|A=vUE<~FP?Sfp7;LzXeogenXQL`xo
z!DE+B27c$f@0d_cd_iy2K8R0n?&WWy)W~UYqyIW|zB@|ww_jR~8Zen1WVqgWwYm#v
zdczs`b*0dLH}CA!-2x!IV^MjXohbUgPky@CrZ|WJX=x0bhZdCI4o^;ee<D#nw-Q3(
zuZoc6`SIDUvM+P;Aw4r+2UCF%FlY}%2pDz7=60|mQ;PNCI3V0rlRxG`4``BoS=Q9*
zUrq4otFS%W2-GytQUTkrTMd)WW^wyU=+M->b*yp0^H~E%wvA<U)g3DO2peSbzGZfx
z5jL_p9JLUgN9##kn<o)Oe7h7?mV7(7wvaIz3L8R);k|Ua;NNfD(~o}>#ualZ!GDgT
zOwgdBp>P3TvU!9vPwer3#b|452S!CjIea@`#lFATK&-E?cS4r|+FnBZNDj9!!ROy|
z<F$wE-$9&E;$%H!nsmYY?X*9owA`<PSIEF_4O}m^u~7d!?^0^*`h=09u8d4Edea!e
z)kiFXEs}Rf0t6ln;Kqr{*>`vdr3rY8tE#Fx?HQX*X3c2ZPU~o@0E)4~m$S0Y#Wg)o
zX7s1aGq2rqX5&~O-zgTl)1!mBF1jD`%gR)7ILVJ={l#%%+bBH~<}auBz~YtTN%p8`
z8ju_s8Uwc0M4CT$<$4r_%YRv-84e_}cf-P5)2cl0*?|_znidIxk&6*BlcqS8TSpKL
z423SaICnujmHP8}L8DTB4gL4uWc`m+a~$j+8me7tRwVad(*1N26p<w;G_q9@^j_OE
zEQDt<6!c7|QptQiA8_2T!u*@NSh-$;rNX)@;~e3oE5%8WrtJeK9a~SBb)(qwRnlqx
zCgM=xPkx#5IeeN2-eGV@HH|g(w0wM7eM?KCJfNVRI9^Z^cbFI$L@~(2*0%Eh4^{6R
zA6MJ$4>z`Lt4ZSqjWe;0#<p!w>;{dKHf&?tW@9zBZT$9q&U2sldH>zXCz-is_S$Q$
zug-%AV6sRHJKkQq`sc-`AGXIFR5CEj;e!6OQ@Sdc+p^@`6sjfyf0u*eV$f>bZ*YDZ
z7ZwiXv#O$L>c6)VD=7q}0)9M>73P1<ds9s4z+)Cq3hSyH8xOCyNIui>@oKjU*lOH0
zY@n835Ccz4Xuj63+<jLK-)R5$V3Z`gmjB>nLCtcLu*$(9{7;FohL0gzS1iW|UV67W
zE}Fi2Bq9+BU@51XpO+`bla$Os)c#&{;HXl}pwbAl3zOhTqd%fra7#YLLH%L*AYCC~
z&j}ogZYcxJj6>a<GHq)Gk3~f*YxQ5nFzkbJT_&Q}QQE)n2dK0`-jsnkv^y$FN*{pE
zJ_%36*Oxy_D1dZtA{z<60SZPyF>fKVsfkA+jr~70rUm1G=LwbPt~WYMG_%33o6nhC
zQ-a`sK5a4RDVGp|XcU95Uzu?c_IX_-oV-Rj(V$5KUat4p5+n%2;zQ8HJgwVMY&)7t
z6TOS<35g&^8*rzn`pDw++Q!^S_V!^K=6y@p6oS}8g{dg24qt>=i&wHm9YiX+10|jP
zRj6(i{{CNiU;gJgZYNg~`rmKJJobZkR>J7r>B_D)gPxuqiex-#%2m4MLIp`$G4lUb
z^FS`hxm_BS{D3h}hEKFF1%tvw(G8*vWxu7Eia3B@S=|77SHOqauqm!owO%g{4IiC`
zg8E1X=ARZ4A;`&y+eN^x<ANovSPpn>+&s0zTd+&eP>1u&h3hu%PG*@;O`|VnG=&je
z$wxh7X-fa^@c`f1JPdU5c&ykD>~13ebwdO)U;yya-k6!0nUj|nEfp0g=bsjYS@Am&
z5`^UB-3H+lg6?Zice5V67GIO7xH9v%ogxv1Ehj0ydZ-G$R%>i}=8pUg(na;E{S9T=
zJ%+KS4_>90WAg~~<FeeAg97x3Cx5Mn`Drv&v{yJpiE<<Sr#kkvs$6a%q8l`ne0MQ-
z3bTS_!xunqX5U3x3n1-n;qD0GnBOo&g&N{W9qWq_KSsIaXN^CPgi$3pnWN3BE!ew8
zp7zzE^bRuqj!(y#h|>?!U88EsR2Xw+$qt^@?d5TVmH*a#fhhti3Q=t}thz@IY~XTN
z($0e0_0m>KcPCZ3`yJFXx_>mAneD@OakPrI+Up&p6HZ@M<6*=#Av)1al|a&nca@Cn
zQ){&z0I8+5g7|8ly9QUdR5~?30{bPV3B}i^+EMhxyUDv=qAG=?5iZH&Rlk^RtEue=
zEYh~?1uFK5Y1S$#fn+26LQD0)$Q3(8uj?XDb4W^dGV6L<pH^uzzntW9cPu*RjYjE2
zdT3!bm8V-2MEu3t#(Xv3qR)efv^(NXju0#_LO8|sEVChADq9gX$$Ab|zFxf1#s&%X
zqRAL)34I$RPg+|v-3F%4byP58QU@D?>T;daW$4{2U9gQ3p1b^0$fsxD?fq(2nw(e`
zTxS;IaDI2)@=`8y%V34_{dkd$-ucy9Rf8(Sh3S+Bs01hDR!8}HwNxY<i|rGN1F8XW
zD?H?7?!hPgle!do9^R$ip~OGawp_N0XelY`D*E4r^=w0ua&mw*RhCAX<!-Ah0+>M+
z9GII+=jquL7>n|pL(gntgd0UcLxTmRg+c)oRh#-5&5e^2peb+-JNpZwU}6%k^4XOU
zq^ADKig~2H*zro=%1!VlN6PE0Q5E9%*Hsny<tBMg{%uMrz^Y<y?lWLH2p1G2_yq2^
zy}{ZGmkCGB4jN5!3jq7vz=v#XET7Mom04?b`jc6#tgOW95dB6*z1wx20#|r#E$g<W
z4;(UbWb?swKU}_cudgHV3uG_(l0a7ivAl;p8N@>Vqzc(BCAI^*KMF(vTQKyB-yk^u
ztfn^_nl^5<>TZL8)A_3#iup}m`Vx}R@WwPer^B{3N*-UH97Yb>?X9g3An;9~{ogN$
z3+Ud&B03h6MO~NM`-b}ySWGcFZ_h-_!Y@jWB*0mq0AOy+!wIU#x?i;6LVv$<(;5rV
zwdgdGVw@0i2sSG?2#q^rPM2X0F<JR<N*91uK$CHAQxkIp{EPcD!Tp)^hNQaA(K4H&
zPdJMN9uSDGx=>fmBQrtz_EXL6XrZ;o9E&R?7g*WpiBOkmwHwgaLym=2Vigq`q>F`6
zS~~NXblXWB<k5dUerx%=#=}RTqI~dh9|!!9a4<PsHr1TJ*v1P~T1%E!eabXdt0Lp`
z%~uUXTdeh2v2s`B8xbAuqb(GnX?4J7Tr^iQJ>7@5`^w6`puTh-wPutt*_H3Yz*=V`
zX(Es0eRk48LNFvK`?fY!oejsc_!We>#zBx;ytq%YZ=lI`n?aRB<r4}jsl<DzLYKCW
zb5~M#!MTc-rHJ>l$dYP9hQmyX9r)Zeg9Gb&_QC&bVq>^M8V`<--aJ<^i%~!MpYB%0
zT|c|X&cOtwebH?uwp<ziS%HzEGE~d`FL7%E;y$wl(gOW_y;%-OsVY}AjE<@v^)#J3
zk=fRdQp>YM$w2YK_&#>*h0-YIl0n-sY5ea6cSeTUOxkYBuBgHx&PCNdc8uinU4;i7
zeyZyjzJ$H`LaQ#o1nljY#M%-6_u)zoAnd>*J$p(C=6|dGf94ddppg-os`~Q3o}8Sb
zyPyyt%^M_N(t$&1Xtn)8pjZGZheDv<++x3HtDJ*9ET9nso%anw>Pr*uguPBtAsw!k
zRt=o*OfFQV(rNftg|+Un2`Q1=t+jP>qvLpEjyacN<!cB8eEO#D$Mxr0!;Rp0h|?jM
zVVpH1zx?g4!zzcv8Ko>gY5npH)VS}^o4se~T)QcVlz)0FkChI%4xOX~Z@9D8Zt7L!
z$#up4UR7x{w{>wl!*Ar%BIu;{^!vH3JZRRcrm?RkoVl!rLpF;np&pZ`d*vMRLiRXx
zz)k(?37CulU-`=08krGMOp*$^x1Pcr@R(O<)Q5QZbd9@xn}s^wyjW1|swe!5cK74l
zOYv$pp??ThveO4vqVt-iuD)U0mhTZ<C4Yy2&VJ;+czZ{pq^B`9XJfXA|IG9R4{7|+
zXz4WJ-#*w?@1<#Uzv5y2c}6p##UYz>A04-1dx%>R=?G|AH!$*-Tt%HF^&+q!UhRX{
z?mJjE$>Sgfqx!JZKPYA84DAUFUMyD)tR+I_Ed)1qPyE&7q{(*jQ+j!h38~=74T6+V
zS$v{A?g~twrZt}N8lj58{?Q>4V{^LRIR8u1%t`RX`<Uy8l)yYHGwaEm5P`B-?PJJ{
zs1FHv(p)Ux_u;-YQEng2sv!-{J}|_9pK^B&vq+z;Uhu1nHvP&6?}yF9Y3#p$vp1g4
zxuv|!wt%rD<krpOQd`@L)n@*e3=Ts)(HdaVsYye$0j}-rq$4jiK3T*M`pxFBh8Yw?
zK`@n=&ThsEXs|iUV{z-2675#w$kx#SB{Vdezzv(J>A^bkYRxYE%{dvv;??afdIYAp
z?GHS&yOTfD@CrF?T@f(MD*BpR!*mvaO3#BC2UwL0=#|;VB!|VisWlC7Nu~5f>bLh8
zZHm6;z8_dNJdUD%?nZg8?D+aa1E#W#T`|3}Db<;#52N~Ez4Mn+Ru9)HsqY09x>Mq@
zvG@FM<={_d&HMo?c7#m3yXg|a!;ja#T9C~Xqb%z%GL+yp!CX6LK#Ez=He~4iaG`&(
z>e5(y;aN{~WDKQiLcO)>>k{C(lgRG*ayfYu_bD_?Euk_oB;*qnlo>*Uc%~<A<voyF
z-5W<TxU|0o=T*N}S6=w(fe%jV%cbU#0%js%CItr04$}P^r!cuJ{kTu<xWl*f2=XR7
zt-31d*D<u?Z`NPER<r!QpWq`5GhbvbEp`~G@i#2Ym*#t`E{6yT5z`Df{n0nT{D}6B
z0rf^`zD<Vgi&~fQi?8W=)Y|{dZ<Uo#cq2FHLsO|gvQgUnpFJ)2HTWc%Kvw&E$W$$1
z5Z+;)Cpx#22IaKx0m@!5KX<V|#6b;4i$#W5*aQek*7%h2ti2?$4-I|VAvzx396QHf
zg0qj>14$ZV>5@?kbtwh<T}of{ueat6!1sLTo%i)UX9ldl(5!N<7$`0wU>5e@GU2+5
zeq2_$UW+s%rsZ&dgaxy*r+u}=qE>=_ZtA_TuMe2avgiXhYP?%GwpWLsOYnHzHaJ0E
zN~{@4O1P%4vLJ3Tn{^pH8*erf{P=mqGJg*K>-02i0rds0)(a)ILbaML4riFT%ip@F
z`g4Ha9IXT;1J<w18{&XnWMpJwrWgnWYy~a_B{gNWeYV@fnQ%YFwO@1gz|yzMbQtr$
zH*d4(C54P-b4mpNT@6EpYsK=a5(1ibw|{gHgoS8=_lAattx{bIM82az+^n%)RhyOl
z1TxPb_5vK&BS(xG&Nt5Bddc4OQ#dIY^b|vp(@~-D{Cl|iVyPYtYdc)@7bxY2PAMTw
zH-Z&E3==(3|9s~>;P(#tXeC;nU8@LJzlE!5Zgvh$rT;9O!kN!SAgcpcRp+MmD`~`$
zBVepmhZ-_SEk8+kx~B=vgIy6)|6~2KIL}(5!%Mk%MuJTXtVdY)<SP@)v<%guao@2`
zy%d&nKiAlEPo70u5Xtq4;cwm5m*k&Ecmf(SaIB(m%OD0h>A;aB-%<qwNFjq)(nl3?
z&j=$y*F(N1_rPkhlMj{5uWqIAy9edQU8+JQNwl+sUm7@k%QKgYgph0sfH9Mp%KH)j
za&H}-$Fr;^YLxE@x;GuI!77n<M<)1_yB<E{o)($Ov%S1`(<40|64DI6dr#~ZOQ)|W
za75>da@(*SP(DOjxr<ffvx-7~p%|1!vOCavPX|lJk5_4i7aM0SYN5_I^a;QY<Pe}v
zIx>)8&4|mqKOJ*1{3XN$B3BaOS;2cV9qrsNSEI%eQDrMcXW$bq^;eF`v7j{lj9=mz
zN^ygU?Wb?I3yR%!R<@ej;q*d6QqbOaOT1s|Y@)+aPazZqd37q|+G>*NIyXtu++_6s
z{<QMtAmxty(;LdRH7W%IhF+h4?|d%)l|;K^muM@Ph5?zAo1giOYGJSrsx`cg&!OOG
zudQSy$S$svU+0=glqoGYvF&oHUG<-jfP^}rjoaYf!L_*}eU0|ooh=H3M~q;mHaR_1
zpct#LE+5*yEx>mYTYWmT#_nCA`(nv&rYlA7{;7}HMv#IQ^9=uw&UwqwAa-Bd<w3GY
zB8i$bmbIOuU@l7rZ34sWQGZRxrpUzr$u{uMj0JKMcLJ#?O<)9a0Tu!eKc`Uyu9c`2
z)G$@<Up|xsu^HkWS9fCW7<z}-^?Ja=@IOlkcnB=2t{EeF+pMwwKTw-a8e}pUSKY|)
z8EpfMMuy6$@q6kB9^?%y+oKtU01HQ8zB`uq0Mfh3dTW~pD~UXL(VI$I`P1@LPhly<
z@Z{ZG<$>kU_Ud~w!YmSyz(8>H2fMBxAdfCb@&aIgAzYkzO@5Zk(odOfL9JzYfch<J
zi+@NyE^K5P(h(^Jx{fMJTt_x&HHh@nY~S<%DW$|(zj{ioBTSk}qX<E!gASt(*8;iG
zL_s5xf_Cb#EH6r$qP<ZL1ZMyjuXp|afNHu|qF0wxV*NDrH4B|3du+my`}3$_|5^_o
zOmBrL@d~0QCaQ?KHU>}46pq51QLrWywLCr*$lxgqgW`dk(`ACxe3Lg0QD1Zwzq-44
zkTp^&u*L7}UF?F;a7Yk5hYo`P-;5W>#%BlP)4)u41p{_>G~b@b`AY3Pki0RiUyBgP
zb)Bpra(DO|gKvx`_!o?rPmypkH8A}kzq&O>y?03=n=Z6`2_KEyljMreB}>djefpv<
zLnM=@3BRtN(Fm(d_T0rvSE$Jx!jT!mat%vaf#TgDT+sgn_tZ6KeX9h=hUQ0M6n|GX
zDof$^{&i2AGRW(#1b3dOx|bCfJVdxi+E2`7^QpFRLmNLeSk@wshYA5vb&}m<Z!VA;
z{=I`6fkIgcZGpkNn=irV41Y#-eM&@^H8hIevwS~Gpr^-`*wjeIS9>T4L$m~^do-%V
zbi+38mTju=&m0milOY9>J^NRKG)nNf_eKz$t2+1b)qZYgve(LV!k%LYFEcZSvB{D^
zdOI5t`UXwH$BR?{&y{f2$v)e$FkdMsoShM2S`S_!+c6Cn;s21f$N>4le1=<nGv2-N
zFR%Cd!^Z;$f7-tf#@+_gA^Z3c8R1J+bXDOUP!zDiJo9^AaJoEJTt)?MDohcD(&IDJ
ze3BO+9*V?z&~wmY<wRQUuA&@f`Uc@G-<3d(4=a8X3jUdLzuuXvx1eYp2K#tDnT_l+
ze$RY|A4!x}a~mJq-Zh{1)r}RO6qHL2J95E>-vT1e>}VKi5%l{~y}skuyyd)S{eENR
z?l3t4M;)1G_Xi8+&guPC)$n?+m#Iz;VL{<jh`y-Og}0*22)Y#SK|c)Wdjwat|5&;p
zzy<#mhK`ZGK!=g@a&H!lz^^b%53g$dO0?~@QO)q+1L;RNE5oa^EnvZnm_t+L_kjw(
z?%p*-foT<da4Rya&bM9kTH6@6V_QIiJnF=@jkw4fjN_f(HAPZjm>z@RM`iR^#Ggv@
zcUtZrlR$d>0tnD&t*UcYWVWr3RQCCjkjU2wBcj?R!`sQ>PDIyDYsHHe`%FkaL8MgP
z?26O}r(NH}0!pK81)Na#SSN|;^_Cm4SbNb~EfukE8dwv;a#<zxTVH8$&kDHel1j*O
zGlmDge+q4dzq~}>W3He$5**{YG|*|5R$KUz={?RS)^7*0*=KT3?G>#$5%g1r{}r6W
zbwP+|Zi+x%KdU~n^!n+0`K{UBIFx|*M$3lVQaA=hpADuobLAK*+_jK?J|Qa9;KfBB
z#j2Zje@|7Glw8Qq-?|4~6=`QAFWpIg`}neyJzlGWQn**>Oj@alnnOKpKaq?qS=CU$
z$ru6_d9QQ?e~dRRe&uI`v9eL)2M;97;^+S`hZ0a2f;m_9QFR}UrvHa5`9C{5PD02R
z1IpO>Pi|uWUizP(C>cN}B_)wFG9tCL+i-JaXJr|ltu~)fyg=L~aOrrGp8-HL;9I>%
z8khUUEvi|Zxy+$)wgQH7%H?Qg71Vqbg~{_U6Ai>V6p}kpdJo73o}JJ2%?SllA#Z^G
znsm0qd`EcZy{)2X6gfa2&x}9yi8G_%ONF?ziy>Fu+*wvkKl&`)zTKrm;oC$zCK{eT
zoEObQ0Y=0ivdCJ38uSm)8FRMKp+n=EU%^+VN@K+1kmBNLzB6HC%=#PBB05GQ`?E$i
zoLhK=?Jrs=O}~WHgSgFFQXk6Er^)#60#`SWjsp@(*HzyVCY4-1RBqQ3JwRFn@;UK)
zw-4ec&qcNOMf0-y4D5rD`g53KV8Gs8O2lAj?zZ^X3rgzqDRlJZD*1MiNhY{DDw*P8
zv@$SYTY>^MOOQQ@YTS4!BHIy<LB8NcTFR%$a!T=LXYg4NU3`EEh6SSxD+;0<B#K}o
z&ltsU!_alc1yYcUb$jLNz7guK_V~;QpA$gkyyS9vP%FD;-!f&r9J*DPx=N@7ww>3s
z$vvDODnsUrtF+_@XNe9@K;0{yItn=Jxh(!RHq!Wr=(4dYwBFtSo(hsz4{MX9h+X&q
zPERz!_BzIL+^B`Ccm2zEXBe8GR7zakcg%h~YhQ}oE{SZ=2A)a&sE!G=EGhO!dZ9Um
zto9xt@t40-N__HvI($50Js@A+wCfI_cziUn>$tqG3~{ZE;CHIzKj~p&U<`%*6wVw?
zwF@N+SRMLYZ9$ZBkU~lQb6y7}iGHfL>$s9-_hyHHT7myY$?gD+tN~*0=xC_NH6}?7
zfNkjti8z8ngDrAjGmf1%y6CymmVJmdY!|E0{NEmh6b94f#Kmy{f-{nx)0_3y*qX-s
zX83;BsW&|&V}lou-xKSepD|If|AQm{21Od4eiN2N+^j9Q<8E1{p(D&0=f?~HF=@zp
zoGv#)2#C(Allr;BE<httUGI0I;4u9Trk9d?j0-EQG0DeQa#Ve+9yIUyRq4-Cb|66Y
zXK$G9Jw7p%S;~9Ob_TB++m1345;XDh_KYemso67Lao76w_vEKvt=ugJ?quPoHJ8*D
zHt(sd5|YGFIe#*PT5VMY8=J66pZ64vK>8KoRyJG)$o=TFRQ&XAtno(pee%9zR8E`Y
z25&Qnic`^cv_gVjO?8(7E>bLuJyLM^q`e6n?b|Ez&xR|~;|?~f!U0Bm_y=R~qy=(B
zQz(Mkt*T=(7S#6Synv>{ok_o1ncOJCtO?`&tPR0!S!}R@$Di7D1I!zT0LuDSJ^9g_
zR#-$-#62iT$ugL>OTL}Y<tG9)dfV$Uu9V>pYO|qbV!z9PG&Ne^2auDY7FJ=p$#}Sg
zl|Pwb0I=KH1YALd@I2e)iDvbVy_Mpy*jjt4p8O`IanGo=wLk47R$bodHNtPoRCT2$
zcEWm`!t*Iw2{sz{GMs!xm&Vo7(A9vzcZRL>Qbw1oqXVm9jJjq2u^IkA00CP$N~ZOY
z_#Q{&C_lBvF(WCnK$}FLpnJWY3d$liUwbzp+Nh@+IsAsq#*m%z#VM_BL0e@$d5CfQ
zoZ>9%`CCqrn)ttkE1ei(+n|xnYr!<(zn1>MV!Z?Yw{|VKy}#JY(Zt3E2_TP}q2(3V
z!WFBM(*m=T{6+}Y4QDmL*M4%BJpD=zxwgr+v4zJR`|{D}*>{ER8t6Mq)V`%auLyM#
z#l2rv%u3`$5C?SfBUv<lngJq@dz!Nu$&a)4Hi<fRN!dg}-WxIW>}DsYZ(j?7!JI)K
z@$Oy_)ps-CS~cz_qEa({|1wCY?N!<LDBrrelJinV&HDOIkhRk7pg-#NRfcdFwxAf2
z*u`HZOJN#%zL-=CZ3R!!#E5p58~0DI=uS+rvO4-|*4pKA`PZKazr`vMTGv|2H7=jt
z1@<}ycHPX9Jl+NX51R9@@+icQPtp~U$(80aYWf)d*X>NM(J5-*{B5IgtsohlphzQO
z+)|=-{F5>s?f~c_q^L?heOc&7qL}iy6vTj3t~i;KwN$8560K5xQ4R84n@jNqg_vz%
zC<-+segCJQM4I2~{OUhiL8e%L9HlV&n^txH!>5UBB!<_P^y$cH@j^+6r*V@HXzy8J
z?*!a-GK-<(3AWOGTTn2PSDRN(S)3jhbJusIu(Tp~V(cmvj2x^Cc3s`f#;OHdo(is7
zr~)&43KrmO{l2&V{T<C2bZawz63ln*i*@5g>iM|as-&J|Hp&IeTvau7b-LtML)<+;
ziY&wdn@AcU_Y9xRmQ5+M7$+Pa`i-IDe|uD}(o#=dq~I5n2*M3vo`#;NO|at^e1G9y
z{U#YdkG|6sg`05rH`5Ct$?Lewt#dn$8_=#OKn-KxulBw-5b`$>ktg=yd%eG^1J8<;
zJjrh<jNC5ce`>?nw#<(QN^vyjv(>V5bcWXAI+;iw$Bv^_V*VsHcB8{Ni#Q;pAgg}v
zzWV%Zve~}w7LZB_*%pT4Q|*Uv4Sn@eb6b|VBRN^zqqu?^UDi`{caq=!v#kRf+?$Y0
ztAsa<_TK2vy&$I$m!P>i+!Hdi8}NR%4V+pybVTvez?V09O-&JEae_H2$bp+9YI7sJ
z>mI`xas=VCeu%-#X~lQTMA|7_ZyqJ@^mL)3Tx;$keV3D;KYF73$b1ybfVe0rwFmcY
z!G{!#pqpWk!7DR5kt=Yfb_7&OZNHjG!&$dNRhDZm)VF`|x%9JC9jhp0bjkExLP_Yd
zYLI5JrmO0;h-Y#JA>zbD-0mH{^QcT|xywhG5;kMp<Wat7{m?`%q<4$C)XlF8dMrSE
z6Wl3lQY@{{XaARP)TIlc=RLYZNqYZY`G<%!7V$x_YPrpeBM%P&R0BA8E;c&kQhY9R
zFoSnJ7zFY<&`{=VRp%2-v-wKOws!uCd>lMxd7S#fP$`#Xv4ha;8Gf5$;Z`(hZ%|Zw
zHWKzjg``8ka(Hb_6KfY_RvDMUtu}X~Bdbk>`%#>E0wPA3(#7LbB?m1Dk0YX_l+<#A
zj714@o#r=p2zEu=G`SU@S`=ccC!yD4I29tV0!})4_+*OIr6%u4>9dn{3*t1P)-y(C
zmPy@*b4joH5>D_`7Zgmph}gKlhILxoHXcJci_z%78D@!>lz!58WIS#gc!H4zDd#Ai
z@+DJH0eE#ZtR!Avd}nK}5E!H@>v(NzvPpjo1Yb`m#wELAIDB?Gol^fea7k;g!?3%H
zKpkzGy~@C%BA;pFr^ffoViVv_!(35ek`p=SWv9|#aSu4XoGuQe!}$2LbWB%d^EGZ}
zk8%YCyj+rH?_I>c=LXE%s%(4ih{4x`16~W4IJ3XFm59{|Lk?7%Sj=VA9k9E;JH${^
z>q1iF18n_@On8PP&V^cbvB9<WVps4;R~3zCMDW5?o`|xs#y&ys)XRM?IOe0~%k9GH
z6_Y2RHyenEE@v#(P|@z$&HU)1eyN8+uvj4i`o0=Jc(1y5Dq^>-d1AVq$Pu`MsJydA
z*~eageUv>o8wG;~<He2!c{N3H1&g05f=#V^!e6LhE_@~CYn@tReWQJLnTJJ{?0UXI
zSFi3(mGBWevOAF^tO~>Ua&Ozh4NM|Jf^6cH6$ZlS5BK`3+-d@}<kg+O*yG*O&;9@E
zpcfr84*dOVy&u~Lt=y(Iq>PU%p`aohPp<u?%|9;<)ub)QP%6XF0oaIlw;{dye7onQ
zh(nmfS1{>EeLMe16DeM?j(?b8^Eoh_z5;msXen6y`=!leL$9)pQ7A$C_rm|u>1HT5
zHa7u^g*+r9<9OzLi?^^MHhu%3(s?s<P_WhwJen@Pnhy#L$=vIvPeNcm(bqeV)Lv<I
ztN@%Cx7|8<C%n6r$PXxbM&^|dX1>OU!$0QLOxmp7C8wFRa0(?e*0|haw3#}FF#!WV
z#*0y?+N#r3d4kU&_Kv~)>jz~O`)-6)*9vA9Gkv;~Fzt;Zm-yyr3ip1@?r0IcV%qhC
z!G;4~YRiN2GIKFBWanwbRNm)skWrca>aX<1Xhea0QP#GQ@?VWp#Q-pBz20>A32{Q`
zKKQH=7OU}hU<Er1p)nt5U)E<{xL6tu-g?Vi(3`!fZeI~3ALhM~C#7&s=u<+*=}B0X
zZBRkXL76%q_X3-4QQYB3^G06$&o@3eUmg-p!F>BG6-$NcGBH;QRF$O-!kzwU_a8d=
z6aJUQ`oiw+X)v9vVFU)XaD*`cdK!hAMGVg!eXRa^oYlvl@!(2Uq|VI3y6`mgY-#xf
z_{jm{{f|<*T~Hvtygaxlz)S}X$T6<nz$mC_5)%(|ly~fO-y2ITGeu6!+dLZaffIIs
z^117CcHj9fpNZPD9Y1Nh*2xrl8RaG!-yk?0%ESG*)ZHBy#(f#KVQ8R~L}i_>NudkE
zCL-$XG}(2}RQ-Bp2RT@89QKAzm&rw9XvA-yS`@g5pR{9YxA0(0M7_CjUm?YGb;B7K
zYCMyAZy35RJuU(uc+E!SPDYNV@F!8KbeN7K9|?qD7zTTnNWmUR>VNvq*Ou-4R)4xz
zmEY2CZ<oEbg6uy;;)abe#sY!sZuSek@k1ceh^GlA?1V+`)c#^q#LQ*m_N%tr9bSgM
z;2H%@QUMBT^BrM037+KpFp4kE(J{}hN*xUGuXzj5ARt-~W6|LQ)!k3lq(EJ{_B~5J
z-sD?~=cO>{jE8SbpIAt*oMu1AlJfZKW_PEBkvO|o?PgFh0E0_NK6c@LB1ugGw~XEx
znbDfkg-f2|mmw*vdhZ28d?an>*P6YIsD;4fPXS~HJ%SDvi?<8koKq5wR@l+J>A6y0
z9%4uq03V7?fDLZCzMrw4x`+$PPWnIQ#=t)aok=34z<=LJ83>SoN?eo&74V`%{gs#Z
z0mvU2*%H`?M<Zq>_0ARaqc#o;34wCS=O;>KF+fd8$!ILi82)C7Z!X-m+$~=7RXYi-
zsaoH_>EdEPBXzIP#j9RU+$l#atE#Hb9POOxre%CE{9S#wW!<}vcc_25D3zR?rPtNG
zNAQ62$o_D%sxTJnCilJr{fV4qm(!GE5{FlsE}xoCeW|X0zjo^`(BQ_>iWC5uz#B#!
z`SiEMrrB#q+SRSvC9%D_JkZkGiH>(@+cHzAq;44TRXN^~Si6r)-s9@nR-{!X^q8Nk
z>lSQn)oN@Ma@A^&kp!^G5q>f!_3;x%^dVI1`EN1&a1`^SLFoTOhwuH#Q-{-Rc1hr8
zYbvRCPYKfmoQ>r8O7EZhHaLO3c8JHw>I8yTq>GFp#V<6WLVwuvR18rw7g3Dk78Lgx
z(4dmYVsL1jdWO^1`RT{!-+7sbTTH7MUCQIT<D~Ny;QIy*AbB^9rt<8o?Df8(*N}7F
zQJ$;^5TX+EpwQ5O1sKJ}pq>4EJb8NC?-h1Nkj;?8#G6LACZ}3O)0n%nO4WZgI6lsQ
z>z=|w6Xd}GqZ~6}P$7>iHaD9|b@I;ncw75hY&J3L%gyk$^@+VTCJXsouO=9#qxl7|
z@rj8h@@K_%aKYgCMlj1F$(D3{eP54wdMcA8vERW<QxE)+ZQgtH54_S-{kkbSfWz}W
z9kyEfFd_XrRcH^ZsSY($g!g?65jkz_7ajI#EKH&s45}-XRfniWUoop+TQq|Uv2?8m
zSN!D5QYJaXM^rjmO>r<$=(x^`*kD^&PvEuXokg4(^%#|8w~-2bq6bU~fL`f*s#(_Y
z`NHz>`~&sxHuq=wp86C=-srF#sgNdF0wqnRQ+x#Dr@S-Pj4-}LpO}P6<?j-~kt%@W
zL(GdPfLKkAuxwpfe<z1=Dj;dCIBPGpU+^i(-F!~`x?aRoYyAr$NL@+4)26+pC8H-f
z!&!L<_kYkBZhC+N+a!XQQ}ln^8g$4{ctL>1Od2i35f_+O!t7QWoUr~8-2e`Hy+Ghb
z_gwv*Q5vB6LB?nO07%s)4poY7DFPk#N4djCqdCv=k2!Q`oC<z-RsAxgR^ah&NNcI}
zuz{m#ZsEqM&^V^M8EPkxl2FGqd(;m0h@I-LZTi~R$Hy<hQ&mt@2Fc1a{9S%sI4t;E
z_h(y???2WBpa7hfrV@+Cwfh?M4DV<zd9di!V;jYs8(#bFi<IX6n(yK+T7r^YKcF75
zM&N3dhDX@MeEHc?z__3Pdju(=5{iHte$r8t%G7SVsOAc=;h-Oufq+96a@NCati())
zos94U_4mlsCQ>)L0UHd%soGIq;$?O{fQQrb$86aIQk#1J#3<r<*RP$FSFE+DAyO=H
zv$EW1p)h1I?9V>e7+;t!u^-<^ty0;3PH>bN(@r!6+x`>&QRY#s<i>7VXNZBnm;5sI
zK&lk^t&#oNCI08KMnfh>#$2z(<!;x;BhIz_kWKDaH?9tS3VV&?nP*^kO6*jS)t((k
z9Y0TxAGZ?(R|IdPlJ;2Ij-i)!Ctn&ZhM|1H9mNkFsl_Z*Ty$j$#I3E>Cg^I)Sy){E
zRIb+LCwg9ynjLfz;dPi<8X#~U^>jdUejShtXfo$(<FrBcAlamKEB-*Xna<W!ESw=F
zH6E(YBsS2@Nvi7f8+b>t)tM{CMD-lYf9SvwSl}$L2e#={fM?>06`{;BDBQl9%HRHc
zBi`gAha7&qhh?$*(R*f%X;uQ%4}K*nqb>UC@`o#l?QIbcX$IC6D>{?|(;1+yAi?1p
zO2z)bQ`sE+1ec#D*0_K^O9IeP_`9U|uhMX<RufA8t|!crr=0|YE4}g>H+>@86zl6!
zP=jkSDtJe1KY2}(JnlXXPwnADE&ZRmR}6YKpgyAB^*`js|M0ghHQ<|CTRGAOGw_Sl
z)zzy^22tnO3K&geECg**&7pV!s%8XMnPq*2s1Ds*?AeG)uLI*DAgd1wAP;vqBf>01
z_3oOI1Xhyt$lp0z-d5vs^B-go#o}5O_i1_UnV;PWkOeVbH>aY~D7bm&EuY8LtE0-V
z2L@q9fSESPW7hC4Q1e-yo47SOfL@Hn6AseY9^8JuUjBuIk?)Pd>*%dh{q_cDPmjN}
zGQ;k`W|iPreOB4(w9g>zK)xrza520ElWxlVs$%_vG(0_i5tZBe7Ye(vfClEAEW#xG
z5oeAjcF^||j%RgsR<-_lJUY>JI3buqZrEywq!NC<{;sLC0JELQ`;C()hrW+<wG4KY
z&Em0~K}KJrzH>)7OURUdoNKc?{Ogv0og;4NXiQI7T~Q?ZZVrcOh8)SeFsQVy=D-gL
zW9tG~e5M%<C;31KNE|G8UER5dJ)dPl_lDnxibo47op$wyb#~^{1+MCjyOk_UDSN&=
z@QO#eyRS6-xESMbp*}}~L(BQ2VGTp``XpYKM2m<dOD>cf24%RYQR4_vASUU7DViSf
znCgw&8;j5P*2e$Vm>$y8-<gs9gibYkGBkRH(}z%OE|%4$1To3<N<^B?1O1HxrH?mn
zAIuzd3e5t^=s_G-52p~RKE0F@7L|x(pG3x+OUc6iF*cv)CX$~xOi)12EiTFt0X*N@
zB=_#=dK+>rl<N=EQ{jU%WVm4LUu|^GUm$SPK%Ulafw`;wV;WEE-P*Y9bK1(A-M!PE
zG9}qwY}6)y`VeqdGyl-*5s*S@I_<$TV@P2cV$hxda_PMI`YAl@i%5+u&GifANZ<s?
zhxU{MOd5jXr1Dt7>ZwZ|{k4HGFNs81ekxo7BCxn^xIRyYN<tS6-magFzNFQ^eMr~p
zKZEKje6ruaSN>`7<st$b8@Vk$eg2FyMN-GyjZWI%-@kF7)hZoGgaR03h+3lQ*_E{I
zQswy~txSAhZz?}V9z}deZ{$)SyozJinMZBYF}Q*Llb%G{h;`w3i2}1;0qSn|!*jes
zfI#XeI!TYudBn7R+-QIe<FFcQK0HPm#_|!;BKOR;To0h!kf_rcBsJXM`!P30XAK`3
zYw%&8%ePovQ#l>!E++&1lVpb<VTFbbS4SNor-%pvk~#$*^0A>5tE;Tv&dIt#Z&*M8
zb_V4p6axN$jPxE&P!su)!RiavPf{%wb0S}6Ir+fx$v7AvG$BhN$C{}$9jR|0MF5OX
z6<{KUuc3eBAy-{OZauW0n1RMDL-oBQH_cuy|8kxl{vMCS{X^~Ju-snM$?A%em)Ss^
zk+IZRyCC?9yXdW=^(=TenU3g3nI;_{9}zCIZi!}bHRCa68N@Kw{rWovPnG;1fTt+z
z>dF%u`Vf?y?0!H?tw|oV^{eu2Izz?Wykbh>w-(^X0j&09$1+ZQZ;w8wa~|?W@+i}~
ztT@ytn1Yv&mVPIf0=e^DP^!F?NZ>Tj-IVjqmq)d^j`_*}yc5$+e6^IX!W7=<POdxL
z2e&A#dVFt<So)Ll6o>t7bUAkuK?zy8v)CZzQ><QI{>#qJu4Jzpd}0E~Yy#;5DkP2|
z3cPRZK9(#z?w2(h@DYq*{aMyl;xxVu6F0d|70KSF>;%<P%wYbdrnyb;<dy!LEu74*
z46k$HQsbSc7I-k@WfI0j$7&T^nT_lFt2W+BiA~gJ&AaA%Im``=o(d9b4p(Dncx0=5
z>d%I6rKP<_0IH+D&*>pXcJ`L~Ed?pJ!Ysh#fPCfl2tP0RcaVu#Jiha#;euCDjwA6M
z7r&MGnugrA+boUJ7{rSYC&XPpofYC&;g3@^5kzJZY-Gz3zkdFQ^!$Os&>T8~$H+Wz
z_#c-2|MlWUVqN300li;@gx2#O0Ucu`Ptb@Z6ao%)IbIMU?j0n^Kuc?0(3A^&kcSq#
z#rU!pUXCG#Oayc~Z9|UuFn%T_4tfAG-UY&L44gn`vnJip#+J3=gFg^NWG4Abk6ZuX
z;^xIbZLb6Pf)My#3z^QIqO)E43p)@M80yCYd18q}fSuQ>pLSD}tZ}WmQ^!};PYJwC
zOg3a6b%;a`tZYoub@RD+Z_M*=3JQvfH8c`1Cvm7!_YzcaQz?y3-x1)J8}AVVCsawn
zcTluWYmzM!o|t$3maBVSAUjyp3`%(%0XJJ8FLrDTT4}S9P?J_eGmJDAnbxjd6r)H}
zOwhE}v56(|)6wheYxnY3pBW_sqWUjvu4!Mhn@5n_Qyfb4?R05q%r0gWGee<{^}Z85
z@}1!$VbNA8i7x>4-go+^NLgRx^*#&e{Y_6<9Nk2eHloE%ATx={C;~tK=BM&P^}HmR
zG~?SFp|iP_70g&>W9T(&ew~fY%7u-#RV~AnlrMTDmXw?Xdql@Asv%LMvq-SCs+8>j
zLdD92zMkQIVYaTe%aE>-!_E7!DDy_p);QN$G0G8YNNcDg(NZJZRUcoc-6mMKS4wtw
zY&7!JO%cKRCsKt7mf7^Rry@6L+%h%m<J8U$j8`+;A)&+*)34uTOAvz$=PSL^@8+Fs
z+sZRmLm9u8dTXKyczY=3!=HV+vy9pyCJQ#)*f~F9HxLUk;v!hw)cpy<U=b669F`sB
zF2Q6HBY}guZ>-aOb8uwQ9wPe#eu?Qr1SO3P5j(RL#p-tQ{^au!ckbo+KD=Js1YpMh
zswT`Ogd5N4IXvX{{##2!4h=|Bra#wbXK!-<wYBBU{JHppfy>}X(AoOWBK$WzE7Ah(
zr7yv;RPRM5dIPFSKHpV6u2A=`mcMfu9{={5($ceP<1@6=Df%=lD**MJCWtZ|KJNt1
z_UmnGn~0$-h>%kFQ@Sqqk(C(IzU=*Z$FZceEI}g7h;g~3?=!R9E*U8woS2kdhH62L
z7zjXSknmGQ)5sHrH6Jkb?BtYla(y#6ws#zM>Idq}e2O^vaN>NgIZvJg>7+S-zPBvb
zxy{*Pr<xZY(8zBfp9*m5E6kef_K02#^$Ywi=Kqx<5zh$zSvo&B)%4Z+HHGn|D4{WD
z@py#$;+W3@8SZk)qO*6k+2Q<8qwBw30HXC{W-TZ_AU%bj=%=~7y*|tch|}lIVzvv|
z7LUHVx;GAaykF+C@xl6RJH~!~KeY9WSpHU1y?+<*<<SRxWU4jZQs*oTeyf66OOAQO
z`HJ{0I40qp59b(lbLM0Kyex=O*2st<LzEd$&zuzQV_`)rJr`49lzHlqvBOb7vp*V@
zwC%3M-uY(FZa=bpPjv7mhHZJ~dTYpc#4WMFv|l`?b1raX0C1%a!+}#|YU6KXgm>D$
zIyQ^t&`@DB(Wo(*-JXR~`SOBh%kK<U6$auvF5UKfC5fe^=4CU4o#XSLb-to1rXG^^
ztb<Za4p!GBwST5avfw)-T+9ZL47+8@e)T6SYu13mbN>AEz9sJRyG2e=e>9%UARszd
z*5vr9_`hY$5sGT+#sBkKSG0)ge~Ssb&>_En|BjA>LsQBC@{q!*39aRLpQ58Hwpw#c
zMu|*{4HR~AXJ2f!;tHX3XhDm6d(vq49;kwT7-(-|I6YV*J<)B;|1B)=0(M9fNoqto
zsVYcc*DYBfms>q}shC5bwFowy8~D={9%B}^q(UUO*h=W1H~iUhOU}!mOP9Bn48TEB
zB#ciFU~yo4PYwZ%K%uuB0QqwMBzui#v_U0U9cpwd^|L{*oD59AOsI*c>yOw*?tCO=
zTPoQPmVN1c><UUIckd?(G*Tx7v72~^s%s}=xAcw#y(^SV;>R=$ul3*-Mui<t(TRW@
za74!rW|{|9qcw5&LvC*;87ta-v{;4&Jk;v7FQy2}cCUH>8tkK%YazfAM53X2x}2HQ
z(2wh+82e;p^&+4`#%ug^V?;}W+R+`qN%6&Py6MH;g2+Hy`^7^^SC?|ZK~4@2cVH~Y
zYulP<Aj=5LbgC8n>sPX&^o@O<d4p`4p>Tne9?hrN&im&lYX{P!+R__RWnJAOMG_#Y
zBz4VOFJ&nzb_H0kS$>R1*}_*<t<48E{22Ctc&*Ap@wZmF8!0b)2BWOp*v3`t_sH?6
zF#V4DZ3Jf&a070tl1qIHTe#ABhXS=eEOI-AcjDA7_?<?=Hqn86l5iR+)m~8R+<*K}
zRT4%!>rNQHAZ2=3lA~#kY?NE*Ey3SfE2-aj(~r-6Kv~<kXdbv0H9yH%FpHf^9&WOX
zz30{RIZea(ZAuz5<&MyLb~Bt!^?dLP_lVi_LhB9%4RhY$(@i8J(m19iwDfM$7N0%(
z^+=8FD8;6Wv7_*~FvKuzK52%};bWGIV~Q8UuS#T+vPUAxIt+Y#_|Y^LyxRY7HoBn{
zCZ)US0j2ya+5Cr{&dCDJ&i)Yo`|RutklW|EB(!_q8awD%H`Qo<&(xq)I0*fvuHNVH
z7L*yUC>G#oQ|To<q^>`ywbCklkg#N}p76aYmoXlnH-0pl!1src?c%Ai29Lp)wxH2W
z4wJz(M@be$uvnzH$TBZTKJ@7d(qDCo@!L8)+epOsZ@M8=u{9^eU7a{OrJ}ad0!<Jf
z5kFHiO6D3~ockmz-?g{ggb!RPIk~?!uBKDc3c#PZ2~{9-q`JqU^ElRMc$r`uM#PVX
zbIIsYbpLqHjxGdHt*y0+XIAx;2ByB4WQPdr?6#?qwMYz1;-3X&m~VEHrNK0EcC|H9
zwMM5q3(8e209jIJc^Nc&vfuZ6jl)|ZQTC?Cqv?Xfm;_vefq-lLeR)au_{Y4a->9*P
z$tJK@x4)=%-W_>D?LKfn=oUVsp`fHxf;Y<J49p?7Z#E08(X#09xmU_|yFwHal3#>p
znpBSj832N=!FZcB^M3hEJcBGo?jIZ^ghyyUB=6_79gd=UdQ^s~F{xltW0J0}`hLVu
zBv`~M6#u+{mg2?e!l#nKl$p%Q7-uniuFwOKv)6>wESC7HV7@<VN{h0NL`0?l5xHa9
zeKvXoaUeB(HcCR)-;wkwOfh``O}gLqN3I98-S*ST>4N71=R!48h(5)Ot7m*dDMBa$
zaz43?m3T_}&IB+>!88{qvBkJ<FzY}8j6W-zKd@leQ}`=E(>YqjGlArxr7W&IqBJ~?
z{EnQdiSdhb9p&|J`>&VMfkq$2{vkiVQU(J@=t6zX{$msrR=Pk87fc~eZ0F?=Z4HHd
zf4>*S@(~_ItCX7h=3ry8KG7m!1D#}9U;k&ugvCxxlj-;?a%H2}4-+-F^VZ>}^C5P3
zArS}sg1qs^FSb!%wg?t#iXkfT3M!f>{`z?fuW%8@JGCZxr2k^9k^Q%y#18``*D=A7
z-~Nw$2@Fz}r0^R=#f60#;Rifrnf5IRJ-v^yN=)&9ozGhPBV7LB;h~neGZcB?=4X}o
z_rdYH^;HiyOe#p9*bt2PH+YKIVkf)4vF`zoDAqS0G2BLbjq4p700`lAKi~uEnZF7z
z_)rPlpYU-!A);j$1OK)UF{0T8!PE61e>o)DfafOt3R^QR(>H4LctqF4L3kJx&*KRV
z&w~$|pE8@l-o49tWA(ixY}$QC1*KWV2c@((Xa+TCa7{h0-T$LbII5w4rQFbY`RaU1
zNc?ogR?&10l`DE9a9(DwvOVC@7b?#Bb`8aP@ZAjk%N=t?c{BR~3`pTZn6f*sIACW8
z>mQxM)2aLy?$hzlT+M$?)`ieCe|^s6JAGCR+^l@<pBLT6k(jo~Y|;`sDi1KcX?<r)
z>i?yZ!vDwUfeF8VFYHTquX!0*x7zJC*r@WYJB(ghXvE>}`;57AhPex2WoMA0U*)cP
z4^0(E%(G{sawr|~aoG51o&@e2+%OFlfkqC7A2hP9)=(<YBnO>&v{B|}tkv<(OFD#?
zx2c?we2_*k@PC9}Tv?H+9k?Lre5pwfL!Ghpmr41EfP8-OM-r_YjB?(Mr8s6xicef$
zm!NiW)*9WVjf+Ow3m%dtzLJQ>3qbpPBJZGF@Ple&Ki2>@AV3jtKhvp_FDX?G?<rG{
z-Xy|(+k1O1mT}utppQhD6bgU~4YlkrNel!GB+;NSzZ_9XmGsN|D)S5IZH#lDL!hCZ
zo}(*E`b%I&5u4m-T|R7cK(Hl`#t`&|IgN}SB`HX4tlN_b0%@nY0WR%rwzGu>ek})=
zqS9TDZ_gG0JKmXqn;BN$Gspw$eZ^q~qT1o(Qf5s!(gIt{c2f~y)a?1t+2%#}-{g%S
zVaY~f_pEy`A)R0)jP<U7>xoNUo>0&ielo+7xLC<8nrBazr<*matTc$yBpUvuc9YGf
zx2l_J-YUx%;RDQ)t5+rm!-AWUY)M|(0~jM?In4@WX{^c#wz#&D&z#D8gtga)E!kQ1
zlC&sc;@oJ^g_^KxJyrC{&*I$+XcK{W7I8tB?Q@YU|16@P*PNg>R>CcMMr#K})e`pZ
zndc*?6E`0(Lc4*Qo~wb79TFNERc0;CvN%X$PcjSjO_LVWZmr`OS9(&(_z-vPdN{(~
z=;Gm<QBpWIve5NOIaPiuX#uz<-hu0EyC(wqWEvuMtX({XDRg`A>Ao^xZ7=??m~)}z
z@ej$M%&Sp)TzO<mK(R~|Aa(uEEj$(xxOWTUaGze4+m1JL)z(w$8eFrr-?lB^wi-32
zpUf4Cf2GhHU6GcN36{@%vn!uz-`xA`_vCt)(65*7;pN5q@~~Ya(G6H;g8S>*RiB`q
zdcu&ZyslFv4l}>}k3U6TH3lFR6xevh4VcN>@Ho2I>;>Qn5hXP>>K%ZW_@UEfS4B^6
z{4Dl{Tr^JFMlpBo=JSID>Lyo9FL)I;Kg0sWi^S_xUqr~Xq;ouvS}}bK{aa3cB-)vL
zdyLd_!7ERVWXgo|!Gj2bhBqy2irAgWHq28mN@l;|eQfQ)rfnReI^e#mV#-57lcEnE
zjL0x9i?_xvrV?Jx(aENfl#JM%w$(>L#BZ?rOcaVXV;fA4>ba2_yI{>pq-62-Os4y#
zraMnSl|I5q?Ki$Ox$)L(PtYd8NX1VPZGG599-j~PO3~iNxd;J%6twjdOU3sh8msyj
zam3_vFsNCOr*MFsC*niV+h=!!>g$V{W#lwMPEpFUMzp+zm&TttQ``MJ=aa(P_OPwY
z<z1;>6js*VRm8;_olt-G+UQaGKbIiIJX_+arC`s-%`L;)YAs^xf=tA8WvNkbvhHDT
znvOqH00c*tQl?=zANO*;$7_efZHr5Q!|0m9T|Yk4=?4wc*QL4L$5<n>f7@a;^hCaa
z3?`+p&9Z)XPxyvRop6BFy7h@`eSt<E?);AR;SoorqXMw#Q`8%r%D4eC_&!Vu6gNx4
z!ae~>LJlB*f3}r_hAk=Vfia!c(7`Hn?)6mzo{#CHu61c?ntf|K9v_5+(8|wq=YF}p
z3q%<4PMLI_HpVA{12f-7(>kGdcT-Nhl&d$YN4vXmzirb0gpEyjcsi~RBs$;n$Ru&u
zem`wggaY>opOa2Z+^OjKh1dGO3Idv}h}pJ)cd3Wlg@v$lPTuC7;@meNeV$9k+t_%f
zD5NJN!s~`QSf971X3;MK!`v}OV=Pk`v@=~O*9BEcgWU(UfQt5VmJ;u>+2cW>eJ9b_
zww}UhU}U6S7s-9~dBB_ckiIY`Ofj8H-USV~ch+<$(Cx+asB6fTOX})Go4DHBbnD<n
zrPP1|H1KFg9w+NHP(@5M`3{9eNsFM4-_W}@LMro1CZ#Mk6;EjY0rmxexQrlH#y%OR
zThvY(J9)uSaq&Rf(~rU|`1j_|Tv0N=Uf)r%a+dwTo`)L7chTkv<Lxb=sBFS6(<(t;
zeeiIrQl<IeI57521PwZTvQYTE>P`i%HvBHQbnF^>Vm%{vQd@#Q`5Pf`kUpky@(eF~
zPr^_fYkF81z2O@D$da30@0m2|iGK`$#R7T^|JTWXW-z!flf<857;?+q%>6N1H3K*5
zdqEOay-r2D*urgyPLRi3#DY+&Pd5Co8!a)>XV6w-nTb@-3eIj-+}<6QXf(Gn9rGFY
z2uRTUM~wI#<}j^myPKj32bcW?he|yiGtN;mp*F+A6S%HnjinCjC{`9T^RQ2_mJvjJ
z$qgVcH!qN!iq5~w*Sv1{*)v`4MY&P7zyRIxTp==juU)f?t1D|>C<k$>etF_V&Y+p3
zVx2#n4vVEcRYHVfR%7-39ev@_i|_BX9;6rQYF0!6(&z1Xn2-qh_iNEA(9qB#YPP?P
zwOb8!78-K5m~l0jY(UsZ(}f<;&_VE_Ynbo|)D-P>)EC(vTXN?1qw*~Gyf4fyPg&Qw
z&B@I!IbQ2etBw2ywjv*(g#p?jV8{heHsVtV*MH=<yu6IrdUkPfF@+`nEi$a=_IM$>
z{{w%75{J#%WzBJaoy}(NH^18~^RgH2nLmFOYmmE<>W@0}Gorpk{`mC<D&4PhkiHcC
z740DFe1$x9yx+5CaIh6L_oaQ-A!%?>6rr+8VTWW*Tai;)Lq+TvcN`;R>;7;I$;l@T
zfkGneyIwPnOI=O1svwh$)lioP>#FEVQougN4#t|YBBztlb)&1-I$<*C<y8m`b3ql(
zeQ;~zOt#H%66xC3u7IMqP_J|9Q2l)lIVhe_XHzMfc9A`-;untmk1q<WgP>fY%4+`Z
zR?~cFGP*sh3d^1;rN^c!_->8@jz<r|-*g!pT+c$Dp@`E-$e+2>HD?58CjTF0UjbFs
zwzjQ^gh(T(G)R|(fON;EJGL}RcOxMs0s=}mNOyOGG}0iQ(%l{Z<lf`a^Zn=67<(|*
znCw_<#+%RkKCQBsL4+?{OQL+*JHGP|C;JU1!$2<e;?whsgf4>;SNje6{2IK{h1Dn`
z-L-R(>MpB!c$_&++nzwn@dj-^H;szQ=)BQ1bMo{-Ha3A*;%~+#zidsGwY81XClff?
z89Ux`AKYK6k+eTM8r?9QZw`+Ub}(-YSe;^nYREEV#%|^YJ+Ntk9@IFr8#}L56;HxD
zI2bJLY@Z#7+it%~PEV*peA5VnHQjijL;UVij*!!C`s~1ckaNbx1@yLk_TG2^7HTAh
z6A(6nXi>Wt*jDW`<-5&pW>(g$Q$=7gK7mN6FdbZta*_e<H7a|7S;f-_!aH$sn`sB~
zquCFTG!q;byx_`MK?U`++ScsNm-(+t$s$EdKN>ynmZLOU%xw6RJAS&+Eb<yF_AZho
z&voWHY6!Q57|2bvO+c*I8uR(b%Djkk5Zlgk11?cjc9KI8CoUlNdQHmD!DNzJE#F+_
z2UykD*wUDNc$u~q6O4%@qq^JN-tlU{J3X`kqs;1?-Noyohe%{&o(MI_1COMz!ovo6
z-Ny_MRT>AUeW}z|&R3u1TP)=(w9F!ei!JIJzkin5kMH&6@G_j!@Ir2Dhk4qW_M!TL
zuM_rOB^_a`&&IJKt&AlP_{MMq!j!gWF>^&n7B6Lgr0exWE5&JSp*?wGRA{EG9MR;W
z?|BE|9eBMXhQX$Yd(7pChWwO8R$b9?ueECNM~ds@H?(Jq9{+p~_{*n9YPryYxc7b%
z10u<C^(l_9GLFkB1e;D>$Z}|4EJ*k2V+K2em)p&{8b{H*f-bR7)~C;waVXcjF$2`5
zUr3f$DppU=eL~6}=sl7MI9Lnb(M&GkT<_h-LLzwRb9$9Sd8M1H8b{Bln7cS#D@R_1
zHhw)XsoVWf39(kS+cS)L5?juEUD!zLQez0&IFg|Hby+-pS2a1EY-|Z-@Ak{%dI!Q*
zdZ(H}o#zz!6+g-*d(<ua>Rn=ju1-<#Z`P(E7x|F;UfV*7_;Ko0?@-+KOA{#h^FtDy
zqs!}AV!B!uYKtrtqTnM0)r$6<t?~7sJU4+p-3<ll$TCM6r9<wD)vH=jR^h#7rx3iH
z3uOC97h8BT{3%Mc=;x~Z;nCKcY!jEw2oRoXh4380ya1kHTIaxPtbB;1hI>?dn*p4h
zo3ZB`SvJX6C8~!9lhC2niL9%bo##*iaqfEGV|VsgdeZ?-uLsNuELR)k#s{aX$7V)r
zPnc((X`DP@x>v7R9Dc7nJqe{v2#bm;x)cOt3ZKiJmBmck><S!DTA19|TEEKt(H*&y
zx;AtpZe^u%2%EL;jAwxUHG&R)%?Ag7ERES7#dRY67(q1UZdP@?Iw~+)>YDxdXvhai
zyxFzGMXD<6n&pwOr-q1R{5k48&ujR!RDH1pSV8xp2S~^_(@WQ<jyn@}LKP-tJy%;(
zPEnvPnvOUktI#y99P5iBD~4Zi1H@tGET)u@2m5_nht$DAVDOOG=!>ppr@pAY_mzFp
zY!j%#;nU8Atq-uPhJ~LWUon;!3|}fv#1@KDC4gY?o4X2BnHe4PNPdUy(Gp=4xwMMd
zL2VQRLjq_`X4FViv$4G9A=qK#)Sg+5*qCG4&Fv-*3T6RVl@@v)_X#YnN~2kCoZ9A`
zdRF=pS1{M=Ubp3~hOJk+>G1Q}34Zxp&ep<?ZNVwV;98?x3@fj8gE-2xc7g9}*ctTL
zOKD>vs({lrL>dA80Th$*(W#^9`2h>}aVJA~f(?U9oqD!OE^k#qBu-u$Mz~3^d^jhi
zpjpFMY4CN$o<nuVsD{#X?xn!_)v$2PK~F)*i-&fTwwMCM`4uZdc-+*>EdqFYqheLO
z+a~daWBUb(6&-3v)n>$T3Ex(2gNysd!bokYHj+c~rS%s(KEuV*y;9wCnAE=i=OOjy
z3+U*e{NZ4p?cYPzW$~pi=0(8y$qt1S6<~mwaaz&%;>dP=FQe*PUD3C%y}dyMj&p9W
z*%1*DOLe}AkOhhjkvDEL;o;$>ii4(N{cN+e*^!7ZIXDKtMW0Y#_y-4P^u*#WFKa!4
zB_ZmUM8v`w-TB(_#=l58qtzWcJ_zd`7ayPI`|Rb*mkV1B5BK17(j7ww54}><@g<qJ
zOaZgZ;I{`49vJ>;OLv{s)nk~ENA@Q{-Lt|{zBgtquw4e*1>wk3b75JLEhdBS>pxyx
zz$d}hgiukutXIE^Dk)eW){%Ie?>4{q?9~U=NzjyMemea*P5AyGeL#`s^QuqK_^THY
ztlygleH;`~t&cGy_`FB%Yr4?aXbM!R(923MJgIA4%l=s7Q%JBv@RW`g&K7-}xAs}S
zQ&uD;?-IuAHvE+0kafDJ%C8@W13pw_w|KaayinXnuWD%h?vFhZ)O*-_t+Pm`S`Al*
zZT{LE0bPiEiA*as*E>`(F8<B&CwwlKR>n0*Z#{9y2G+LkeOQ-o<8*M)$xP$SEuOqB
zywrm>(ps-V)&U5H%OX+*i3*Atlf<Rm`01AS5(*8JQy2X+9v9Ru`Ab2;r_hjhUUXqm
zxW*f&Q8f+Astl5~^OHF$Ecan|x&2cX&2_dWW_?VG*8M`q*7*~8w#ZE2JUlcNU%i5i
zwhAb@Tt4EkTMrr2%tLSc@PTOkJ6%Zg*L!6AcWdrd*;4rg5e8%CQ!tqfJ4oS{w4x-u
zZ4W{pjI;4sJ2IQRW?7F&PQS>Jep@~`P-4JRW<rr~rfD8R<`39QKfKN0O=VQc=u01d
zPbX=+HSxaMAvh#gxsWV4Dyl@F1&^UOqwVB$q<bKMCvmroB<ggtUtq$eetyS>`xRa*
z?p6IFMJ|8g$bEaYrexn|I(go+>wW0?#M!uG0(?U6f(!NMrH)xyL()93tm5+Z^%Y#K
ztL3`yjZAAPO{yUxq2$5TX4yD?QkBFZ(XyJ>A-)qp^AxIWf@0d4B=w1*3Xx5~RD+z1
zS+uwxjY1VWM+i1Nu#P^+=|iyZ<3!&=>IH~tlVDOfEa9Njvz7-+PY8o&g}*UUk437V
zy$#J^7iIR5r5CT9W~Y3WH{7;2ZxcUljFk<`<AAcBZuMxtUz8WUX6ZQ_?1u*2OAXx(
zYFd}hN3;0lNmh(6;)^%b^wT+)n{))%*4+B2#)I=*qe2dhkJ&B*80yi!yLpE5ytF>v
zRC5Ns<6k(5-Kx}EtxA7a&9Va;fGPd_A?wvqzaT0i@7%p-tRS`@+JaeI`A+r(mMAXs
zZ5whGJOahj5T0XXm?ObE&3@<eAM04?VS2>b2P!*sS%~hy5Xm~gs?Rcoa?Bo}zJ}+V
zjT4B*38FR<;sX|L;~?VHv=jOCfLpfrmpNyi>56@VB7|42Cif$HF%RH9CZ6pM#*>nv
zBcF6e&~2afIh2jNdL6ZzFl$Mx3MB~Cw(9(-Iy!8Kk}=^*u-o`fMW4Ia`=&2}PAFDA
z;EnZ@^4p&WFCt7?B#PWcNr?%jcc4)`<kXLrO?+izLt?Z1>(J0p$aC%dKi>Jz_y6;6
zzbRsA-IdjA^G#g}wzaqr5m?yUdwyql)|nO-k|;nMGl#Z~PH(nH2+WJG7`xV1@<Nzg
zArEz4XI6RJ^KALF;=Em}4%Pf5A`wKFzc&n6Mv^IFv`^B}q=p~Uaoo9!cIR#YskWXK
z^R-DcZ36H?3&@57K*v9FUS3{tt|oKN;^Jc3M@Y-a|9FVsZ|x3DV9Yz2NzLJt=sqf)
zJ_tv{JPoy2L-G@bnw+(R78uYo(LMAt5~h6t+O|aY3W31TON`qm?Ei>>6^=cS($H%x
z!rZLLm$Zi&#god3Y&h!AdgT;TPVkcS)qr7MZDBy5O8RtmbVtP`it(V-ORN0}#A<`H
zL-qLP59p*US9=qEmuCmRZI_p@w94#FmZzwz$-)88_F4*c1UqME6G5XliG$@HljnQh
zd3ki8!zpz;JsVpv1k&XiSyf#v-yK2M+1jdh`o2~g^t!g)Qjb||xD<KeGF{aD5pa%M
zJ2*rhtEsC)#>dB#8zdpp(#mbJ;RpbwtfjlD7k@!VON-{lS0D$0`0sM7zY5QP`2Dp<
zKt;ta*~%JmmRL!NjrY#+LkMJ$hmv`$GKdLqYdzz217Lu0<fW-1^m+_Z5|Y%SeXAwC
z)>qL*U*;ATNaDTR-0BCbqNAdOKm*Ub2(9yK_HwQ_goK2|O#5W0s4|RgxVq9y?Gb%L
z*|6o?x@0cI*0PB|($9B~^Bq^!6cr`U&dM@M^S2KC8{ohBH)y%I>FcKk=p~Z4s+?7O
z{dEzEWL;s7w|Vq8Rw0}IUcAENqm;ZaJp7pyI>rmgs^COJ%JS-py>Qb;sq8x^Ay3i4
zhWX=VND0G}-@Eu@S<(S@i=Wy10|^~yLd<NFCC0UbdTgD+$G{eN<n3(|jb(FfEr?tp
zz8Oj9pEF8;g3qD2breX>sPhoxAG<lJ7eTeu(lcwHWO<=AfNZbj1Nv90=g;{*P%NWC
z6F}FFEau%d4iseMFHrL;VXB#i8&nSa&BuYbY|>9-<&*pi=XBbG@Ii0Fg02??ulWH;
z;fj)lMbQQ`-Mp#!<BxV3v|0Tqnl8YIfNQrkq4WX4bVP${uf(8laHg(-W-VKY!*-RA
z`|U9iJUqNtPgncfS0CBhHus)xW<HI^B>zZZU|^6%Mi>B2ZH!~>x3MnBEG|lb7-(ru
zi>OtJUV+c!5>?ufKf@jS_($W)e6~_f`1v|V^<Fhc`TYF6F3(lx$cV5*q&&xq7vTWS
zs-uXNJZZQ-Ox0D@&gJNq4r2ovIrz)__%NA_<|_@31P&iNEzQsKgJ#DO-eR-~&#|IL
z05M!vW@d*h<NodG|Lv76*4Q*1d8$Vl7LGOO5uAwio!nT)(aeyy<KE9@y5o_JF}LDd
zzfC{bE(^t0`leO%RTh0;5mwWAjZEo*+#jo%$#eHgX?p!+L?2r0xKOiGp8~iIAvOpP
zABIiY@5U|!5`V;Xh?N_F4GyNmEgbXI2vWp$ynETpnE{EQ`AD~EO-Spu`aO?ED%L(j
zuE?{NL38-c9$$fG-A8}&N^?a;tZAFR>BUt;)k~t2j2Y`$+NV$0E#Gxog#}mO?s;-S
zp@to3czDkOM?V>Qwzoz|z4=xt@st9(3^;C|I42_>ot|+m>b;R<AsNjJ(Cc<RSsm~a
z39KH;H1ymkY<&+1fDlbc`QvispOcp|j`*QVd1jHv6j!qs04{V=d<qALJnB~^dY`qG
zFS!vwClfk>r+=A8zQ%_zPAWerDc0ij@AoMlg{5#BU4>pzshOhxnr=`W!~Qf;XiWf3
zhdOM!Qk>=lKZSx9DxEd1RB~vNtrhmCs~1JCy@yRP>{x%}=BJ-G2bw&GV;8S{izcnw
z>gefFQpp)*hg$VNf+<wGhb^)Ces$H5!)ZTkk%zzH<4~<^H`3gD7^vx7tG<bei4-Hl
z#DOQEb8@v9e%%tqsOMcsDmxT}X_}Rsn=AP=hjwsIcz^Fl`^LzN2u7=gt(Nrihxf5-
zJFdExF57Oxs2uuHc`qpqMm8eO0`WPOOJtUlXp-lCuz>?K-}Y6389o8i-FBnIP!~|2
zAA;`FM&}Wjc6O$m4xlLZ{L=}kh0{kDf_;|}y`?G}H9gcaSIs?#zE75Zc@Qj|$W^r@
zZF8_uF}|DEGk1rG>8<$f{W%G@I-JiHqodyCeR&<Nn**Y7nSrCIH6j89yo`IXops6-
z4GtyE_2VUSq=1i7a~0yQ)?e%Yob9IxjoX-3Ergu7CjJkP$?T`+$#^!upUNA<wQ5LZ
ze600+Pe>{9Q<Pzg@wp#O!w_d?d_&r<-Q_eMrhI^i7%^oJxCer*ZE!`#sRGE0OKesf
zJ$P65mxMxuQ9!fpq<Ys2W9*snrLTRw3`#QM{w3Nviyi1OE}H$b4eq@0>{jwt7V`@W
z0)Xi=?ZXFzwEVg{Ze)B8?{c%r{Kd}C5p+;U+#-tw5-{6G^JgiEiTOL1ui;P$gr*`l
zzY9>YU>MET*CiM(bcNFlI#yW_xLaC2FEhcB%2O|sceVoE+;g9`w6st<9X-+^hIe-~
z1x?M<0Ln^MT->kl`yBN$uj*HSI++e)8k&IP&2b4XUY?t=B{)I`pb4t{J8VLQC}~w?
zeSw^z{k}Ss5$vooSUcwW%@30z%;tT2$BJ)7MTLma7o)Kc7<N{gMNn)zz*d<8Y!sSp
z_R~0RD|DL$8-A4O8i&YU%$I?5|1i4#X?oqR+#`e!v(nK5&zcBff0OwTSO}zhwIyva
zokjoSqd(424ENp2_2-r!KxrPuM4^tCA_fMAfT@$`{rkv|_V@P<$BSPB>CE6q?ub|W
zoDlb|<VTy7H>$OB=9B>K5AB1ro*&_^0_K4(81{-Eu4d!K;q)5SscY}2(K2ydmISZ`
zGw(s800~Z&2usrvAde_@IkWDmAKtS4VcM$Q`0hGpv!&(P`O#>ZycR8iHe4iwR(elt
zMZXUc4vXEmyzc~tXL?}}CaueyRq+ujwv?rI4%x={yijlS>YBdJPIOacS$X*o-8^DW
z&REd#KaFAx5dop!jJ^fg&c;;jVN&;}z6#Jr$0&$209H9ym8wV1!ZMIHg}#@Df`TG2
z;3*H=nPYJo;>+EaP03Md67B=4=6*ruG%8Klf0Z%6$?ZS4`RzrL2Ld0v4lEbcY|h6V
z<;#~Zhs{WRv1U|FVv!?V%lB2VNmkXLeB#ubzr#@5?J;ZWU^jx}RBAr0o=;+iiqG+k
zZrFrL2@#vL@Ph#UM1@6$G(;CeV*~v%!c|A-OL{__b`E|lt64-Sc?Hl%F~V=lD~SWt
z9=@2Ww!?j`uTLpl%h&75BE;@|NJ&P4tBgeW(pu3%j8^2it&7@YV3t3Tx&oYRQZblz
zR;E>28g9O*gz133j(!k{>$_5pvI*=X=kTZeaDC!*a9M!|{?p@`f^XhLaAf%%SiSj-
zNN97Nt9Fo+j)(Yb7yW5M{LO{OImMlMZ^UJgqm@)eq0}0Ch=i14^`k91Q-e(yP>298
z&b0Vocvw-YDl)Qyd~0ouf76~H#q>Tg`LfJQBg<~2c_6!n!-_@_?F=VbA@O0@BR~sf
zcMeGbi!v+>YudDqrDj$ZUbA$CG5W!#fB?R2dj@?@H#-!L5qm7#o1@SN#ePVK_8EnV
z+L}5~R*v4r(o$Mca^toRC?7I3jgsf7F??y8c|DyHg%>8RqY<ZKY9)y8;!@lB=`~sv
z3X;p|+r~to%R9%%{)i9$d8q!y1q<3;1PaM_1{=uI(!CI5njCCMZ9PeKGJ@bmPgmD>
z{mJohqrv+6`k2xzA7{JPVa2Uv`kH65@D>(?cJc@$r7$Q`U#NA0ESo2xG}qc}@ZtB%
z>zlAS7L!a6`Fabw>2_v^b=d=WhxPO$@zMoeF9G?UGimX<`H2Fkn7UPxWB%R~T@SR_
z%o|)`rtK$HjmL}0te)QeFSqX=Mxjxypvl<hJ>3=VlPN(`k%y6R&G|TErEae9(-q^$
zTMf6yOL<6!Ng5G1w+0pSBORK1wUnlM3T`ol0r##uA_(K+%LE?S2ocos+Q4F0F9ZXH
z9{n_1K3y|a89FXYJ#6JoC#Fc2DU79LL@}BN)?`7R`0;{kT3WP2Z<I}am!8E3GmUta
zi<6xUP+DY^js+yp<-FdvZQHR4&{Bxv1^sIl<WGOI-~Kd{e!DP4gF%yi+?Y=jGv{;d
zFdJ_$nC9tWZcMh(7We?^!N^ws__*-UaF{Txl<;Su&&gzDWXNLkq!*W##EsrwJUAhY
z(+MI&wAoODLM1Lf-RL!mD0$`OnJLAxRGovlABj+Y+*M|>tcI!c1sTcwDa}PSM?r4_
zH$^;W^#Wq=;)Y*MP0b<D9o&E&wLeRNVr_Sx)E`0I_~XrA<i@{}CwE|<df)NJ<QTIP
z#xxbynW=Ta6=M0qTxv}58VTJRURhaP&NI%!Fo#C9|2XZD-6}l<cRl#vTb@BK_dX4R
zVK6*m08yEZsl`mKToERE4y3_2hcHGu#>ul46A>{o3)Hy`=WB4zFN>Od7Ea)S8m|GO
z<}%|Ee;^wX_q-p%L2pmGAqnj1PF#_R3uZLTd&Ix-9)EeeL<ogTj^l#hma`QER9KoK
zo{Zg+{G?|q4+Si*L_$A&5(S-lXkNi}Pz^yfRM2j@v%Q*|1=i@CUw#E1-olR`OQ{29
zeD4|tn5y1sXlCBWo^`8HrDuAZLqq+%Mh7!nRi&Mkmsd-$Y0BokhE7Mm1`Gc1^Di`W
zS>_IQu9`)Yae}_OslkAa%g5JOp*!MB%Pg`64c^Sm42w>)qk5UKon3~P{jVGTX?FbW
zNEsgpK{ODp`;!k24qjtO=?}v!zuywD&m#_Qo}3g7ikX_2oHS`csuqAP`{2pBe{#Ys
z!9KsTVqo3yN>yH7ASfsZ!u|FwXIF2p+~9{W%*-6U9GbY@J;t3l#+9*k0#0nGA~qKn
z7j=%VvXg6q%I5MipzRv;g>Rn?CKh~e_-eK=$@9Jd?JD1YyW1bbC?l6lww0-93<x<p
zSA&d)nGHf`Csm9QsBc2=t11SDd1_WjXv!n{)ni-$-^;R~1;9VUT(M3Wnb8Nzo}Q(8
za@6XMLMMO@s;JKSg__{^>1mD1jm%4HbPSAKBLmtm*bmqN-(gPrVl2&+?9<17EQ?Oz
zAt4Zn$ZHZ<zVVoW`|z>tl0yjpt&&hDl|6$P=51wL*{9OPbaZrl62dgKO0I$}ha{Ct
zHs)i2Zg+32olWm+1K#Es4ujsfk<`9;&J6K`$%D_IKgV!Q3;Ckp1FAd;HYkHDaK@xG
z0ry`PQ#Y*X7hMoO?(&^}#&RO7(jJjVRyc|HvQWvptM`e81;hGORmoJ#A}bAz1l7vH
zXP+nO0u|;OQjcOalyO#+R(j(N=Nj)0W&oPe@PrK7Bw2XiJlbJc{g=AWnOu7ypTkxd
z6M%X{3>N^Q^O4KrbvK6$nZz%E)QFPPcqknduxfk(m69}0>mA;Rm>qz|w6ogjAYD^K
zQ+4IOWf`sy5P<UP6EC{H<*Gi8<lH+tO1pdSyjwhUG607GqXzDC9$ul+ZQV)$+i@i1
ztUAzX@9KDx!Vr6|q?pO?!f5*oeGnZpP@-IR>%($Qqt$jM5J|~FPSi@6L>iagD7{Ya
zjf`|n(y~X0*aW%IiiCheFbC5>5K1vLa6AE~rm&C@0vq0Smt}Ht^0RIX$b0JM6`LI8
z`E0!8W!-TRW~yhma;#ARVYQmB<dczJ%-<fQKL-105q6)l!_TPawjyc_z#`q5adk*g
z?H{Q}o}mq@jA}`AzZS1XJ%I;iH;7xI>w4`A8<kU|J$(u?DKEpvoZoTa@wf=-dGOIs
zmYdb!g_nN|zmK9(V^21I{~pwH7052BILDfCqz&4bvAVax=@tYlfN(F<{l=|jo5vA7
zCQoG-dJRZs6M^x$6^!>X+i3RHt%rn)$Ib^>Yo3}et$foK?r8M%%ghw3-pF4IS67#H
z2#a%3ickIY32p6C+X|UbrJTN*o|arHMhx^D8ywCPPp0q9DKRLEP~qa{HUdOgE!Z-u
z{a-yAaJUkqnRiAILh`j5q<iEtl|uEre})kMt=J)worR?xT<~Tb5Q0D;t_KAbS4EIF
zKiZ@Q1z7qL?^&dzOhO11?&-*NHhIA#E9*p(XGq7V+ixX@TWiv84`oyw$}uT@&QS^V
z*(K%+*JJPc{@hV6K^Vi@(%v3J8I41n@MT}WeRo8jbHMfc^%uUiw{AxakUa3y*4=au
z()Vr1)#I2SwL__}(8~o#kO+s*s`rp^7BT@l!P6ons96+9b($+t^;~rc;CVgD{-id!
zG6FUs*<KK!$7Avbp|%B7cx=(kyo!$S)5@)}A_e)vPN)CYgc|0(8&Jaj1;~QV&M!^}
zGbxLUi{}|yeQy`pCV@XdPq!FTV`AR}NI|<Ll>xeDc6G5+fqbLG2ZZ%X0hjGdwKe;m
z7_BuBQVjndN>eE8K?f~Y^$tLB>a7Ll1}+Yc479?W*~AJkR(}Le!t4HUf9G7hl^?(t
zdB9CWS$)Lb1LIX@GWvu%+g{TwQ3XggfxW#wxOP1;7Jw0_?U_}@^};8{{4Z@PX#~}{
zRz&+3&vjcY5y=5ifxCSqN4?^%oxsF5X$gsLmKPEb2#b**qRo28*5DBH>cvi^ERaN5
zpf42MtoKSakRZ0JvJXKSU#FCmxx>zk6v$)^7ieh(KDt|l&X8TQ;X5{_=S+`(8t9_n
zG3`;v>8)Akj8S9#9Lte7VfK>Oa!xzkoA~{CwlTpD6osp=3kK<~ehy*y$Os(+6=QF9
ze$W<huqXkSL#5an!z*Lh4HR(<*4@4F8ixXcw;C#h>uoMmk#taL5Fa1`(PX>N7&4G*
z616%?T3W?@_GUA?dp3EH%$@`Pl`5wL><2j8FQYJ_B0Al;)gCLK!@`7W?62N1V$0b+
zA^N-E^Zze00t0Uoe3{vKtgPiv6s@=b8TR3rUa&Ylkt$15KvV?YSlv57?gmnJA6i{#
zfO^G9_M^@Ae=Hc8n36*3<mB|(*BAZ~Hnyzs`U}7&H<YKG$I?)@v$jSRINsYEF&2n`
z1UD9b&ohEg0}r~qv$RAN<PnJ`IrS-sj?gRHAG?&4thl0r0yyW^HZ%?nP3>W=Pt(0|
zs$GYlY2d7cmy|FUU7!Qoeu1k8d&S5(@a2epkRcLGnRrs=<I$;!MYT!Sy;&WNCN;C2
zuNW7xTu#L-W^ZbMCZPiCc-nrH&kg>a7BR$zU3?+E*6JXEDZPuXzvm5{f7L@NGi-RQ
z(C5-bOiUrkDU(kNWP3tx&$w`q;D~A9o7+k3FGb`7iIO0#z65Tg!Bp`O)c|3r>Bt8<
zqM|#2bfQH{l$Sl(XN+E!$;%H1?)^1L@K=9^g&f9s-n+GGeePaU03w<cOS(ewb{huT
zoDAR?E33bUJ)@1D{k<qz@E_0NL5-$u^0JTn1n)K|Tkt4AXuR%``}yITV8it}4V_xC
zPyqqcf3$Z$(8{xW+(Z3kUrNO{f-~IN*VmV8^pTKP)7tNFK$I|Ai7@;>d{<-0trspX
zItjB96B{ckEG%5ca}XC7r@n)U{}bm?1uGJSmqig%>2k(oHdXn#H=a`zgh|uoQbgnc
z5yjx^2Dd8^2J!#`B5RQt=GR^Q|GV{egm0LHiD{jj?~jBRn9X-pu>JuiTA$u**UJTW
zbanaHpDp8pU8Q2V2^ydBT<!{z(TTq4i4mqP{v>E+#W)S(g4P(5)M!Au7Aw{i7JdSh
zkz}nPB9+~LFZ<uSpJ2JzEFvVx98E@|;NBPgx`{goQRHao=wHyK06+5pK(ZpUp6_=v
zPyq{?O0P&5==v}glD~hV-&E8>n($vNP(uz_5Q|NDVrptitI^=55t<<lIwbPPr+yLi
zH6Hw#^!w|M`gKq5(lFmyHV^jQ`9}Ctf+mTh--dEOvQbfqhkloe18h8@kDffq5+}X;
zA0|FR`c5;V1n<4)?mthI2e~j25fLBr3<wZNsk2$_EeK0R0KG&W2>b7LJh(qq4&b}f
zUOjBQyoJmC;}wJDQCrK^;}{<w|H5b*kShC<cYpsLk(+CYl<DF5@4xV!FlM8IO#shj
z6xYum29#%(XZx>vKH1U98a@yv;o^G57BDq6b-4fOKRzhr_CdM#quBoZve0Kq8_p>p
zoJGFE2)MoLtZ{H~>bUfO&Gg@{z`HaIF#YnuT)z^5{m&5NcwE()&4Ix44+{Fe*y#s!
zxbb9pUYugNw6rt?@3&mh-?}1&w!qC+J%94<%<JcmvQWVQfP^hTN%cf&xgII4f6t30
zFOZ0&KLq6PM*E9G0oZhll>f;f(%yqLrA@eV=hs8=VUiYVH^H0(l5a6=zOk{f{;4XP
ztjfx$;*yfio}NGe>-gBa4&t;T-Lk*!;lJJF5h8c6DQLGo=+*!EZ>fYk0i?G$E;fsq
z;cu-oGYOZMmn_MC-@Zv!JMJaR2Tv|8FaMEm{<%y3MjU}uG!Q{+26vYK6lh?UO(#nI
z5}enmAQBSH9M>N|K8#^DK&h&%q_hKuUKsm-K8Zq>BOWEc{cH@S2Z*0JFZfYB8^r@n
z(~?2{VgK+jb#YN2WWvzm!K%hYmz0z+eFaW7SrEd{z4LRCeogBiBi@+o@V_1>sT1?o
z2m^*LgmAi3NJ!{YN=iydkKJ#Xl;3XV*XQoQQX@1fiQY$Q`8Ad_jt&w)H7{)Z{rm<}
zKmYAE`fX6+Hg=encsGjo=RNb4kj<^HLjaSk%Cd^GvIxlbDhz)3|DNFI+kZYH8bAAA
zr;Nx0EN>KESz;m~ooeB`;UmC(CqtX?7YX;<jr^1=chNG5v=z{WAN~|t;K`G+&`#&P
zP&=BMJig~aMJGYT_VUujXch3Q4`;{_#xT8pFg~U@wLV?z6j~2FvvelzkN?SRTo2@H
z9XfQLB(sP8P4>wuz|h73ux=7a=Rwa4pD%z8d-`T(W`!HbxU8~(y}XI(Cpzlqga6-|
zc}Ir%E(b+|=RAt@=N$2s5I54l{OCt+zd6PaTuO6Rn^vJ;OZK;Go5YIPxFBRUD5Ul0
znIV#ufd&1qAb_;7zw$@_v>l*zb_D<s+s!e?X_C}GrRl%==4+BW^RUwQf6cU^C#))3
zQzA$&gQ^NF5Gwu*0y=<kOb+lrZjG1ts<M0hr=v}z9Rs3J>1Rn;zt-#N3lBhsj^>W`
zuWsbe@odq?Z0DZ-2fsf1=fD2VMGOy6ATigBEf4?AoBscQWs8F_ld-2D^REf`+x_>K
zL63A9@Tqk7hm80Br;ix}>7N`k*Z=!A{@Zo_eK2VasO;o5LcwppkN(H&q?lV&4>>!_
zuMGBYq1nGY&Tr#}=ipO@=j~|B|LProJDy2?H`ciP|4d?`Aq>!8*xc@t1pjU+W0*W*
z*(@;J*}=|M;0byB=K=XwXX*EGzCd7Y%8|MlKK$*x{>SavA9ic2hXoU~q5Ll&lO+X;
zb{K*1>7RP`{~q(-Z|&zb%WD``DW}~CCVK`3hV_9IPGQlCl!XOd4%c&**0wfzz#W{1
zARs8%+1V+Vts-w758|+Cm9eq7$b>u}Jv}{zsxX(9mj_l7-OWpR0cHF;2(<u&jhwdj
zoialm;U`blS{UVC|Lg@2_Q^6DBsm4affbod{%x1UAl**0Ja8dwqEVLrt;K^a@h<Vi
zdd{o_OIk=+*bjc<EG#NY(Ez^6ZUcdujxGh*5hLR~1aCLx)<+8n$Hxp&hX6<@%{3w-
zVsJ1`Vr^7w^eO&VlY%R+SFc`$f%+HDPy(k#ou^FtAJBM9`%5nt0vJ|-42|Iu6%{?7
zoP8q)GE0YT#43x|x03AU`o#TkqT8<U{%;%eZ@1mAL60`Er17eC!^v_wkUA-0aoBzZ
zGS~T-%OFRb45lt&`I{4eaii=cr_PtJ@PsaWUU0}v)XH<N#YwttAD<k$-<&XX8hgL|
z@%Y8M@>34m%ml+`S!lUPk>$LA*8;MgE4DU3A}S4EMS+m<u<(cfVF&P~koRwTV}krJ
z>D#w&t?lgcF!zKU9og%4n-5wd9s@XQ7U*bO=KOA)tj+U25+zZi)(}HYv-T+7X0{+(
z;in(t28km*-zA_>=#cBlbVj5FrPqD5ojNv|Z$tbAQFI!+qHLD2_mOxo^0{E_0zSe0
z53?pB&bM(dSq`Ph*z0_+J@J{uLsF5CvMrbZ=#}%R0$)c*C&aM1vs3)(@cKxORCQ<O
zL`S!YOtiJHNN(e`BIwF)pkC)3I2d10z#tX%JmJ=>TP(AfmBz5a!p5d{szxs}L9u7F
zUhO9a302;-j0^=s!_2mxwr++7A=*+|P*}3paO2AV<jE8Ha?r7H+Wp3r#c@}=)zc?0
zFE8w*mvbjOmgIjqqk$ps$|@>OHUh2nUp!VcHO<vWP6nC!kR!m8<vdWNR}>Z+3f<CF
zQ+@8RjhCghtv`~jv`|t#arMN+aa6<Mb7W+s{N+Z0iP3oR5+sHcq)2Q}cXjrUk4ef|
zn>>Wk>C{yR07@jS^pX&Xc5`!cF|~BM(u%Yv@rEa!%gNu`#)fPIz4);w&Ee*Fs7NqD
zo)IP{CMm7#W$bYC!*UL*e}<A20JQ4So;NUp@<2{k<inS>hyRS&dyq>d<x0-3%Z4VP
z!J)#uK?8t@c*TwLqYc~ZODAUaqz6B(ho92rFA|7Pfw+H@R=Q&@lJ<<Bc4{_NF2y{r
zXvq)6Ph*%f1Xzjy*{t|uqMaPp3eZ6yW?Pj=ht}m{OIQ4oC=#Trg@T?=Tf0y7Dpqcl
z7scq7i!})#>3Lk}Z#<%voo^%w5)TErn6!q+CY~<;gW5C1f{n?u^jy0>{Sh28;>D;Z
zq5|bY$HSvli?Ot``;0PH{JPt4Yr@XXemDPB6@-U}2XeFd;77QMW?FGE6PZj9z&s3r
zsQqH9+GISZgR(jU6O+7x@3eVgH=4qHPC<RTL?lKSHK+Zi?81MxNPo>2pB`C%t`FwJ
zD<B@Q1FqQ&H^+*Uuw`KH-@hV@u?!C)gvx?aQ`dNcZc<Sc1(1>mbM^M|8NktU;cvLP
zt|_!Gijh|+pn9zoSa|B8VG{MAx3?Eqg?Wnetm5M0kO|di00$AlFj|epsEl*=%U=73
zb~+MlZ0!wqh6{(jXD)3I9Su@2cFX=kvN&?rBgiejvpq|IvS3EI>BxoS)1fa15=eY_
zyb)>~8VE>s?b2{x!ZH~0Q_Ra5S(hAXYM>i`8(CvXS8bo*-`YN<y|FGM{bf3Joh&*s
zYj+*dCN`Pi=cak*gPz&R?d$WU*_J=46C;ZCduZ)c_v?EN+a2jGix?#<Or;e_WhPsc
zBeU0{^znW)Of_bDIb)k(mg4TCZkFp!RZe~bQv?S$7{Jg=#>U3B7Ik$v)K?0C1suF?
zU<pz|j+pvl37><5qaVNz(@>$&mDWoS@VOktFsv*mrW%!L%%>`KiaGkA_}13e!{ROf
z$3Tri^WYohb1vRt77+y<stE^<PxC~&<z#DM-`LiRs<Dr3y{w_cZAR3f6!YR^CfQY-
zHOMM)$1xHS4M81MW!HJVA%>26EvalTEuW~uR;NHV?=2C_kHs~AlUmLu5wLc6c~?={
z+kmfUHSDY6ALd|^GQ#j-LW(k+hcp;j4{O}5&p$jK;_u=KN~FmRv0OOwz05MBfzP^f
z4Xw@Gi8lzVk5O+S@y2wK9czUPfFqZDtd-?R0s<e!EW{wjywncJoi~=oupd1d08lW&
zod(`Spf(PVjVvr=fI<r4QOJ<~0?3j($vVM&9jz-<fc&f05G@&*aHt5(-x*6uR_K6^
zJv71TRfFb4CEWV~F<6c>2W275xT4ivl^5hcI2WyiL9t()#1r_20{KKWQI(LJ4=WvQ
z<FV>vW1%;@2CH4?Y}v!`)T8uwO>(dgJEHE!NV|iA12rcfNJ3e7c;=9nxXt1Q-9=U=
z?5rzt7<q`{+J^WKX9rmksO&3&fN}!aK|IEcp!B;K*rM8vEpLtbQ!mn-v>2$8gA?N*
ztv>gqg1)ATdu0mxB0NAoBBjXKZ)J1Bkl{Hae*I>-OZ@fQQ4La~^FwrqI$JYC2+wXK
zXIOlE0o2>}(LZMYL5(rC(vGtgk5AbKbr0Fn;LG#nvhf~W%?Nfs;CK0m1aH$w)g>i;
z0JI%$X$%=`O42(#IJpn62E#EXTq$M5V=<l1u4qax8_?yIEKqS{UX1wGUy}92r3dB*
zwIWbNUHU(wNey*gXqgQ3r?|YjdM1HcYzP`A5*h+$_Q-ke0TNOx&MxEnWJNHVvt-il
zuBGunvd_$8_5z?l4!dXy`d1Qff<as`O(i4y$!LMrD2vV)IGCSji*E}P0TJ;_M~B#w
zg^Q6974SGMlx98$1|r*Sj(tu}N%7M#w~A>^HVt0~=-gYa($zEK-YC0-|K%=#iIouT
ziZ1X}M?EU|w&c?Gk}ODU8uN5*48wS3QgeKu;{&vF^1}v78U_iG_B*~<)~3V7Pz6fL
z4pG(I#fF<DdbaWDH#$0qpib(;g?~!((h7kW5;9!1kTO2HAwS(}(TogrUHhw-Vu<6B
zVYYT8n{U24G=7B)4Q~++_AqT7;HCA8EiMN#L1y*|d?e#2Mt0Zj*wVHx-b0u$KbG>@
zYhY^2wGb5<W}@Jt#1A7-nC2dB<Z?QO(5Jo0jHTMEQV>CitW}ohfFeA{&Yw&Pd*Xli
z(Nw&`-XaI<s*?HrLhBLi7juL{N&(kz-QKPG-1FXv<<dsu$aNfc%+=`wCO3Ny3hj3*
z4B>D~%pSFxs-<-*P*n0%DEPM6v>RQi+{hWch<20};@n3>QE1!P#^uXGw1QL@iE`K(
zOIg$%eX`}%GtKqzn1S0d0JP{W95Pi)WO`<5-goD{89BmNRE`qv&5DNzVeUH&ew8tq
zud`mr9Ed_FHJc3a^rCrX#=$;@jzk#)bv&fk+P7u6;qJ6~d*nr<l%TsAEx<uHWg{dS
zhBTW{H5-gw0Lcj1V9S|O0j3${JnUD^GUM>lsONwKj{8=jCl<2oCF`$w5VE@5TwzR<
zn?b$sQ?4#<h_1&bCgg8(<0=IS!(f<O0*f{&iu(c`H0(`H5!EwcnaNQpFrHw>{1YbV
zF+mE#$NT^_NeY6CQW-8ga!T{w!NI|n!mL5IK0(S0Uvfak1tiO)F%&naYa*rN-pv{#
zTR!6hzTYbssC=YfA61@=#nt=4AHkGsZ3N?XRuo$@mvu#`CF4O1tV@)8q9~tdK<U>f
z9c>fry9NfL=k2_2{0(3q!Qj~my79~{wnR|hOY3tz3B<-`LG7<~k{BNO*oH&rtj6U<
z>8@C6F>7^x3R;qEuqrmiJD_AtS`cP#x*c!cAbd9b;aXzv*dn&?kYBi6wc0V-HI{>m
z`1mMfP_dZRYE_g>BV0^*)A+&TGtd$76w>3_Rxg4R`7IlQlR4ReXd8&2ETZ}i+vq!$
zxYy?<e9}w>)mD-|dsGz!iiaTrZ}f=!SIUjBrbI5-7>P)_QY{zC8+wRmKPkshoxU$O
zMw@Tx=QNPJK|G<<JDVGr%zDlS6=yp^K;oT!Yf<i)t}{B7F`>VrGV&J1g(7zIOIssd
z*t<YLeY}vcKMV7bh^Hv(n6Re+JFx0TJb5IsG-6_6ygX_2hCs~JFFETzD5crGt6uU3
z8HAR+wkv<22y^X?sAvs=3bv5Q$PCIFanR;O6lg<3toG16zFkjvclKR@ZUE9WJl&n|
zf@a6Lchgl2tFnKNi~FWQ)zs9)KLO9o|ED(tFyz>bg=ir+<=;hsiIfKHF7$wBlJ_<F
z0M?sm@2X|I#6U_(_zB2!Jb~Seo9gIkSTK{NKy`<(rQm1ZS~z@Ch^mOp*RyUH#g69l
z%4zwRSKK}Meal5>GaiDrwyl#nZyaP%AAzLfhgq(0uXv3gZly2MzOp!F+LCXvkS#r<
zURxJ3jjQdb`>L8|R9%Q+bs+L$n&pFm-srKLxQ9C;<Ex2><j@nM>V)Y-0!wN>w7YlF
z3LRn0HQid2af%C!5^b0t!yBmR#1q#JJl7rYRpI-<L;!`p&9>}K(Px|NNC}o6{y+|q
z=w3aU4OY<A&31e*w^u>OxEI3@m*`p^6G1zkO!b4u_aT)-Xc84)au=-e1~|i=)G4C(
z&@$OzP-o_)Xsthe6%9bvvRJZKm<(MBpk%D_7J%t$wX6u<1yOda!Zzh&V9JwqV*+&>
z-hwH^dlkkagpF`(@lI6P80g^^GbMlw14zmgw8W-R_!#vz(43iW*Q9&kDEa&QhY91m
zX%FT>+0GC8c%|&OR#qhR+V@dUum@p!K_!9MsIyNeiY&q(5rm$wcfe<tie?fnCQ^!3
zz+-;%5g;A5UjhiO5U>ZEThe0n(;#Mkx&TQNvJnIb)h6)Z&S8E!Ync=<7WFSBWLQ2Y
zBnZZ`5hj63IE1Eqau>(*Sm@}_%wBh+AF*(4w%zfd)KL;KGt)ir34}9NqU+9C(TIVI
z_Kh?eRFcwf&6oGaocdnVCkdIkG*_zOcfB>#4HaQUrj97{RCi_S7?JCL+!ZFuRQd4H
znW8^U0=I`}r)Eb>SE|WH%~?mM$Wl%@cP%ATEcQDVi5wYBnNy#~j(&K53KPOGuEzz1
z62jnkUR!niixTI<p>s*+>n3ZHx3nFVCUH1dmE}fNt|n8(mmEAVKtz_ok0M=)M&+i&
za3R(LTWMU<-VB);G;=1GuGLr%Lgw0>shdpI=2!Waq=}c+83j6arLpNQ@u<du4n8un
zZuM3Nv^SS4ysh`}K+zp=9S7D&OnxQIw6kD==Zx%6KGvnc$H!MzSXhQABeOM`0wB7{
z-rlfj4PSjxhcq0fh3)N^sI{;K?bnC>bai#ZIDYvEEXXkC=DouW?xH=~XLQ|Z5)~%<
z<z_TDoPF3?+YRmyrQ$ghX({<wvOE-n{U%c=sNT}lP|YMujisdKJVHOQnQ`4wh{4w6
zmL9b^oXu3GjzXuR=}5hlfbV#jTcJ2vGddksd^FqaFC6_OPwxJ$S@)E}L)uH^36}I>
zt)2A`yh5L#uJ(3~XeWDnw{Rg$h@jB=dp^2Zn>kK3HebX#Pd+IGTYu|kS_KcH8xx{x
zV{9qPG)hV06W%szVI0}CeRXgaWS7&+KAHk;mvDU;zP-8yoB|&y0fm4|wU0D&44-%G
z7SSFuP+>uMzT?h|y`1HyvOkQ@+LwniKK?=hrqdPJqw1t_+Wc*?7WLwN+$!_kYWdxh
z<0XUxx93yBkItFsPoHTO^d6NAo3a4Gr2#Kg9z$8hFSC%?p|YIsn~T6Jevyor--DgH
zu(04Ay=9nYb#c5!94Bi?^fQ4g<=fctnfrwox8rVUf}wzh2c4Yj)e(n!sUbIr)N?&l
z80D`uM`Rykmu=|3+a--chM%-h98-6HV=$XgjnkRZ^-bGlE}%!8chjF2Lc)D(ZN}+o
zEp3)B9traQMA~;@o12@(uFbj_rp%_R%lHj?7=&jiX-G{#rNzjQZ|yxns;l+auO;cX
zHT|I<tt*DvTAPE6Mk675LhIh|LPNa<EzHe5Fho=55r^Bj;p;<@-SHS<(4Gs=MPFR8
zv=X{&xw7F~i?))nt+kv9tUq3(d|fmdr0oucK&t3fj94ab(M_kC??+2-jw>2I*R}yH
zzycZwnX6p(CB8?lt-QsrTsn`_+;iG267`AhQ67BEpjk_~1YoK|Ur~7_L5N6U-AaE)
z^D7LJ6d5xHz`YD6LxKso!zTFoJ#O>w4-$1GRso7tk=$GWT4pQ^@M|eS_+=J#g=r7n
z#D0~e@eR&OUKe$^x1VfHQXsOLbP11g<3J<(k&A0k?CL{9G0#p<W!2SVIB>0yNahwW
zAq2z&i|AOw=6BKcS2p=utDb}<TKNF8p+Edb&1(9tgSoUNs;QtR9Vg`K<y&|ODeDjh
z**6PD1EX@(9kuF4Y??ap9i1gp`w%zvWW%=*;~%r-3_kX_!a)Sr`mfC-oQx2|oX)Vw
z@YF@q$b7<&X;ch#UQ5x{1e2f4l@Ge%y{c{fI=rD67s)TIJ7a{SOL;b|Nlo+OlC`{U
z?g#F;#J2QA^=bKVYTZ{(+}9DHnZpAn>XoFmLUb~h<cm)w?q@DG1+S7m+AM8fz|_nN
z<h`E}m*yeXC%b&ULLQ%TXv2tAVTKrv{iH%ZBO#`)2G!>{mXAPZOPIH5ktpZ|VQgG?
z1{L%6<JYg)1)>*hQgWLsimJKW<FC|1WNNJEos4t{G&rk*Cq6pAgQ*GpbY6{7;zPfE
z8SQT~*f~J+uGv>IrE!}y)29qME&kjKG-e0^%}s1;MkFc<%gJ{-2o~{2LTl9>$VQV`
z6+;rq+8h*P9QHrszv+V(*yt-pzst$N416rN2erF8zfzRfy(E4(y2Oe%c6dPO9+zvI
zxVf!6nA(Je^$c61cDmKV)(XFi1`AbwAC%x=0W*XF<Q}sI-G(3O2cVmVa4<0mt+Ub5
z1@y*M(b7sKJlYnx!D>kHSraGyqSb&B6B3Af)1MkhRw<+Bk}icyJmsczTC&75CJ>J2
z;=<*9l>OOSz9bMdP`Efr>|b0XpD07Zr02envn(vAys^Y=Z;F2Kz`uoiK*?|RGwI6O
z=^p#^n;6>+Y4n9?L2vQ`r5rw~m|!J0x6kA<(z%*-q7xZ$tmS!YdyK;tZ?(1<1FD=m
zWXq_RszgvmhWof1prQHZBqz-TQVKINHt5o)!bilj->0dzPhKlVX&m@AJ(U#`gB5V)
zHd4)C#adkw0rhwK7AAsK3pEK;`LTX$YNZ!Kcx3(?8cLp#mF5nHPx$1T+=e+CW8?5Q
zSDCb!L*>^hE8n+dDE2Jc>|{pB6LP(`Q5g)|J4G<z!92H3ea>5yM1QOXJlxLcm!&8A
zT=?uzot^?}y^7T8&2p#9)4jp4@hclaBnn3&9GMo`4f>@MU(z>RA`&YNsdyn@hOX0F
zLKzas8v4Hr=<6g{CcmzsA2#^L0z4H`HVa;B>!YM(PcBH6V-S5jj{r{4CGi$?+`~gG
zCy1M>R<D)&p$ekmh_ZssTxzspRANqNDCWg?+Rw*S88nmS>%#%&RV#=_-;RTN!$K1T
zBKrtZxM^^P!jYC5YN$6-Si31?2uP+CvMx%?^XGP!m-Tn+y)>+H)s;BicZM%mDQ1e(
zc#$9Xi&x{!U!c}YL8N-Zw)H?_4}ja^Su=2@;`22~fkR?wJW3x2bFZ7uQL8$PcH3{E
z^}LsH;cafV_oVp-#Z(!GgcJ%Pk7$NW<ZR0R7@^B9>jP9&A_pt8H$hYj6Cf)<tX^TR
zl~$9PcWY16$es`|ho1+<OPlk!EllW1JP{bPTN_57*uQF5jDm792&-)NTt=m&)D?R3
ziWwE^e0A&UqORcT&yaarebB4ZteekP)KA66mYDxa9B0Ejc5RID$H`vV9_KrFtVfR^
z+|FTI6l$-^?9I-e8fHl687+U48{Bz8pyKRYeyS19N278rveKt=jjNSls;YVi8Gk}5
zw@gG{>;oZ)LqKLtt`ii~2&;H!CdO2UlK3^e3kw4+Q>Nst%Q_l7#>y6o^l%JE>GyI4
zH``U`Or&P(ml{Y<*;aQN2r(mI+vWQb%vxb?koWd)s6fO#57aqFoW?Ja2K8CWVN1Di
zFU@Aox|C?vzKYb%eJkY_xoT~7&mbaVCRNX%$9*P!O^l+*Oe>!xZZ3IJ)Uls}m!<x~
zQcFwA+LqR!F(RHguK(qyK(Z>wJqLktCW$9OWsYJFlV%m-gxEBeb6nG(K7ZzKxZDpg
zw=WwabS-_ybEZ#xi(qg)Jv$p<?&C^HMHU9lFK$7MkEsQIhW%8Z-QpDX%2!B=40RlJ
z%Club^y7sx^;j|N&D98Uib&ufty>3(+1aA8t<@|(E5{aSY@3O$o@R`6At`N!Ce)|Y
zBtCOP*yf7k_~;r(PoOGj;6Td?Y3phWs+Mu`bD1=pbz6o5O*62joV<r4a436CZ@wGy
zzCz>P=hwXp=UW^?GO?ey#-jb*SDsgXS?i{#vYDZnt&HHg&oNz$pwlR|`zQRF6?^}u
z&J1b+KCaV5NZg(rC|`OjcqJlH^3y_Nc}DZd5$QPs-^w#+#iNhuJl|`VWiK&9Z{32L
zXJ(2o+Es4|?;|kah(}`k`C<jzWz1XTl2`Qa!{h8fi@Oq_N}9Cvf65!{_SWR-5(2SL
z5gMyLby@5o)=TGe+}wqykNKPG+99vWoOFwpZr(iJV#r*{8@8Hwm9-r>xS<#lNd^1(
zk%i>$7^%pV)T9=^4C(B+7%R#WDpr*T)bd#w9{X+Q9{&f-A7iT=kc=emt++`Xo6iio
zE#AaYh23`B`0)7zVL<5a70(SZgco`sELY`j8i;8)MD7hb9{bBTb$2VNDytTx+L1EU
zHk#*{rkT3+bGx2zR4awC@UjD%aCjeK$koBn^t77u^VVd4xs-D;U2k{-$9CG#!BBGK
zWQv4J!JQqZlksZ1LNuJiG*QC3`0MKvRH~QbyShZYyUOqisFTA-lC6YJ`kq<3`v(VT
zeH2|dEw(gmts0Efai=T1ghbfR9aAG_PQ4(Il3aT^VSQ$ut$pC(h>+vX@O3L)hLGwg
zZCj9yN3V^pS`89INUMC@U&0y`Tr8-RD)H{vVtdUbLosb6pt_VGiKSLeU2?RffO0KH
zXiP&?O(#OPr#bDYF~)W@bE4QV`E_v7AO+h|GMX%HMh=A=Gqtm+qL;;@m(J%F%pY)w
zR$c`&VrrlIA&d4nqo&y8Sco2z%v$-$v_*HcsY}s(PJ&j2^_)wGa+X)-A>0$*7|6sE
z4(B9vuWDkuBoTUt@wqtciC&J4i>ZOeI!4=U4TC8a$VpB3>Nz=nmCR*W0-t8&bixus
zWn^5w+wT0ZC4a-%IZcC2)$A8^&wK!Zq8hp2w5Gy+T82gEm?qph`fS2I%XM~MU(aBU
z&8H?qe<azpVP2khl)inylOp4(#vOdtE1fI`1x|doQPY%G1C;AG<#Y4fk+T#>E>#K!
zj5CcN4A);6KghdYG$T%Weg*AW<;zyvJ^c}Sxa~8nvA57rbb+FYmX~d)H0@xw;L?z#
zDH(CGdvbzdE(?_i2zTK<99BT`em8Vj7B~s&UIs39c!^;#b*xpoA}&Dar|y}pw$<j_
zovWlUCG2^ti3d$j;ju-g>_%}9w`)p--6u9EXT9#jI-&<SMjy2JF~n|Gmv6t^jmO$>
zYJSigFl$aKbEA!HQ~nY2dp+(EK3hD`+iL;{yPcwfrWPW$e@?^OOXzAzpR!-yLCZ=y
z$F5Tg%srk4RdyDG-i&qK?4H@XQ+ua-_gW?ld0!LK*4FRT4?HF2#@VkVA@MXkT;(aX
zoQJ3v=|&E=sp>C(8xZ*PTts1WZH@ZqtFHG8lViiKZ{oW<oxwcL^61P;rB;z{dMLQx
z0}0$+iYu`%C23_Du|xvb=`^$|b8|Q0dSYHkJE6Zj@brQgKX70D;;@!epgDZG3^sMx
z6erK=94BZj)HV_b=YV5kjY;_OS(;{K%8MEEnNUHQo?J&(=Gp?26fEh-v4%dWeX7Wd
zqck1>*EHmL|AtI?Z5<9<@-c=K9=jzUm*Hv6>43rI7S?n<wZy?S$V*eS3MS=*D=Bp`
z0Ixon`?#{H756qK`%lDywg;@S1WVKE*nSwtGcvNQQ2DrN8%HN2K!qLtN<(9b5=ho}
zd2AmY-xTo=c+<mRKk+`vcTCEJZf`yk`kHV#kz@!eK!k3nSmrDUKbOUOnSUOz-Km)!
z#FWaUDY>KHm>c||6*pZ#sDU$cny%!bKl#Hln}Ze63xsg=$LuRm?g8)Wz`PV1<hM3u
z;@kg^skdN=BkHnt(VzhmJXi?s0fM`Q;1+1y-QC?Cg1fuBySuwJ4#6eRIJe%JJM+yS
zsIKm=bL#B9)_Qg?pEVn8nmlCCjt3Y0%UgBhg1!7fS4rgn0gw4?;0Eqd)awI!l&LUd
zy`60yBjim<_QWcGXtHR>rg|1r=2&Il`$P8)nVnZ)8&%G8d$N}H($DP>t8DM54B+N-
z-_)?S&otkh!*lJY_7L__aCj-aHRPCE<$IhS{SI8fuOjX|Ve@T%U}{AKt!1K<y5MM_
z7SX<inqF`Pka>aQe>e)@5tZ&v@+#P4VsfvYl#!^$tdkTJW%F{)jgNo<4so3}1&ZBY
z6~MbGimFk+dJn?iEH_~SLxnx2)uI>)v@mg8ol_qOH@P9W`g#TN#Y^rI`2@CP#If-$
zU7ZeK&VW25k$z{4W$EE=QOn>lu9!g_5`Ny%|NO=>-N&|1muEa9{e%CURGTw1vUrRF
zp=Sd%)w_&Pun=WpdagS)0@+$`j!tB)iT6pCex?PsSG%5W4eNy02X($$`24W2pY;m<
zf+d4zen#*`=>5SAy|yqU7&ZUW=cn9{Tw-*M<g|weffB3faE^(^gDB>zrcmYOy}joE
zu?TH;>a>|n4yFZ0jr$@Y=D;><pq~%qAJ!9>_SieF+6_l761Pmso<YO7jGijM)fkUj
zETd#NbYzzg|5KKV0<nKdxgVtUhn1O~WPH~<ignoQLl`SC@Yw-vc}SbJjaW&!jv`v`
zXs*Y(>;FVCPnfS70hc1Bl#14W(j?0|KJvg-HB9;f{Sxo<t^4&Ks=K{seSwNRLMO8M
z8xExV@la$929~DE;`n*YO)9y|?1}>yrSx#Bb6wD8tztdc?D8%qgN5F3xrv3z>0ZAU
z!|QhiNId8?0)6td^srIAiM}~cJuz#n&{WyXugyu;chYruXegX%8YM0rO=JD0*<gXk
z_!Nj|sr`qQAmKf?XmrxDW)y5$E39QrJ7rVD|9s{U*BD{9XHAA4gDj9{&*N=6cqny$
zzAgt?<&x@a|JNH*LIz`QA>R@4@1Nsj7NE!v<Vg*}Vl=t-s^stYTySI1hd{Nr9kU-8
zb;7rwl^@ZFdm`5<jwrWe*<$xWYfG2VJ7TNQon<r#RIPM=fKZ@z#JiL;4qOQCZy%Bf
z&5{x4U=lRgkd7RjFrd({I3a}S>v4VEn`5S>8KIm`A_{%}6Od?I-?NL>WU5EKvcjXV
z{t03c9&SHJ{dWb87VEaL$qB>ZWBeh#M*GZf6$%!n?1F+7tA)O@U6c3-n-XJQE*iT&
zm?0zO@^Dj?xzun`%$QnEUo96~>d!?}tBdgMZr5h(5gQs!O2)%5!As3s;wH<la-*y`
zt#0{|b(pdW+Bafj61;R9SP5|v-8JfS9;mg50kF@R7t9t}wwU&+3lSVki3!sxR8ucc
zG+c-rUn_&BXUfxSOoAG!n=py7{j+XD6uZvpwzL&E5dS(5IHf#ga7R?(9xC4a$xL9_
z7~+h$?dhJ^9i0r-3_Gn~kIon<a@jBeyz>S_k$;L6&#mn3>s$j4ug#lnMuM5TdE*HK
zX<WIkY&J2eb}29$EWfdl4}d-^*Q9?GNy6H9J~>~vnVxfC1^S$1cjHS;E2wnsd9lxX
z2nN+1_JE7TR&ly>NKKDL`@G6vB8A`a{_McK6Nw_mZoUY%FDUpvjWNCNfEyluaQA#F
z!rp1}{#c>w0z|wbgV_FSha+nRwXwcFVBinfIRRJ5)o)ke-Ay_pVEVL`PS2s;*{73&
z@v>4RL?z8&kkST-{v7B}E+rU6ukrGyWxgdMI#mM)Zf4dj>u?`7Bs6I3W%Ubj2FDVK
zZu@orKs@`XFO*cH%q=JfneQ?Z%i;qfElVfN=Om4F<>w?@avX!;#5jM#&No$G{JA@v
zzwy~w)D<F?7(SQH5l=?$P6XWf3(^tDcYIUN;`b_=I#*qfY4{HOe`KkOeqAuW1UZFb
z>|BIwTGg2LWn3Nd8H~(}J!=F#^Q1dQ0k8<_K5%*)5*^=7W56jtm-qM1$304iHqZ&2
zhsQ4!iha~3bvv0B{kEid@h;(xoxMY0_FeZ43?UGqsVVB=0`tOD+|8~&y1XF-dM+VE
zE?Y)m$|EaS&O=nl_Mp#<wCekdi%6;AS4DM2>A!sq-s*D{k}{lf_fw2<?J-MQ?oyD7
zjX+#M61PhYcQZ?IzHxRB6$VNIA`90YqP9PoEz?ONFSP-Vo1u+k9n$AEKCMv~O}E=O
z9^5#w<e5AYW+28mn_qOuR_kg?PA_N4#}gHsX&r6SXIn&cn+PS4*-npyn@mQWD*F|!
zpxoG`BrEE6*_$lS8#F%BO3(Kp8y{d0YUBF%t{At|O0^$G;n&?d0BAMV)*(lW(@^Qj
zvev)a?5rt(!E4m7(&4)A<h0s{!6dcupm}mJV$-v8+k=$2JK45)e`n_#!<x#HnibeV
z6%Yf5mSpSx^-ZAM+EXjEjMHFPb3HsCV`JnIBGX;Z{Yyc}E@aDolNz-s8OagKOuVFs
z$^HHE@$m9%d-^sQt;3Y*oq?TgDD4gH`vN4ERIAXEc)rykY?ot*O`nv#eLy}0u<9Wv
z<6M^2CvdjU;_<db#2x;Mu3^C@@DQpa?(b$>Df@u%=ADkIYI!rkI{!oS!QJj+!)WJ(
zIdLUU?D@X($FiRvEDzwW+cX=F7Ld8{e^zV0aJhbUS|s4$;I-W*r=Zlv>?TE!v=-)!
z(aQLZ^W;)lGcxJ~8Q2Fc6-XY?{4K=V2YI6(AM1)m->dvq^~{&_T4=Bb+$=%xSuR1!
z!-jflHy^J({>7<jsqjMoDCeeK#PtJw)Yl=`PG&Cj8K&T_%&TQga!&>9**|3Bfib!C
z^}#nIWNbdCW}9tJyAiFj?hb4~mO?XBxFCWerhi7G%J?Jd|4Rv#i3x%@dxgcF@c2Dj
zu0YyvIWc1K1nia=#%C8wWk8yl+D<f0z|T7V$ke+f5$9;$?^1^XNA~ywj_kjdTN1;g
z3N6w2(`)@;^`0JdJv63g0ZFcUpoF#}LzvEC54cpk5pIwA%*ca-dAXj^BOJ8CMiN$r
zjUru%AYE9Z$C`Lp`6T^=HX~LmXe2RS?!2&n{NuZ>v+W&@K_+S77kpp`Nx~g7SoSO#
zy+uC#<#pjDJ}Sl8ki|$+wFc`^XoneD^YHa>9M>&K6rWE+T|NSJEz*0Y#CF$Rj~M%?
zV7~REj^akrWyzU)?HrJ5eVHs@u(*H5nsdp>ptyS<_Q{r?3;tFM?v}Xb@s116=m;3;
z9+xjvmpo$(f7Gu^V4RT7CH6_D8eH{4X#cpw%hiB^UfIT1;-x!y%l~pm=a?`39NW3M
zUrh6KkDM!bNrf}BgeyL(#g@v@?ic6fv1B-7o~teMWER?_)z+ZmJigp4PLj!lgqa|%
z95~4?m&L1kQ&>K>B>K3MsUFzl#i-r!r|Z=@zlivG->4kxW#}6Mj=~jzuuW&<FUj$D
zt1VCYhijrr&G|>YgLyf*MCrwgRZO~x**8ig%>AcB%cDt+JP<Hw7Cq5Rv%^)Hx8Ys1
zTGj}EaB!KTdqgV9QsD*Tv`Nol1MGPl_YdRG_`_rgFt{(AquANBtPV+6>wTxXgGK4K
zXf@r2F%Adr$45Geh5PH-&CGbK!EboUh1e<ViRJ5C@@qqb;_+U5RBG{6X2Q(^8o1yz
zXSIWSdZ5c`s?r+Y{Ux+I)RD^0dik?mbzRKLmqZ^&AART|ZcdMoUrSWnk#3Q3au-Fn
z9!Z}gXuf>Y#EpQue5;dLbqZ5m>7?I~ED;&KQ<NcMl$u(=4Jlb)5bFRL4#K+O5KlZB
zf7JT)Huw>~3C&KU`aXefKy|1uCF}f09+LBUFZ~pGp?MmdYuhY=OAIB4-TD3u<3cuf
z5d2)N6o~Cknxdj|VDuWK`sP8;u<jr#E2&{|tzmxB!{{j0+?4jx_KPq~ZjNx;afe5n
zV_-<9v?1D>KuYfN>3~j*leB&In72Svy2sL6C;uHXjaNUnt3Nh9mSZL0DS5WlFRwd}
z!{picXXT6^L7SS0_W*j=uB3le#3NMTB<ECdue~`dF9Y@5t-8v_nwN(mh~L$a_rM7B
zG8J~gmO}j0U7gT<3%#Q-m*T)`@y0QhVTb=2+H&iqt8Qj^sj<uftT)v)S=k?v-MqD?
zq2#sRg!i=Ejbm}+T6?<)GNGkcOZe{TioVvx_fshbv(sHn%6e=cri&^=;GIgn+q*l1
z;y<N<Z0(gA<HHWBc876<>FVm!GQ5n4vT$e0>uI&e-vIQaGRg7F=7%@ChpUS;&rMNa
z7vAQPaD3`vd^$<&HiJ`c7PzPVnC98--wjDAjS}W0%@(JZeSmcP6fkI@(HiWBR#zi*
z-mkrWU?5#Myo8#R1$aGnyf0TCbC(~v(zQZ5Zl}n`T;c|0=vBUx=Xw8|4YOx8^LYA4
zG3vDaF;Vp{%i|}~GMB-B{;8EQ_=xR;p1e<QeE1|fc0PdqC<A2R{eQX+GDgw@3jgKs
zWjB-0;Q)@&!iBf%8B^CoYl8;PVZCl3?0b<RG!Dv26ugejIiH<p-u3ej1Fw{^=?NO8
zKuk@hA2UfSpT)d_xf~9EwWA;+<^U$BK){quR@Hq==Txj^M}F$iumVa%tXYo)tRI7Y
z!#@E%x_C7&jP`sWatv_8{sTOTbAaASP6{uIX)Gv${r~$dON?OJaL53sQX(H50)mpN
zYD(N25W)@(!hY%3M6>(@)60VRpB6eKhuWyFW4nDX9|5QmTRuO(ZarR$I2sOmND?>|
z^sfvrNN~3s)MlCb(`7uLBS`XruKU}964@Gwv`O7(9P{F-CnR5`O62XP>=RKud~#34
z+$60us5mI92(A&s7YsAORu9lrAlfmRcc1$ySpM+c^F8#xouJRcpA}90W;9Ct|Iz03
zfnlhTOG1&Wu{}gY=~u+W6y$#=Y>8t0?L>efB}Mw%iR*f_Y5;M*zn6@Y3NYc%9+w3O
zJ(pWn&L-ZsyteNB!@lvfSdp02Q_@SJ=!OuijnlrT>D;_uJZk!TXI0I$0BIhcfaDSh
zm&3b~HVwns@SNn)p8t0ej@0>s^D))notUEB3mJA{_M=?50r~m9HBF{>nvR;u<qlJ#
zUcq^wTZTnUgHn6Ytx7m0U{V1m3qP5i*Jiwmz)NAN{>=T0(IZ4Zdjfm^1;m)khTsL@
zaD7rkcVrg*IPFLXr4vH1>6(s1DQgHp);l?0s_L-%eW7Q$%hPRVEH>LZ^|8$&VEvDu
zam5fhAAO4o6?}b<7UcE%0&(Hq*G`vD??GpnRVVImZd)vqv80;=yWHTk=O=2OGxPBX
z43sgH1m&{KCPhU2vT%p;&EQ-j+K9$@3snHkq;Coy(oV{D$B%x$CbslCV&trKu05&8
zK&DL-{}||9&mZts-yN94NaiSt<K&g~@Xx_trXV8Q0o0hsf4wrst=b$JMsvcNb0ugk
zwkxTgq&*9FZvlR!yV^x3$gTP9RkIPTmY6!%9pQ-laB(vilkO;rsR}LjO%erj{_>3G
zTqASjw7lsgl+yOS>~vXg@xtKyp2+KT>>^imZd(wA(cImTMQTFnbNiIZJJrBtU>A3A
zv>i`Ura%M13^&{d4=UW_8J84tb3qQG5cX<j{PA%Yrx1?f`(?Vcp5X9X2R*KIjKmPe
zfX6T{H#M!{YmSEfKMEP9Ffn18pQp38(Ma%Sv!uWmNC*2=vhK8Em?MZ(+}*FvWFZ#!
zmUkA>{)lc5=gnH&c}Vm+W14Ikd>&$D;ql8Y{+*P1JAF35msyd8fA;ai-02UQ=2)p{
z&E~R(fDQGmaXepNP-TDk;cidMfqm^)d8#Y<Y@mC##me@Cv19-ed0Mn740^=3;$aft
z!de}L^AT;{=snNt{g$6Zt*e|p5qa#cwz-UHVwx#)jGaiixd~rhcniFflal%Y>YQW6
zR<8WcOzy2BpU9^M$y_YW$;{_ZRB1i0fBr_|U)I>EpL>vmSILJOQJ-y;VjBWrJ->3=
zOEUGlKL`yerqnI%SC<i`sfS)!6O%{lDF5o27c#kNqyRmBZP0^O-Sq7sSx0vO(MbW7
zky@=T5b3F)lUf)q6zbDg7*StD4Crq&$4Jycn0bRp4J^!n$G-F(AD{DYzFW@EWvwJj
zc(xCAbjk%I3{qbUs03^Ssu*a;8-)qHsIt7TbIkwL%Y`PyFqI>PEJ>Idkw=G7dG<A8
z>hkYw%GfX4?POz*6%{xh7Upk*Wm(;#nRrzu7X8;Ab;0|+?aH`9Sl_1eT_+JUv~Ih$
zh~{Nq>C{36Azw^KbL$#@HFxbk9jnaj=lmk&*ooXmhI0^I{_=EU;4R@?_FFTh%1dZy
z;$=TVQO(Rc7;88*DxM%2t<@krVW{^mAe)!5aPgaXR~mZ1z=ABsv*;Z>md2058aGxO
z_}n5dam*AM=Fsx8fv)FAH<nYGNyiT}1NH_QgpvK&{Q4tPQzm&~GWv=p5dkZ7AnRlm
zHa(v<=O{yKE;&0Vfv01TG146VOhvi6V6CWpEEB;C0eTECOH%6s@1*CEHx=q!>0)&`
z@1r?`2yk06SWlGUz<IoeUsy|v#0{)<{_rd*l&YdhSq;i;NzA|J33^t>xlKYWn@>{T
zEQ`}*)Ntdis)_!5{6@Po<9_&UJa0+7r8mnb5&H5kO|c6SNrUBV-8wbm39shxS`sYg
zLL&h`${JcGQt1(-w~(*=ubO{AY2%9T>Tw*b!vocKYlMKXu5)#}D&{7V?i|{$7z7f=
zNet0CvcbnQP^9C@sae$**9r;t?6qcZ)1SF!mcIK%4Brc<6T=2cD(O53mU*(>V?DoX
zQxrytU3KY6wv0_&=3Agj9X6o_)Q9XK(J8G}m}N>0Lqrs^p58<A*O!II*=H5!xBPN#
zFM0$NpPXYH|IVd}T<yhZv^Mb8nlGXmKU%ajj1guVT%~@X5<d{)mx#D51A7&}r(UJo
zu-7ckI23H==l2)1lzwu2_gfk<$4r=pI&?j3$@Ga|2YHu4?8!6uDAh)KU7$QnK-79w
zykEF;*m$sh{pMJ>^XR$W!@X12TkU%NUcW&??}V@A3iNDMBn<#+y|$+Na+QImde*~X
z`kntEo?DhWA$Wa%iSlX_9qjNAzCoYta(E_p6IDG^FgZkDu$klr12>tTB5{dgrZFUU
zdw&FlilvSgRk_+(&6&}M3H566#iznqq;X~E@hIB_hhI2_E&maqIng%+q9BuaoG}{<
z*~2)H6k^j&rZ5M1`K;BM1fG&-l)yWzCH`mW3I6vwyp!!23t#Tc<3U5^bN{FN)^#4p
z*%fKCS|=8|N78C5JO->kxt`h1R>$av%pRflv=14Yv2yf>l+4{d*eB&5uJMkM;TS|!
z*SU~F8kluSg|~_$Tl#OvahawLKw4|<k7cs@+XYfksB!mJ*sMr(m~tZ4_7w@@f6_kv
z;;WUqj2=vt&`iyD`MR&gHbn?};C5|>q5>!BPH$L@P>oll#F)C(G}H!^-6*;xVS%0s
zt7-SdgcB#kLV35paw7A79|^)VB^_MT=IOBw*ffA``-s3E!3fq0jd(VIiHUjEzd}7F
zw@jbQCKHc_^0r>~?Sp^GX-7omJboRcn@<&3Nc0yAJ+Ti9M?P>C>YM?X3#6gUEig%f
zejh$?aGd9SENXYQswB(k@%yDIv{DZ8pp3-J-}51WV8Wtp<@V@LrY*1b%qSj0l1L0O
zPZx)mW@ocnzg?RID8KppSUoadbN$4UU0GY2)>Q`<;iKEC>e^Vmyh`c24<%?;u&*zz
zn`-O3Ncv5`7U)ICrie4E!&+-_JoPTGUZbm|{IJz|JmMBELdn!=Y*7GJcqUQYP;P1r
zZfp5<eF!o8EKtdIJLIU9-Fg{L-H@80+E9h+2Si%K`BJnTUEqROlk60?mwzoWdjw0%
z2=xr3C>-QT+!@WWln#9h)4A!ikrsMjzJ9QdR$`=-h3rS-{owa#=ps)eRR6yA%s%Av
ze9p1xp3-W6AbF^A;?j9=$SAlBm1irA#k$R0wpS!lDd!wLwN3IF$(!^G2ks5Gvh)KT
z@%Wm`tu-T4b@f9K+52C<-%pFKRTDhlQ~vXM#Kk>#A%e#UmOeJ%l8qjtGQU=%Vw8Q>
z-ai=Z7N?>t!uM<%Sln;<vN<JN&qAQprp%E;5DT#O|9b%rzb|zklT+~pwQF_>>DeAg
z_je`lxIB+Dz3)CL&j+@GVbMsI1cq|3u;D&D9Xo0;S`YUrm%lBQk{Rc~3pb#dp1Fit
z3+?M2$-e5NR)qMwx7zll^YtI2j0Fh|A~%}^1--N&Ea7G+&Md~{>KYWfp<|zp@Fs?;
zHLfKk-S&wfcx*B!suT4LWbW<lt@in^&H#o@<3ST*S9kM)<H>Z3Vd+``<xH*jLb#Vk
zr5UO4KX1AJT56{M;6za{^~DwFcTP@ddAGyd07{vE-nVl}o7O}mECu-%KExHyHc2XV
z?F1Ba>kkFUKfgt1rD1#NH|`QvX8&ZCYh|FD_!EeUqr%=t-k6K6@!${2HO}2O?srAI
z@%5frgn44N;d2fCS7&N;ir87i5F8!{Gt%mg!;*3kUO`7iFyYgxo}DgCtlb{I>)ENr
zFgai4-y^BQa_whNl@W?eY|GJr{|>j(c12f`=yYJ#--q<JRfHvZtlHg!l$^c?w^RoX
zkJqVriPh~@`RMF@OvE^?+E>aYU}jyxpU8m*b2Lp=_g=VW5t0|+bead{HJHWignxf2
zKv$tkOS_9uyx>lPk3V4K;ogQQjKDbmOL(%Oq6I}gt_Qt|$JtVcGRtyY6pNqxg0H44
zB7%%{@r6@5?O$ArN2ld=i|K`XkFRXp_r4XsS$7pc|LNj)MT0+hd7WErx?lQ{Q1yfU
z+yY#b(VW<M-wJ(Oj#b68?_|@+iOe7K{#NzX*J7$d1D>^9i?M6%89J*v-(<Ved99H<
zTM3C~hC$P#nt+f9+Qktyq<ms=;BTOXZCq+|jEpQM9L^A0AP(KW9)<;iz#`Ho=q*YV
zs;g9`Ns6CN(JnlTgDx_Kt~%hy_4QjACO1A8msd=Y8~4NTVdioaQyB1&?DLduX4qY{
zrH0122xm)6ZwnWb(C`~s>i52ezX?xI*+tGQrAW97bwM4PgXEPmWcD9(n&<CSzv9~M
z2A0<P(sdm4h1JwR$#Q<e8G66`B{j~xM81E7E7gaDmAvaRx?o4x(M_|7jmMWG8T6lJ
zqU96sDuaAmr%Y{8hg`?f!s5uZFay1*oAQ*YbZVj1g`n9QSLXbSRPOP)uK6fvLKO*|
zy}wfyuJOaoO<Vhq!VW;;=(^F`9>eb6GfGW$^OrJG*w!66$(r*IQKZ&8-o&a7$dy<1
zB+|@mRG~VvV#q0oBmprubl0-D;J&>ZrKM{5;qi3Uy&TWx+k(9yNK0uXZu_66)&f;=
zeX0S3C)G|MVqnvMpZ@-PT_D5l`y-w)RlWUPEKmL+p(!s9H5`3?V*HpRV?=RjP(_o$
zdRO}dXFJ%@@<aq-WZ0%^EML!4<Wz`Dwr)VelI3)3j6LCMc@|P&?@kk@HT-j$cyLo7
zOQ@qOjYQG<*WW3srVC=b_$N$G6n!TE-jo@3GcIHOh9ZGR6n`T+0Rxd5^zBra`TB|T
z@k4*l@)B|tujAVHxY<ax;u&0P&7(^zW$YJ-gc&KkOiM)fC%Xu%_D0L{OAN{*4vQip
z&+l$jWh>ioIE*i8k33#7b=-bLeZBNLI_NvBuC}1un7@BpEeFpSRUkH<UMf}Ga~iXP
zex|Q|g4h58DCA(A1CgX6WEkL4L!si&MPbryL+$L32B6-r&e)Y{u<Hr?q_CQF{Ik?Q
zc|&#S418+gcPs2znI0tU3lo0xX)T29mh5i2q9=M7J(V21HedHvS^@hbJ<F$<nHBQP
zY+*g=WP81M?rDdnEouU{Haz5EjG@66mi<YK?Okpba81J&>n;D4a&JHC*R)z-UrFOk
zjT)w*;i#rLS-a1?ujYX<b<6e2CY^%@>Kxs8<;8TYaQt_u$jn#$#`oe{qJq687jilZ
zg-g<Mk2iOMHh7ec%~hU;vo>rjJlyfT9u?x5-9TRIY_5d61E)b(Z|_eJ52o)_`HPIL
zT;8==YfT%{5RL;@-_|TH>tS#~Ej&Gk`Ps4LIe~6gM_S7<MvUh2B{U7q%WaLT=0=*m
zPkaPYSy>gUU+9h<CDtG6%HJa~Vb_O~kAq(&Bs%bZs*%i_E{b@99UK>I)P8cIsi+La
zI3y%qPycY`PfALA7qEwrntP2f87{FIU9iHuRFE>}N>`dk-E3$+*!?N^(RImYzJSUD
zNbl(G_h(1|=VZz3<M2i^5FhSCB4SAp`hUfX-%sfr05Wr`1<WT9>T)-kFOt!0wRe(N
zOMN8vZ-rIJQ}|TlaHz8}7J*{ED4-$k9h5S4;+43R=rjWpOu7T-F|KS@Xsl-H-2VNR
zwt?WD`p8*mE3L4RfwglpIrZQIKEzuc(bPZP-y4P_5|#QGtfZkoso7K#MoF7ucHj3;
zlzLKPuR{HyAqJX<L+dte4ab6bo})y6ShHtD#Lk$-aQIsPhg++9$B*d;!LT*&gykAI
zTejK#QIwtYW)kRzUtdW$lOd=GbtGPn^r(a@NXC=yI@;ueT3U}1J+4hRU%WO|sB+%7
zPCoEX0VWPqpbtgmdAA6|eq7b*67yxTT{{qy&!b5RTV|Ua3XS(0!eb8q(`OF$5|9?!
z(8==f-6-8&b+a11ESAv<Bee1VumJ3ejSDfjZG+f;QB#T0Vh@)K#mgAuR?o;{%sKG7
z28*7)o*xxznz9^`T~ed9oVI6=p8ky(*U}$3#j5vv=E|=08y1HIMUze}CRx@gXfyT9
zV-pk2BDgmq1-p1}k}}2Z-m|N_pr^D#G&_D9oA1xDy<*agvD-&PR(}IsIPetD!WYD2
zzWd1Rf5IQtRC#y|lUQlANX7#FWVc+&nJBycH?^o^-xtQ`<Ec|=kXMe*HY;l9&4_hq
zEadI{;dhb+xSFhO;Jb^!i>N{)nrYG4Q<lTz!VANC<V!1(+}zk$3kAKWcLFf0@2xpc
zb5mQsC+27bg1tvU@xnJ2zbP(*ElUl`kFZj4Dfj&FeVKLm{2~3ftS1Pf{zLS&;m0cu
z3+i1l{}!zIxDpl}9yhw1nnc(=G1GMNaAsy>Qq*@6uv=tMIC7<J9{Z)RB=J~7uJ``F
zvfZG!wlR+ENQK(AUtHDoH}s3`yV#!V>ktxeyq}SHy;}l{@1VWgDPShguf8z%7Gg)l
z|0w`~tvDqLN<ASKq1AL3hy%sO_gA~xI_}HVCnn(Ou#wti@5;mr*7nr}bVh(GWedoe
zqSnDns}Hmw0`YTN{0)2tp#_r`XJd|Sgx93!=1X*9hBbdy)^@Ah8g<{lj4s`9JX_g{
zbS{*4Zq_n)syqEAwn>!onhx80!(U(j5ics8Tn`k_bVN8O=9p8kn&1>@AF7Ma4&+WB
z+PO9B@Ae{)1OiFk#is=p7M8%?P<0N&p%42i$&qXk0pNNQCOu=GbG?@bZy+`T7Z}Wr
zaG;CV6tIhoC7<(42;a8m69lur&FQ^&t?@m4lpDO8^TImqiA<-`@s&u5%a#c{g^R^x
z3eFk^TSgTyG1^aAHon9Xu+zh^v9{fCA4UU@ajCwFtt6dP@04V{e??Hl5{#0}bTKcF
z-}>SbmA}+7yWSDOD4Rl7zRw^FXf_fFw_E<$?w!Zj%<g%YCa2*ixy?!z(t)stjPIcW
zZ1335%}ywFI!XRkSjI~&Sc>K_>Z;V^;S<V=Is2`=_zco;sx7U0ks9vVVk>G#UAoHt
zG>?D~OaVXNXGc^d-`UOe-nIafeHp}SPh&K&1|{dS<(`lHsEXf`a*5%^7wQyQT>!}M
zP6y0CLjjWh3<;p$zk7hBYI(D@2o_Mfeqf3|AE<~lqwJAFzA0P$SZMl<hYhLA$B3PL
zI8)i`Xwr$QcS#%aT&<qULO|p<Ao`ZMoPg%;aeLWOTKW>`Ac@T6{_n<~ZLPvnj8~;f
zw%ZoFol97Y&tb-9ju2FQv0hR#^WF`fnN9EWfI=o6aN$8gi8A^iazwtw_M0j~Z5bJP
zj<M(J_SQEr@V7|2Z&cJ$nz4)<0k1Do(DkU%OnbfaM2nJ!$BM&1%W;2TQ4p>7mbxB&
zRlMZ1Ip@wmfkeFS$wFyld(?s#R_aJl_wg4E`ekjRQf{&T(^L|K`$Ff}Cwv#8>e(aW
zU@(S(g*9MA!=Pdtl+a>?_?x*I_xP!=Px4k#H+-gdW)#<$(r(b15|P;wyDw}G#(O5z
zq6Q7~xS3EuAIKNL{s}0CwjT7wr1T>~5ZRrb)W@+p^%az#a4l8VL~3@};iQ&s|8_t_
zChOfhR>3WIq_sokc(&1T`jQg00|gBYJ@-|}>S^zA2%UJjh(QS=2A&S~ueERVngyN3
z2v~pOSG^dT7y-M0<=MFwLLB^<oh>8FY+*p~_a}?m=4;E#TH(teavB;UTU~i9ij`F}
zgs_t`bj}()j2!F}Y~1AD1~VH69Lj{@su*vY7&V>cBgZG2<F$@-TUR**rkduukhrll
z6ji&=d+u(`sw<|H2ZRA_v~rayX2VHoUHW7kRUn~Jw!5%ib)tchDR#6fcQMqT&WkiZ
zVG$)YR7|bP#ESK1>P~;zUR^D(icgHRJAYz)Z~mY-y;t8@hh3{OzoNn%p`gMc!>(~$
zi%cqjc|b0liWE;pUA1EO;(yiKL}+QHYkKqx4_pqbI({*`=Pp)?OjUKT@6d-NXCnS<
z{9thRhF>uQ@pp)znZjh3)csV|Huj7n_ir`3PxNX03H9Gev9}^uR!Spk67JH}*9HgS
zf#9-JTU5O4`<sSOpL`}-N=j}=_22c6+3EY3X4D02I0@6P$xOwz?V4=~6NNILWT~ml
z6#~`4xs2Id#~f<U<*Rr;@iGT|P?bWV-OL$3#8I$<15qTUoXkN?TwIvkPT{fPFffrZ
zq$6Mj89NkmHtV60r%bo+P7Tfqzo(<4uddM#YqQL3ETCo4)XVv()4m6Mnm5mW^@WB_
zNgPo-OXG2P&f;-F)Ao6FdH@I$z4P-*)E@V%Cb<A-*7iS0k3pnp9E$(*$j*!)6%>|M
z`>(V)(cMlKx3kcZlLzwT1Cs{q%p^D3;3QG%dV94DxR=+akSsHKb1GtWpbbt|agA<a
z`KS1Me>z)zaAr(PMz2s+)4mP+Mut%4Y$rR%wer3RW6I-5*>J|Lz6Kr?$QYEtkflD9
z6SWIpz!3ZQIktV1TDIF<{)b-_r|XAftMV#j$&_{sET<n9MQ)=m|8@pVoSZbxmmOhJ
zQ(w##3e}9<q*~U7384{I_}?BlRO=5(9^RgD$*%($(g_EIm<~?59FAPap%^sGF9r{f
zrDWD)tBaT$KR)_q(L6Vp5560tlknRBAE#+P$5e=<P7svpW8hU;ed@q_mqMP=!yn}F
zvv0IvZ>Y_rrh|ItD`yBg#>t9nL!faIyKR2i{hNQfnyP;##~aB)VB9`tNft)DjQ1(g
zlCtgK&Mb@Mr3+fNa$K~H(GrDs_4Tcy0bEcLK?ObA`@D2*kHIh{#(wUv9Vrd%BBtmh
z>bDgaWPnZ)5MwMGJAg@DQe#-oqcA~=4q~-WZA7k2%);5aAkT<}&2tUFKr}7HRx?1*
zk9o0>|FN^qB7ONfID<s}UaYph_N8p=t5J(2sDVE3Owa&J7K;Y3oj$li$y%m;mgn8s
z&Z)&YI5r&)99;U4ZM0uLQTy7$>D}u$H~3S~SC1o*`X*K*BetD`webD0LJ2fY$aYTl
zO4+#oWzVLrYYVmk%N%E17no_SZt4?4#NFUeCa!<SUgX%Fufj~~M^bDx|C6pwsl1xL
zx=KpCk=-KB<-xJ`t1-q$8_{6X3okY^sn+Qn?GE{!kyL%7M0bg4U}#R5K}DfKF7}aF
z1Wv7mx9C{BxcBQFXazvVAW`khQ_KFJGwzTql$MpDk&#5W>Y0tbJxdAFH(QpzWsn6U
z8iLVOR^|I*Kvd@6%C+vkNH_^jzoQlFhkV<A%gyGFZOR9QeJ4s8s=eF$i!f(eUMZ_5
zj*Is%>n!hG9F<zSL3P4gL6Il2cNzGQOLJLHy;H+A$;UWPZNJMNX)mSke|#+qE#MvI
z^{5-p1j1VHO!1V4joebdhV!1Sh8t$zGrMnw;c<r){k{jRgF*^_b}aPA9*;30sdd$*
zPKt^T;2cuBfq^hsX{)6I_Z9#@J)qINgcj`P+9K%A?GwY}K$&GxEgsVZ5Cjn=1y(dE
zFh6sqcxy55l-O`I{2*0N@8K>&>j3SLpH5=$T3f&PCU+TxJxZQ_8hWu5xSinJty)~$
z^)2RwV}(F1szs@Rmc_TIBD19r#6F*Ut}Ux`D&Rq?fk)ba6VA~$Z=fHqQn}_X%&_RJ
zaY^Hf^W&!(;olqG<t<$c4I~`a$l>c7j~H++B<0QcSiiN`Zs`mMh~_kkX>bj3v4kAt
zqRd>e7;*@r&V*kBmfy~@DAAYeZVyJy2OUtPwx#uHMMKQRlx5Gh5{gq6Ivk_2XEL~R
zSP8pQR4WY>jK1kw!z?v*H2Td6_b1U&@+sFtDmqZNGTLoyISsYi%`fI#E7z3Ny%5pS
zeGP^gQwF|L70Z8?-F6-8glzSS)}QRUI|dYC$x_3AF&&h)29)7pnHBNu=O|_a{eq+K
zXSO1hqQeHui>wGuTJeJ2qiOQx-CifBd^t@ff!&=`nT<=NMbh{cAWmjedEDM_LA3_7
z@Jh_g3Ljij`Mt<NS#f;=2zEhE87=OWgzD_gpQ3k9CIT1OCvz$?a9frNP+&bc?b@y0
znh&SrHANPsE7Tjq)uKD(TF~FGhe@vPmURfMpc(jXS@iSU<>CL&sTRX8n9}xUUjmQQ
zHfP}@Kr$5)itsi%fR>3H1tk?06x1l!vfV0E+a&MG1oS+fgZ+X2Kxuu~pU$36F#@1(
zCOf9|b4Juze)$td^RtQ3r-H!?gl=}Pf|n7VqTXvTIB`xN4s;TN{*ax5)f5)OVgI*H
zdZqnQ&`1sGcLE;qhA7TWY_h#V)&c>O@&hLX?G)yy3E$^&ZhhP8x4d>NY!e5=A5IP%
z_@oIj$;5EB&sfr;o6nj7f4FYPJ!Xs!J?5@?WISM-81PV+%Td7sl|-67-6#%^H<y=l
zT{0B*z+i(OIVD7DLO~St-F;vRVC+|n9&G;`--G<0cS$DrkuGO=AE;yp@GAm>fZn8*
zg08w%ki3u(Gob+S@PvAZ9=0C*Ndyx=)a{WEZNbM^Boq|iSPY+)rl@RG5|#qGbsyxH
zyJg~s-H2|~w1mO?WJWK4o=E#aG7z;CRvnVE!uOr?bJ~=;!CPhuYIvkfZZifvYKRS(
zA8V~~uTr1p^jJ!#wNH*^(@q@su<ER#>xBE!$<E6Wt&b({rdn85g1u$kf<F5n3Ne&G
z_LD+o*{Iv&QIr4sRdT^ol|ugHw+!3U??25k$=pmh?EXGUZogkdw5z1u+2SOvDI4qe
zV;2V5Cbk}hgS&CYBHZZM^)oe$(qsPsd)QS5G2R9dzv^?$$zP`!L>L#!3Jh5F=n}<R
z(~twwE@F)ABnFkmcB`F16eSdFi1~)yJD@awJxv~;RNnHwV4PvCqd1E>sDzXd6%f^H
z#!qj+Xc-+z_#vjm_axSfw;rmCLH6fvL~Yv{F*d5|dB^u%&0*fr=G<oRINL96;vvQ1
zZE%d5+d)(Y!}mct-m9e=3KU1v0`Ebq^}|vWn3VrQvc1=;o;KKkL2RYOKN+?6D`i51
zsAM(cvXGcBN2#cKmE^p>;Yeu^wx@F6$<jpq0h}hbf1jim7Foq*rv1F**(g8)&x^|*
zf>zUqAtX&uZ5mjWTTaIqA1*GYV&n69ynk4&A;zPHT*e;f&GZTxFe6re-f{x@{Fe&-
z?BUUF*Y~la#{Pgk)BP^d?}GbKda(_s)uw{V^VQ-!h!D2T0{%f+nL~G7TdV8NE?VII
zg|)rw;*9?dbN}#W*F$7@dBvRdcfi>HIl>6SnTtW`_-Zs+j#3H>x5N|{IvbG?3#vt%
zwMsD8VgjSRGBnUCSb_0v_pw#@#{+u+g<D88P(>{2nOI<|+7oL%|GZKHYSV(8=t!r>
zoxcXL?`gB#y-z4Jq&J7EJ7h-Nr8Fsf{RulcMuj5p=QXASPLj%u#nbclaV}ePWKlIH
zTIJq-<+$iVN$dBAzu7s%uQmZDzZy<*HPgif|2;fvsyX|c#akZ_30=4k%(BXF>snQN
zG4BH$chQ`$Vmvfa-iOZ<I#mYBeQYHkQ8n5SzQmdA`dH+CRa*xkR72riUwdDfZ)$Pl
zx((zj|KLfs(c3Q$$r%@E)BonC6`mgAyRi#}=I(XBIzM+J$P3eU`EZa7g1;RrBK)NF
z)AOo#Z-V~F<Lci$<oga(xA2Gc9_Sje2xGg$_*tvaIhhdG4v>x(nrWvHDiGtS6RHiu
z!016?sv%^M*zS2LQ?Bky)?w6zy~iBbEU1i#i2sVy>kbsE{%*IFuxW0IDCD*Fzkk!I
z*6zXs`*_0r;K==X2Sxy00tE|8L;T3d{q1x%G*)rSXZhH#M?067qm&;maHizC-uFjg
zclyyE-$`!l4X#&Iy(yl0{4${c_XrycTgvm(G0%lgtwrHC9dRAg9rG_zW>jJYd0#&w
z??EJ5t%*`7g3_yk3MRgYZsa$DTjMN>bLnsGKdPH;v~P!l|07Qw7YEgNU3X$ULm<r^
zrZCkbC!528%FersLUsd6dk9eK-WUOFm}wvXVj<lQeZ;5_JXb%o7GZF0=kC=&kMyt3
zZb6`goWmXai{RHxa*-MI%nvHiN{)`r+s*q0wNzc_JGB?O<E8R62~2!h6}P`7WooFe
z^|#~8-;Nlj?2m8(BayY;=&J&M5T;++XKET<@bVb4nTy;z&Ud>l0?WFnY}vm8W*;Wh
z+9b<Bn<I-W@f(ap2$6w1^I0$lC+=0BDNsKPMqt_tG4RKDKI~`;&K9vbh?9F?Jxbxv
zFc8T4hWD<n3b}eaI5yw{HxJCgL||qnYUzM%&1-r3VgqDrsw!<qN6wDN!+uTTHaH;{
zThl>dR8t1a$D1hqx~*oXy9tGP%v`Xc%;@5@_uU<_{Cd5RU!W$v&FDtz>s7y$um1<;
z?M}Vby5is9^#Sg&a~JS+_ac`ACE_lU8=vRV0OW^4gP##~i=ui(?4{E3^|bdC#)ebq
zaH~l{J6`2AJ8d8FjC&BCGZC%fWoTowK4}wZ^Sn6QTb*GRu1OAus!S^N1oMCOU{Qe6
zBfrUQx$-^0V<+G?(`Bnv=?H)bgaB}A#&>RwM}Qo~d^}eekr1OoHS?nC=Ejw-T058e
z3qXbX6_DRyV<?hgwH_d5Y~H{>G@l}HN-zXpc`JRbxa^c4)0EvtcBgAP0T0c}Jl_<V
zD0`U+;S^*&$JBFw!sCO3;YRh(t1#?k3*mFnAoW2SFwlN6p&+PPmL(2<Eh(>b^^D26
zpYbyH=p96CL#CN(rIaSjDe0dI%5I?_lk`6uV5M~Vd$Yxc!Mx31%5UF;E<3hSGKW@^
zwSNDRoOnkkr!dpHe`J-7M6esT5q3Q5la}6oU4Lw{D_X@_W>0XdRISs!DV8A`qX*1|
ztCYui1(8<nr2`#23jQGe=uG6MNu?zb9Lg8_+xw`z+h!puTU}&?ia}rFxaCTZkdL8Q
zb)yazvZAC*%njHGQ?mnSBY!#r<?uDkqRw}=)9UNV>VNE%I{0XGx`%8T&oT^83)qCb
zzsfy#6CqsK=~gu~WVD{^QVOm@5MNE`WY$lt{ux87&*Sm6#a#8$TUO@*nuiVHi_(V-
zLDlwq9it}mr+7K<Bhim5CRjzfu@T>Fl~+65NKPASjmCxivQ>Rm1ZLEKy1Q4+2;kx(
z==BNHSC8Vzob8JLh>3!D?MISyppV1Tp$l{%e*Wx=g6%rd*1><{u;%SX$BV(IHTLDR
zI~BdaePcqE1i8Z{$2QiS)XHMt5Ojvdpr8<;z+cTwXCe(}Sm0;UwL9E8SX}L#U7nQT
zMn4d9!|>UbGyYRnG7DMWAd((u@SPN&?!RJGw-ai<`r0Fh-){4p#V?tx9YP~w?ER^N
zr{vAju-DrG&$j!zGcOQby|~A#F4cD|Q7szr<{HZJ<2Q7l<4^j!nXG3n?zB5!L>vDl
zJO5p-!v1GPfb2F{C_hGtQJykLD(5Wla|bSHNGJ!Gp4xJ$Zv%wy2*isgRwDW}-hGM5
zD5V(g3Ej{giFt8u=BoWF^D#L&+x-$7FD}K`dINvC?;8D*>wx1IstjCv5IB!6tq(%)
z646Qy`<~3pf;{)RVOJY7t(&1d$EgmGZJ=Z|!%1mrvG|`%tAO)gY3b^Bqp@;LV#+Hn
zC2Oa?@$p2p7k3R;XF9raC?;bG@y8A$(;Ljquu+CTJIwBP=IA`m^hO4Jt$hxk!kq^p
zs`SIY-_Qu3%|>)DOrqDaP+lo5q-v}o)iDq#hm2l;a9Ia_yj4^(rP04T0R=%|J((Qs
z>y{t+BopsMuOLs`0c0!B(avWdFNIi5qCaf~05Z&bWO`ELzRWSE=IH5y5#gr&nScsh
zCyzy7)p1k*_$D%o1FeOpYAZa7<$kBlocV@|$a%^0&rNy0+`Z5LZ$ALq!_wPVJN=e(
zUloeGqN1Vz#~DJy+smz7W?O>YDP~C-b%55mvG7)7#K!1uPGo0!j4poP(&*-Xav!Dz
zuE^71fTzX;Ra?9Z24~Cj-v)=j-8wsCy}_>+I|b~>6ujy`{Y-2Th-O8V-Du99t)Y3S
z=CQAm-!=LJ@!Bx$Mi%?RUq9G*%O?m6Nqs%t{S*owtsbbWsrvw#LEAnf83W`HsR+`)
zJs-}e?g+=_x)6DAqu~oJa2%O-2{As%cJ=BGZ}i2Q=4CNWO!nszpcF=+zP#q9DnI&S
zArsg(YRkZ=GhG=K9Rr;inhJJBG~@SIh=THM`HjI&&TE~Kk1gh-YP2wtB>@Oq1@wc|
zMkmsMpyit)S7^+Enq?4VFNO)b{L3bwbceNe%4gGy^#(um?v(~Xz&eEvR<TAAIQ)H&
zyR>r5+oCY{)s#Dnpzeb}LVW_)%mM!0r8V{THHiu`>(jj_tVG;ipD>RBk-nUnUfo>P
zN_y-xJerPwOurNNB^&wLWD<AT!dx9Qznweh*P-4JjL3v6AhC+a$(;vAwEMI%h+%#k
zOXP_WtQ)hLOnN0=6vZq&NUV8qnV(pT7#1wY6xzDLAR62F_~-_>B-x3$5Im;7G#TDZ
zF|9+Nj>5hbZLUb#ID$WI|CP)`;>!4mq0{Bbg*hID#ZSH4z1UYRl@;P|>HR4ns*=yO
z84(^AokaG>pUgD4N439f!Zo{%!>LXvn-a7Q)_S9&Noz4xr@3E<uGm+QWcEpTU6-~~
z$EY|Du<c-eo9XMc;I?w1OxuhdF*t@4QBo#0Kc3ZR_X9+leYL)JR&|N~BhZ1vVUf)9
z&S~|s!yUmlz5iMfu>Z3nsv*8>S@6g;IzF!+5)V{OM<*xL9ZF%{;#h_TT1x%-F^tB2
z&oEWoUC%j#LXSMODuTI?JTU>bl18N3d`Z22Oo&^A*y2{6agz<G@@}YL!9G-KM*X_f
zIl!p{HafW+{<Ca}LN4$BsU%bW2x?V+UTHAH1ngYCe72y{dmNIRYRy&{fwu>;V-LLF
zn}1krXkd(jR%;;X#oH4_(@;TJ!NShFX1#%pUEHR*yCWydJO74^{2P(I?rg=5{7A9_
zP<TMc<%*}CSiB|h|3Fzz2jrU7^dP#V8*9z#&zhkxo&UTAvriV0TAongX=-`80{s8c
z_0?WMicsy7iO1?R__Wm23*5tpyEPESlLc(9+Ed)#pe(bNal_}_>{gs$!8$M2OFwdc
zi7@O_W&};j-3Ljns~{#xEu4h9xpsjdl>t8Bs!h0}6=JI>%oLUbHu*M73`ie%FZkp0
zb_CPg=lZ}({!e1+>S$-H4vHo@5$lh}Fq;4r<dwk2vs$Gh9<pxp-opp!KsCJ+I_D<^
zlV(>gZ8e=^Ok{UUXE6-CKN#Th93txt=55>r$PT9Cn=-mw?`G@G6$E9pntR<HJTi4$
zQLxgz*3XzU80Ie7c+uAqb+ETP6D4zu4%T-1ym1ZD8+A?vGOU5CHWcBS10=ukzkQL;
z>X7F|vsXGLyHNRE@YXGCIj6ZSZYgK=JTGznE{tFyjyF*uyFmNhyL25#LWWZu6;5MX
zmqsfyv@t@UrHO>*JnkNX@bl6|(J1@}K8&*E;0-JI1!<i9OfQL`p_}UfY5UR?rCyf#
zHhwWSHmj08X|7d_qUQAhendCPArjtk`g-Zasz!g9)Id44^q4@n^QcS5MsYn1pX+LG
zs^7N{!ys32`Z=!lwWQ-3*d1e0$epr>W%vTd?C&529PhxJ<7};<8Q+tMv(|#F!wdYi
zB(~A6^9#6jfev^3uHB=5bTd7NQy}?OPN|tiUd8f-qqsTW9eGS@A$#>;k&bid=JV~4
zl+?j;-My8-^BHd6t+c(pabr-!c+%@s)-eCUhBLKCAVj)>k=^0&o67Xn?FW7izWWsf
ze+pEQX&%$-v%=&qoTp0OtgZ%{>7b{3wltjp6SOCpFNNkc!e)Q2Ympq@DW#+qFMU4n
zloi(iV&p$Ubt;XEI&rlYha&}JHRG@?Fz1^wpa_qfBT>c0&FSq91o@jvf!mSpVHvIg
zVm3jI+by(Fv*X;;kcSg(nIRsxkK5fmuGCj{Z4dNx&IuyR3b%5-o2TGixsA*I^XC(m
zO?dI(`|8WOR)?d$3bp#cm<>sX`m3wZGy#PLh}z8c|5loQAE@M2io8<HucqV?;9yFE
z(U6h#>A3jdEieJryX6fPF2JgXUnUAHy@#Weo=JJ6XJj;H;z+ju>%unqUcdv@pfADm
zO1nEs5+*XsXHt$w&qjDS)6w2eF%8=rR6}D?I#L0)uAk=%*k}!bJ7<`vXcIx9g^fhF
zu;}tYQaC6Tq^84!pV3iW&cEo=zLWLo>LM1>+OM)X6JE)`)s5v$_0pfXEZ#Ra6s?wa
zjA-3^p3)eGLCrJ~lov_<i>pH{bXlCF%mY;ebnj)d#JnNGT@yAadDxVXg{*{`<EvH-
z2uk{j4k!p69~8ROeMXWd8_IWXC2w`t*4|SW(3Iys3+mJYEU^y)0_cbLecE^%K-PsR
z$2Nx&8U%ZHJgZU@yM1}t8yJ%4PZ0U=fW_&;==W;VsS<Bo=p`(YE>bMJgF$%4l%n&~
z<tq}BneEdL*2T;$vPD)Lpam4DQkhndExk1n6^i@(4o0ogmcboB!)4TjZ#bNpfo3oV
zi1S~7Sx-pB#EkwF;Zn(pfkMJqhChaMt4{NIo5kCw{CN6<kyhc2;J<sFdwuQ3r8^~%
zsW<5k9d7cE5|_#~e|xlwZE=sD-AurS8D@fMM%xQK8_S~))%q;bheT1JK_At>-8JDZ
zf>`f9ALk{Ry87rJ#}X<x?q8nTDz8xL_4E6|!mPQNp)b0{Jbs5JVbCkx3aw;=tz9A#
z!Hn`R8Q8WbK{_10$<E%vEtT&k*-7!}r4vDO2MhGQi@#*ni(W$oose>Z!a}Q<F&2vQ
zb*;V$@DNpLMF)wbFAEw4>Ge80#faSz;6iH#MNhL5@dVc%^&$T<f@F(?Oo1$fmEC@}
zzyQ7w_L;a=s=lz<+at`KtDRf_2u`ET4|3^$Q~NiLgt{dhFxhN8Wd8C&ZC?L7#br<p
zrq<t`snkGc1r4*+e<fEOaH$^|`Fg0&6&JPGhI|=69IX|YFV0l+{A=$y`_s}K4!bx0
zPzBg@N_TM0()D%zq!Y61upZXE=35z6^a;x#(tSTJv|!dotQN&uf^+tm3D+t1|9ABY
z?tK&N3mbCcE8(~k*;e^1yMWHjEonfSLzxi^Igf`W=>uP{AE;qfi@?}?)P}3<Tq_~=
z1LpIpQpY21e1^-g%-CMP7VxJ|db$}gsd?NTQqN2`uti67+eRpjiWm<TQY+E}Au1Z-
z)H++C{gHbkGoq+U`}kP<?_Cf^_|yNsHU+=RubZIt{elY>+@rcWI2HO{6H-4jJ2pmu
z!FNHJkeF`mqPG>m|J@^eXcA$bxThv$cl$>9R*kjP!ry)euJxqEVr_x{f0F|L<rVu1
zBMJ;uPXHx~*opnwk~7!4Q~C5`#_a#2>>YqB+t#(=*tTukMn@fY?4)B`9joJxZQHid
zv2EMNzxLhdoW0Ne?)UxoRIN%?YOOhIj5!D1@xBk%SVG2WCT2Y88TR|vSq`Nr|KJ$N
zXIHl)b@D$%-o0KP;f|{n3zr^^0uKu|ftMzO!@h9^-IoD$zwrkpUomu7L~}zert?Ps
z2}`pf1ZnU(X!eqvPC@Z2l+pia8&S}9zy}nra%|O#EHcKDg)4hIn?DEF-DRcOa`>iA
z_;q<KTEC06xS~pjXwN<QL?G%-1$xNpkc0er&#5OU?N?o+iKgrO2oEu^lPDmK^kUw|
zIhOyUga5^g_*ZX<p?(d724~9+k^SRF|NQ3Pe)d28gM$xDTO)D3x`CP3w8ufF?x@-H
z;=U1!87&v~=Rm;$_xnXG&l%>eK>4r5_3vT-Ul{Q}yPz)zf^lFKu|o2nw&bUf@*g9z
z(5a!g>d#yKuRHP6R|EQ&U2i#83G=@O*8kMm|Dglf)W}5JV#=+Wb87$TrQPLVl3WI=
z>2p~B@3-@Rwqz<E>X%(EwGRCW?SFcyzA6Y=Iuos&Ma19G`TwiOWhM=1?sR-5#{J)c
z{r{^=nP`Dg<dV@T*}wc%^!tB}fxliH8#$o4X3}cmFVg?%rO63E(3E3gaX6&^=}1aN
z0W_DbpiJEBpY!Uk2L1Qp`rp18lkOfZuUMyu1P=rYP;(S4E-m*jpJS7hZHM8sSz~g0
zNK{ot!oq=LARtgs)MYq}OG`1fBc%C{r`<^+pmU`ooIHh?^-z}J<l^G`)<&Sj)+9O2
z)kr&&nIW`?jNSLAi_V&GVNd~$Iy?al74Y9wzxgIKum`%DA(|o(1pl@YgpmywDkBnX
zW-Vkbf7-RBqM^3d%qZIUw{!XbPmg~BN%#h$;vw`wtH~omS)s#(d~A@bM|7`v3)5%o
zG%-w7da9WbpukCdJgXt8=%-}lfjXV6;_`WU5%W`nqZl#@c{sqJDlCay8i-~)C&~S?
zBaYIjEbc!+O9k>n)OEuuj5uMubJ{j~>;;7t@U8HS;_%B<#ti+7-SyvI!T&Hxg(7`}
zG%5B=P_OQ8gT^dz7V!+>on~ts&v}~dcF>wVJ%vA+NmCShC6K<sVX?yCrKjsp29Mj>
z4arH$NMmSw#3v>8E{jTZ&&;6w00r$Y#QDMd=*Nuo`N;XJ@ls;D&f%IBexqn`4p;^j
z7T}We<s??T&gAMXFD{?$-w{LqL)-psc4r?W6NRJBH=9IFO#DhqDXAN}FQxg(?*eke
zQkSjVB`|e6!3(g7CUIb4NzvaS6v_!?*)ukU)iA3e*_ZaOZ5EzEl*NHTcxardfxN$f
zYUEf@P}L>gU!On*xQz>42l8>Ptd7K?QT|_N#4qHdtyN?^>-4~M*5e}LE;@Nt>FL6+
zME(3|Z|QGA%FW5>uqgwryM>YWZ>crlitDMaAw-LbTQ--#1ZPIJ=Rgw52z`K5KCWd`
ziJsWs`{pbO7$)<+mVjZJknkc7R-zV{EFSi)X9bMI^LdP0Wg09oAt7GGSR8z5$vg-q
zc~gOygbe5hpH53(o_LVNB|ZY7_a|nOPaB1T(9LFyBhqX`Mc`H(;i8Ov*#CWqnn4G)
zHu<YTbP^knt-f(VQ<CAx3bN#klO3Vv*Gza&^CBGBW-OA)mD>LPxRPAd*wQ~Qp564X
z1<BwW1%v^AbpSw{04%vUi`eus*`DxT#PvG3!fbvQyxRPH*`k*OV<O@hXqXtK7fKq6
zC8?W8Df04!RUS*PL+~Wqfe~Xm(OuxXA$R^88LQooU6;PIn7APgNE(>be_z$|!04>c
zh^lvy>>i*YC?|ocs~5uDWo}uvj#8T<8imnMf_=+;umT^mXxO}W2c5YZK1it;a}!#E
z&3vBsL8`mVxovL`-v21KiO$>pt}Rgx>8>{54{~H=U<lHv+Xy*btSYNjZ#Y2@Ez%6q
zX^ZNMB`=!~!x7J{s{=(tL*oqVWcyB8>Nt*Do8@$-mDQboAumbkez$@wIov@~Ks|E@
zUC!4cf+AOc0~K%q%)h07<M+kOursQYsS2}&(q;}blt<#PMcNPIkKNe9R{}UNEve{)
zAk({Zs?pN4hks~V$FqBS0Q)5Z3uYbSK7=2)Nl1m9F}AwC7K9hl6G_LVm_su<MbwC=
zjDUV>5*FkKKQTAGOv9VY*qhO+KsVyQs_zZNNLW}<+uPf|6o$;-YE6RxD#DA+QdUI(
zm4>a;Q`&}@5$y<oH<6OGav&6u9{?FiY_VsgZ(y7U12%w$h7;vWidyRy;+(*<bwUV?
zZ65-du1?VP7W3MzNe`!(vH+_UF(hnkFkoO^rBHz4cDAnwy_;v76yN+PDT!vWF{fl^
zkT|Q`)Alq#z!MGN-pkSx5;^w>)2NVBT@5yo9vT9V`_SVDYKog54ezWVy7*%(8S7_g
z=uT^+^{T;AqwHq~1w|of1omvm>S1qC831K)+QKJ|1kCNHOaB7Y>VVYuIMjulSKlEH
zm5-qtz#rO1Oi`R=_oc3tA3-9yEW8v~CGr7ILLzGaB~c?CxJ>RHj2e98ms%>UI67J9
zE|8-C-!}OsWWcWWZPySJ9Ze+sN|ncxtF29V5!fpTo%i~1A|RwHTH$c?85Rj+9wFDr
z12~Kt;8sI?etL99*B^d!ThJaHwl*S$`e3#76|N+Od+TtYfnqx)grd8hvnzH6jrd=a
z#X^pVjSbD?{sdf34o7g(Q06IJ0d*VT9|SHYApuKhX=z!*ZE$*gEY%Ag1x1d>50bsR
zR0JhP55?sUDLiB^FGHWc`9c4EfH3L5?wail1%QoXXL`Tb*x6Mp^Jh0Spf|Vivib=@
zZY!%e<9~_L2HGD3-#sVz5_LAvpXP@b{Oi{NL=Y+<K^@#JG_D@fYy?P;lBFXVOsR(W
zinGEdFB>Pu`~1`(ZccSokyg$(fC6i{fco^j7Cqj=?exF|Bu>Z*EK#1f`yXTNdgmw5
zgC!#T?`wP(@=H9HDdRN;e}#Z+Wd*Oz;JITA{M$ZcqYQ{viU)%j4KOJ2mdGT;hN!9?
zozQkF32gL@itvk%*W`B><u|Nuw-UET`q8M`sRj`(hbA_3i(``#=&M$Ut|>1F$MGNi
zz-9E`ld60h5(eo<l7;!dV#qafaSNR)oCA#&^nV*3o&PCnWnG?QyXZ32Aqpl21}UVe
z%8(u@6ByZsAo``z{<hET8AQ;K%bS5<l$I?(m%wIXs!PlBXqs6G$*Z5Tpm$`6w%Yqp
zxVV@tYjk~c6<_no6IO?cftqz$1@eNk-WKx+9Upq2z_|L;jqc6y3N7FGAgm~_F46`S
zgrgR^Ivkq%SDae0vV7(=OE=^X{`LHF(xTmL>1b%(5|n>zdD*&9_2#n>t*(~{F13fj
zD|lGqC^~H}K>#5$&@f6WBw%GIvB;F)DzxL1ftIE&qR^`w&6VyZr8JD&Ckp<Q`ny{o
z02<YN9fD1#P~)=Omw1a6u#3)D<BU&Q08pUz`$!IR`Z{2N)9>-8o<9jIC;)ftkosi2
z7rwo70<PzXjmde9Iyo|%q)Rm02)I9&e-;yx%JvkJ@0N06e)G18#44}`MX`Ihf<P2J
zZ_ZE?va9fnQ;bI#QjQj`*Q3m-Xj}PeG1nUkWP1Kgc}N*!mb<VCWbxOAKm^Ds{1MgK
z(JS5|p&>&6!kxgC?XO&Zi6k&7L_~s=nC)-xM4YU!D2#)`;_lq)t4r0u*fM5=6wGIM
zctp+4U`s4HVjef_6peOZo83Uwjq~bmS9g70bvaCv&34^^m8xwpa$~OMRVtc?7-+yS
zC<vMDKwdme$SaP9v~C`*7Vw_Y8JsI0OFjGs*PpUUCtj@%pzSXslT3ivgvn<RtXoBJ
z^y=ab(%^F1k?C-La!WJVJLvIsa@^OCpGUF{vHj9r$ge+yQ2@jU!dVS}xUBdGn)mV(
z<Cu?Yiv}226(2MDV2vYMUo|#kUrk+7fBwWnTu?O3eZnEX@f}bOLu$0wYq*{P_HI6$
zAcHqVdrFH2b9P(&#O^_uR7OQr67JdOy;pU!`3*iT(JXt~=WK}#_Mbbdf)ALswzmFG
zf9RPHku7{K2S31uJHQVV^5m=4e4*^h;{y><))gb;L_h|iY#YB^J9LJzy&O&aULmMi
z`;(BkRG(I{rN~opnF-Oalx3#N!a|qz&CNKC)aH<~DAlxwb6(ItG9B^pU!h=bf)*+Q
zi0J5kIV$#^i$UXqC>O%{Aqu{!Q2Olj1D9T|@}N@(Kn+7hSo7;j?<X7xTNPe2lbb_^
zv2lZF?Q;A<fg8*I2{M2d$-JboEWJKTL;PF@7C`d1*nkKmn>Somfea*yVPb6ji|y6b
zHO89NcU>9u9d7KDYTMr~6cJ_+po3AtZ)bRk8xRRrDBARBdj}#z8~i!#^=MI-%fI{4
z9+=!_z`B3nQe<N>*`R$dGVR`HJtShU@gBzzV0)Ic$;Gb_)PH(Al#R6m0q7HD0eKSo
zz~;>(oOb=dZWRwYT}Sk)eLSAQKq%J$2_XD|%+ODHT0zTbS6vsRe46CPs`Z}Bm^~j+
zVgw;%O965$c&|alTBo7vHRR&z>@Ta=1w-toDR^t)B_<5O-d%vBrGNeLW<AVEmsl$6
z<-u&F@sY|V6tuu`z}iH8>Gj_BO@ct<`Ga+>fzS1rCX`~&_fJG8!15q!OgbUejD(#X
z{VmzImZE2MRZD`+FYXI9HMNyLRW^m}j6f5xp9w~yzIg>c)kJf#`$ZePT!&PKp$$vj
z*N2e^ih0u$I^<$`5USK)T2aH}^uCaU-!GM(#g#Y#ua<s5k?(qp^%1I)dP)Zp{2dHn
z5m-!<j>S{o_K{H>2vv-9<$M<;S+$@v^6*<LpG(|E79>OoL1aFXrrOG7)`K2(f=zWh
z@C_zjC2{n>#lp?w(7!UI`SpB#f9W4_dVq1&sN^0-6NH?1eE`2UUHHb+LT?=((l#HO
zVIw0@RdUt1b^$a*II`S`5o%{=i1V#2?Hru_e5a5MSl(ui>+Fs$b*fJ%@BNE&SF=Bm
zSRIO|3Nvj|_&rwwd$iMJx?YtfZPy*+QL*pN(4Z69nLq{H#q<C*N^aET;+9DvH3A=>
zPl{%4UI(w4q$lrbK7d3A>KCer=848pUy$Go!S;%=$~ZO$p0`&e{AsXE*46_mYWhV0
z#chH3YMoc!;hAz`sBf{$YX2rPRe)gXJcQ*d-U4JUiGP6=--1r`{N%GVWC7HlDTHJ(
zB5G=A)hb<hpO0tCZ);B6#xqeKG&-gXDHG}3pa7C3{@F@{j6D4)1qhG}gDzfh>>C_|
zEc72)4<ThDB;=eLuu!i7*Y4%IB)eSbeeV7N@*Y5yEEt&-L#QPs=x)@AeSnRny#07%
zW_=xdDmR3$xrLiKrzqrCkn^>u9~2fT6WtFoHRD%uZ>s>>{C;}j>=O_2x3p|8OyO`;
zhDL^_{+4N}e+%{31i*%O0!JIZEaE8gw~4;B+#-3N<!^b5mM6Mhqx^9&7T&JNR%vS-
z;~ygLkquF=wDmN+1U?dUA*(;#K(|V<y$!2%py-uEE5+P9=-JL_1J?0(I$4B#f$LJP
zHuHOS#<l|yC~jGhH}_B_AR}X~>*nmM3@F;3NR|^B4QnBI-dys#dMD)VH;il4y+}<W
z!_$5?UuST8&Pz~G$iGg*M@9i6?BGJ>X|N`52*SYXbhl(!Gxm3et+7TkY`=eIyjqsW
zEpQ3GKLxoI<OS{LQJ<n2MkL7OL+gAguu<d5R)KP|C4oS5Xdi!hoDOp~#Hhb|3?90~
z1xJkN5*-yS!!qj;*$V(?WOxS-e!K+n^G*##aO%6BjeYjDk?!~Pk0YPtC!+{D2RTS3
z3vY?d0lcg~4$koM*`=k@$>0AlC}bt=L<A_OTdY%Cp@O3p$z=e*-%*kva9UccnoY9s
zYdB!#R`@+tvbGoBtuoxM3oLK#pdtu*=X=ELC)kJOrYaXOXt~^;0?PD~f0fhG21m$9
z^pj*%1Qnn^eR+tzxm9KqR&)uA#~>x3&+7)T3)~B+SfL$aC!obUWB7B#i*ocY4`4A8
z7Zj3Hpt#j0g?F~$6*MXVG7PIs#+Ijhz!w0bmzEG%^HT##l!l@vl(+`<FCTgYlxVAO
z){6_%@a=tV_91pR2s<;GJ@`wu+Ft0MfQl&9MCaiAA?kQHEnBKa?d+#!Vww{MjdTO;
z@$>tAk@kCEH)%0{Gk7C}gnT49PCEj()FCnLN1$EC{bdDpN!6)QIUzfBlX2oZzzv7$
z?x?4dH|?pz`yGOeEWdZVujXsJ$qTP+8VCJypeLir_z-S;yLNX<XnT0L%=T!4rQL-#
z2mk;JStPH=u_B&+b~!_?RIH|;0C&20iN2$#SP|&WVS53NaE4D3-Vrx2NYP8^a~9mp
zHA{DGAWE<G(&G!9k?m;u(1vj5m!1ydQh8|b`p`FTA#wB#|I-`*er<KOgtuOWfPEjd
zj7v_2p_JDR1{5+Oq@-2=1xGc!<=5D_xP={k7Z>3CLKE7ulEU9hyv-#&0|Uq&k2Z*a
zaszZC4IjS_aa`z@kx^CebRMR<U^L7owdnakzmqQp{f|JJBnI-no`BTX)t|`x27ALB
zzSf#rTD=XH8g>t7=ug`r^k>+@mVQ$TtLi2bmfkN;d}0!o7njOK8_?mHpLF;i7j2MI
z0E&X8KQ0=r$@27^uk*F*Qi~&)*cS-s-UtB9NQi<`ez4~9D8?d#lK``ecX#L!^lhC;
zLQCtxC$}2x<_2c_WS;HmwCXc(v#7+2%{A@ep|RI1Pr1nM>cIsREk8Q}?X5ER7vv@O
zlh^R?vW*V>OJc8A7oazIgETk!)viyvxA#ZnhxakmPSo6LDEewZU44PdzqMJwZK`s-
z;gdI<HjJo(YTQf@PQ}j7KES2p!dDgFQ%J~-*Y5htuYK&BWUCzx1HmfnkgLtqYu8dA
zBN7k76bv^5!Mps@<kWTb*hCMsM`Q|(3U8e&ZayVW=O$#+DM-xvi-_H-+!iVt#T_;O
zHj1`@GZf%Z0fjAft>kHeETQIlB=DnF!6|_M^irz{WmGy0c+%kMu4t*H$uzuTEhnFe
zP>CTcVArQAB<|Bj)lz!c@zxw610wQZ^xdDd*-70=e!Ii}cY6w#j~%9V+Yj9eN%l+0
zQ3EWb@(xq6XBXd3l*i(Qg0KIcke<SVJ|fJqjOeHc5m;Vch205u42c$AJ7(pP5c`cB
z<o-O>>d2;T8i#=yl{Hn8m#COLBnDlBNt7Qs_|4$0Mcu&1eVuOM;i8K}B$_xN`*5nK
zIzXePTPmg%#;ik#z<c#3iw_!*qe%kL5kS!Jzo~H%b39EXSqjyg5Fg~oL>aK^2J6sn
z`Yq)68FKVHS=0W+W2ot2H3A05HX`uCkILxiS6Od=g*p>-A&C0CXI@%emNaG@Yi*kd
zLIw47`4trsV=P#CD2AHsdansVr+!DDO$4qJsxOp8?nsCQYWt&AQ!?CVaME4b&d5I(
z8qT`UUw`xn`0LM`=wBZvkwd@(sD@m2BpBYBRVvTn&-H)icKw2he`RJes0UCna(eX+
zs>=hYLt_;E2#d##{xt#$?z<FQ!(s@Ed6`U0QkSYaK!T%o9i=FZ?c;)!h8f*a0XZs!
z<N5-HuHJ0$(zmS4rKncPTSOkcAk=~%-I`oo=eX4LUo;Uj5x9Dyb4uIM8tFSBU-;_L
z(!KnH_^uJdXn*v!)$Pg$dTrAC_QFL1Y0xcpSwqAGT!c(*pgNZ>wY~U;+fqF>Mf&{|
zMilz8M$Gl`N&>(_#htW5h~exXZB`O)NznISJRvY#zRFfe4m;kNA*>g+7dGL+B2;<E
z9;Nk2*NVW>;vVr`b6+8x()^wmi?I}fjI?|F1HlNu%kntyVLSVH?Mble@ey^ycD_Hj
zE681VxVOOU1S#fu^rdqLSD>}O-LM_am*FoBXVwi6w6^lV#C3IeG+@>O3b!Fc1h3s&
zdzVMkUQ6FwRKEuLheHxzLAb8<d_vTmPfZ;#S*atcH=ZFry}RyC-al>%MzoY-F}TPt
z?c~!mvbx_8afGgMQB+*5B{F!4B(LrB{6-NFu$gMGv`pr(<|@~2K~H4dEG{R>zs4CA
zEeT^6ba$8C0W22Ai?<9T#<@!n4_zu{Kpeyys3zk$u+f5@bJ=FQF%p9;J&|94^m_U~
zNF^BbcYb2_EUFoG2wP!Rp~C<JELGv<`R_xeP(Kbj51#l@gHQonk#xJADBk+VSU}pQ
z)^YLulPELXA^fnxY?@9Ojf}C+5drQl_~Sh<h5eWP)y?nUDL_K5Z{nSZgNk%FCuOtX
z*TJ=LRfso(0H2u^(P{=3>y=f1CUFh5Ob*ku>FMpOvpVJF$7LOFDC(%gNJF}I!Y%c|
z5W-64<45zJwSER&z7U-}yAt{ceb3~_VN#<dd%+NJ*g_WKP?KvInD#G`FM^ewECv^+
zq>Z+w#*n}aE6ka<DTVUw;nu@VUW4n9y9e$4-f<W=Rzfktx2o33Q~D?o-h13n-!Hxo
z%gOGX=!1x3k`kse?we|Nz;0x?6vZ!K9t%DbW8HKO<r`*U5Ldr+m=@IY`Fo{w?3rF!
zm$(<kB(=D|ii#~_VZCg{Rqqzb8{9S#4u`ii`<Pi)Rsqa;eq}mgU%Yn>0P>)jYC<vq
zeLJl5wGL?2_6IIC28v$Z`<)fk+x^w62`?Z)i=L5r&;_sSM$H(DjpwhCLSN}39!|gZ
zLL)<1|63j<6%6>JB2UVx#fJBI`w+DFr1M9j&r%X0`?Etk(@%%zGj}R_h8Rrjh#>+&
z>QHjP3A<#0o{=^H_46DO&Cc!Rwd7;ux4}QP02Y|l4wiU59Av%T`aBrCp6<k{zB8^G
zLRlUoUR25%&g`B0NK63WYJ0rVsn0ZMNoJ76HC6}fZ{1n#oqQiR5`xD+Df(~L{7ITk
zH`;oA1Cv8Y!Y=ULoIBJ_Dl67T!5dq=F6}#HyRLd*l5bB;XH1tz;dz`<m07kTjmw(f
zTn`1Q)QbSA7nI<KbGn3_vRKc<4$1=Re<;*N2KaJ|qq=>eDleC@H{Q+u(qZNVhPJSr
zfQof+WcvsRMF1^3&n1r(K=gv5LSVwc;|De9-qkA$qlkaa^+gZDrg}0P1rEXj%~G!f
zm>y(ehDp8fy%DRgn9&zdpHj^pv<r+jjwcKzZ0LF2`vAlN-Cwy{UY1Sef7dzf0HhUE
z&}EOleaALa*-FyW1+OPCut;V$%8xP=>16b#B=ofM*H017tcvKm8Fj*+4y>I>W@i4f
zs(4{^aR-3#Z!hZUsiDgbM+Y6gcYVSKF?LSLIgI{}i(}oBq7boLOo>0F`9|ueDh&Xz
zGN6imokNzTN)x7q6nwiv(R$xh)X3+2e?FW9Xi4rRun+mfYREJF@F@$o>@=N}8qtB&
zToqylhNw>@3RAJm^#Mpr-Z0=sOs22`19+iQd5e%0a-H`JUnxvd^{e^OzHD7`Pz^8Y
z^VcAW%bVr&D=@jH0l17aw5bXYpk1f(0^HCWZo39T27#Tvk8E$1)Z(Z&FG~wrw)`Lr
z3<x(?0rrl1gwH*io((aS+h1SI8LTaOR~85eUhUW;e9nyj=sY~8JfYjeD?SoB>o*ND
z^&~3l;kcU)5Yg@^Xq1ScN>R6%si-Ug<#qB@jXL#akE&9@Qv}s5>QO%IZlC;!H@&rg
z;EfB(Zk)E81nD#4!+(Jf8Iez8u=&+wd*P;PPZ6(bF@((fBA)h&)L?^H70^)dAW(L2
z(X;@W1MzRQqf|QJGK$q(o)dt_1~x0C74(8tb#A%XYc-=_dO-q&mV1duOM4}s&A@}D
zNzQbsx|St9*zl=-`%Ph&qlBsHR!C4hyJhB=Yu~cEhXNeR!+CAq?ET=-KDJTEA1%qA
zpIC1DyIEfam=G$zdhFl_+)uL);AU0&H)VPYm4+DletKSNQCDC{$^G_cRJB&3jlFpw
zj1J=e+C1H4$xCfJn9sYtH3F-&vKG@EXc=n>Z}mD}bP-}OizzZ7+f{S3n^29eWXW-x
zD6qG0hzE}DhCj6e27$}be7DYftKJ%<F1|GJ;~14{=C)&>M(M94c5?xAJo<sqsJVAR
zYeNPpXO3=s0-XDpY!J)0c(#Z(#`JE9MI@~1&t>SM>~=21wSZ(P8xw31xFZO%=2tAC
zaOfA1Fdh&7W~lP>=TKy)v>4ZOlD(pVfR3`JtwvCKUA8&}PTnlXdpfeLwVsw4yBnLH
zdrHA`mO5X1l?K|Dk($zHLlbcgVn=s}Z(m`wAUO#SG)3E#l4#jte|DaJb`SdL#YA7o
zPvJw?*+OIz<M)inyuSU^*4ku-pRiKOf{P`bNCyx&D_eG(!*t-x&6n-24P*652*u$Y
zFcCjKGN)RdWw?9<gv%>kwI=#Uj^v2Bxs{nBFOSS9zi#B>LjI8G^^IE($D9n_?#nXh
z<?!B-sW8wskIsqhAk`;SMDhiJb227EY{vPVBEEm5POraQjLvG7xP7CPXIbPr!!Ofm
zL+Y`HY&5lE(e?i7I23aq&bYx?)BAAEkF1li)w0TL&s*7>B>yuc1d>Gt%xL>|@)`Qe
zUJwIk|E+Kt2>^-5HkR=kvz3|8;pMX%83Kk0b;D6xd$T>3;wC9S>GuoCWQ3CD8_Hbv
zX%MDvGvZ(bH?2D7ugju{JT4%5UqGmaaufx=?(nmcw*O^`BFsYI{SJ{ie05=;UC^FH
z&ViEEcvRo*^_*~f1K_kcB(camycy4AqpjC`TKS=^(r$BvvNuzJc3{{SSA$?+<5d4>
zR^A1`3ien-H|>u1-%f5a{!r^@c|+K4;C2pM55QJ_JKuGM>f*IXH0*!hTWvK{-VkV=
zl$0GetTdY;=4|rSD82Saz!w33Br)W7f@U=uq@sAzq%^T#1rVNKF>Lly+-yY?v91IH
zcQD>Awua&rFc&4f*8s_-8?yd|sh$42ML|d>FJi>!<zu`3F~wooE{G!s61GxW_2nfP
z6+1fHlUtds0sD-US9)*zi4mVBp=e~BG7Y!Q3)e-qrPdu%_gU?=<#pIKFLs;C>TDuj
zP?k97PrYo|$Pz|6m9@=E(VZ65UwEz<R%d6##m*83jiR*WqH3ghCIYahUEjKze)FPi
zlr;V7zx34X6_<?c0+K7YB|dNS=i&%OZ-v8#v=nfQdH>w@$vd(D6?{4)gQ)-J_l^Oo
zd91+8N!R6c<EuWtXRZAJZg!bh(|@wR1+O}Wud#nG9rsvu8kYHhBO|n95Az$gpX%Rt
z=$}AlS?SQhLO?q9XnT7iNgrO@TTvNb`@03#IE`q5LHb0%?M2HT&WW}~@V=?sIN#;K
zg<CMfA>{zr;M)~II*wEU;Hawg=cP47zcS;?={U4rN{)A%8&xY`LuA535!K$vp(&Yc
zXReX~&`*cuZk+_^i!UD=K1zJ~)%UUR*>>QyVswu82GU$VPDlW<a&Xg~Z>hCD&ZkzJ
zu6Pi4Q*bZ4o#%bazGsPyThSGs+j)cwz+vAkP%b>)thq+CqqnkgA)L%f5VaohK+#$i
z{#NQ00&s=W)ytSp$I6k1*E#dkm%;7Zd~BSm6^iX{st`50>f<H>y88Y<{T^k!;E$On
zvh7I9FZlr~y_9%zwoh09VSu<5BvLA>V=ixCN3C3U2+Ui1Ek&j7m)dWc1O52tIYVA6
z2^jz;Z|}U3Rx?i_#c24=*3~4V<9r%G)&_rwzi&S!*3QUAd=CVb@6gC{!@qv%eeGiV
zy--NK%d?;zBO{n437<B*wp?<Q6^(i5o_Vg5d-Q6p>%)Wp?d{g3gnJz9m33y19b+t=
zThlI*NF`Pr;4-)*W=iacTLZsPrKV>bO?%t*{=nU%EpQPwd5lVlpua%rGO9U4I3P8j
z!iot!gly@2xe+X@E=VHVyZxO%b$4=PI%6q?J=~{A6d9@&E(Vr!%A@b@n6&=@_j@=7
zikKg?3y?U}?SWVMu86_W)Wz6*H(JR>z7(jzd?`L2;Tj=jM4MA+e=!mWsFyxK&N2x4
zF%tK&FA85G0tUO^Yk(dGYtMSe)odVa{ObKNZGfhCp{GZ#TADbF$j%?&KV?hP{_*0f
z&F>W&06E!vJLxl`L#qAEh>4v|i{#ZC+S-25_0g(qNYt8x3@+d%P}usTXA>t(cMo{-
z6@WtqcG4h0l;?NmbfnBl!5aMWR{00MTUR{H^{hC<ZSa)Ua^cl(+rQNeJ_r~<oDC>1
z=QH<d_}Q{5wv7@d^KijG4#sbJ-|EnES_wSXJLpydu)}^(L6^%Gf~sg3?gMZHhO{@{
zNGAOkb<=>EnNve8Duu`u0c3q|DpyZLca&P0+U9!dPz+?n^jE0%gH`V*b%`_m!!0n!
zWEGfCq;Y;=akNJ|buhtB<|JOY)?uU|RQ0L*31}Yc5mzjy%e)&hyyXwdBn(u<_L~x?
z$=>$0JG7^}5^5d>(JMFCNuQAU`JY-Z@~H@)<sY#vAQKpAGi?>+R3VHQd_dPl2vW{#
zKT`YNY&ildIs$%~nj6C(&FpP%cEz3O=Mzz)c6xh5BrR4x>L)*}94c-2MV6(&BJYAo
zn?sVulpB6{w5_xN1H5hN49u38Drv8|lUmsRt|}q~W@8IdI5KTZ`o-+w<!WO64=B?6
zU<4SV9^u8A7bplACr;4=A<CLfy~U)wu495RG^8md6abg><XH2|gB>~*vI(p#4Ry<q
zos&`ih}{b62@<j=;kHIWTb&9c#W~!B$f(tfo@opANUdxh(vy+NUc^MM)9HtkD6uC0
zFBW*Qowymec#H7r%r!oO&M{nAs-H~cXWSl%Wd{dJUaq9tpkGh~-y6b>g6A`qfL6VB
zA$oE)1$=3FllmGjH+<b^2Z37=nAyMAq0`)Md}ucCXr3p3;0YF2X~wYp?OZbT6B<x~
z+C-x<6GvTIm-&2$K`&S_HL`@n>@YRhJ%Xt)WGj;%kcL!!%PKVk`AsVw4tCw!L#T&D
zr~UJlt--ntxvqslZ>dEDPz^z6xcGpcVYHysn_Bs@2S`E%S&GFl4c#lUX;6-M0puKW
zq4}WXOge8yo7S$UQ2aZY40>U$8s5u1#8I0G<zjcpn)v`qezE}C|B!1nKz~b30?iH}
z!QF!r@MGvFR7C<3GvWBd>$5o}rA!KW+aEc3)Eo83A;Ko6aP-50^%JkvI#b>r5MMX_
zvqMnC_5#w>?i&F8n<ZydwWgE_I~4VF)OS(Q{23?++swe|<IU6H_F&-ZFv}J;ZiI@D
znVe4hiAc?QAdDVxpeR=u)7IDt<kyr(`a=gk795UQ-Z~ruGSlk;Hp8;sYWdPvyWh7G
zdrm}0&++Xd#~B^YECakECEE-V)LW0!n#FpbTbH$E0J6T)@2~<*R=-Uqu^gj3N*@nY
zQx1#mXA_g}GnW97Eh>He5vr{IdxPa?(Cej-vWi{cKGsRDEZ;@7fqb3kxI+ivsXf?s
zy@LW|dGx<QAs{rydZIBSHc`dLXvGM@(o0W+Eoe1g;ZmSXN3H5-cK)%OyVJSyx-yhe
z(7s%1Juxo^r<#G##$#aihSUv-x@&}f>oWR89t$h)h#!Q~R2lv~7bTxF08XiP&L3Yk
zhH~UBO5jrYA(Dx<W9<PK=*x7TtnY5l+|FxV4B)TP5^lWkQpyPd5A?g+9@Up5UZ2Ju
zas%2R>^HbsR=)!|1`B5!od$vEZtSj2sBNv&;v`D(0*M%CZ+)@TYDXsi`n4Zj;UD4e
zM^?wJZ*;EN=aVSSaU_`#QQ(xPgvSu3c&TJf-cS7`l81{;HLrnS@ETuVe~_@BVE|ET
zEwda5NhqWlQJlBK<z`P_PtPP72kLHHfh?oL6!(La<xAbDwhYrO$Uh9)g|>ppfQF#s
zerLucemPD2kUE^~SEk$^o@(C((5t>(^;Ma4v`W{9KA}<`cRyqR@_TY_&o9a9F=?sw
zwq+5#wVsRv0|d$<Co0ilO7Z?8qQ`}u9mS{CO$v7ERQTcCl4r?^n#Ow->%%&S$=#eO
zE{xBChH7I>UNv=roqVicK4Nk%Sr;A&YY>dh<`nnQ>~|IE+bMiDK_=ZB#@*KHZ+&Y<
zzI~WBo#}6@NoFc5lZu<|eZ$7TNR~WgAWMrfGz~p~&pleM={tHVtva5p(#xB$rW0(G
zg?wLqnk76nUln-%(R_L#^~ov=Za9hY@<*5d{AA}MbG0AvrpdHs%b53UqObGq$s#-J
zM;>_P&*7%0?kZ_-Z{jj$E{Q&KC#kS5u1zzRH#VAV?D4fYhf?6u*7UlI==Gj7EQWKO
zPBaT}MDo`3SsBHQX9>{f!iL>JSzO=Nz4OWuHVDsi^4=6yd!q_+sehb*=LlYPIp-0f
zrcT@x^ymOMDjbWG2ZhWL1%ABqO3PX<Uc`Uz06>Dejt5vOHa#zW@}B`bZ^)5jp%b)T
z&doOlZsfTtLi2BmGrztjGs#L#>d!yh24qRfjL2{Kyx-SJvxT{w<E$vD;3?e6u}Mjl
z^qTJ=roEg2F}YTfr$YM>G+0}P`WjenrE~wbcBZDLoRe!DI^|5PZ9d?2!CNTwx*m9~
z=job!CPtNzp3JOZWB;H_Wjkh-<tS^v8C_Iz9Ey@9O93~@WmG8(MiN9)idDklaOaQm
zcClJ@k<|2le_;oF?ZP*cWZS7xidpayOCD4Nv=3Zh@0A|}<wpv4B=aTe*)&5}LeI1a
z!ixr4F3y0l0z%@u`hCYhsBe|^J4ePnMZ!y?F>FC&CMjX!cNM4-)wnl*Q5D7f8ZKdM
z>LfOeio1?O=7v%{pSMlN_%g?>UpzrqhfRb?ylTY-Ujj@l<`0-@`4bu$KL_eRFTrbB
z_4SjDq6`ZM)0dJH>3Ofga5fO-(nl+)eYUHaYi7|>XZFE89uG>`4j<g_zK1~XX^z}v
zFWgyYO}D^>i$>}M9DxD<!;b_A7^#^Uiby3S^7jvNK|L<UH_=ejiJx=W*2Ss;9`P}$
zU+}m|o_oRV^A<8DU=Bl9B5{?%<?zjJ^=PftNnolp0!qUcJL$EkIVnSCV&f7hIV?DB
zgyt>g^Q&=?N0;XEW$JxSU0RW{^k)-Uc?P56`(|p!bGcCOF6Mf-jf>66@vyti74FCd
zH$Nh=<&n|*V{%<l4BmUscns^9@S}jHe{>tMRWHikJ#~N<YrJc!a(XU7d}iCuHzUx$
z?QwgYRA95&9&ZMv6at}2WB~K8&K~I8L?(&A3j_aiUI2m7VENtF+yvKnyQhrYL|RvM
z+eypt<)|s1cyD7sg4l31@8HsAoL2Po@d~|Eru=vz+CMZ|<r|NGQYZHh@if*GAL^3>
zL+n5{)h6udm?^%Edrb%FQ<ajRoZ%?o=U=xj(P(&uIy^l(vOq&uiHw*)e%@)y!(pCO
zOdFI{eh;*_5A}%QLJz7r;(Teb-Dp?&f-ZYNdCRQ?Qj|h<ibB93I6bb&0`NyQYK3zq
zeY@GWDt)v4-uVm3Q6k>!HEMdRXOb3~f-57i)Yc@qYLWLcqDVY^VW!?Zy!=}#dwAkX
zzph{;*7T~Ak*<!Be)gHuY@@a4O0_}N_aQ2P0MPnU{z!VKn4ZOaDUDJr-Ylo0hPI;|
zYo5(Q*`>K||IWZ^LBkRX*F9BHk^(F*vK<XVLfXoNgcmNadT|t-39{;vMv&ggJGd@x
z(f!k<&mqmFb%&0`X@S8k7iX5y{YlQKsl<4y!H#3E11tlJ(ns6DoZuh|lD>WR_PxzA
ziqW^}?{b!opYKg(wHgKWmC^PL@@m``qbfQl^m&yjc=Pp<b7Q-na6Xb;;;mHY3BwMT
zk{!`|xKut1Y-Xzo54QDOT-V*~u$_gvu2G8{mK7d|+2pgEi3f%`j~UUD)@ex-aez4m
z!`PfuG}@zL8M}eqXO+R7R5zUG(BpiMn79dAivNDSHlp4^HNPyidooYE^8=>&DFn?%
zo<%`g#HEwmA3=WGz)diIre4*=@@X-DB1WftWm$1&l2pcgeWZaT@@uS$AkJSaEfAQE
z6-c6<H75sTnyC-N1sr*%fQ(A13c1|x?cGZWJmQ@L<i4Mz%6s9zs_@8jb*e6$7%u8b
zZX;Pg@DI0-rTkP%6~1@yguPodkd)|#o9t<{Yz3oB)Yv&Y=aG6oP#eWDYJbC{v0@m6
z#>X4TF{r<fgA->yCsvB67VWMoYeeHIFR{b2s|PzG`Fa(J8nvch<z%t`Q`L6aNM8Jy
z^^2qAWPP9=os%6jdNOhsUr?UxC&BsA!i9B-*X;|MuDCZyfGvvG-HtlBbWn$*hX|L!
zTzIKXLn-8CbBg!Vx$TNtAQYkMm#IHZasTV@zNBy0r~L|?7CEJ8)WQCN`Le=H^mT=j
zGNaPyGHL7&ei#Abn*-T{f+rDqR^E4%k|<OL8-me6SljL;nu%6{#xveBes=cRN@|yM
zg>dg(RqI(ochcLMp<tzGf(o`FD6cM!3{DDsYDzh>rEk2havNftGVA(IR6oPx@WUep
zxm(5Ex#X}&Df#ZEfOcojM$-#@XE~F(`|Q91T{lw7+Hp9ea(OR~q-4_;RPnUtWZgQh
zb41&ezm7?<@G!BNA(g0+n!H~1ffh9Og4K<Czhiy8O35|m<IX(VuP2-MDH~(S0H#G$
zVDE&4hXk7UmHzWh#o&JO=>5saBhJ$cdV;Zf@|%`M#?e-fa=xp>_D>R-L^e_vp5?Yj
zEb9%tJT8pyKSQwa=nD+u4oyrm?ROz!rtOC}TJOeG_`N)0dndwY%dZ+{iXIfsi-%^~
z1y1mOuoYU^Iojv7)4F@0x7`mzj2C#jFg07Bp_NoH_0U<1t7^hz2zsUWT3~R=)aXQ6
z^_cVB6__V=rVf8HR(?M7$}Xt2zwbSsR2Welx4~AlHMc4WCD>61{j^t55=pO-ioLzP
z5yRO6F(r3JTs9C_q7&_z?2}KWpGWc&IiZ6jUZYIEFk|s|81Qshj@hLCENu=62Lbtq
z74m<*^-mPv-9S)V@XitY53Bar*Z_R0#&UI8U4f0g^V72Srvvr*;ndOJi7oAG+6AX?
zDRm@}Mu~RCP>SiyQ5VrUaUr7@CKtPpa8vE4^9>)hhIN_^?q};YL1+m((`~Q3dt8cj
zrR427vb(u?_Un@7IxW4#1=TZ}VitD!PFBl8N^S8LufYlVM`FZUYyIkXi(mE!OaefD
z96#Il9cK#j7u*tfc@m~g5XJ0BB^>r+HC(+abr25^xf2THiM80Vu@zfDO8m9a6+?kl
z?v2P(;VkxVdf`#)`Xy2_ROya1;kx%AdoKD%P1}>ulGjWb*X;&wjP&ys(-@OwG;mL7
zEDjxj$(=~b)SdrOj;D5ud!LpFG23jy$EWQ~<o!00*`cpInF$)sBl+pXW1EQafa}Y7
z9*GS5O{>89y9B(~od3>5-?YFO9_8JGp`qNAWfgj0#bGhn`^!2RiIP*nO2hutJt{>+
zHoK*ZWP1dUM_bgwyd+fP9c;9R`qQD7hR&_^DguqU+?*q~+f{zQj5Q}OhdGJF8}lr6
z`FP^(^lwHVaR9fz6~o#8{OVHQMQ%$iOTZd^HZ*iZ+9`(6ryf5@TqmH;+Mzx&g*A&d
zwlA<1L#-yXlJSfw|6}9up}xKsUxbS$sH}{9CuD<QQRepL=uo<aj+f`f^9A#G<fBya
z{{A3L#kCGO$7we9(tL`P(SpM>5=R17pn7=zlno`ugdPFeG^+n+ecQsOJdNio4YeD)
z=s@|mhwHjit{8`n#<&cYf`HA)u$Fd1_}$YAM(X98SK&>y)O({OL-U<l$^`0OuTrIV
z8hA6I0AcA;1Y1`^oLLXLhKh|SUA<cea|X~x;eSQCKwy>3Aa?0gz2Li0D96+#{S$~U
zy@DpTC#&HiWomgkr<~Ms7;AcUHf-!>^CJ02OBCs(2r|=T77G=5fN=i}*Gt5<itUv2
z)irJ`+RGe=-lf~#pHv0!!?N|EuS2|VWskhK$RxB#@eJMPI{$0-Fn+rBF#Oo3lQn%x
zs5~8?w(f50&1_&SaK==Qv1o=^{o$6q6a(V6k~EL3_aUxk7k_Z)kG@#UI@#G)j-)!X
zmD|1CHq_U%Pm^ioN5ou<9O2RAsVyLn&t=Ht<ImU8LU<=%AgF(Qgo4Po^3y&mFA^G*
z#~AyuMU~qJX)^`DHzDU|hwD&V`Vyl;<b8F9ps$U-;A`eY2XP~D)w;>4=pV4fq^9PG
z!AnX@lY6&n(Oa*u)xX9!l@<x|oIvFh=2c-fDpoD-d#EO!&(VL;F&)|74t^}Ki`wkq
zZ5%#O?zb(<Mcd%ht^FQwbF$e*Dx1!wgnMy*PR$XWCm!gZr>W&@XR(;HJG2{GWv>V$
zVNtCn?a{I9qM_p`_uM^=H&<&my=l=fWn^aNo8K2BXK1uv^h^$px;<0C7N?3lAhd)d
z@Mi4sdL9y*7kHEba|g<02rl7yv|NWCN%+~>`MdPODs8q%zSbdCzbFM3Gd6UxjEF?8
z$JG4(MCI%3RdM+D5Mr<GM`tM+b6vvsm00*FRBv&o^egCJg1jhlc!l-(w=dK%6+;&+
zK0;=@RgPv`Plp4qMMOLbx0UZ?L!lca2_c<t9Y<On#q*$jdy?7D?k!GMlY*LEc?l8U
zUmrWuua~!vG}8+XFU_Cun$vgaX2okAxi4ApyPUpa_YI8~an6()(H^~j{*b)*<iTnv
zUkSqr;mAq8eGUJPJNox^bCD64OAc*&rFK`$A{LJ$A><Y@<=k>nu?e_IDel4A?0rTM
zee(8&gnlR|qwToAM^v@08WaMP-8v*egqm%x3SZcOIFXR)t#1{%2wGR#!h-^zA6?$r
z68(*9FAWVbx;;oBy=Cb_TI2GuN;glA)GCCoT!TKILV!uEc2^ST*Ori=hv|)3>P_Y|
zq6P<7xt^)Tx>(d#X0MH`8SM$Q)cNRK%1hkh<UPK0!S@=!56!N=1GGVb%h7`zbUk+~
zG-k>MJZ}3$69!G;)yILEFb&(%ai>FH0=CD+hI;F)cU;#Mpl^T0L)mCh&CRVz{whOX
z4@?STifnrd!#6^EYo-?qRaL{%3wvf6o2O8(uWI-de~)U61WA-o%^f-CULEC$7RW9?
zJ%!(m(rzxT0qM5h>9EKYDW-BQA&bZcD5{Sl>xPtSrCPGAM1{v~Dz_hu#0j#NCX}{2
z9aFqa`mBVb5rF3ayusv7b6nE_)cw%hJo+?10DS$M@l@JbXMkB(bum596%Ol)uH>?;
zp6&J6_U_Q|t8kwj>O}j&+0oT7sd8urOfcN>7weTdwaSd;*R%}UCBL0;#<R^jyTtKC
z`cuX4-<yL2E>XQ6*I80|9~nnkLyNf$#cbQmzee~7zWgLzAq$o^K-QIheJTDODxXBi
zQF=@$MHwewydFfrn87PEpG%L}Z5RI&KKu}kX95{q&KlX(j!~S$BB$8%6;jEqqSfi*
zyPvXJ-vd7zYk8Yd(DUoz+p#~qy9zfYZCs(CV;0TE)R3lML;dX`8x}UVxTE(hM3Tt9
zlLg-R>LdU9?2h-iN8Z$+UHX(+_TTq!g)KvP1O#L|N7thAueVcGEz8{X&hwf(ctPi$
zkNJ)KZHhMoWMS);7Y*rgUK%NJ8O)=lUp?%K+2(`sA<0^p3>GHK$PzpuA7j63iDV3y
z-c5%a$+qc;r^aoXwo6~wBv!}&2-rT&`e2#o<k%3b=UiW?%c#+av0Q{|N=+iw!{ak~
z@Bb}Jk27_UwNd1lb})58o&^ww;fbl7o^L>bKbqHdhd*;h9rv~cfj?eVEFxB;j36Lk
z*KYp){vEZ58QbTuB9-8_#c{_oto`u{`o;K}q9U5su}F^O03bR2uL)Nml^si5-t5g#
zCG`6srn7_YBqa%@-h3%^ab0Gjp~6{LBH<49=5clOLj{JPS3Y33f4@FFD5?b+%?*@;
zq_>xml{M{4wD)S^EEsDE9m#cq^Y$FBh2q8`34c(BVMM9Ed{ebR=44E7+Q7>&p7FVM
zZl(P!#WSb-dMmO;l0!r!Kk3MzB({<%H;l3SI4eu7n8nYp`zrCu8+Ah{BLPF;;0Y6l
zj8(Q1>Be_=vsqKw!jsceIgC>PkxT3SY$kxvYe<rwQW~kmL*l{9N!g~^Lb+i1LO#uL
zhVvZ9`}Jr7?Tosdm$Ewbn0;<}<>W@-`izphQ7hH{*ff?DKb7`JS^`fv@mt3gu6aC;
zajr|9%ii&R#XbINop>28?b)}OB%{#1-5gxgxsI6coS2-Y7p5(`Aq;qE(P%mq3Q!A~
z>hu*wrMB!+!G8<*iR_F}yDuz|D+Lc%oF1#skGiL+qRuvC1U|g?_IF8VT&&_}9FK~W
zZq-^(0Hvz;0>!QtN7|7yO2<S=2ZP=*aoXdsrFu0PF}I&+;KG2A#UbpMUYA?w3P(i|
zUrVpKz(sQb?78+^4H|gB5QA<@(9Wcm!~;{^Z)?^K5C6grz9<WEw7oh6=({3nMEJZ0
z$4?oXVBD9uPufo*Rcr5u6E{N%SO%3cFzAr*koigyd{=xfn}p8qE3~^u^Fx<pQD1T}
z<jR;2eNc}>Jt2!_NA0KeaLH4$Zl166sAo`Z_1>Q_Gk7eam7kYR^%M#j?ih-`JfAg4
zkntk@ZDGp?b6`;>L)HDri7m(c;ZHAbd%F5NH`DtgpG{W%{UKJ{u;<2Eoq2yp^&#zG
z&~aEYmec#aH#dR?q6J0e0dace#-X<UB~rIUd8l@~kFL?0m&*DB_j#^VMdhW^=8Td4
z`OTf%^vCUiLp=X(yRfhW4~&tI0ZS3CLU@(r(2?1+?Za(hCG)#)o{My@>DSHJj11Zo
zUOS<Wu`NqYWEl;;+a0E@Bf7Jrsze$UI%LNA#u=`g*Rwczj2W-T4svc>HxCa5g9)(4
z1?6vP$jCRJp|^*>5i_w4L!%ge)NzpJZTaC6{5Cfc5qXO=VQbOhl?jBXm{y=JJ9VTu
zhuc3mG^=x@3CxXGhWtJR8wIsJR%<z~v@?feVLnq6t#r<=<h^COkEmBnQ#f?@J-jcc
zER9#?ff`?ecy>f)%I&^%|2BQRdAVg$W6t~p?DwLDYwtvEDwXqlJ{>oISeGPuz~81Z
zU_R3Tw#{NPJgx)i=$ld9Mq8Ai#h=-&<1pSxH_BY}ysl_b7zYMnI_of*P)fHnJWO7p
z-(H+8MbFB!F*eNfx?~@A)LyOd9UUCaFLO|p9`hkXBx@D9+$j_-cZv~YOxs1SaZP4J
z=QpV)5VlqJkb2B_Mq-BavMM8M)VRG{iO6cg^~dF~KIxK6#Ug$_@3N*|b?e`-Rd3e5
zBBc}n8Fb*N(90)Wr+4m{M-|>%ET?UlY=#p~B)%-U2atZTla6FPHKnfdk`XNEgpj~+
z!EiSn1TjB*ofMEf`<|1SzsJV1GKntl!2c2a7T|4{g)moOJ)L=?aM+FfSFUOd>WGxv
zu1j7Lo|V0z!lRCW<5jwi^!d!dJS@0FLdHQVsQg<vDDCPE!_X1VNz2}$c43*?jY`aq
zvN^IUUyvfh3PrV&g=W}ee1Y0o#$ylLvr=XcF^^WSqFAZ8FNv_#%0)2VuqAPu?xsD1
zSv057001QMqX>!8(f#;IN=hR9TCP|XQz5P$1S5M;;4;tnie^JB=gpltkGjw2$L>sZ
znvKO*U|<0yEpepLmsHHh^m`xHblqIj$%O%Sl|B12tnOpsJ94h(?`gSFD^9LSd1em%
zP+CFC9#|RmV@|s}dtJB8MmDU<$}1Nwhk_ihclgH6UJn!(^Mw`YSme2e7;B)jIOpHw
z`p<rO;5J^$2>=T#X-Nf<@^YF}@O5~_&*9%|I?t>)FqkTp%SoJ0sZ3-g3i4hgU-`6d
zglToSJ;c{H|FU2wZy^)eohqEUT8C~UYsrQ37|IN*r6>pe>q!e`8zTAciXj8Q2`P1G
znjJLHPb0c}c%iwvw}o?+u82E?L+Q1<fEods0(l_MeVaz8kU{#OU~#tr5iM!ok_ycY
z>f>+>ys8z=MsyOkAVb`OtCsw${1v@U-Ta(}Fw0F<w;V7he46B0_O_(^Q-QhDLHa=7
z<_4CW42#_wZXwMwcT2zHsf>*c!2n)@&)1XJ^Z7$MU0I`n6^B50BLhkpBQ&^$XX|@a
z3;rkQ>yH|~jM+|iuU1DP#F75@NpGr=((YZ?v!uS<2@g{c_n&txRR7u%iMHTCQbrQd
zu&k<7d2iwIT#BJer-!kXF@6uG@Rw0BuHN9U_VN0jxZoNus*+=>l`g(BINa6;9yPLW
zIfR{YA!{~8($BM43%Z)svFU;0B9NXn>r@S`$6l0JcgfsD(qVB<Yc-UbqDssbPS52_
zS*N`hEHisPumDbr2jizJU&EO^?kdQ2M}uIgQ{laD)?<oR-Mb|S>3=OOS7^afqlcNy
zDQr^#_k}!?$z>SQ-5z$yZF;}rv0GwTpVh{uv6qo9(D)G8qak~3$D_5m4E%qTeFapM
z>)N&`DyWo{l7e)KbffeDLw8BT(A^-?Eu90>C0)|eokMpG-QE1JXYX^i=iBFe-}={b
zE#EcFy!pJ(bKlo>-Pa9~x<PLPWIj3FXEe!Y8I}uGX9~&V%HtFDKc27KZ}nnIzp(AH
zrhGS~tZ}S$l_u99{Co;QWNQ?8te_W7n2cOCr&VDLYI3|Y^*mpd{FzjN(kbhdit{D>
zI#eqAsFRp6dfN5eLc)-m@4|g=!${Udlh`Ef<GXA@WA(Yirl{`~SX{NP!G@9d3$@$M
z$F3xaBTX?|_IR?}eBL4bN=H5W{BhHJ9!qbjk6OIwO*1{1b%r~OL8+Ggb*C9L7?phr
zS!^C(^REffBIC3_k7_BkTyjh;Wq^ZG!AZ61g?ovGz0PseY=A^F<KJh*iHHBlBxp1P
zq-8v?SoiIsmU)(T*Ci_PSu^KbpUAh4({IWxJF8u9%Yirm2+{Q%Hm&WEk-THJ#pLvW
zwIPq*S>a5<uwZ9b*gg?QC|fKbD%Fpw#U?0o`um6I%=_U!ZSpBuoux9AHVo9!mWbD+
z1-&HHV|=F<L(fx(c%yPgd?nV{=_bX!V4o|9j>t46*(PMoH^b}0#=TQB?>%aMj*5HP
z#~`5)_hqMrH)at-6g@9jYSe;Is;=iJg2^bK6d?Gr&}o$>B%XRk-%Z)ZPcpTBKj7K9
zV7iML+-P3sFH78qDR)S;0!c^|2gI+?<~;M9no+xvt(eckGwNq7eTDZwa$}CT2i&UT
z`HI1ii6Z)j(NWDUvks5gIdhI?#Uc&Wvi91Dh=_b@_{Qd@YHk?IgNI0yBwwu$zbh(u
zKWSL)Z~vAUn%gT#JXI=prAgqdGq{YF8MtL%7d0K`5~?9J0y#)@<z)@tav&7n(<<|>
z&|lT|64cn1S1-vBE1yZRGX9>xYg9>iVd|$JlmR-ZJ!x+r3+3WF;M<hXJE%#XtraSE
z5S(zv<dr^m%~7jFPkg826KNrX=Er`@e<ik7u+O-Al_g<P;aY7_zA!fCYdGi;_)+jV
z!HKg+Sl_{B4km$(0+m@qfpV|(=cdzf6}<PE1<T)?hv_a1VqY$uYznDW_PmdUzHGeS
z6Lwidur&(9V{O^!XD3bvkRReueD-)QM+?JB7Dh(2Lr;ie^SyW?>-OWNA43B@CO#9#
zt5J?aqj}-tc?xoJ?>Cl(w-=I&8_rNRVG%%a^XIhz_o-+?TR>&X-Jf)h=Y9!iKIwWZ
zSO}a3ih+B7uq*0wobPFEZTjXMqWdcK7v?b2ZqSa;aXW65@lp$WJ1hIb!P@q1^V4wH
zep8buCS@3zL)kkVaPQ$>-AZ7FMy@ZR$BE}4gqs*@emq2S*&NKiK%fU-{kgq%9+PnF
z?O_gqW*8;&m{_Z=HZd8pT7AML-wmz)LEP#IXaX*NobV}kCJ{=kT*dd7Gl6HhN3ymz
z)N@i368o$6wLC+LHufw>Enx{MNe$DZOkRYvwJ&PIwQh6>rQ#cXo`iZ1XKPljT+A0n
zLrtv9UKFVb?#hMr8c9d#Gkd)S@2Hty-be8-WcO)+Z$<dcv%zVs5STHB&gpK}waL%c
zL0K5sUGfxEcNlb$5*-&+D1|9Qo=oI)EOCTZMVJSYuaZYTN2Uy8NRQ3(_r%`xFc;O5
zJ?*(xQHuE7d(Fed|4&>87{s6T5DCI#*5ezt)q*`McJGbwS+|`qPiyCny!mL~MxB|>
zO6G(S#MJjQkBk_@%CHrFAy{TGkagLQ<OJ~)(z&Pi-?-dQUO{nX>3Y&fcO07JvzG#p
zSZjOOy9k+XCawraSI0%Eh6eq)s!hIUHgiNdMK}<1fUotW)i_Z&bmhk`7iY8sv{?&$
z<&<@j!u_R_(+HVF#Zzg708aPrq|;?t`F0w^?nIvlK7&-SNyFAiK;Lchdb#spJBTai
z(dKAA##m^+NOF!Hd~MEd?+e^8GNIq0I_Z9r4F+d(;0oN3J2BPkC7S*Nt4kJrLq!#E
zbz1J(8sCIJ>vr6)6vd!c5ipP%muh8{MIn_aGgEbzI)8k4SX$OSTx!_&m0hKfLiiC<
zJo*n8@^J7z&VsqRYKxbsBOV2*^owu3dAMCLMirjIO@sGkJ4pkC^B=p7P-Q;}Ju*KU
z;ws!+Gs2YvXHSY@lKg1LwTT!YjpmpZlI<-GeV*$P?pmS4s&+>1q1oUPQ?#a@Y=}m8
zp9nT*4_}ih6laIn1n*GwKGD>G2j~=9q>{3Q)3J?-qZKC#=Q!Nt1=(@#l9Cfl3Mk^+
zk54;EVf4GocC<5tAgGKHN<RFiC-APs8r?Z;Pd&k=wUHu5^)s~7{RP>iwW=8|YT3t5
z%<=3rx3>+1E?=~mWk4}N;dY?mfSXqNK*XE1LC?@h&d==U?(WY$93juhbNirm$s!>e
zg_HWs^<LK(E3MIS^E-f6OgxEwe}X-*e`h~WBF?Z4e@5ei*XexjK20{`N-puDKRV7)
zc+wW5szD0MNT&BB&9MKS%U(@gjFN*}7kVBsz*Ke%-rT)!oVeV#JzAAU!FeWRc-D$W
z+g3|=k5&$Q!JVPenEW<AJGinYuz#yZUvga+QWA~Vdz2WriZzMh3w0Q6>6>@b3t4Xa
z8XYaNv$3+Yw07XCAT`+HaA6sxJvGG{otzBbky)nPV^%08(zWkjAJoocXx`c|OX9yN
ziL_{H@INCuJ37iNZcO~RK0qEgs1h+Qe&cR~h`n+>0@3mFJD<Py;=5d>HYd2><vkrG
z?CJfsRkE?Ot;c5FcrkEbv_s7D?L%`z`S{rM*XlZUz|Y~{laLA^(Tz{*H%G6FL|M$i
z)Q3CYW7<quek>?*;3}V;VWUy2ie?W#nabOl`SE2sUMT0&4A8u%Lc6N3&vRcDGE&3n
z?1bZXza(|R=g13c5DClZtI+SkrS{}(@rkqiY*S&7^L>W>o-eibMWb?3m9@Xt$x%3d
z%s!Kge+;%Qe-^x)fB0la(Pg64&7*9dSTuH8o^hgambPYfPwl`nvMI;2rs#3hAIsPu
zD6azD!?68_%HQqdW*}gquq?&rxUgR=y5S7!^vSvn$^FOK0e0O!kj4&^L0?$q_U2BY
zyq%r)i`#M=)?JP2VaeNC3q7NU;Dy71kjHJ*^k+nTvZOi4yx)IZ9G~1;nqtrJGcK%_
zz<lOAmR5|+xTH$7DofrpaAgG?TW4C029Bwp4TW6xMzi9qu`C5hZTtp5t73AL8HP=^
z4Mt_#+n<xAensjx`O<{BuW?Y7DNoe0raCyXso7hYy*5fX-#pgEoeL>VrkGqTMR`tj
z90{lXWdCv=-4;WZel(6(H1hM-X;(v8@mR3)*7IIN7b3pcu7~+|d)jxRfueV^!tkyz
zlE$=%$Lpq6i5#^{lw5~{y5htShp+bs-|9Je&Y!GHT>))Yx=jEt+w_1>U*#Ak!B8$r
zwhSZHTU0pZ%_)Ax4SRPjIXz?34J&*yAUkIoP)mhPw_rTkZ@fm~a@hHvpH1L=%=2z2
zJYNA>Cd?3nHWR@Y$t*kr<)HGt1(?};6XuyUImygc2+U4$rBnCiSk7N!oXh!mcvNc6
z;F~PXrqtV}1GYFhK-Hz3(9K2s2&_DF$t|?C<so+L)p>5_>bIX03B?kvewEQ(Z#ql|
zBEUEd8r$D0A67<AN=o&kV}RGx`#Vj)tFfv$Tjratp0AV{sDHQX$NR+vWrTYO+&JnN
z168)g91)W++3TL=s{;)JYXNN+q0^CI-|_nk2O9dj8+z&^L^NH|z;6dg<R3p;Ln$T)
zdiMJX^Bjs<9i3L0IwIqe1n(Pi*a5$p4DZ?imcm9a5>j8wA2#~yfk6r$w>$KpI(>1*
zjH1wmjC!Th_Au(OXplnSm54flsU!JLX6AP?QNP&Wfy)=c@-9E5$81y|Q9S-lB$6AC
zxX2+JvK^U_0`5d3kRy1*K$eV&fA7nm)~>Z?6qYJOszfl^7&Xv7)u<yMLarnB8Xf7`
zK^6{5MpnY);iJcY=3UR;E_ONkwwS%TmT1kkM(vtl_qs827VM2E?;jA$ZsNx;5MqA^
zYl@5$oB>jTZX-A)YcO+Mg1fuA$ACeDvEn+?Ygf<fc(y?|zcSd)Lj9m*P!6vIU*`8!
zAzE%j6oNFJ-5kBmp`L{3SSkXqcIRV}_|gp^_q+xP8s^0A9xr@zZ}Nn|7t>Q28M(cy
z`aHr=i|@b-JEJZ-6P<Zc*sxckuyVz{`eS>wI)}JI3%E<MYIzipsiG`NewrE@&2cT^
z{1HH?sv7%st0OJ>BT%82EoYcrgUZcig@t6q0TjsE3-QR_zcin5kO_q7oTacANyl*V
zcEmI7Q-vY>a%z{%y%hz+0P%(~yk|EbdAG{}hhB{~%X^3m1-q(!n-CyLt`0jD{j^N2
zms(g^Y*uN5qC|DpJMrPYah8>@+gqk<SLg{iTa~OkSgT_iTgH>Crcd|XGX~}xL`@DB
z*8#c&nw=W%;_e}Bw%`$<<+4fZUarLNxc9P9yGc|iUJN#ErpUqDX<F<~E7#apmX%%+
z=hx4FKl@QW+l_%VZ!#?Z=djdd-fD4EmH2kKV?P=ZPaX%cwF^-L^E1zRD=q>LOa6;R
z&&pf|GY;OlyZeZNdcKjs4WG6Up=m2f!}$C3P3Wpxp0RAoI6c;cje>FzzeCB;xvU}N
zy}9<?b1Bb`m*O9iW-}w5w&L@Se+F@`p<+`|L}!m?3c1{;-33MY^F8)U;Pdq4z{D49
za=Uu6t6?C1tdp%iTBV_R7248aQyVtn@0ec6?=BTL5co8pjaQ<4uzrWGlL%)^t^ohB
z0_spUw81r7sW>2}?L{y%NpYQEC>Yy1K?U=-U`&7$J=YE<!5v*E+!@!TjS7pKi*86i
zis@E@QcZ_fl&LSBGQoJgU5D?pdA>pWjBMjZOko~FtC0$8?iVjk>+@<1)7N<i<t2Bh
zr5Fl(%JuwZQwQktWTA<x6e)Nz5<x#+%iXV)<_Em}bx@6SM94WbH(BrId-KF?%`)PL
zpJJajhQ1J-C6Mk;10^XYJB<i%&?>Q3(ihUCul~x-m}`0KVZ$|oH;9G1{ToM!@Z~KL
zkELPI6)Hc5mlsrE<fXJ6=mulyolcFHR*I?J*=)>hfs9Ol$11*@AcyO^ETqLcqGk0B
z+z`9*a$~1bqu`9AMQEl9B~La(4U1r>SSX#t<>dPX!KB;<=Awc706`7VaWS?Bc3zL%
zi(g)!r-l(69*$cHQ4CLH3%z4MZC4BmmcT-Nepumpj^Us2(q{BaM`%W_QlV8uK8Zr0
z{!cI-rSO$-7=!i2feCq*p!I7ZQDx=v*W_{xWv!$+ejLt61iLeik{lKqG)1a8p>?rE
z&hY{BT@&@<QPUs=G;n1zDz86U=Ts=7u21`>jYX|^<^~qVr+mfdI1}vBm+CwoH+0ry
zkHhL^MgfhUdPS~8f1<EFlnVnC^fC<GIza5!NKQ}i+FL&A)u27R2d&bW_J+uPIWU|c
zr3WDKIdn>t-$@Z)gs#0iY_F2uES_BU49~}z`?^)NBcPbE72MSA29j<R3(N@{Idq?)
z=9CSC=xIo(cE`BiM6-@tOe+a>9=u!#DjK=`u>w*E%BZVCdg|Lk+(=VU$)!gWCU-dY
zGXaaNh!xi%*4cA~d*GcWgzYMzf;7CsRilhJ&L(Ie8=AJ-+l^)G!C%O&S`ok+$%OP5
zWb@$R1Qx<rV0<_>t<o&3FGg^KEE12y-~$_665&vI;ov%c(wo0xh@U7Q7imf}5Sxl(
zT83ZA36Z_<n4^N*Y&{NIxIYiIsm-!UsYh-yo8s>&P@u3%m-QG)dCR2n+?SBs2{S>P
zocc!pK9-)Tr-01CEEIl1+JW`9%C0x#R;_kz$9OrUDXXuqmo%syHD{RtC5eFWi*}am
z<YwCji)@BS{2EKMZ3>^cxbR{ZUb4M=h^=+4pEfF8`V9U;n%&&YvWJ?pnXgy`Byd!Z
zKu>zD3-czw3vMHVw>wj!;jFl7&t+;p2RR)|rZ_5IgRyfParD~dO{qHDaiW;8gydf;
z!PatLql@1xFK;hB?L-cJLG#x=veLt_swoBI8a;nVPWh8aH27{>tlUFO)kd%6ckbf1
zZSptote25Y>`XY##iBT<=t3?d1_DQs5^5fs5T`%PARs`lH1!fV&rRv6gl}_u?w{L<
zbMz{lw8#pisPiRw@Ln(jD7eB2T-W`tvv}~(K<ohqWe@sU=)189Oe5n7gx)BB;9OQK
zV0W(D9?y=>6?Y5*awNl2Xk3s6mg&}<G#);_xE!hp?zWR0U4WJf^g(3^<X=7di^TeU
z?*M0KZJoB@=^2Mg7?c61-iNEq$A@uJ+yHx!(KirrFt|WQ)`nqSGy71YBe%Epkn8Qi
zRbpImH#4XooR(16D62&>uShk@9ZgfGNP(t|79>RjHD;P1qoTw63;(ou2WTjMG&4Av
zr0%V0`fu=~MGu5$53Vtgd&Jmpx~xZ+rMx`$`j;-@w~g6F!1#(L!rz}8!0V*;8@W?#
zY-|GMk)Yg;fe#<L<pTIezQ&Yb`pLZOG1=>fK;rBE5SN(|y-DUTYUP)hBMj3C?XSr5
zw*&n8P~b7;PcYUFT{ENJQboE%tl2lIq_fv`zr6zg`~k<WJ)sJGdG_1v{?EVtvHNIp
zFIwfIk?tsDEDQ{gg+&ot4j2T=!qti=k#k8d%kxJ4OC<y-V*l~)8VGoFQqf#~m!16E
z>3{1(271{00?eU$Lbb&l5@hI2WJ{|z6$i)Xfz&3U>odZf2G?+EYMvf9>v;6P?)x7*
zDPsP0_XilLz<<cre-pR-d6dN~QgnP*zYE`gM+AQj6d5i=4NxcD_b>l`ng8`({_!<|
zcFG5xfkB?3B_IEOx&QqWFF8`+XL1jpm;XLS|Icmg)CUBVG<U2m&;IKj{QEUOKm-MT
zPJ&cBECfPMuXu=@l{t&I?|6y_3;fF;{uYk@^CA70v-XlB`5b_m^#xnx|LfRAj~`ly
zAB$)`-=;gnGp#l$octj>P~G<P)9)v`nD`c*kg)JOCnIAxkc`;(7ZN{z^1qy#*U=l`
zT;LxFZU4WXmI4wmK626H5Q6`_)`L}-z<+uH{4a<5?N3x_zeG}KTk)9xbMXD!IR5?O
zfbDM|f3YIIKVGOH{@3^EKMXVh=U+c_mg!9XKS##zU%>wIYm~GZ{3QL~&gp-g;seAU
zZ{TM=-dt<H3)%mVL4kmti;g%;(?(N*^k0Sz@C`sLUh^Zuvz4z0RHW7LG4E*{re?#|
zL66(E9f`8EwlM$c0i-rDZudZi>hF&;8VvyJqtP7up8e-}{f!I)vX32sl;X9dl9B^C
zWfW@tOjyy{I#<;Qh(Y1_EN^uSJ9i^h`<xT1e(I&Cm-hH?`;oEum4{huFfsl0a5&;V
zCne#-;c(6gs_*}rusNUt{-{#95^-x-uV0IN_;43_3sf+G3Y7Q1P8X5ujOOyO*yvj(
zNem1Q<_u>nWJgE8NaBJ|Ep1^7EHzLVOMJ?C>JO!GiVl#8D7n!LdUfF$6iNf_9BKDl
zlhL|z?x*-|S^npGiyi*!Y0k4Y2mR}5T0D5j3K{(d7^%u;fnuV|4gCF^?(b%nn9mOm
zzKMk5$pWuX*Wh5dii5SaY{&ZQs*H;Z7w}n7mBk!Lxk$r$k^$?_m-t)y%UmUTA1(J&
zgaSBxZB15VmXphkBMc~P1b2o(G49VfQ<R!}K2ftFKE51w-RJ!{JUnJTFjDUfHJ!Fj
zhm3tXoNJp|yR`PNc7#9M=4g(f03J5Y_TV5mBeT$UHzingJxeo~s{UNa<``MlOmX}C
zVLQE3k0iGF??d*FZET-km)hm~^Zj3!`r_g6@bGA<p6JmjeV1!t%Bf-m`wT`WvZbYE
z?d4h$H65L#ZLN%XuBbygP}QZR1vqbIq2RL(HG4lDvmgMj61Z8se&K20NBiRgC*FtN
zRJ8QMQL+eLN2Kp;*N#{Bw5(`#VcG6Lzfw~FxEAo!)2*?0W0tcVL3hWgNfnKmnF=nO
zS;ZSay`t3Ag>!Ef?n5iLS!6NBRfZ?txj8Z7vE&9<^;xgniJF)sBx*zkiOP^Yt|Tf-
z;Hb9AM|vY0Vyp!k4Rp-ySaifzN07202TxgF&XV-A{ijDA{OkJ1Pk%!Gb^S&14+#j<
z-LKCSYHZ*yp=nJ`{JubpVCD^TwA-JDUi<+1-THTa0LbpeX$o}NYNp4^m1ghi>Rjc<
zE8RgVxAq^u8A=7OXai6RX!rXU@7qn7H096{d}agcxTX}a@sDud`$@z!XE|(jZ>|&z
zSRLQLr}IopV(&EOn$U#@GvdHzYkIS?!io7++=xx6E3uV7t-lWAOUFS&Tc4ZGA8`(W
zC~-)x!m<eYO>AUosa@k_+RQCw$l0Y0jE&>0v8oR?(-Xb;{(86moaqE!V_3}>_r6zq
zmyPhR8P>}*@Bug13w$<79?fknn%*@Q0$fHd1+DeLROPiiwMrVGX{-3L{nlt8U_B@p
z$DkQGP4egdepZ6sFfwXqW^qxbb2!U?`W7yxZgA^qzR+l%C+Oc{cRpvyK~M9++Sz_@
zRs)aA{Yn?W1jgiMPTv6i#W9;s;710k<L8ReT-+Rpm9>KE;GVmMO^8Pr1#V?Jht|%W
z@0Xbn8NVkiyV6D;u7O4RIk;n3Cx2fHdp`e~MjyP-{@2v`!y5VG;v$|)ij0g5otp!z
zdUXxJvo-75qVnsg`T4cqx0-+W@WJkSw>ql8^h4MlD27HhoQQX0J=HVT?)R&srVi~0
zaTZl?3=V!?X(FGh<#xyiv=|(pt^q97R!nX#&MT{qa)pGuF*0!IRMd%je<rgbA+iyR
z#b`WhWH0T>+C4Tm=9+gi>2&M2{v!Igy3w1#>}uTl(a_(gd@AOL3<hkN6#3|g96V0<
zcelbSy%20&-hZuNv&M+vR6eQW^}(F>U|dXYeymE3A68!D-&F+x)|q~Hvb43w<YQ%L
z1o?PT47>hh!oz>!RYl4V34Beq$GutfyPj9rz#TSOIE6c;*jZzzd(@DSk%zKZSqSU3
zqJsqAWZpJR>mHTEs8&Xmq!=v7w|Dq@B>0O_&}ugM3d8;$oC>s)0)YYcwoCLDM6D7c
z97QQj>al#XSGWH%iNVz5>SQyE%Sb%b^X5<#3lA?pzPqPZ5{>6TKwL_f=g$EeO^p!t
zq&ev=B{&&~j@bg=Et!xf@&kbhDk0bE*HFL#QD!iOH|GA@`9aR}Ltw&9PG0thIvDFx
zc?mEfD+J~WhjO1}Zy1{AL3W?4Zte==4yL3>F>zBH!a!WL>%>X1+bovS5uxfPxA!-P
zZw)fBQWCQv3ht26w4C>Q`IBw4B~GYtLn9N15Nu_3cF1Jo(=pSzKnR;L7^uXNaWLe9
z^12A9E`-H2$tkG?S;v!IBO=OPtNYQK^Q>o++fsAW%9q;rKEk9**OEUvL`(mEqQK?4
z^I%u)6n|IsJV#%UanxcuHa)Rwn4S9O1Vz(tRzmglS}K2%2UH@ioikeaHB&l!%?|~+
zY%Z(C%z$KDAE3$!lnhSOtP@$T^ZYDEYv<*##{;Os_rC$kWkRjkxHw7_qFF`Q{YrR$
zbh3t(R=p0No0BxgCZ$h(18wl&@(V84Gtz$OHSX@5t0cajlC`a^BHOHbb&+)arB<OD
zl7YTPc82KSPzrBpg>Jh;67`!4jmzXQo2wINwQ7rMnrU9tS3|0q-wx#L!U#B}W~vA)
z3WzaeeYqUWK>bM*Y15Sj!N(_9>rP&0`|J0fXMsq<r4F68MsW=Nc>rT096q?8>WNBq
zs&2XahTwo3!}6xCu1?PFMmQ*t^Fz52W4ZGlkBnynw%{`H9dAA$`+8^stmXMsgqPDm
zZJ9R2R^gMsPxbs&*w$FVhlq$+Dzx*tiSR13K<d$urY1CCI*L}S$Ss&$JZ`iiQN6jx
zr%c8{3tkxE_JOr3);XNeDYgTUJ5Y>h4!yQ)GOy^3S=g?gpN>$g%%{9Fd?*}E&5xne
z<NNYuBo*5k%P&Bu#(|pp^@y8c3w^cS8|lF>Sd{A3L^5}GeJ4K(4SHRGnmBZNT6XsE
zScW-$i7}JiU#JZr8;NWHDj%MH0K~W1H&P(b{j*@);v4{WFw~Sw3a-OdM78`@2{hsq
zSbm;N5tkY1pkFA4@LrN>iAV;j(cn$RUw&|(+PAhdR)A}b$Kk%DV2;lgaGL)2&@?&#
znB+h{#h<KTGo2CA0XMDg*N*!#^Ki+2mn;y&=$Y4gcl%hREh{^7s6*dnYPS4z3;=V0
z*z;-~c0V#3_T>&q*IZm(nW&87e^-0-&$ZAB1zk*1GBbhMC^o75A-7sdtB+cJeSMEP
z{T7}TBEnmQyCS!VWBELT!I==vRa^z%^u&tnJx3m~Qf~I)kaZFHMkj52iKqehyqVpM
z%C&DLTNN8C$}Ce#2CK~ba-mmJl@<;P9QEc66hI3AAH5F2``cKcvSKSKhE*vrAboAl
zA`JnJU$k7yJsQ<am40)>7cz{JcOT!a78Msx3{<3vWMp?Wp-eV^fr=+O?uxqJ-FY{<
z-ddZ7G>+J=sw`QJNG#|p?z2LY6_ci|jJFqpR{Uw=)()5apF-BAOwxsex$G9)tBuVy
zkYAi+P)I?Z8|^1;`V%V!EYL}0dZ<6NwBQG7u?mye`<gD6aSs!PmX?~;xRrka03xC9
zAPbEV%U=)rm{TQg^M`&|M@KGuLFrF?+4D_Dk+SyY)JJ|;dvC@lH!{twuJ@k~XIPRu
zG%iNQ#Yx{@NzvKCpc8i|u*U<eJYj^`d$rs4MQYf0(36|vbGc%z!on*jXkR2$1bDS2
z0n|F}do$>8!Ox$VNNDGCvoCwc^|_}AhiJWVd-(4AB!ov?!#>Ec0O+T_pgWhOQ-9yb
zpb5!h+nq^O`D_<x%NBsXK5w`^YfZ%CZhXh+3Puz3v&-rvs?)sM?R#>;E1v`Qu~ON1
zBj@oVy_5J}##&)01fRww){jA0|LM!yYsKQ$0d!)|dVz(^(JAYtDWm=Ll9D$Cd=`t_
zBe}Bl)|y<j;3Q)Aiq9UmV>ic=tnW-B;d}_(8$34$u8_Df>zj+_pts15CGy6q9N-Xw
zDNznY)>5_L#-#!7>n-8Dfq^%rrAC=-%*}O5+<BZUt4iVwfnS{=b!!~W4sNE7nbEgR
zxV@{H;!)o_H0zx(!Z4K-ey`m7BU}}xT$DQ@d6h;fBfg4)mam%1bNjFo_k0^lp>l?b
zOj-O>M#}%x)@MaX6-QcH+JtN1K7Wljj_b|8UMG$i0cT++D@^GQ;5Qe@v(Z@B(ts~s
zo6ZYFf;Z?muca98e+-YBv~bj06oj2@NvlV9z36CET<FDL05nj{`6}HOdqkwQ-sE<k
zVF4^Uy(YRq714+u@vSkOMTez_jo8ifNoixhu2T?anY9GoWyo$nsHzqGx|Oog9JX3H
z*^Iw0l7qbBe1Lgr*}ytJx%0J88a@cUE*r~kvbNIKZ^k_7I1?o%1f{wiMZZjInaqis
zo15DJELZ4C8&!uzT|PYxns1m%%o8_voFlhHWK=gKGWR8<^SIhXk<UTy{)P@raMI6l
z8>!PRy1-;2ybWe+cIo@)CnxCmH`0LtkBP3<p2@FoyxjSoj^m*8N%Up8oE3xgGyeb`
zB`~IlyTeEV?=|_>bfs@;FLfCojsN@`QOr^}OWMQ=*NoFv9``S?&PaOwEBiO<NEafG
zRY>WvB*}!yitktS)f??sYm!;fcK&s@|Fsbv@_-Z^9YTERCxXr`y&<9Y<rK!|q4@Tc
z2E<Fh6s@Rk!bYccQ{a?t5W*%b+2^GTSDJY7R~3Lv8nTd(kl3~a7#ypQ^hO2)iRW%u
zdKHfQhMs(>O(%%EBF@H^L0$;jfi;zzRTa@)o3RiN-sd0H#*0dc6v7=yRv=}u^0)ki
z<U5`#wJuE@cXIO4e?|nk4oCaQ`~Lfwqv`2@_g;39;QoYuQAt#LpgT9!-Q<U7c}nu)
zG0nF5zNe0bs`;6(WoOI?w=1_Y?G7<#*TF<-J}ds+%0knNSOm#<LiFZWsM(K+>#0&=
ztIZH?7p}A$-?BSSiF4(P(;nsS6ryIWxK=+)Su=4NVbmNw=_y-Y(h2ly-Q?8O4GXsW
zxChEd_OQ{Szp3ENIZ|nKOPXFCDm9&0o4)pYdhp~5kRXC4?|^j@NHf*9Ch+0W#MKM)
znhQdJUV-#6K$4`d&?y!Zk&ZkaRZ7>(1$`gf6z1^tZFB>yQ6R8vuW=STV|HtXvsA<N
zXne@hdAl@!g6KP)PE^3ka0v_7A1(Fec7GONWlV*EG#ctO4i7zH(wiSfV=62c6tlCl
z&tl}|mB`HF$jS_tfyLx{a|pM2qn+gp@?EQ%kA&?UG=D!89wcRERu?MZNZTLZa`DG3
zEPWM|naQ$bhMpU`T0w8PsXFgw8=?pb2*#Bc&W~D&j&~Bz<j)gHX8Y*AaOB){(89}N
z^(iD^HM(F*nYKXL5_cy<L6)-&CIaty45o0?<lOaFEgiEMg`eAgY!T+Nr;*Lf62~;r
z&ktxyH73sr%I~EXC2~7p^M6~NyF$}*xSo2C(?_4`UC+QP8hgISOH<@!Pe!^|XV+c&
zRLPAL9zZ`87?vfx!ugDL3Rika@vug-J8N-1!Z9?~7v;n6nx{XZM^5ywp6;=&4~tHz
zZ(F1YNC(<gp|Qn*TD5^GV*-?HK$$vdc9omPg6j-}JqMLEIs<d61?$f!S3&6E?sT_K
zj&v%YCPrK!>)cO73wNu?RhEdjD5-L-6&74mG8&)^F<q2DUNmK%59C@ojgl*Tu5Nrj
z%}>@q?|DO&^>gtA>v$oF6j&z1TC6{6EA?F}Fw)pNXe^%KU$vm(Fl)b-cCIOV+ftIV
zkcoOL3duij<O!XBwK*BpZf1JLd`^vun(rkLVWEFC;Tf5u+}!a4(7M|bxuF%Rv&bvT
zh7pjrzM}S)Pp#N85D#X$4yB}KrIy80mi4(jRvtOoYy$NraGf$OS0F;151J8#fhuU|
z<4K+6hI5Y+8>K}%B*rGUrkE83QQueW7GJq4ZEn_6U;RqvV@|NI!jLgVhRmz&M-qQw
z9}ze!22yL!a=N;DdMLs^H)na=CW5w5-N_KMRu()bnVKgiBusThk%%nm^g3oK3Zd-#
zoCZjuszY(L_HQ>@(NeJ@n4hf~86kn0${cnX8WQ`tQm+Ad5p`De;s%~e=S#4*&Kk$z
z0Jm-7PLalC+FFUtvJj6{%1uH{7&HFz3ZqyUCP7xKN_@?Hnl}^=P$WtNT0?2^82Ku<
zo5QF?L1b=O$pjnRhQkg?@o-<u#!_(m!I-jqMQJiaX6||lP^8H5z<l<Hw76i@*RT4l
zjO?=>u4ott1_9&j#xfJ8<JP(}Ro);j!d-nKxG(M=c7*!0u~cyrU({rG7Fl~gy8^xk
zIi<X{-4I@~O!uH9sXglH24eX;guj7hKpXMc&Vpp)6Os3D)0g6;b7YZ1!T}u36Y$mU
zsFN{e?N*az5tpcCjXyGD3$celuQ^=lWVIBJbr!;z>fW?;OR;wxo6iKlm4y?ZzPkHb
zMKqs#W3~(hru^?#XB!Atx+8Om49ZXVX)M9E_}o|}gq1A2v&w~Pgj26c=*q&zQxamo
z_hqo&sOuOZv4?*_F|q*WT>nOwyAQNE$a^cs=tf~X>-lmI^L?JL`y%8UpI^X6*U58`
zmB3&giGnqElF$O#!IyyoTR%j60WSzuPN{>uUp^^;7T;2EL|-f_U<%XkBwI~r7OQhg
zl|YZzqlDG`&^GU`@1@`O4xmF65cU?uo)7YI&-Ivmxy}YdrA5P3l1DgdKNf4nqG*mU
zm6=4r-J4MfA3ae?rhmplcaI0NyE*FRl2~tIB_?LXV@j_cAK1UnNxf?W_JFOcH#pQ5
z2xHMK;<>xnjWm;3q<Z4ESKnRCnCej*z@S~lftm*<ae)TONrS<0vFVN=S?)<M5$(on
zi-Z^$;<=HbR`%h_f^vFz?iH^~1zouU`Hj}bge7Ui)fPMHh))d+vDg&QJ=g)!nSEdo
zOtMgIjoO4I3%`DO%ODUGnHsZWhv$;SkP;if1x`hJ@^?%lND5$s+C`M#4HZMAXrG(-
ziM=EU8>XzN&5VPleB^vh?n?UcJ<@OPAa~^G=;&`!C}IWsET=2PeM+m$Y!GmeqS?JH
zs>3O8HGAqBw&RBL9@UvM(C!^*<)zB2ZoteA1j1CB!8nk^qthI`(|$sfT2#V9-qV4r
zjt%VmP#oT?0>yS}?~IR=v;<6o+IWr|dAL&Bs+)Ng?w5?&?w*VnN)WUc1r*&AwV&M5
zwLST0mAdjcpP<^&x%kg_qzik}qQ1PUYS{vuZATO)NpwcYt}!sQoZ+TYskF&zZ7PO?
zS`@6O`<64->6&$Zi54Dr*jKmb{fXa|{7|;R$uuA7x5sxeWFHsGi{#(#+@$TVD^M{o
z#Ee=bb#mIq&g`sU;XrhZ(Di!ID~s#HJB$elSU+m#E1}>}Gth<k{ljMGW0+ya#9)7a
zMvbkqv6S1M`3&38>PXQmsES#CwfPK5UV+CgUgV1p6pPC`;?5b4HeV})7~uw5BTtTb
z(?Lahi6Q?9^LX=Ffe=;8AH=|*#s{(w2u6z8CM4yrwC049YIgUM@5u*S8vFd9rpo|J
z^U!aWFoe_gF9Th+WMwNWs0W}cJh?|vSo8Dq3gy{wKaiW-!>nu^4kxRWlQ2T=fE?w5
z07^3kT0KCrLY7j(_3`rZGEq~MHWZIF-46v{4){Nsr@yqcl$3pwkIQxZNIxW_D#V4=
zbR6r_Bq_)?kJ@7KGAOws5DV8a@fZI58bHqNrNY9(C<fpKvCKvTaxS$uK9SQoM6E3?
zR8(C@c0CbqOPAe>a_7jolnRujR&&ioFfdr#2tMf2n~*XdKc234eh%fd&F-pdsIM35
zT8SlPw`4w4h|Y1k+Ckc#DzBb3$G#ML_Xol8lLEof(Gicwsbmtp+$^`fy?waR{n{+-
z!&9W_r(OZIp;;!H?dNd7MQD7QCc;3zdZY=zUU@S=OWRCIgbnh6QqKWmuAzE=OozvG
zNmy7IS8_SG9d25tW-?(JucjDAyXHaDP4^?9pB_zGqQ|FTnVTqQd2!(hM0O&tC}O5q
zt0A4!p5rCSGGLZ6mORG9&Mi^4PW;j^%eIis3KF<G1Mk<otpVa98$h0(G~R|kD@;vb
zz6|&e(D$Ij%V98>AbxAoXmU_%U$?+Q2PzH(f(~xip`(<hkO6_7JVv~r(yTO9mQTmh
zH|j+-PiFYY?<v`54O_sm-&XS|Fa6+<{)#m}+*(aoX(BJYqs7#GvIM8SE%_Z`23wJu
z0k@p2Zo0wS_*2ew1X1)n<M#NM!uwXhx5nwz)ZRZWTrwu2VRz4&#(AY;ML5=2WsV<|
z8|JE5+80)zvNa|sd=(B^uC|O9L(sdV$A3-jsdRDOYsyeAto0mIvCJ*|*rs^ZfZKgc
z*_Kg)jkd;lWb7t=;Sr#qUGG|0&@PLK*5|$o$ozfg_!Ig5$$-#X45@=`gzPc-kgBO#
zOiz)@alY}X<+<cnpHp)cv%?hM2YC<`-dm-QYvW-%D8#>qzwSS&wci#ZnjU0Lpxt@J
zWZ3traJPEFBZJuUCUD+mTdE!T15n&_baZ6A)|UVvk2IPEyO3W{>j1YXvi}oK9s>YT
zj{b0Xcz7}_N=$1aY^Kh%Z?e$HJLi6`2>^zW{C5sJg3D{4Lb{%EYg!Auqv1X7)3;`3
z7BFpeIwa*ii$4u@P$YTxPG<G_oj{#<&u*&6)oVZ_rlm+d9x=F5RJVs!;{;FA%rDhx
z^`k~5gk?)*%+;Oe_OpcpExprS_i99~V~1z~KuH$kl7hzH@_x}9P0F%wtCIs3JI}E7
zN8$;{GzMM@`n^c&iJ_N<l|5PnvTaqH6+o^5ra)KAsM0SL&*5t;PLFme<Wl7Xn_X`k
z;hmkRuU_px(QQ4OE0nwf5JNH6-Zh7#OD7O#>ZdFtyS+uE*VUm=-7KSGlAm5k7~;s*
zXOc3F7md4XS|thlMH2YBjzg?N2`MQCjxo55*)+0z3jRJ{(R<JB>K@(iu417G+Zz`t
z4^ERT0cZ!;duVp6iEv-f))=>sp1N{Y@Sw@Yki`k0j3yhyc<Um5RPVgjRO%F^p$*hn
zh}_VCOy+9600V}*&`*-KY1M-hqS}3OpEj<03oInx>V^mmfBTSGQ2~HxG+V6fwy_Z*
zT&f%M4dg(PMnFp|p(6#LjaWusU4?60ulbbEjL}|Bx4tim2|iO@L3*IP|3-WlRCW85
zh0Fk2;#$4iCCSCA@E=yW4+0JajD83&YVMHhFSE^akojCa@_nK76w)aQR3T4^oCIcl
z@JxaHlekM3=k9u;IuQCaNN%s`o-bnJoH_}NX%=iL!)7uf#DOH41+a6f37+dv$C#vY
z$kTN{VzxeqJ8cIcS<BU<c=?=V&<+bQK)rjMCv6gCCf0zalmt520Vrk7kf_bWZpu`J
zA~ezX62%LG=_+$t0#GBmbdYL#<f~JtNv|>f`+tP-0^P{74m0K;AJVaxIcq9EtaKvS
zQO6EBz6hASJb2FLXh+|ZOcX;u{ASdeV0Y<)Pa^1Pc+b2-PR&h2*?K@}eyz=Htyvmb
z!N)?1!ZAo`I6-B4iSAkjN$8U3VsWcn{0d^~`<#3k30d~F!PK~n?L3Da!X%amLYJM*
z=`EP(&G0th`5dQ}scuPcr8~}EWoB|2+JeE!X8t}L2aAA?-@2%J$#|}}_fDiXrJ<(Z
zbj5vhMbDaI^|-4qI`w9KgP5HDD%Y31(!i2O^zG%6zw$<mvIuUs$rtn5ExET-Nh>0|
zu$*<PQyR_Az=ACF;boBq3l7WwNi<tgAP6N}QS@&QDJ?X*7p7xb`5?O^$(&ZGS6k30
zzr=&x-7-O<><Bn*$WC`nZ?Q=DyW7|<pJdz_4q!@8hMl~5jq{Kj|734&X7YQNnfCtd
z&(Qk22`$%{6qhX%@=$-SgNwtJ<-Az~yI%U+QHn#dNg04zV13=HZQ~P?n@c4X4vVQj
z9am4(Nbbo9=lcj*MY(l~!6;VuWY8eybNe9%$M^utR`rkbI2{9;z(3+#V3=9X2~VgF
z4<{&!fh7W#dA%n;AE9mKC~pl^7#I+s{P~ts{Jb|RKTcD-xX*h09A^mLdj#-w;ctN`
z3Lyj58bOF3R8Q96?c;H<<qXTS=tWh-%z3~GFbq-_bFN>N*7rqBJ#Ro!r!hZ=@?9d{
z%P|a3WvngOlM6$?I&6Lczb`(*vuM+u{mG{H%}9Q<f75n7h^Uc|MPdFO`~<JGG^an-
zuzVLV8iDbJ4SoIkRS41(5fDJrk~W((GV&h#)?!XAV1XJ(G^tP>Epd8DMDOH*E48%Q
z>#6ef+(L#d&B6I1-N*aiwHksdS~AHlfhp$#blVx;8NA?O!-68-EHqiU9UxwCoRlq{
zst<qHjLLw^K!(}0FDHN5pm5;avaSip;*N2xp=y0VKEj@g4&Tw>g`fK{gH`uKBI2C8
zUsLG(UU~ZGa^DSb`ActxDlRai7cHE1Q(I5`SRu5b1B3l($Nml=bE5f1EV>b!4G9m6
zs-c-IOSzVhAQWsNnG7s4N=n)!#w0d#9O(^x8dOxrS?i}L1RMg>U7o8Eq8q@1P_E_<
zG#X7W*k42;1V284Nk4Ck(!T^LxB8&~<eN1p=vf1%uSas}z`*kcmu?bs*vN><RGC4A
zi@jItqa5nZ`38LZ?Qtn}Ms7l$>m4kho-JMfsBXV8!(n$?E{5hY`=m<vTM5a8qwm?B
zmn#6i(CBtLHnA+CIBZd}*?C-p52Yw8FE=^cnUcec1{BUzw#@RCc3Y$38~qs0QSze{
zK_MX(Hi?s^dQYXGS6&@6Kz}`*mQ5*zc`Yq1P(`@sU8xxZu#i*<{Ao0jEb`5CqKLG~
zxxz495O#laJgCbIo+lW=l0oo#Ch!LEM|6AioGs6ZQ@e>H7AU)imX!(4jLU+7GHfRt
zq0HQwo+EwFPb&6DXr*Qp6e(PwIA)mCx)cYAC7>j4J2Bd09uw9ZM!vXm!Q~R$XGw-a
z)pHxQNZ8q>8Mzertv`aNTELi5l%8utDx%RI_wMCZa*c}e@KFMwA4L-B0+7NMLTPQ+
zx-e)?pqrZsSg$s6SQ`#nUMwSFQ;j3$D?~tb9QLB`i>8_>xN2+JthysnP5_${mYQ@0
z4m@$dWTc9~!R&Ic&Y&$q5@;IbA#Dmxf3GXFPntt89L`=)SF6?ZLBci?9ARY43$Fm;
zlgK2;cW`8*XGU1KXqGmo6*moQ8eH%f<t6_i5!Qb=v0to3=?&s3fub^AYq>(_tEM4-
zz{pc;%1?4K_K(rB(fA%S9|1ouJfQ(S;wCAvZSILFzyj=NaJjkqlGwxfZWS5>Uty80
z?<x!e%O>$S0nR8J5x3>Mn>l9c3=nbW_9<dLMFbP4HKp}PkAvgieL$8f5((t6TKp^~
z$fP-|aHR#+;yj9~p;xbpo>p;M31!cWCfwl|DmOxt+6PvVHx4N>y=j8}#{G$``6}O6
zR>FHxDf=#J)>Gnu3X^y1Ebcp{ozx5r;3WUSdmsujd9OTOZAsZpDV>rD)D5M!B|$%N
z?B4=|lyVawK!qZqCKB&o{E_K>YeVFyR9xu@W#z7q0J^TetaUm}ANPBP1b|E3frley
z`3lA4-Q?J)7OEKuR<`HgItX2<ZT4kXDjbT;ZtTOzwtWE%a!a^-Sa9nH0-~p<XZunt
zVZ<q;!z_)(lJRq2Y<EPz(b15WQHfd0kQQ_-{iz+gQfr-0KrTD7AHwJUtg*cAhr-KL
zxa>3*f$#DV$xKo~V4w}&%P=i3T`8cmXFz=eT!B!%s!c2i!28KKd1i0e3o{i^Te>0|
zvQ(#*3;|aVNdT^w-G4!fQt=jR?Uhc*fKI1En&wSPu^9R7<P#Ilc~*&(d~wzd>|u>U
zn$DAqBMmu9#Q(VlJ@B%53lPukLi_kitq}by&R&tKX_M?Yn`sX*1$#4Lj-$0+03V^I
zrR}xj#Ah@621I&E4<9~D0b1JK0Hh*ps@#bD7Le|Mj<&{3g&OCj<dSGgT7OC~Hjt6N
zl^jcdlk47*k(!!{WN+%c<=5GGu`B_id6vP@D-p+#m7A+3r|++B+2HH28~OG#8AS?i
zjh-j^0FoobP$Zm4Dv8}vmXs5yN)<5$a?h;$yK_P*2C#32=*C;Il28CNO<rDsqdXpC
z(~bkyJ*Z*dg`6$k=49zx_q$8n{GgYWf|x?&Y~yFw769{oa(68++_mr}DJZ#2NV}zl
zPTIi6RorZIHy!mKV3EvwfZfkkEKrKXa0rkP6Z<;-=Cgn>nH5;bC0Dj7ud1R;gq{k(
z$)y-f4BBT0bDgWzS(xYidBvELl*G-Ii?!1FCDu*2I(phKI1HlH?MF~@NptqzZ7Gu_
zG%;=k*X5AAq%_VAUuind2|s%B;+>*)wFT6~RVTEuQ44g%5f-VZv^7yo&8l4=PuiVD
z($=XRT~x!Q_Cb8T55V@okJBt509zF#=7>PLtoinErt?UnwbtHs2W)?|$~kfj5Wlgy
z6MNsDP3Ad<P=~_j9JTqo>2kD~xE6m^D~;qS7U<qVMTLAo+sXW%F=Y6@fJJEsg?vJW
zVy=l5K-5XvkBVq7d|3$2*ND~==`axIrK5`<NUnKP$w~8ye}RXG4vm!q(wZCRVU{tv
zN;u^whgSG?I*9f{s4B(}56Y4`@DcHju1LG7F|!?TrMf+vk;DHF<1HPtWHy2NY7*bY
zCqYmsF=0i>*atf&8dj=gj$KK@%PR=F|5P;~pR-Dtwl!Wzn>SXVEFCoPGwg}B$7NQg
z9@eC_&gBuj!;tneR(%y;2T0(T*Me`_zFMQ_j1DarGtJw{oW{{zhMuf<U{Fv1T8MfD
zLOze1!%p%6V*XD*&0V6}hDq2gqAh2|o_*}<>iT8^<HM#_z@aIA&D<ENfJz)IIAp_x
z#(Eo&c~M*f;2dgA9t}tD-`i!=m)8tG`D3WqJxpE(v^l6FKLLHd*uA4T6kXuk7Yq)2
z0kHLi<p~U|xippWl!|%mNWnuPiVaJvfZ-BRC53|D{u4WV9X<s;FB79q$FaN@fJ|jH
z(I{=`^;{yFxG%|`lGTtR?N9+eKt@RtHRoEFb$6Svb@MH*^0&Nm%Pf2Q`)^4HIrqD5
z0bvpUJw3hSFX^6B2|<lFjB%3oDQfc9TG8-Ew)wdFjT^V%j1a!L0K1Q1^hwSv?WQC$
ziKcst-TEfarX3a!m{e%HH^Lbq5?O`;*^jz92=n2-syeFZ_cm(Yt<lm(+_cw2ih!bO
z-_gOaOp${$C@06iaPQ+xI3YLf=4iqC<W=T}`)BKe>U=Xb)HFRzlo-tF5cM-(Jv&xL
zb?k1+{01dP6Jg8ktr)jjf~KZPiYc!`pjY-tZ~RgDWCzpVG|(1SzXYml_&-OjNk2He
z`2-VbxS1sY@jKSWm&e|g{NUKOeP2XMvXnf!y7G2GA2M0uHM(!Salq?(23qO!xjHqN
z@khnJi`I2;VAHI%6K7sGS>LQ<UvQJ~;j5gLv>eGqwvK*YxieYn4YaB+3To%Gp+R@&
zbdYRx&e?}eOx5TvwfOe*USuw;^(UR?ufi1*_-+m!xvV90kACy&lagb>NH*zh<4OD@
z(GL=P!^M>dbOL7xy}I6S+T4(x8TKVJ0BAJ?B(s}S*V^QSqQW+Qju0-C9}-c!ioaO*
zO1$1-rM?r#;#*Bq2YcI$rwfsUQUJAGIc`}{<~EQcH}SPon;d*At8$2flugvyiIuGc
zxkaW77pqb~$D``T76uTJ;s7ok!m?DDQ-$S%nA#fPbWK)M;WJeZcTREAjXx7=Y~XzK
z$lc`PK<i8)x{?2Gl9UteWNXZCYrN8o)K(uQ%uT2G=4#s|LS*;|(NipdABAADeIC8A
zSiKrYP7S><BZLNsSf(Y@(h!!<6_=>hD-ckXIzsX3(vNvFgx6PeI5}%h<{XbI;SS*7
zGE-$b<(L)>!(WOn#R}Ke?eXej0;!*SpI_Rg@R|k={4_Ni%Wsr2{l#eX^XUOp3f!ec
zPiTFhKZGXeW>mgaYKG99$4w<{h|~D%4&7=l;W)STM~4^Nb2Be7%BUPdYN@a9hZ5`a
z+21M`3jj*0_V!kF4jmN&O_<(2g+q$KUkbc`O7U`?5WnVUd^KIhR`H$Yy^teOdpu{p
z2LJ@?TT9fHH9<+=HB(b)DhXBjQkT!oqNizstd8`T!Z7pl&IH%|{CY@)rBkbjF+TF1
zKYEIqtC-aJ^XC^VlKhsRUXO&3bU0nSr*ru8mtx1*9Q?#2B;<v6yUevcIK7FS_3Ov8
zl{nnHNArktbpyk^ypB*3;^X6APOUU=Zf>>>Q1&OOTe#KK*3yv7aen8{VHF1?Be&P*
zu;uoq5#Q&r_|_fWe<jJYNWU72=Nk4Wg2Y^IFOSyC8b^yX)fs6{0bfK+QBygIv3$im
zfCkIYCE#Rzy8SAHPaM$ABtHqtz)AZo;EcJ*^7?oI`tiI0VlDaVYSnb~hrDIt=~hN`
zlDYG<#0j;j&hV?bd#uXq!FNX|XKC^M1sh4YozuLb*bAN_gimMlHW8Hz)5eZ{1dmhf
zJt1X<Jqyp9(kxm<<Ubj+3j4lQs=qsCOT6~PG`{b^R%*qo*acPdyo(^+VwGhxpSZb*
zi2<v!v=K(i^H!ioyk|(^6{c;xpA9ls{oXlFkem%5g{f)xM*BRA8C3IpcVFl6$w;t~
zkm-GJzRo9+HmE$neyk7_r2B|A=x+D(Lz=6gFV9qD&=EEpkbUMc#l*zO8*rW06Ml67
zU|nJ$SWOsQFM}DKaaYIHK^OQ2qoh6P_&<b8Ujx<mTvT%$i`l03{a4%g>e_dfO}n3m
zGhCS`9Ag%St@%vHZ_wslEnn}<70~bP4W+%7Oy+n+O8Vt8@%|`S2ltsV_2OtAhw&U&
zvh)Y@xlgcc&r>O>fhOw}3b%`;!9Mo|Oq=<T*LvS1;$jcR)fYYhaCve#hO)Ae)6L;^
z{9`}x;_`CWEJcdngqAw#XkMO>iwmk)EX9H2l(KdM(tiChZ!*8-O?8e-*ap`_UrHbt
z=(`nvaIL-lw7J>iTdz%v>puO&GU+M1(ST!L(1OO4CdkfC{$ewSJz>MGbo?6Cmk%(`
zStNb!7XIxzygvy|LQ{1oz-_u>SS2ih+wmpOai5!vnvKBWK)NuafPjEz)VdcA`_M;U
zEWma|Xal#nRhl145#X9xtH`;`Gpra|ZVTsqnY{Al@gS2|uXfAy%D#e|C;qdobI|_0
zc|zULiz>sU)1uO}yUenX+XXM>?IpRF^=c^I+fO~e!o~ufs_M0kV@vn%ef~#Bl|P!j
z{d7V4YSj{Anua4DU%EXrt|%;gNgrN_^SG@;>wTW|2`n&4V1rapTSmS5rwc^Zr?INX
z4a;%kCHNCz#p+O#C%?m61>2}+$NX0tdJKF&FAATWIwy0G%x@G~+;6P^;_-CY4b)BT
zy^`z^5D;#B@vW%RFRu4bOH5!Cg|+cI1C4g50trH&k<h*B;y+hcv(J2gDK$_ajeGBj
z^6H%c6s179*ze@Tj*}k%L$^H%gQyP-KtJzI*U&c--s6msJnTS9o;^k*)8u;eVTpb<
zzn|;m^Z5ky^YRxSK%ni1Z-&|5Ur;2jM6?RN3;tFYv{PZa2*=H3_!2C74uNm>s+<kj
zIh_SBz;&Ne;yT?xi{q2R-*@%)JitF|=$W6#NS>XYI{km-y=7QkThc9zyK8U@7TgI0
zcemgkg2Tq$-6dFXHWnagu;6aN-Q9v~aJwsg-qW4#x9@$v|KCs8d#|<Tnl)#QSz}a{
zCDmMW)~DKFUTL{-*!J;0Z^B!GDYxbK&!Q89s3Fb4W7&i#CFfs!q`vpO&6Nuo$q+Ij
z8o#sIT1>I?EN!0}%eaZ64xL@11r=<;0gYKRiPu-$XxXftapTj{`g!I_h>x5{)vZkS
z8mwlxwRv;P!kAxaR4jiTo+Mgpec;t=NgaSCQl+k){O0>4B~Pw7%pE_}V2W&K$CJot
zChenj-(bICRd4)U_6`LE_Pg7W&z5Xc?Ld73gaV?n2k)91c-amy;tm)S*;T|Zo*#s&
z*IfDw8Oy06$u!F5p|<+1pV7BkQds<g8ci8@P8Img>iTA85YJle`MV-<b%AUIgK97W
zECQg$MFLtqvuh@Gz_MAiiuoMB$~c@etlVK%C~%!;(K!_U%tdE(c2?|})700~25`@I
zKzG#wJz`wkK0QN0+9I}ugakyB{!z?}>4@Oq_q*wg>UiGk%MQn9A#?GQB*WW3$k;Sf
z^FokZ{8XEGuZWWh3}K|!2G^bikIC9hH(;(QLaLW>=)#3wQ}0Xv)n)v*;XqOf|MiE4
zWC!2Lfi?k7daMUxu}|eDDy>?O^JU-k{Y<&J4KY4Get8AIYl{>^WfOswBnSkWIhHM5
zfhY4us4;JcV`F0rT*7pb5E2r)##w}MrLs<Ml2**9VQEy0{MS9|(mMi6sMhDNU7(;J
zLAyu0kb7;=OaiH!gkpQbpLlD}c_d`9S1zVLD0E3PZX7vi{d(+HPRe1JuC1&2dD-p3
z*X*SeV<DQpUG0`_yoqK@!5PUv?h>(EXjsg6Wg0=%lpoK{>o78b6yUjq&m*G3nd{rN
zjCHAU?Qw1M?%mDuPwz{uv^b@;{A5VynB45r>g;c~0nkN_hX^jMJw47Re4<&EECQy3
zMF3P*$$h1r*9)6TH9E7p`fJTlR0>Zv^Butulfm8r>76XgwpZ!Kcy0}=&Ad%e9-<}6
z^0Z;?9{QaC{Z77e*V<axWs80uVkS@n4YJ0)K{h?byQguc^0XTUt)kijsxkxU22MA}
zhSTZmc8VABa7!xsY=H{9^@>?vc2kr@%!h#C;pryJelOnmFwz3EH;ENs=$JpM&h_5O
zo>IJ9T#A})oxYmckA9NdVeI!bUf0rGB23lml<ryOz{rHw8LX=y8~?>*uECafxGHX0
zVqyFxQeV~O@45bC;&0>pT~<WCb(xkJ(Rg!gDI#-RA|OHYOPN!!2wlBN!VBk7b(tAz
z^F#zCB_r5IIdO#iT1gog9>!Aqfy1#m577(VCyr-frDr(-Ku(F}t6)|zV#KnZ!*P-V
zKujWuh!Ey<t1bX=!x%_pIoeNlr!QTUs&x%eqLRyXIn)@Q-s7V880sJT%;JPh;Er8l
zIwZX}{|)=ndO1@li*W@Z5pEwiIPq*eKi#a!X?IOz`XG|1{iEfMJwCQF@;2ya$(t45
z<x!9Ed2wM%`=C3|m-AMFDz{^$vw2<QMi;~q`8hTYYRuTvTO!vd&?4M)#adg?bKE;B
zyJzE^-jF*CKN?BR8_!GToJags!Uf2_(PtE$o0c)KbY4p>%%&n~XsdO~;c;aXtZA8@
zn%H16^4Up{K7>9v`1}5F4+$yXPyH_USI8;1M;){~LU$jjYv5Q3h)L>lHv4Ix%t!7C
zW65|%2qhi9?b}3Wv7~Ily_{{-q{&4|<!V-PcX>&#wAI!|&%^}*bqdOvCxN~izhk<H
zJJxgQAVgTA&6m%OPJTue;@7O-NrnqiuybA^-EzKMA4{d_Mv{bnRWB_A3p-bu6k|JM
zJFfX;rNV|}FSo*h>`VPVldHK1%Mso~&5jKYZdGuNGr{Pjc5s!*-ag%s9PzBG?82EM
zaa!SkxoAxdf!t2_GZX+yyPDSjaKPbt&t<dhj!|JaW~{+Yy43}ze>~yYM`Y(c1j_*p
z@0wKlN+;+0+H-8<&sVTilE2~)8K}N}lNt8eDGJ2Jt0h;-Iy)#eysRVRuNQLqwuy*_
zHiHe)Z_6BBE^PS$qiB-KKZwvON+Whkpno|g_zZu0lZEJ7k$j@~_|S@gSo%vy4_t~)
zKh}POLXX5Fi%fBOCi_-DOB&$mTvn;HYs?f}n)12-Fk*73zy1JID$`Qt$z1s!f90#b
z{^;z?FW5^Z)l=l~mE&|&Z4KVbTr+onVuwt`S0^F9sKPCAWqR?UcgQ{{?N=*FE|6z%
zHpsv-B$i)t(i_#DH1%qK={vf7I;YGiKw^+wV&B(f&f*dXc;Yl~aLF?3)Z4tZnXeL2
zL?`4#_zjpdM+XLscucdCr|v0%gyB&093M$$W_tPnL~PQ}Q?ERpuI4D%t3xu)2fcR&
zX~Z8Ny^WtA?=Da|S{e&maz7^~LaTj|-`N#b*i*Di20~FH@82is`L1_}n6<eEWY)ij
zQJ_G7HBJVo*+g7xbS^)lBgp{d$o?Bt>(REaoUH0JP~zY|#H6IXwc6tIALIVw;828U
z;<pKL@3piLh<HF{xhkcC@>*K2?B0)-p#W(x?^~f6ECMtz2<t82jm!B1o81Je%-2*V
zD-8msgXJ)QbOn3?txnFyhqyEDEU@uM{u9N5+6IKliaycJ5H)+I>oP9+i8nv1Y%_NG
zPrjMpZ-n6EU3lc_1_Q$6D%$0h)RO1JD(g81Q1x26V%OMMhTXWNB=@EU;y5f!6Efg;
z-}n)(5dsyDVKNO5XE)?ik4M|Kmbzz3ExohZ*zj|!;-AAbO|!;hP(Xt`Hm^D)-YhK0
zJLBdc6)Cc5@>*^}L#gl25xY3VOw34Z^@%KBK<U^6#0QL@kj8gE?=e7W6Bu#aow_va
zX!cY9Q4bQZsxFN>h_$voewU8!KMwy!D8n9vkB=6daQL~DQ=yi7!nqHvQDJg%As#n>
z2`WMFhxA7vS;hZGGYRrEaosKH0Kp;YNjdWmulbkVDeEFiw-=pB<I#S-WwyUKo4`_7
zE~X0$M42%EQsEggrv}Qf$crqpoIU7|Bf}5Iw$O&;Szt(Qw-N)4ZZ<U1V<7|?A7%qa
zFu-^eXft1^{9%8x@TjC_V|{C@JM8?|uizhvwA~5Rav;ljK(vk66%ih8pLkEiY6JlT
z2j?FXgWCKpbMTR%lBXo=J>r~EcWBI!Oo`a=_amq_X02U7zMidIZO$_!kAIh1!(!>{
z{Q7?uj4+H98Kg54rq?EhpZ4W~d69llcZSC0XRfhJ#WW(&{qtGSRb)au6)5TDa*X1+
zTBBlT2X|RCtVDya?CM>asewf!l;P|v`<Ri|QHyWT<vQ!7++oW#8DQQW6yBLiZ|QvB
zm(LWwJ4tUS&QBi#_1ZZ(NULL?n2Sn@I>U^of!>qquhW&qayc>oUc$ov15Lo`Fw(p#
z684~H3LPe-$;5RU4z@Csrh}cr)ik9i`ms{J^MZocbZ_3knVZwD5=&s$n6(bd54IJ3
zZ~mf?A$)VPa+M+nYq9X5CmewE<EYZ58s+Of5!jB|e1W3j1RUAWnwmTYNvWv_P0Om$
zL_8^JXjjP@TOKy6Eg^R<tuQYSYY&dTr>m{0jZ4RjFL{}oGXubdH*&*B6C?-$0tuFQ
zExs;}S-+`cD^4jstczCR^#)A#meZJJnP*RLZ|7p2-w&6WPs79V^^y|H0+H``PfpNM
z?MB-Q+Wss467SGKd|mE?N+?(#tu#hYj&(4<*gb+YMao$9%?<8*RfV!jLjO{J9pV>I
z!;Ts%0s_W;$J!Z#=4$!_daju4zd+XC`=ZrbNG!$o=cr&^3<vd6d^ZxPsK@umo;s+f
zlhLWEul6PjYrI{7(vkpzQQnPmE6=2r(9_pXtNM__NEv_OLUMU=(NGw2fA!?S2D)f}
zypSt<vN220;5q$l;Q1*{*OtNU=hhZef1$L61>LgW%adw?Q0F<o&z=8DX3#WRYkTUt
z10yHV=6FYD*d-G^;fp|a4X1JB$|NGtF)^8LhN7Mgv9u%1L`Fq5zCDIRB^<a5f=4%_
zF;c223XdJ~P=#UAm(O}5cwX&sX;zXt_8myStcHyM)KE~_Q(YlZ+kArvv4^`F^shU;
zIi&yyMh~iJa}WC!_P<sqU{e0L*mSajsOCc96|*RINw}SjN}M-BUuPn|syI8>&I%*|
zC5TF`R1*HnZ$TmcBjubGF}4c0;;C<{ikVQ_?{<lH-Rkssf1_Uv<sJ+yRm)yzSnR#Z
z%P1B>^EP*qkfu<q%iWPJq9;|7T8s1Nhf{}hi5x+n)Iwx)1SF)uhm+>d&C|+}G*u%P
zJ3_JwcbL8SHRe%WF)>6h#$P<9c08l-S>S5V$YC=de(g^c6xb6B`4WR+QIGJ)keNPC
z15xDSpa><QCwX4<;ZmHB@95{GF#F;uf{a&N#y+aR%!=_405irQxnqA<y%$sm(2K)J
zy-xnS0uIct>;+BwqA?jQjC{Sl-;r(`jkawo{@v{UZ`=91m-#E|@d6oaUv#Kbv2_M&
zYS`z;OQrndVyOSMT>TMJ75y0%Q%57`rm4fnO=U#&Pj_R8l;c5JZ7QYVV4azXJgBDb
zR8Gr;Wm2Bgr8?_=L&q<afhPhsHg9_2B5leoL`9*%LtJVT-hbBuK*Q0O?i?MBZ9EF!
zto)J4Wg@#Xc@7{+|5?@~<BRPd{&*w>{u)dvOr@L?^gFrA#^;+X8+Sj=rM1T!oy_N(
zT!=CSeRM{<rI+fDgE?tVTHVMWZ?}|0eStjeGOce=eX%4AKdGpkVFOvjjE@)Vlr?D5
zQJ;Vg2}Xchu9k*cayyv*)IOdElMU^t3Xjv^ecmfdvGgwh`uA4#uTvDOG{h<Hdenb=
zJzB94+L^^ry8N{G!k@%vlbtRYE(f*g2Ba}PC)8Q4eo-{2FoSH6W2{7=Bw*z}`&OE&
zi_Dd5eR&25rCvS5)LnR-a>?Ifa!pOo%j?rMbYwhl=A?X6ggR+RCXqd)Ff@`tfQ3So
z*h}bMT{ReJcHYm6@9SA@eW<-)-KuP#btrvBXTwTuB;eehThAR}J0aQ!@LDJf3ky2>
zx#VJ>EueCA(ztE;^qOfRy@wY*&wiu}`g1veHL&OyN{f?!D$pwYm*eAKmSf}tQ%lD4
zz3r{eNc3P7^2YY5Az@Zr$yK!L$6X{-(?Zd>kPrz`LhQoAyoUU$D&^8xzI<?pJ4wk1
zu(y&kGo#TcdP5O%+t8T~N#Q^d^SeezK~9_Gr*<jdUXF3uZ}!NzZ+|);=8{zFoD7^s
zd+0w0*b%sK)et`UEI#!CKF?ot03T#9phhG3e2Z=7@!``EclW{qA`tQ&Dzknh*A%nH
zH8wV0j)aXR!*)WMu3*_7WUTgiK;zzpbwBzhMe*j1>`xD{<>>VE``gD$7IJ!enFYOY
zlZ7ODwGDvC{g^_-7m%2kui?i_Tl+OY6l<p?Bvz{{)2HO&%fI<B;bU@EuWPKkhrJRt
zhq|qTea1f;)&7U!lw}KNg@@C85m*FW6@73IoR~;H!2&WYtr{qkXJ0{TYHA{&+YQ6w
z;NtSEFE={rP1^@Gay8EQYmgCgT0rFH<|<bj=<mL8B<qGL>#8=)IDDO4?e7mmRFkC;
z5?b3ftFNzrd`HOHad{SUd&{6l99W_B6?=RVCX$zs2Q-|KuZt<xg)C+QAOo>2WddMn
z&q{#{3OsW}X5DBwsVI&30zOemT@2D4EjKvi@1t5b&^+h#`&WE-ju5wY=i?;)FPp(1
z-l)S0aUFX1)tPh`VyQk&`m4XcefV0q3-M47KOJZ{3<S}ty-VEw%klINSRf44r$wT*
zvGTMhjQi6t|F!)7_%g)bxB2^;v!edN*t6AGoalf5=RfzlKc4yDE(u`jc>BD*PgDN?
zUw`rU&;9E#$Tx!P%3wzRZ6*Ev@&9_pKdxWw0QEYv*kPNK{67cs$Cv)=c#W6<;AG6i
zAaeO%KNkMKu3Z2NW<ns+S`oiR{crK1|L1+RkO8crH6%O!?r+cWe|ww%IrsoVTH&q;
zLMcUPtbc~0{-3w{*M<N8G^Iynrj-9T)9vs?oNv4fw6@^PG4c?h!RaBZUi~pS{P#?-
zLb=$GbmUu-jppUmVqCBsQ!@Yi3l^pYCU37t^dEub|2+x*3BqRsN*(1Y=Gn<)&0)dV
zvb;F7f1MvnUmKmOkcswrGmjl#+-%LiRQm03O8kA}zh(+pHNn_eh<txc?>ZW-k-0fM
zE-tP;fRgwh<t^@kC!#}qJnObLGEv(%b+|epIqN5DPVNQn#3kBMr$VdE836so<{m8B
zS19uL4VIAtCd*(3-nNpyqk=yN1%|ev<Kv-0T<7m=G!@qW+aTR2fH5wIM9CJ3|8oIo
z2?eaL8-<65`}4URoc#b2=({WQzof;uI64N#$76H|K0ZBl&dlK2*xK&24Gs>1!C(j=
z2)n-C8RTz?1YCZ(5e8^4vi-yDbX5mWv7v#t)4Eas>iRl8$EC1v=j{G)ZQ#m90;nqt
z)zHk3ECJ|)`Crp~LG(x>hhm4kZb#xtFNk+@fX6A)k56!ZjPsXLhT$Z5OzNPb-5}Om
zJ}ZwelIQiD4k->Zr>_C$)gpXIX`|Ry$-Bllvz<t5jmzd<Ld>~6CmCqQv#x(GrlPc`
z#gbmRh+xdLKeL2bwUrdn7`AiUEE&)IH{Zi3E$kFF5*VaB_it|~8K$eN3+(iBbbWW1
zhFpXJ^9vGfUmV$32$m>(WN>S%fV+psxh61Q8+#M^_S*xP5~z{DoZ9nXoSmN=<<K(K
zDHfWKaaTG0WGnX`4v$0%0+Ld#l40RysW*c0a0lZN*5ML^G^>(cTVt~$vTYJAz=}4Z
zV6zADqX#rF0SQTE;sc+tV(z17teh@)QLz-I{jD}8zI)J~nVeEP!J6mz^BeGDF8aI<
zMo%TDTDV&6RyNQhF9MKjG$!4MV(?L-bti)rT_vIY>0!Lj2h`;<@_<G**Y}G5oNtVP
zMRD-ts<kbj37_U4USJsxip~h|{{3K}4~R}4qMRc9$isKLwd{7rw`f-Y*zv!@c=fir
zX!XatU&@B9rtgJeeqo*+v#B$`k&g~Yh~|B(fY}WL$P5D36@!4D7UMoitL$%p-4~qT
zZ!Yb0hBDJ)b997=idoDa5G^3L&CQL*yuP3c$V&A-QU2Q;)J6UViRwcNv~vG^>S<0$
zbaeDr0-l^4g?7(GEf$49MkV&-)D#6!4WpfygapWn!|&?uhLpfo4Udft-QNCq(k3>T
zPX#y*H`)L^Cc^5&cC_V&+~a0`zNY;Zk4a|@JgRl9Wyvb;Paf`ty?sr({GjOv<M6eo
z=GpzmX;hfco+3JTNh-~V+xpEgZ#BpEL)H(7pj;Iz96e-CT<At+K2IGWq^JQSglLE=
zsm`=EIwcrzm_B@j`AGH>H2$w0`X7T!1Dwi792|<jwv6BJ-Tw};p{eNrN1>pgK=|qY
zs+5boX?0*^Bm{^8i%Cd?j0#?#tRVkBrIhJ9?~MlpWAj<6&|o$+Bg`)@3a_<IRC!z)
zZ}jjvTfm{A?czHi1}Se=Q27(dsWy1zLphGwBqca=e)8AU!kOpe6_c?1G@hrj<{+Am
zB@Th8xAKDTx1T=&nhYEFZ>)&#x~q$#aJ^)wmyrS<4FzN1T?^FX!{|0w=3_=+q9HbO
zG3$76<lj5aKZa(72{~dCUbk1U|Nf7KW#5eOnueweh{zfNDnDfn4S}2{y37XW{RD#v
zm~353OZvyFIm0eXPcJWI%iqU!dpArvdirD~i`z3&N4-d({s|d9(qNM#jYPPABt$y<
zjfF#HW`>(F(J~!2&&!S|zyr`R3~qVsRZ!I)vX)<rS9I^ZE2+p7!TkMBAuw6_1IkQF
zLj-+JJjA8{3X%Wg|G+eXU9ridu<N{@fNI<SL><W3!ciD|s#`!8t}4G5-xI~|F0sLt
ze03xob7_z$F)?w+=qTFY(9jMaFn6=!>#JV;qMw<W(zsHZfUp!AkR4$>Cr{xdlL!w;
zhC2>sn#q}%N@dkR3+yQ4lTb~S7UN(+H^Wcy@ldpiJ)N;6Z1Jh7W>rE;N}8`Yi#aNT
zDp+PKR-h#$sBK~efl8LZMvMTbq{K5Y#u7L`|9Zau7y+m_ylj*+D9X>T3p7(i1>$*7
z>0H(jz>(1Y*&FI;!3hc|lhD_%I?ID2<iU;xNGAJAIj!*qSFQl0Dh8Tta%muri)cj1
z;*%J(RHGCTxdQgLl<}|XCKl7-jj!w-g01J+*MC_)dh^5f#~HF05;dY_KQuT%-!9%h
zcm;)pA!7%x_-AH90r{vwLGWW8YksGdSkO*43oRbdZO<YiZOWC|@POP%)YzEqL0&1e
z#(ZmI{+pcr!TU^a#V_J5Ez7AA@z?fa0wWZRjPY59Y<@x~i!LZ=WP<%``K?~xO>*Yy
zTbfP!nb|+fFGx0X-`ubJSL7atI9xKHU`&2_Ey{-uNd!-8!1XljODC@cqw6JQF>THW
zQ+tR!y6Ud4A$*-Y74Pd=srVT$w6Da(8rg*^FBg<}y*|}|+5jIaW+}q`v6nRL5I;_M
z@Y^x4UxH^s3_s%AKaVL$S{mTJCR@o<?@x+`Takino_AOGGUv&anao8Uulfo7u9CuO
z&cUO(ZzLkaPt5+}V$0Mbf|BK&@>aYSdyz<v_hA}-Z8yuE|5Q@N=yVgYQ3n6kqbO&!
zKaKEEOgolwqCDJ9%i8`D8J5=0k0y!U6huA=rei>zR6GeR@Z(`0BIq47gWEy_8H_i)
zn5>iHpjEVWuJ5Vf4<b1>T1Rw6i_fkJ#rMr-`DnAxqqBT`!G6?n4!yU1sBRPOXaqsb
z^EZpBn6ZD<7lhSz=%={cRH19}9dS2|B)n!ORc=?XJF{Lu_3m0ayW7ZAjXm`rmSgh<
zX_=YmdLT0$UdXWaK7};SNwJv%o#ecpq_K<Fn(%o&?__191*-{UFH!vrJYXdJdA1ls
z%H;azAFlI~V8+IG*Jp|gGyB3d#m--FBVz}h_2#sA9A5aC4w+N^XkonY-4Kq>a<pQe
zUKHQm^0cpJzS;^GQK}wmn0<80=M;)+T~j(c#1zt0KphZlm@=|QMu2w44W2Wx6hYgr
z8e5Z}HPo;{al&?5HF6WVS%!Cg@tHNv6hJsBtAsmp8Z8w;_HBKA^n|UdbhPaQQ%}~>
zM+9|y7tCyN#-Z|giBcb0=ir`xOeqYYd8=-UYaf4-PN>bD(fqvHp9=HwJI6T4Cz7ar
zmJ0au@U%Wk^_wz@Kx|h$ZNXL><K=6*fa?LydovPA0H5$bX#J}&xS;1(#*X^lbwx#F
zAZ#r}E}GK2^I%3RVTWEIEIq9bdRtBm&Hu2QVK)z#Y({mJ0$)r`5>2daiPc<Hg~1J~
zHQ=}c4&L4p%EUlww0(aW8WMcA-!r7^*22tQrkX0d@zMNS$-~@rfD$op)Dkr`Z8`D1
zx5W0oS@HBy2iq>u0Ig)EwlB#1mSHq2zjT&qZ|%Hufq_ML+GSKXw=O)Kz4EVY_l<}U
z?;$!-m8eBJ-^)K`W8g}^>{a-MZ=f|$3IqSpS#4S=Gm~bqMTgG?i2i<D3O+eg<C7ZY
zdELy~C@P(K<9OICIwMHNPTSzM+#hJ#?~Q94R6LuQsKEpB5}f;AY%L{3*iMi@wkiY7
z=;X1e^up=(53yAK+|_DcVeK!m8G}=qK5bXCTk@~5EEBA;y@lj+1mmK-r=2v5&Yym5
zgee^g*x{_Ld!h7y?gCO_J5JkA;}dkG<jUeWr8_#bmA@yNG2`Q}z*7@^Q~f5>zacj!
zLXshiDNVREEOdX&F#gi5u<R02fmU6a8Ms3B4r)i@t|>C)UEKPY@#AE&+ua;xuyhhW
zepj0kZPyiY-eLMljc>5$2;W6IkKL-j5Se)%l^XXcuFux3&zdgn&w{MQZl1Nm=vFcz
zG<}0dAsVPs9F51T_e9z~6IPEz^2%p)mFezABx^lM!Pwq{*y*w>7G!Du;F<Y3@VS3~
z?GVn}hJDZ5!!&!fI9(PAbp*0o-r84BEvqgnvoTB6#IY=XQfY;_-@ny_)ho5YQ|O2O
z_*tpG-;Ux8d3pMI>{3Bp-(`FR(XnhOn0nGnMpJ;E#dQkZezT}ib#fh($GN$^J}}C|
zSzTVp3xfIairU%d4!-gBY>uUC#>aZQR-*^%FrQfL`0G|r+^NQpdVjf|(4=?Lsmbt=
z3@`H1>Z>=n)+8zgj%$GeT@OcVy&Mg~!e5s`n=fFIxCzzj!Tu4Jo3O`e26d1*D(czO
z{NXVmaXs_Vizh_SGQ5=>Rg>DRe;lZg8o7aSdHY3I=mIa;l?c*Rv9H}cch6=_D(**)
z`oVLkual@jduHj+4vt_S*RN0pRLt_Jvmd4}zhe1E5j~?TmOlzJ7>-t*T?K6gM`xpF
ze+t^B81r>Te~&|e_c)NO{^{zlu3gNa-Is*aBbZUU7zp(Lu|zfGAWqRgbeQZ^x|L?V
zQHcKIBR4@v{k({DUIyn83hj)Jb9;^~acnM;?7m_o$lCa`-3)AbECr+X1iFs#SGTp#
zmF;cT%A5hm6M4P2=g^JrB8GmGakM4GOqzhP^U{}GhKt7I8+vP*rzI`aTGC<Lwv=dc
z23!FU(`bKkK@~eOR`<IVcUTzOG0k@Z0UfFY;X{lsq2tPaqm!u?P!D1%fH{xt%<`gK
zz5JT$1~Mrg_HogRmo|x`VF8y}qK2F(j?G&ck0Ers^Z6|X?#%o;Cp`KIRE{_M%(@2;
zh`2{W9FAWVN9ThN&PtH3$%q#M&v&^B&5@?iYL@7&scD~|6^T46(>tlxR`Xa*WA`$e
zpW^2}o=uILpXdPbe;cEp+fV}YeY~@pq0@<8+pm#`S{54AQGJ=3krW&&Bk~f6c1-P`
z9@`yBcFb4>ub5z$Z#lWv&9?pH>IrcbjQl!DPQ$!}mU^?5=d@tPxfFYz5-F^XY=RE+
zY{Kv$qhWCfgI!6C-*W~$fnPx}N$(-Mj#emFTEYXvnukY{y&rx8c6jHg$pQzcCG_BI
zyQeR|U*CA1RI>~mw@2aVGe0o2_hPBk9;I_}oQTWwnvpnXtrOncC?#5l^H;s6!8Zhv
zp~~xGB0P|_c~kp$l`i<tpNVGe-eC*08dWJGIN^Sbw1DD2H`8D`$!gEgjc1*wXPBl=
z@8CYpxfd_8fEuDa$v}ub5qvd+#O3mY(_`Jnu<?4CP+bRaDjmc0-*EXfA5^j{ob`(3
z6e2d{UjPySit8sd>i|vF9fppt$j*E+%iR(@N+$v{EWRGYL%Ib8SJGTv?Rb($!F^5W
zwlrR>0<o3~TIN+Qrk&9wgN8cjI;<3WGc9or-K5^&&V~tSwIEhl=y<j!R{Ext(1R-5
z*w0|j{h$FpBDlY5j6qX%{bJ|ii3W^*pmYUpRhK^`$$HJ0#y&1X>%+-wV-wPcW@q|{
zF^<<g_>@#c=Z?-{D#=xV%FF$%v#mwO-5nzb8|e$Mv(dR-UXJM+4a74$E-G(Fv6!*m
z;4q8gzB6~uQdL!j1L)68+DK(qqm@P{+U^1wG9=pq7#&=X^?+5?1TrTl<W!l%#N}i7
zrZ=5j=&0rBd!AiMMiGL^TPZ0iB90d>(z1j8x3@U<E-ss=WX?X6Sv-+?$~X>dJ}lK-
zmENi%3t>@F*!beoSKm;WoHF_G(H$J-AOJe(YwzrA-$zW$YvYrvPQm2P2_8{Jydw6f
z*GE2{43IfrQbd_K;B$Tqcg>ZUAV1rB1|$}lIgu%}<;!>!-uaf0kg8x{yfyp6jyxE7
zk*XU@GCcgK-G+EdHWMUt&ZypXzgJJi^KBAEpfA}6%mC-yshsQ&q5>EZ%1HKvf&%ZB
z7TXY;g*@XpHvd_SGZ{b2Eexg)U^z@Ru`wRsPx{`{w&Ur2F1vY9`W9da7!O$u=5Z3~
zuo7gWn+KD^gDy;klkeW^rWEM<hG2;hs9lZT(TTKj3G6eQj%C_ZI%W|OC?t|3$Q2|o
zf70d==Lr<d+#GF7d6negedy-A6tk0U;FlNV$;yixG|+Y4fCy4U?$Y^!L{*qJ%LMLt
zWUs&!-auxRqJ%c0lT<ZP_12jE90nkR8X_1KgluXWPcuKcns__FWR|{l|EZ`$5c{l^
z>uf436L*(~h#OTkj)RBxTmQDzD@(_hL~k{NLB>JZkZw7Hq=bv}i`ZnN?&Ui=u_q0I
zj@7!!bgW%N{+5W!&(*OwQknv8a`7-4w|9Xci}6BCq}*|R)TVa{qPHE0_O4e@!T}lI
z{41iyRmDlMJvWeHaY=`h(G0#PNZ>mMO!-_R-5&09OA6hbU(&vX>(#?fJ)~CI(@OY^
z_&GHM@$uc6IY_?%W7+{@4=Z|R`by3Hs+bek*BQ|g`mH%P!tc1x--rr0uN7zgX1Mw1
zvPRSYxu-YC0sY1SFD1N#>ch{^fA;Iw?}RJ_6cn7%s<N_Z?_(r!I%8BA<reUA(%29~
za2Tm4QDmfS?Uyj318myWF`mzLNVo)c?N7liX)z0ymfAMm_sDJM<;8H&@T<@)?e8=y
zqCixDJQ8VP;cn21Z;S54{k*r={-R)a-%&`&&Wz*(-ugQ>a5zAlpA18FE0zla)g39c
zMujI}ng(xg)|?#mow+W$(JR$0u}O%w9@W%17JmAp3-RDcgRRkIrUNKpf$T17Ks2MJ
zMTUa`WaPT(&F9&~LB-r%=0MAAW8&c<Shzsz+Y|>)Ucjc1@ViDdlHQ5x#}ui+aM&(N
z1In@)ZDv!QJSChE@}V5xMHHagM`9>eEZuwu*Uh!-&%5huS5{AF7Bim@&C2N5Q$=w}
zYu2fKH@uN@%JCGi+YRpL@*d>{-afxUl_MjO6pty^prgFk8bXZoYkO!`v;9Mi_Djvi
z+Sqa?r^au3^EP(e-h9M5zcTftB8~K&A#+g>y)?vz-6}g{A{|Y+{Vqs&9188nevKIq
zl|p-9!QwRhptHr9HOV;nnI;$d6^11Qqkx<#U|+UY-<X<Y72)`WsGq8U{(InfL%SKr
z%i<?Lc~UGMDHQ|?*ky>78$>6uJS>BTJDy-tyRw8{f(FZd`~}!?^+-O>J#N(j*?TuC
zVx8OQcv@<Ewc3Sn^R!zE{lQ5O8z4YK@iM?u2~qK>!v8}$o{7Qs2Uz``RJZ)Hq)OaK
z!qKwqF`hV=85eYfptjS>&vQ5-z>}6)1GNL<XGtI4jEsfaR-(f#4}XSo6fdQrt7fIv
z`rso^@coU;u*(x&zjzzGP|ll%#J&5Ao2rdQ=HV4Fipt0oIvu(mMfc-l&r^yl(8qE0
zo{f3@Br(<~x=J=TcI@qz)WXVhu0)QLO$7Gkr|0f2uFXAd^!wI!NaE#|+q5k&99TBZ
zo5~p(D19<qQ@x-XKi^Jq+9n|<W$~GxS#|3N_+1ae)&dq>l52HQ$-vQXo=?Nz6w&J?
zSS05Zzi(}Hxqh9?W#g2Z)nY^Bj)UGGQE0j=BE7|T@NzQPW3e$R5Ir{@>yJf64h6)}
z8V~*>hPG@A6Brl>Hf;BO1TwH#%-*z@r&#<BqiK|BL4F@H9a!nh9PRgpIg9Wyoo{<8
zR-AyD?TpzCLDsB6-SZfv5p7W`k`_M1R0S%{g!Geo8O~>>3_joe#8|>vdrf`!<r<mg
z9bFNsgy7xBLh|&ECc1I0Zy%z@%VZJ<N8l+Esg+T{C~LmWiWmw;+KP&h@~LNnH<iU@
z*0SDHG%?ox52vSHWn;hMGmaNb7O}4?Dn_e!kZhti(Qv@T@7yI%<RZa^(P<p`vNFEj
zyJ;$-I<jDOSkv1R{wJD6mG{5n%=SYhgWLxV)c3@1FSvFUKgI$vr%^}=I-sg5=9j7V
z_S+-@ygYE8Vf(dcYl)iBl&2wO|IMl{&Ggjgs_A>W{u-z9QhD~5Q*F_vrifepcEmiy
zqn~CHu*7#d-WSUP!ru=Q@u+g}<wuLMmth;&D)9hVX}&<?wOG>nY6p^Mb|TUr#}S)F
zTE(n{LNzu6>zj)`)^hO2Oo8GWf^6M;f)TS1-3I6og0@T{4I@K^#hp~350Y;f#lX@g
zKlx2+0RV;Aq^PW$YH>Nw&-ZYHW=*}FV@PE%G$^_ZArXM&$c3}KFm<RZ>_#2RZ7?y|
zzZyqsa#$;6mFL39FdQP3V}bS{m{A76t(c31t@U4aIY`Gr{HU0dsa4<Vg8CvA+=rK*
zuMtEz13U)KJ06SJtT?r-e4^3xdXaWpe3QhAh}R%Le}7^$&&3T=<Y?Qqtc?cFQ>I5R
zWxIH<4QfJ$^AKUTV4n3KGlAK~qkc<Zf3JDodh&zuY7d#na1T*8ja53w0%|F@;loSI
z4^jNw6-fk37s|s6`nSkGUn82bVu$F<Qm9_zD(K_*(upY;3LU(dyMi{olbrH-G5_!i
z!pD^0yBXEy(TvfQe>w%grUQi?9oYe~VSp_k{!HX$VPZ=S0vH+5RM-vwI~J)=?S+hE
zNnD(eLFckelB`VmmfKo6JdUO`AhuDa|9TTXOT=wAi-4Vk>-Xdm#*Wz5whGt~oxU=d
zeB=9CkE^Oct-C*n?JHr@Q|?lf*$C&)x(~f(iA`b*XnWkENX>3J>mc!h+I#nB??B~P
zjaPtVW5tc`@au|}^C1mr@y%g6VP%Bi)d=hukv>Sev%g;~a<Jd)#FAO-lW-LIeVH#f
z8BOd|yF^W{JZ@TubfzofLi7@WcC?uLp@0p!(r^nzTu@6@g9B#ZJmA+Dl|1(sJVa0}
zq*`lvEpa!&^0hfr1Bq}P6#}$MFE;l%r3=i0cBUDnGR6=E27+CpggmiVAr0k1KO{z^
zMj<$Z;viR|QV&RBavmkWW2!b(`xF{z(rCdeoaHye&^N5BZND^5f4Vp;u20zL*P~o^
zRMuMUc-strfY<rnlK5KNQdU}!(YG&GOOnK!auE@PHVzb)Rq(Ez3^@GA_}gq^bY~o$
z41^B8#W8thL@5+_*WOMvyyOq74|^}LL#0rYK4vrrema;?5enGMbRNH1aCA8(6BPrZ
z>Y_T*sqRnfKP4qfc6oy2^r3yKAurT6gN<b`xn5|K@(|13_XutklKa5P?x(l;j&DXx
zmPceUAkr4pfq%#I|K8}V_#vAY(ST+wf7pl{JLIx^UyLS-i?dBQm?+L+tB)=5j(=nM
zZ48k=|6Qi#i5q%=S`jlcZ4fi*_)LJ~mSM5c>wpvbq+DMgGBYl44!c~eT*iHGFZKHN
zcE{!6?9A$~6rxA`iSHXRy$u^NbNS9pv!z8VhOM62j&JKDVp`$$?!^q}t2W4Ml#OpA
zlw5S3Jra_VAnC^AcLQCjYcAc}n%XLy-5dHG;ZyR%yI#rd*B~5jHCP~S4yQ4sCW+bD
zV1eU>k-9@&La3xhEwz{92Nm7|uK%jRVgm@6LJ)GJK-BT(1#08O>*ezDS#j4F3KDW5
zCFMOf0Q!82a>YzuOn4GLPBn96OTe@ofu=IFrdXg9T;%<O*W+dU_bqeyvW}HQ6?D@?
z*7I=s40M+h>0-)Z52=WdF#}Qux_8dalhjfxXZ5PMZ4?B)r`V2!D=q~+Hd~gQKBsfl
z8G5tepRaf?AKtw!XY7`*wF#Jg?HrP1vINP*0uG1BY5Uw&Cq`6QJVDjOrwsQoz-bb<
zzzM%nhUg5z3TiJ;oWOB&42o4H6ek@m4Qg)e2|4ZCVufn~UtjDUy=KP(t#HNc^Zr=s
zPG}LBZtC5ML6wQKihl*?@&ONwGaEVV{&Hb$t6ZV9gzT0I)0f}$Otlt6wzo5blQyd!
zgJGI+$(2g1L#cz4p^(m{@ypBj<c|&|w?WDrjjc6|uejz#og0<rNFGV!O5_YD!K+=7
z)mWV?@pAg-ele?|We^e{Dtu9IueSCmbnrzF1?pe8G@^b?`@CV2HzF97LBcKEe2Kom
ziXrcwozVW;7x#VVzOl2->)V(L%E61<yQv<b8nclPpqZXiFN@>2f0I0QWXS-WuiI|Z
zMA^US2Feb^p1!{7m^rPq(B@|T+lL3S{#cUE5rvvhK%E4o`pS>p+-!9tM?*0HrDv52
z5s5Jl8&*?eM&)oYjd`}6D7JAh!^!J<M0vF4mrj<fbaj~VrMdaG_7;f1{ZgMvi`#_2
z;r{q>dylbS-kHppZvEW^7c?9^{ISBXzL?%3o~bD=CG&#=9%jYM;4c-9J{~WRP8iwl
zo4&d3bIeaftfCSr2#Dv{)lIH3P~Pg)wbpa*<#+=?;-sF%m5h7#&dvbJ&For(cdvMP
z_CiA==0(M4*5mS^llv7B<mKMLKF3N0DEjNGS-a*7&YUzzM8zah5D`lb-iR*Fd!aDs
zTKObltLUayxm>H_X)+jOW`U~oWwLiYi%l48S1i-lX&TwV7`ZD2=t<g=Tc7|!WSF_J
zs9BRo%I3kY2!B_fkhaWsKAjUQQh2`8)?Xcl0+m7-awhQzt6`9M#&IQ{xLZT==9z{<
zYIB37l!KL*tLB2_i_gLF=8P&ldF3hgn~R?m#xFKB7r3<VRwayO$9VigCLe81;9g(#
zFc0v0`8Rj6&bGhzby*_>=w)r$Kzt_(`_q;c<<w6w1V7QBuG2<iEf(9~bk4LxiVM7p
za!T5@E^959g$TY{d9OitF|~>6s+J0Ryc|$HG_n7n&d7Olm2d6d(l>!5UqoPNiM!=e
z6@|#4d?wz>2?cA32*;q2lroUwIQ;>}MGWT^7uh)@=K+TXhJDE){nXxUpE4Z_Jx*lu
z2gED$Jk^i6ZOnH4S8Dx=mn$_bRrjJ{Tm5m!C_rf94`$BZ9GmqK^>$Q{2YI9o?Uvgb
zc{Nwz4x4I0lcnoQj<#-C_bdGOZ*CATyAuGPiGnL{n&q$$vt9V=8M5FcX!7sP^*5C!
z3G}c)KXciiqy}WN$l?-~+<a^?8nn|Vn9)}<JK`M)FspukZ(A-$#XYD<`n!s5CVFAo
zfX>F9<-Fjb$jWwu{5kf3sHnsr8B3v~@Jz_BuoMf5%!#a+b^Rwa5zDRU#5|jPKf%q)
z$+EXhlpV<t0Gld4P<N6%;BYWmH%T3(Z$<+bMPpWN??}(`hnRNshcuVN>&|!z{p1C`
zci03A2xnZzT|UcCy+0Da$-h76C@8e#o(hqCp=O-;Iq*rKu@Jqm7fs)!^wRm&b3g}h
zdgF}@M1ghQG5+nrlD1Ot!zn3r@$F0<>Na~DCAkM<QWN`8Z*@^!4lG~@Za;E?cI9YJ
zl0Srlz2GcSae)(UkL}&3pI$K5!6<3?aaJ?x=HO<uLVKukyY1Jk*61{FCsy4(P4{1O
zaZz15E`{37*f@y<_31>T&>(FeF7WZzX)M@l`W%4Bt|TnFMJFVWd26>0q7UWIaS+uV
zGP1ILLe)=nvmaX=`5F7RWPYC!B}lREIjB{n!cq~L)ak^GJrmeVa9M^qPuPE`9_DkU
z=?<_0_GS0x2b=CfQ$@<0_E)!GOPaalGgZ<OU*-B`q58^eQ+K;)3NA6ieGjm;$xYb}
zN#^3Jk7KG;0UyCW#HXtKd4+Cnx;)=;M}2B8E+&YsmT8RVqFsiM{!g(AAoIBTeNgYE
z26>)#uahlc$~xAheqADfT5=8BT$Y#StH!P%Sz@{!C_QRIn~pnxF%}4Q#O3|kX-h&(
zQDEX1zVZzJnq)<#mq6Kt3liuwVs`SK$_8jxiG(as*W7e+EdSkV1_>yzZ!}k-|J{j@
zllw1EKTQesaD5yENL0?QE0&L{O_ff$?N*6_b{{||pYakM{(x35r7n)K;V_`MUZAem
zIG5pai)1IH4vjDmX%zlTuKLKD;qtV^5IVqZPJT6Kq@tx=Gr}$0_X@(j!twNMLZa@w
z9~vCQKFCO?V`SXb;1?Bp@<<#W){~ZDYolPfVrgXgG$|FE`8kh<Oeu3*t6POTo#zz4
z!I7GPMuCu0i%4Zw<XnEKUSS>J{epqwn_bxgq2;EjHDiidlrE7pjzDCsIni4<rLZu4
zBzJGmY&ki?@p-Ue(Fa~fn+<3DBI29TkE>686?7PDEUso4ipw8Q3PIGo9_np5g@X1|
zLYJ!1Nu2xP8CQex4$m0DvqYUW%h26Blxuid?t1&X(7iZxnE*3s+J4AI8JvX8zvFsO
zSwidPz;T^W8ru`(cUbzBW6fYA7K-6Dsa8=<cCNgS*~{4TH-GJ<@Q~TKmR^0My#wem
zo`$U_j8_5>*S?Ru--&Zevy;AWWlfA<bZUYfUZhOFqpGGki!+caocLh@ij^P|yEq6R
zJehQ~tgqDR4IY<pI0ZdoDjG=GMju%>LUz-|9YS-#zU+oiA6uHrRc-Q_6DL#j$Sk9E
z1#~v=CwORUNAu7W4f3u?T;3MCU>KcV0;?{gc8)%s?n59r@9?O%f}*f6d|grOmqCqs
zTGY2wp20S&`+JoaA*zjFM=rX56SOD*j#gdEkLShc%z6S+u@a~wl4eAzkqdH{vsku<
z;XDxt)Xn2<KJjAy+5sY2X$9~5Y;`j55?2@sLjUN$5yj(QeA_5`2%i%mxdJaX_`~OD
zH$u`yKV)B7UDBv47?IU}9b)vu(R|nj(1M8FY4o8yb_B?4LfSJS1tO`~8zn{AX1n20
zWuR<M3QFPMyK%z<0yrdMG>dDu+Q-M|v@NlKqiG8<^Q{vssr$MD&98G4Jenr4p%i2P
z6V&mTAiikQ6=c_=@CirAT;E7Co+3j}%WqA0wo0@#ks0*|3NBYL&`{!QTL+F}`#%ze
zpe%!03&d+mEQ({^r{ow8h_|1pVi|ZH6NxaA<G<&)07PSuhIFwFH><Jo)3}3eEOS#>
z<lyl2t2wfeTrqP3k~KXa#SCuMs_B3V4xkt%zu6C3m7fbhcA=CfEcrYjVIWFk)(H&s
zhGZ(<Lk5A;Q9XQI7+VE-PZV}vo+K?Pq?LC0?ybaO?{`i2A6t@mjS+AZ9v^ltMGe%k
zOZweJE#_o5V49xSXK7Qlko7f;q~Eqdw-8CNeG4YL<pgzKKI*vsl-gH%Q)<G=YE9^;
zWQ*=%^M=XbeG)E_ZC;sj7wLRFqlwY;Cp&{(4c25A5Ou65iuXn%oEsrZ!@>c<qMkK0
zE`f{hv-Pc)4t)1k&80xy1vKx|Q2+8IoKEFgga!N_v*@u|_rekxpS(Uqa~cu6i?G2+
zXv8e*rrR?Tt@fH}NaMi)K-pKA?hEUeux9BGjc_#rL06*z>cG~hj4##MsfBY=V^!*d
z^*w+Ghl=qOf_X0Yvc#1TJi{vB_|9?<^G*kquA31?C&o*mVRw9TBv)cg#COm%>uJtz
zN~+Rd)*PDS<Loa0TF!~5x>(X^i(>jK|08Gf9~J_fXHx-9(ATQlY<Y-JS<3tA`PB;w
z%;140Z#+?c)b+|eDTCcEBtR)|!Dr8y#POY&O~{X?VFysZgf(PYgLejsI%pZOCdV|7
z5!2qt-&Irs$`7(T;&YiEc+yuUE?p4=19(7^Ev>bk9eTcGOfXP*R3@AMpSnb?$d0SS
zyb_mMU-1A0Erx)e9!{FzC;e=LAh;{z!6YE7SB%4$iioGaNZ~=gA`G*ZH9!M`nE1$}
zt)`~Wtxoxzn|5=v0+FLwb4*RT6uaSv!3rSvLA(8`*fHW;XirI3oZUI{d=MRA`{4ug
z+2`r!Y_Ih0=@P0`dr1>*h`C<@@b^`xV=vM(D5Q3UN^WlW9Zt!Bf&|gY<3cDX4^<|U
zvQC9eWqPX7sUWl5b%g@|5&!)1Qp4P`(Avrese%~hhNkuI_L}r6Exao^f*z@MS51xJ
zt)?QfSnf`kE~*8hD1kE0#$JVXP|uSen;e4Wc=1iQp1A)e;u;>I$OjLHTmw18L0`5C
z@2|T0W{fcznX((f-$r~*p7t5Wn!FPP&Ky*kCBKQ`)DQ<q(XV%tqc+6_4lQZQYJ0|6
ze51PC!+Y+M<*s+dnBOo6_jJd@&zDA>P(Z3ET09UJZf*;7hh7mTegf4`%OCDxF283`
z%F4yVXt;%g%v773EcjISO<C>G#D+9<kjdexxc?F%(tkE?M8$k)A5_U0ggWLDa<RE|
z^OjQS3!eCy&Xv`?s^C;Yi~KyBd6LLPVryxbUi%kHE}y4{(0Y7DrkCm~0e@=w{|Ewd
zNp>`#juU1?UZHOv9Wx-17ZBtdPBVDTb?*zc?<mEI$D|{D>ZW0Ha@)taOr%SXU)(M-
z*qLaG$uD5!)A$5|L_NOUz|PBSA(ULq*iPc0sX0N+F)E_DdYnoWBl8#NbQ6Nal3jkX
z_U6ek_Vz~lEf_dk^%@G9LO~ekhK$7>j|s#Xp9v~0J*T}XyytRxuS>{E6K%0jt)ify
z@QPMYP+b}z<%Okn-#7p|12gp#pZPX@oX<Sgcsj=vrISUI>@aBVw`XqwY7^&X{S-?K
zawUNdI5R~`tt7*~^k#5zj5d9lr4@3GV-@?nJ}cVv1zSS9#Gje4VEsVz=_X`aO52z;
zY1dp%<}B(6CEytTj59VQ<5}~j;?ocyx-?FqT^ig!Vj%n!kZBnp4cdgw)l`Fl5)HDV
zVP_!?$#NnKo*x+sCT&SIjXZ#9@e530;uc(kzDN*vlQlr)grX|3b0KY#Wy5Ld)**Pa
zYkD^)K1BVjB7jm~GIvB8w4>$TJlnt5gM-WH@I==H?<_WDI~y115|mnKhX69Qr)ocp
zTBFZMd(}=qov62pkftv0e7u<47?_@ag@l4q_CaY@cSV3)K6SaykB1OP0k9wBLt4&y
zqr5MbWS`*(H((;0BNHW54Ad1}0JWFSX)cf#tX_!x^<T<K3`j~NiQmvIq_@h+*{loU
zX`rG%`vV^RXiX8t8&r?iq^oci`l6b2rab0vWaU!tl#Uf#^snfZG9d2dq9ZWvih=rH
zBF&q&qi>z}3;~FgWFBy7P<Mb2=so}Pb>vVfuQBjwR#``eaeQWV9c>OW5K^N$>TQ1~
zP`p1;%;7?;YmNmtb!m_Z6Q(nTs)~bHHd@nWv99LJR2DQm;aXK9KZnWo(E@|0U7V0_
zdwjh!P)g<nBlPTo9rVV~0!(Ern`3o|d3Ptl=Q;T??ShowS8tgZG({s?ADy>f!miQY
zhQ2<eRa|oQBW{USzPGOP*hA<Itx7^71?>cuzu^$bv8f5u`HljXj3)BTW;~GgvZ9xL
zE}h!`X%o|<22)?L;Wk8ihT^J#j`<VvFtJKAkHy{ikQr&Gz1z<@Myxly9@E&9>I&;-
zrpp>CFdKTBUfqkcoick(W#m%Q$cQu_toS}g#uqYta=8nRC+T4{0wZJTLzWx4hjLD-
zzusOsxx%C|AvcaVlp?Iys)<Ui!yEajxmY4#Z`v=*TfI&FTTS}a;gDJ(Ofh-ti+Civ
zTCmkFhQih9T8?(@0r)CmxeN(<H5ZYH#!MwtRcsEublz(DaPWW&uX5tBC>E6$-U>!T
zVos5D?mg~|;2ecms6}g7lS}i}i`+~$2G_q5U4KIpYN&g4i0{+KD+{-h9&dRVN=}ag
z^Sr*%D(SG@kkEot@5o~IUdVYpEPOe?F0DkSDY_WeaXp>)=XA6Hiqpec+u_rT!?T+;
zKV9m`qMU4~-#K<=`VaU<@A!2u#S_&PQ)wjr+8i|G$lts{n*M;`lW4nGOJAIm-VBsw
zY&%F&0<tXp0lt{iGH=0ung<e)LmKBdHZ;ha&%h%4nkeO4XUiT><kzjcikMTSM9k8Y
zx`TPZ8KLP2QnBIO8%2sFB~J6##~A@}alR@cqmpKWdd;rr*e`fPt+@>*d&*PXQ1M<-
zc&Iz|g9thnXV<QpX8Y0kLujS|A+M5#v$=b8`D=ejbj@}N2vM8nnGUgrM{|NOU%$QM
z(`!n4%_D(~YuENxM3I5YuJx*cy@Uq@M48aF5-^c>?$S|}#x%rc)UDq6+<%S>VOtUu
zoLfJ2E~##ff)93`^C{netHe=`Rtd8$Gwvv=DFjfvA*qBLf$Cec0^%iR^>2G@=i{Dq
zKU$gNHg?xA0#6#16p13i)|ftcZ_d1l^#oA4ewqqmPKahPLZ@)sGdlk;W-Klj!{Lac
zJcuuM9K*s`G1Qk(lv?J&Bwmhgel6xkzHiR?<?e8PUi46EE#*N)a#7)4IBlBf`}F-D
zNmV**N`tTc8{?<GAivV=i!y*mU+)N%b%4<!Sh#FI53EbY%g=^)_A;>=P{Jz@1|)SB
zR#Q6qEVLVC_RoV{SV&r390l}X)+5(ofO1;yYO=TPob=eue3Xlv{PaiY6^I=C#xrL$
zbfb-EirFqM^=C+kVO6Bv<UDssnNMB>na^89pe#zq+t*d!=3L1FJkUU--wUi}-+t0b
z_1GJyxV>JoqhMBiq_9<>0}>6^<Ak35fm(dRKtFFTg_vE@zif(2xFb}%%xWAA$!Rq$
z?Ovj<STe+BYsVr8NkB@9b{o75q&MeE#gVR`o{n)R^_~&}-307ko^Hf|^7p|t-7iu<
ze&qdd&xN867e>W?#Zw^!)U}N|JFGl~>Qm_eqgi~~Sh6!TB}yiA18gl*Q*&z{Kt_NL
zw^%RKHigNH1SrWCpIH?BTS&Lum<W_kS4wSg;dMUN5tzCh6jX>9%XukPE_XYvXLUJ1
zpg@<vCiA_mjn_<!0BR3ZpZnp3X0n-}c%OAnt?$wK?ix`$N3r|dOKW{Up>lsXrk(dh
z!&sD!07_rt05xctb*D7J=1MCWW)l+%#(mN71vHQ0C)~eaovzb9Ya;CIq|+*$Kiza8
zqX)*s>^_BE3g?ahMV<~a5;UG$JW7LGnDuq4ug3zmQ}QjRly5JF()^{=0t;uQ=H>|=
z+7oL?S^_&KG}}|fD=a#tyH<r@@zER3h4!ML!DCrapix&JOZw&Z|3leZ09CoJ{r`d>
zDIEgR-6-81(jna?9n#&M(jC$b(p^d;2uOEGcQ^mrcb~n_+3$XTXXZcSFlz||Ypv(G
zuf9ItYu%8{^UotG<b9T)zG(Q4_+*8PnuhR%`qzTUVwSiaxxHvI)&4SL7Pec9$=nvo
z!-n{RsGoc%nv*QU!fkhUAk61^+94v36(~o{Ol$TN?}+dE+kAH>n+18{BV1Ir+f0s`
z@`)cWvp=a&xV4`kAgbFz&hcNsHBL^`Gnmip5yKu7pjKyV#{Z0KiC;W+`LO?nxN=~n
zP++L;#a)@r-F3_FBsBmm8&i6Ds8U(aoIz|~?;9M$mUwu#z_0}|Fg|8ostM7Gb_?z0
zzUrb=kkaCBTwMZ_eckt$UM#-q>XT~w1BTr&tY;OBPtPtHdIKG1K3d08-M`#>f@L8%
zP9C{xXNu9tq+(=1nd%BxpD^RIdr`%x42jc<<=)Yv(qB3z@=}MN?|@~Q@tB!sZ)O*l
zR~h#|N7O_*o8ex0Lv=Q9>E_l5uZlb*;@9;$lw&{p9?UZ$iZX5B<ZB}Ts?z>oh5)vy
zkdOtR18d~r!T<O?tp+=_uI#y}dTOC_Emr~JpAJ`KrGm&uD9HV&ZF;3?<;9T?#2jAa
z|6r~h4vr9<hFR6XipmWFcl*cn7tBw(pUG?Gk<7~zQ{wIOTn<Qxti*Cz{X@}Vn0>!K
z$iIINpOV5UFE2k#hwkE&m6h}inqHDlv%nQzi^?c8n(r2;*)cqp{pw^6m*0zs=ib)4
ze~4BuZH+xy;OmQp1uX}7)}IgRBpCqAR4Cg6p+WbldwZ-+@A~-gzV+bXptDDmrILQK
zbYT5(u@8ctS40GA=xYvn$i*K2+8G@+^}4lqYun<CNwgV1eLgEP0s>TRh0k87L10A0
z>q}0jxXOm$;8Gp}v8w$Q!H37b?~7afPp=KuYDP|9zd%0hhO#&yrl(IU4@Y-#X-xKL
zSEMu<?X@U(egFOy5Ki-ZpFj9}1ft@d5&i?_?$xxV#9b}k^MR+<%2M;lU-%m5bmyMl
zZ9JL0HOW6br{p~RtC)D<cB`IZoT3=O9JZ=UwVHKy7{&*(llpq35j!}(H@cq^i3;P8
ztbCm0Lbfu}Tm%^^Lt!=ENpQExp>TlFI0!J``OyNS@ts?o`k+V>HdQ(kxx}Hw9_zug
ziy1LCYced8!V~+Bfp*QtNgG(xKw%tPbe{EYed9!w%C7-p+qaNgfs6|Rj3Wk~1-ifX
z)(BpAEhL8FZN7t<9y*kd&sfDZ(&dEKd8v77S$pa0_d<(VixiI=#`fan*q*uYY|`5(
zypsX(1_6N<FFPlqnh(B}yDy~5<Q%sQiZVDW2_5qNrZdOkhno01p4II^r^_uQ65<>^
zp59?E=W6TT5;zUx7@Ib?B2IIIVe-Sx=ghV|4z#|E9-}$R2-KD-j*J)ul#&A)-mSGC
zsj0McS@75*LuCm9?=3#+9c>N}pqw$^oOQ=CS*+cD0l<c<52+SBTN@gU3L2&Z6FKew
z(FhTMI%I+@SX^xWDm$n+QC`cj`uuaoi?<z-OZ$C+$c;D9UkLAUy<5J&;4NWowNct6
zWo>-Za$}p(bgain(P?XYv2t-bUSU4j@IDAg5C;U9TDwtD7WPjelaOi(0CM`ZQYjFC
zv)vpv<M6tNYWZ01DkPAK&3A)~gENpBW!@`I2-6J^4J)0#{-5IG$&}yRgs@kim}$J`
zrz?B2v9;AT5LdYJ4Q}%=Pt6clO*a@|%PmK|>`oGBPllfyL%{(2=QAWgF&N3<e$z32
zq1Iw>D73!NbhiKEM6~^e%)tQx?seby^3xZ#Dk@klJ0)!p1&0J#vb`_AuvuxGIfh2d
z>9K3doiwd(CReQN><oC2+zp9tBfOsOlkY6d`1%!ZNV&SYdiLHE^<Mu^7Qpz%pL>NX
zBSbz=?8o`ED^HPtvLj?}UQ%H&ND8SU{Hy~nM-Lpjvj<t;CS<;AI5f2LjwDdwOp#yH
z{y?t}f9Him#oka?2f@hrF;|wM^<@kgs`!ZTe2_Dz=cR*G4&v5G&yWgS{0%E+*4tl7
z$-H-{+Y^NuJY*GdX=%*f11Xacdb(8c^5Nuphqk<h(l-I&G<iIReVPYn6LPB6%djzi
zX&ANDsAxG4?IP^2k&vABuL3@*!i@5@JX`W~jujlDpdy>C-9bToT|_@K?YNYvL-@KT
zhXdPAwi0HvUlOpzti%NeH<4{hFGLp3mmW8nwt3DpFIyH=#r(TruCi@8wG$*{@6}zE
zu;%kKXUJI?83%*?e!AFR*br^eF7o!LU`6fUZNUA`%Dv}waN*fwIANd>ipxsG9W;G~
z;Of+bb_-h@QJlVeq9pIW8+_~b%~8-=(rHkvF*CTsOCg2)+tsK$+6%8{B^2@Od{ph#
z?qw+=gCAu2q`IoS!`xMR@HOw>VB=mIY~@mBlShQ_bp%pe@fQ~cC0p%Wpo*9345m-Z
zfo{)p_@q3a3gVH+lcxBeTm<(X@Cyxkg!4s}_qxGT(y7rdQ+jyCabR9=&5v5sT|q4b
z(0VUpfh#v_-~#17!B0OQty>7~Hm_V!7EZiYZ-rN5o!6(vsfWb1_%+=rZ4rK0QHxcW
zeh$g6B#g$of;ZsG7tP<zL|d|dA3Q#;=!lj7_w$AVS@4kBC@kBnI3Y47{7^I^&-hyA
zYRdP8G>5`B4+AV6Iej^4t>=|LC_W{{KBF!~dbT7YFxeVe&g(q6x_t=kYt{Vm^KWW{
zmgVY1QDE8TC48vQ{m;@e#s_xq?~XcDDE~vYSOmg1E2I3=oqdGf-!eDP63^a@1Ii=A
zYqdIa%=?R^Ub3AK)UWy*{W1GHJl{170n&uY?c7wydnmE|7y!-?Ja;5rTwJQ~s%nT>
zSmGCdpvXX7?oCIt3qt(f$(U7A3%>|^)f?sc>Nl$w87SHkc6~9-p_bF$dH^sLK-c_k
z%+4>oQ9mfb=`IN~Y6w!6!F}_-6D>~<4;Ob2T$lT6@$<_-q1Yr{uh2!7D~y@n`*j~H
zJkZwX>WrKwF0>iW<(+<(DARt}bPaop0O-NU+an^n$$Xw%4!e0xZ_?u8zDg^Hdv04u
z-Tcuo)5C@E^kbjU2(LS4ZW9g1LV5KHR#sNl;4=-tRc?)B_yZ{H^X8pw0jRRb&M5r8
zWDCC+`<Rd;BWq$IZWUXjl(rUVNsN@G;kDz_m0Q(EZG_!L3T=9)8(o%$^E#zb@xIdo
z`BLwER9*mp6Nz!!FEx#lr)FWnXCtWP4CmWp8rMs~{_CwjB)e)xM}p}!H}}$!y(-@a
z<&Y={l+iI`jgB&ot3&g5Y>qrYOqI<(x8LNke(&Ko#Zqs>58v@nFKpu7@z|W<S$NR1
zfIZ1>dh&eKduzmSzh$3sfh2Hb<Z-B0B+Ia`{dvuY$mu;<kyOHJ_4fOhu5Or^&Cnx?
zf$U4yiR%12Fs40#aD^xT!yn>Cx6u~!@#twv@O`}4&j{n`3gZ<)6Q--%?biXu1=eYl
z2$Yt9IIcNA_Q};Kp?&wmKu58gcPaPxDE{YoCJw<xUuuZUjyUw0rM0o?-;niL`qOf&
zl!R|M%<Z)K*{<zA*4d?CH1*P9h%B%xND2*};M=_>WgqOZXwS)$r($Q--(EP`xkcyy
z9vHw|+GGLe2?=Rd2KE!w7Ws+vuZ|QGZCe{pxF22D(U+#O=byi3x89Sp-E0`0@r;K2
zjO+->J|fJ842`_mEoc@hpp8r~rsq9VNlYyErse5$bU1TZyB|_u=v6c1QaI=3*ECzl
z<<vpe+aosNrWn=`^;<5ZUVM|I&nF8qFdBoM^67C%+ff_$b3H4VL05h(pSN#WWrQ%9
zuWpN)w+2qvJhW$(2budW{HM6$54C9qC7)?Kyn=6(RV&;|>lmC&ed!&fomQGGI`y7Y
zP8F&=+R~*Sq4w1UPmR_Xc6#f*gU*#CHgWT9%&7w$rGcR#m=P#dOyJ&CQ^>h{;>i4#
zID7T6OIeM7@hT^85078dZS+Qo?+DL02>RKiC*$tkbj~z#%hmR>`1&CgzcnF7VP?{3
z9ajv1k-%Sx=kraKsgsKSoz`R<j9P?_I`-|n59+WgPDz#>EKI>sFNCnOa=70KO}O{@
ziW4bm)ZjU*pKPW43SsJRbApz=Zw^5q%^`Hhw0;}s)2BlB>^`Q5HhVi~z$cjK<d`jF
zzUjs5Wa?H~xe;H#2%}3wp69!4QGV%p91=X$_!YWb#ia-}8y5%j;wZA&P1Xw$S7#Gm
zc9NVcmj~Q>1F_`CBiu(!%x$ZKBpD|_=dmU&n12_{t6+#pCwF=%yp@6}2xx8PaoJ2U
zsiS+Rr-=dg3SG8n6c3uTT%+zoP9#e1S3+L5csMD(HyWdAf#3`ecEhy}a5?RBWXSx8
zxC3%JIgaaEs>ZDf?M4IaRTfFtWbtkp@;+}}Pvf}QhksK<tOGh|9r#T~xIN-z`tzWE
zcQ6G6pV6PoS0RC;J^~0Oyq7;4@W9%y9j#PgV4%-b<XdKDh#uQb3@f!h_2o?UY+H=y
zr;CjW9cdx+%-r9Lz_u8VFUgO904SL*e3Vk%Wth1-i*CA90L(LXSoTR9po$l0z}nfF
zo#aCRfMU~mHoul$TRS_whXo@%QZp3nq~WqM?Xp-_e{;ER0pVIK|FgY0R(N^KkB|4t
zGk_9z_gL_T*E-uZ66>>aM1Q~7k7h>>bln!_B&y4Fat(;k(5C(h)QKl?7K<q#bu|QI
zAtqf4DEpOVz<*&T0t*l|0@#}Q?PRc<hv<v_fL|W*y#}H|ASNYcXshAlx?oM2oNX21
zUD*isH)3WJKC(u5959<n0idqAKhyU}-y}r&`Y%IdZ3nwl=TPB|c#hxHYh--dB*(|+
z-Gkt3J6tTnOjG5wM^-?*p+5Q4SB3*B)G;NCj(uGF&UGdd%ua{pDHdpikF_pd8axeA
zF__M=Edxv!dAxokjWb>OI!yM(s}YYVjZzV<7GH+7dv|Cq0u6J>pLvulwt10$f+iT|
z663SKh)Ej0HCn?K_Jh+tbGkr)CY&lXF+~tyM-5DwCZfHBGD_zzDs@XZ(@IW@8~1xH
z_}UNeLQ)lGuRugtUBBX;XPUjIG;URDg8BS~Ki(3^y(V&4t>#!R+t#a99v5R*S2lZ~
z4Rl_Tbj{93hboT~9nF!06-#wnX9M~zi;=xPu(A&o{c~Zt<=B;<>U(qD(cm>$6ctRE
zN+$c@f{f(NzS743o3#Lnx&LY&Ilq9|X~834{qX!SqG@`D?jcoFSmX)j203`hed-N=
zPH;9Ee=r<%ub*x>(gJU=%>>&@x0mU+`}-6y6f4W|YXjog#L92(!sz5-1$`=Z*{9LX
zg*GpP6OqAjPxxzvKat%G8N(n)$BFpmdQT&5ux6ky<O^}}?{S{jLGqg3op0Q(4tp}`
z&VHiFtn{`qoIHOt6-dHqaXy+#CDCw6<~V@^{DV)K$x2r{V3nq_;}N&@q&JOgUYWH9
z@CCYE4c!;C<Tb`V-C9mp;5(Dr-LkZNHeCHpVRPC3Jct)F_&F>rtO*ab4jO)g#dvUH
z!4t+h>fNgM(;cD5!-Z;fw7b^&&P3tIA#_Fjo$Ix5=6ovt92{qlw<-S`!dk$A`jJ1C
zar=HDLooS+dK}ab#je{67`nGcf`X{nB-yXJaG%4c1HjOz?i2_Auk^to+T@uHG;iv&
zQgm^4vg@}dOwL)RZBXSgD?@0+Z{En1&WFH8x{KaNekcL!M{l=oizpMDe<^)1GeBHM
zY;e4Uw4uo9zfV$!uZjf?Oi2lS74l={G)Rp?0fp!7)~wkGFdiwiD--Kra^y6r=~krl
z`E_&i6QjK&^|?~f*HkEYyF8yQBk;TDlkGk8IMvqF<}0#*KBT!mkN4xfHhpR*I>YzT
z_FO*7?@kX)T`CU{mHie`Pc7EUEWR0^hYTGBhT6s>ogH!h9`%)FfvTKCnS$P)HOi6=
z3z)%xKDlEPXzE_T#}*WEGOFO_612VJ`!p<qx?S+qwh<1yq0DbvT-Ud1iL}f222JEF
z0B0-u<iqyq`taOQGHZD6kNtM>><j-<yKt;zn*pLwiVCeJNLrOLBRR*6m9zt(-Vi{U
z>7s?AP-``>k_pde+@$|iOrRtBI?tlR%QK~EHaPGW#E6sB>B&5<u?xszKP<0-7EvQ@
zXhei0dhNyDT}|ZU4p`U8Lm?m-p=YClhE!BnjvjY4F)?9A@9ubW_6z2EB9}_!74ru~
zL?8sjkyNZy*bOvgO1Y#H_M&l>cY=h?Lp;WA{T)WG$w=TiKM^-`#dMQK^FShC(S3^b
zNi#*jW(e5InocHa-O6-NhTEsu-|0cH<JDqjWMt&bNJ|@n!j}3g+4}dnD^iDqfN=c$
z4n5MCr&dg#{&NlojN+p!;r;FKijp0|o`G^VoW-ih8GtkZN9Ye452x=ijWsU$B6(0m
z=_CbQqor`S<K$STVDosmmhhppgy#hD-6@Nx2K@2Jp%)(FIY*=q4xx|04rlQ)c|2!t
z9^ZeAb_qbyNp<#CFD|>baW}dN7*bd_w(c>8EVgT)$gIp}OGV}kvzX2tczuAJAXvMy
zVcH=>s4VQRGj#7P)VH@iLk{{`6I?gE@{6pudyJ4jD7Mwol=VZZtZpR5OO-&$ckkW}
zJ0Dpxq;`IwGMcG2Mz9|`sTk2oq}P1Ge_s_5PEiH<NOiqe=~(5kqxjj&)U@bRFO>DT
zxQIyqO;M-UQQOr_T;QG{*tOJ`l%%O)I(fkz#!e=mtzYpeDG8ael_~D#%Tli>I>3Cl
zb`o-gW6@&;om^gGjVDT6-`oshkyLrt`kXA-GaHRTZLY?J1S1n}-o!d04cjd9;UWuh
zfbJ8A8;e+f8mE$>HstqaWSqBZ43%2pSMM+x(LclfF)s9{fn;LzP0}Sm@V-Cc<GJ`L
zzo`@2Bq$$PRVAR-s&<xv9}a+NQp$Um6qSS;NPvg9Ss9=_VSQv|>Of)}4n@+}3j3UY
z5d!r}1`_n&%a^ns@C2f#RpD+Zy?%ODiWG^!l~T%sds#o~nh14?FxS=@jY@)p?&*k&
zzY^v>M%t!%A4=r*w(06;+Oigp8#`f{qQ8{`SCEJVuqfY$2dEHQFO~Ux%jJGgp1Sc=
z<4j<yJb6UuZFEGfiK?K0{(gaWVlbhAQ<8Qf=q2mCN=Lo1vHFLW;lZ~PK^jfW;@02W
zM4=#3AgkH0`A1j1M|ii88avw}hPLMS9NOJmJGQb<AJVt<$DX%LNpMsvG1(`TQx{QS
zHFz^aJK#&Gu(9RbA$d+pA)Ha~9wp>B!bh(lIUH2qEKnTlbB0r#Lpx1(V&TMN!Ce!^
zSegmx&NN>Trt*0<?>GA|N}9r4o)uz{laZ6ddF30{mJXO<z2~{k?kyJ=5Xjb2NrJ6(
zKU`?a*%sF2cfUH!zdKBm9LJsUe5a>JbmH+H6Y{zLd+owPlcMoK5e0=9(@>B%$PKqU
z$*dO$tJ{p_h@O9Eml7!@N*`sAJM8f0qSw6iZ}iI7OniyQ#=^<JJy=KbhsM*hf60PJ
zX81%$2OrxYnxyjFU^VYmq=lBh(`rkV0c?$Li4>s5_&%7axHzTO^{lJ6oo*NzDwPgG
z{7Asg97kkTNhg~jE^ryuhzu;z8LvK1g|vHVDbDan+|6BlvqVL?3Q0~lKV>u>9;%84
zi;SG)?cBq8&z%E`qp&Ul*<!z;K~N3NJ$7k;F*ybXEr<(I|5L@pG!=>{{l^?T7K57l
zd~A6edIH9Vd4dW>xz)ip2{Xa=B|G7isrpNy<tc+Nk!}8;&EM-N-eB8^BNH}@ZKBI+
zwYe$RGU=O=0A-{+7G0Oq4QgTKo_kPxRX6PlKCSl?MXJ{$hOU?WVlqlVt$x5uBYB`X
z+0)ZB$JYD4e`pBX>z#Vt3OOHNCJ712#^H=|2xlPrzLXLUfG>+)_C*z!i%B>#=(I|B
zC}Ymh^nj|eoK5RVvzFEM@v2{7q!2vPRPxiWExn$wtY2IqKF|I~@bk~F$w|+i+y}mX
zRc<|xjL*oBV{E^!YbV+8eFmHC`wW3hO{6QSUH((1#2vqvv@Yst>MIB=NeL|3*=owC
zC305Qy3lgS2`f`bTGa}S1%gV;Z8JTO|5P+XNB6N6LZE6H>TgLE$*}3jlC4x1`jwA+
z!K7-XZ!GGieH*eCG}UHPu%UEUlv68Giv2J!<!O_@*Udjzf$($_d__(m#a&xfUGSsJ
zuxEcbnR%{<LdJq{%EDPkO)YQGU?NZ%8jF;Q{{1n(fCV1VXX)?jE3E%sYMJy2Mc0@U
zySfD>-?n>pmL=z<@bj9Y07mgX$+))r@Sj^*SyFU5vyC6o59TR(OzKt!+*=L%WO2D1
zLO58ixV`T2Pg$<9Uz}}?CQba~LksTg@;8B=4lD=2pW_bt>!U3^b^?@kuSe1AyC=sp
zX{a{8XRskq<FW@iiTLg@xvD;bB-6Bm)aDP<4o=?<*ktso2;ftZe1T?lQCS*WMv7s<
zA4;8nechyZ28dJokK!jyj>}^&4GA$8jCtg+*($U5MIyQ3D(l%lWz^tl&zz&z;V^}1
zTs5c6K#MzebuFercHb$jebF{L+7+b#N<!@h_*G0_CmECHUS<eb3tCa{TwBu&jve`Z
zZvGNMUpcbt=fuy-+t`36LScC!psQzr0boYx741NySP}^d$%wR(=?fN}-SKKWr?8gR
zMR#a=dI`N^vY}VUQ@e%(YR-O()qFjR`z0Nq+7y_QlhV+HO;s+-m)F4=6G|o0p_ZvS
zsD^6f*{Spu=4&U!Hv0d0=lyXbCWrp!N07C@#y==lt(47iNAmV&tgbc}1U#M}C+pbM
zoU>I!e9STki+%z%<R~3i$ZJD$BfhP3;<35T&p6#~5eSFXl$`E42g7(p1E=*uvuF8;
z)HwcjkNXJJkb+M$lb&%{ve1y<TjaCwAy~S}%HD{(quTjKFo;d3a2<SwUM`~*$t8>V
z%lPNV4c>USP5C+!7%Y+a1Pq0HU-}KKnM4mRu~@l62}w>z0f}IF+YZ!kIfzK1;!pWf
z+*8{rDaJ;NKtq?sakq^XOCniPUV&j>(-09f4lxQHmpzpn3;HZfEC@Vr&rvJE(H(>D
zLFT_Vl~2#vH+sBp*zrfkqN#!E62UFkY|u#vhWh(k@NtF1z`~k1T%;W4hINC1Kw(N1
zXgY35Ej78q18a%@lpv;ydlrEH;<7HMEI#MyCbFU@J-?nkGS|oYc`?%-4QHdPlC>ny
zEUYe>R-0{vpWA{6evnLoQfUX8+qg~rSc^8t31*uoYXT;=qM%rq-s%@WKN1^oGdB<T
zh2EEjI+$${#$ys1>#4}_-~Ep29S?BF&an*&Fsoer7VUsykM9e_R|24h<|b}1O$=mB
zbFCMf$LvSH=Y!H_+eMx<GO{x@%`z`9ujn+<J_*zxI*@-Tum0Dssk9KVlqIt_5y{N)
zIPQr&a}Iebyuq=#!O^C~Im^QhMO3u@gF})c2x$9rq)J6Yeh4Fm2oP*YBOANRLHDG$
zVY$}<j=5|PL2>1ArO8g0aAdT2nqmBn32zxQu%K{0`eh4sT<4^kv4yUI?W5fg3V4L@
z?c>!aDhi53G&F#Zr40v3e<<?Vb4W<ju^i-Ib?R^NTw{a+a6Ik~oYychFhtmwI3!l4
z5`eU?=>D1rj)$kGS(l&l&a6q6(udNu1u<RDt&Zbvgma)pP_#?>Pd(5-ed1rn;ExC2
zL%|gl+h-%3(QWa_+}GxXh7f&~p>tOE%Gvgc0>=6Bodu~{)HaPyP_yAg^y{~QUXrKP
z(1M~&u28{a38dUqH{W!Gzthop1HVvmk<Rf^h~wN_E}>8w#BbDb-`{2?Cj-Fv1Bnh|
zwq`@c`SDlexQ2#?VNxchPx}W4#f^<>BT8Zb)=%A49pIndGg`B8nP=F?)Vx!Ww!Q5A
zlrZ!+r}^wp^{@Zqf$yfsGr-H-uP@JK#{5taN&;_OgGFCP<<XtHfioV;VELF*y*3iw
z<F)Ep{M|>v!R!uK;dR#`XWq(mekE0Um7_yUHQnPOVEk3aARjHeA9-??Gj_w=4ie#C
z(w?Pi-hT^?JHKAH-v;$$A^@Iqz4?9U?#Yf4ClvF5F67T#@x1svP)@o%Y&qHqrQGay
zW&Xe;0>%#Vfmh~4M*UA0_TL_xGC-B34hhM8k=2Bu9F&s!xf2GBy2W-cAUccl(|X&b
zy1s@|(}W%Vklk<X(kdr!y#*TkHSQRcv%Cwv@_ye`@eM3xS$Vm!6TnC+H<Rnfh=_<Z
zYGsio?w1%2##5jFRFVTM>f)<dMWY<Q<EPN;YZqmwp+sB+3`Jjme}74$t{VW^F8D23
zmM@i*XKrL@D9qS)&d(VM`*-v4ccc5CF#roCB#P`$y@v9G*F_wRQa0h$IgnguTMb6W
zR>Io7{6g#zo}W$?(WzEf_}%uBur@+(Kqu90i2hAYk;J;BpC|_Vl1uKAarJyCux38#
z8IzW{xjms^zc@aT@hJx2k2rzM?wQ|w;#`|zo7+VmNQuLy0ex{N!+9xj(aco1x~?uC
zbm2;?b8~Z*&18=~8Y?hnSO-&>O?o!E0}16_U7OyE5EB!#*lkGs|9M~7kagU@tQY_p
zeO3rXbY_Oz?3a1$jVe0zVJDW|`7tq!s$7><A3VMkx}p^=9`_sba*mnALAr|yD{}qK
z;l6DEJg2OW==`my;V`Z3JYJaPB?$zqA_;^WtQSKTL#ujTVEH*5EoA_$RpnCG8cbN@
z<IBqeXoRJFFu>LCp%y<@sjGXtnMO_{C}L(-Oc(O$cEuGC=iW)8O{=$F8**l3WXOPs
zGhyPjz7#fSP?qqJ3H(>v_wVm^j>FBU-9pMVwV#d~*x61yh7v`tV$KEn-657r!&gvr
zi!BJ7Ofh_}UK1(~^Js{LLRZ1P!nFGwC<YS3g6h0ZEHbf(R}4D)LBjJnBKrEooLpRN
z8o0S)I~u01cwCsQW~x5-+UvBry?jZ?r}Zm`l!GIg!1EmS#9-Bb+%16RnZ0KHK8(RM
zr6M4T<l`_C#Kx{Y0M*69oE#Emf@m;nC~pw+0tU;wYA9+eGp)4bfBUol_YJA`7D6q(
zsOwNCoL4-v3m-Zhjb6E20~Tha%QINv8Xs9n)HP+L+K{^EP)EGNtGsxAgL7khC%0r2
z4m(TWO(n-xs%%RB2d#FGlqEL{zJ!E?9XbU~magFYqxKd7<!DjJNNOOzDsRFCgo%F)
zFte=#Bz6u6^Y+Rs<X9B6w4~2A+uqGL*r?XI-uy}up?#(J!NUXcVCIXGWXa)vweSEd
z6;;S#qhWdp659W=(Erb;dIKPX0PpDoxfX`Gs(i41oahOZW)|%3NA!!76Rto+T;bW!
zHx3Rrck!s6VQ5GX!s1?P0{MYAKldJ=6k0x`_k;b#*WX8aGBhrlMI%hKxRm{IewLd9
zX}c1CKR-xi4Q>TBHOD3=&jSZ=UYxK%Q#mTr^O93iR+hr^mq$p4^O26*{+E>aq@=<L
z9d2RGfS9bTO6@@NX6r*D{*K$aBQOo6hDZ`vTgzfVi&XcL4ojc-8=#_5v9qg^o627f
zByz}RaM8bQwq5nB4goDfnr5Duw<%lQfe86|BfJa@QI`kvg@ajujZYK#zhamFcCCG}
z@VNq5D@L!si?o3B$6!=E>UH@9EQI!*Qm`gv+={BuVIc>5_!_chLA(-7;8*L&A*f<M
z-6X!Bm%Z}?BeMx%XLjGfte{G~+a-T<)edE`Monu?pg*uE2-Z}VR5ZIJJ-xjp3$iTG
zRELL$Yb-T2H7{ka{^c0Hr1v0RE!bCfH4j31d-KC1N24s5s)3uJwUer3;6$MU<|8ow
zLqzggWlj%<IHlb*0@>z}=oHc@v{lCrpir!=YTY^h<A?l52dt#tzCQL9X(pEcW_ekx
zA!Cib+UHpgi`m*|$+H&Zrq^=%X=@SG)#v4P%>7Kw*4zRs9HGrFi%pOe+<tyMHOH2<
zezX#CCgAjQ42wvvQB3&YE+;Kb)}CrtB*{cvJ~TF_5H=-o{V6t9(u4RvE&G3eoE!|I
ziMkby_zb~!eNK}_#;#^?+PvQHTg`u>B&6~967afxYHMq2MRNM;`~L_?{*T-J2M4SG
z#~8;YL`@YF<bJy$Xg>X{&S!^y@uEb<`PU$(GA`VI^QV7{6?}t0)GqS%OJ6^hbmzoG
z99U}op-z0)ce9z6&vn!Px1aqZ*zoNY>+Gr|opo=(EL3)2O$`ei8u#<}HmSZcCuJyI
z8HA(x{;s~3+<^C=uUrhp$F>_*q6iYQfJk0PM;1_A3&B}XatP-8x7Gd2ICok?m099b
zpLgl@501QhP3k(-f<>KvjB`%a<lH2qWvG8@)?91kH=CSe_>Z^i+bacvpWYVsWOa0k
zPnnqv@ML9WWmL?}acgU9+gn+xiVC21q=Q-T_X5f9m;6Hu_IiOu6H6u@drNWCn_s!*
zT#rx=ccL&{t1`PWAo0OoLe~CUGS}dX2kt<5qZSoA6^B#h+q-RO&hIf08Nx;GMFk^0
zd8M@%$<0wEz9cctRxtpyj0j8F5Y?bK66lS=iUR$QxXly^7%x+#mI&4<ZeI{Ixt$Ia
z?s{q=!v0U`=7$4pt@&gam&3LIy+$nxrM8NSSc}ua+X2Y?`}-n5l`d%qN)K{4I5>Z}
zx7}zTFo)81z19YT6?$YEmyfxwXYGZ4ekDD1K!xkGru7bW!+e!KKX4}>ITvS04f~LC
z1pR+n?}OI4v}VJjiS4fc3&;E~hA<_AxjAU2JL4DNH>V=|1{1btxLxcT#X{GxcB<E4
zrQ|V69ekUbjP`iJN5aTxb!X75qeBA-Cu$fU4U^=X8e7+zD{Q+}wF}Eyg$kn<d{K7L
zv7{fMP69AATwC^FDczjqr{T`+m^C;Q?C3MA<!p$qj>pzed>cAMo3NdKT!h(~Ni6&`
z^GbyP8A@swg<<Glw^?Mc01%k@Jr52l6z}7j8Pc;;g*du|BEUdIEC}REynhQMP`(%W
z^vrh-b^B-W%eLEHho+NQa&H`R16V}McMrE_?cIr7$*dMUp2uC1)Wug`)7tDx^YsvR
z>KYn}3WkF(aXH?)Id}_F72Keu7f#e$=_PcBiW4+tXw;o5e{XfP(Ea@fQdJF(R}L{S
zepb8EH>XavKi)paz?#x1OGtEz%=EgQFxPmcyU)MoZD%|-_ieSrTXrBJ&6Mm{R$#Sl
zckgUk>+OO#4oo8J*reXvU+?a(2X(}H%4uSz&;M1^`~Cm&%#gqr6@XsPM3w$m2Y~k5
zE8d+0C58!9nfHs3`QT?*iB}E|#2_G+PA5we<YZF!e&X}Bvd_-3@$+)qpP!ukSna|A
zxZG|C*Tu%&gI6g;diqdY2#3^pS>pKIFVZX>*<^L9_uvm%44<z2E&|`iT`a%irui<L
z(<<e@QGA2w_CAUf@;_eEAJ*&#4=hW^@(<Q%&mNk;t|2ZQ1Uox>DsW=9Oy(AsI87}r
zN+JPsuiIx~dY*xo>PXUA!A;<1is*SUN$9v+NX^#1m8pMz($}#g?Kz%DT#ZMXA!Nj&
z3Ar`e7gJZaYQukj&!apl<L1T&;t=OLJ*tk`?n#YC)yfuS&grO!3Q0|KlCypqJ2Q3(
zEdtGql}1Hr{o=je=6~888aM$CU&{YTlZPcbXJ^$bO-abf0|De+hU;z1ww@|JEO?nR
z;hp%-h&kj^k9lEXdomVlj_C(0U5n@NlwiGEsV{SE0Sykw!AC1ISRBkb_b)E0SDbCc
z5h~f)1*MC9lYs1ACT+blTR_F6$SN35#{g?&2j)%K^$3ZqgT;Xfb&a1A9|!|%bIfe0
zKOq0_50;fg@7g{R*U^9Q_vQcdUoT3d-7olu(;>$5tt@Xv5DveQi6}uQAdn>>NceCx
zG&Dp_Ox#uER0IXA+%eStzU5A)dl37*$gcj2=}O(C@@Fn?&0*Fr;=j7NG{WY*WqcF9
zcN+Nn{_=*>n!BX55Rb&mun_ku?&!jEA#)Os^)%1mL8#}@KiHuDdolM9w^3yYS;e70
zdlx<lDxH5gN){#vtT)G9%RoiR?CJ3#J}u4S6o-?8LmoW&<#n|`E8NvpaOTM1903cP
zoYL7J<7w9EW4pStkk;C&C5k}P)C3)$k|L#`a8mo>JA<TDi%PC~Kya`k$Pl)J@PvwF
z@Vv)Lgu#+k1`m!fw=+R5t?D@9<<{QbyM~2vC1nCMv}{RWF1xbxLja~(QCd2-q&@x<
z6hv%7GPRQRXMhnS!JNJUNiSXX{!}@y<Mxj*P!*@<<qc=hlE}^#&kd*}oaDA~iqp5y
zyczvgR0PFkw;>d{)!iNZS=c?~;Myd+R;)O8qR_C|{p!--bjdw<0*0_GKFsuVBkh-q
zrDgST&2aQg#yc4y?Mtm?j-@4Q763CdU!02u8cY3?lQEzYLe0&s>p|eW&mjf?64H!v
zo(~@h_@meRkPA9H6W5kz=I0f4bUyzu$t3cS%I|oblLFI-IOY|D&JMMO^I$|LCI<i8
z%@?9TZH>G<BSnXEOfFBZAS8S)$`RGcs#KBDO#Gc*ycV>x4Zig?#qCbtnp)30)K&FC
ztmVS0swo3TPR^Teqb+Z`e%=`lC$p9-&0mS*ZXLGRB;>qTR1_;!J&K<QBC+%(r|K7H
zSZci?(rziZ;eP%^x0dy85Xe4LQQq(>MA2fyqI%U&mCu(BzkTI=z$Buah}Wi>P=79R
z*psm_c7WuXLPs{hSEC?1O*USx$!<PhUtR+DB(2pTOFANtN%GH%&5!KgE>iyf)oZAK
zom`Nh<>lv(RT~cl_{X8u&^yjl=^Gg<n@P}dbEl1D@guJW%$nvJ+M_h?6dazPPdK9z
zs+hy@RsH&E&u7{J+8;e%SKJR%3bkb@zf;^{GkOW}EKD+-UtDDCv~i6+M~=wBq<t(n
zYM=0?n#vV_#e08zF!x>Aj8AJ*O4rue`EzAEz}mzlH@IKDTl=brBrAK_EqEJQ>twZv
zOx={#N0?Pas-{PAFb546y#HXjIsB2uWW*q*ki+-sX_+)SA|VhSfcHS>es9nqcP)-`
zS!liYW$YdWg-*iyYxSB<U3HE(rt$%j93O}1+cui<*!IykIdx=JvETG$()Q^|5!tlg
ze4=U{!}30^+1=U_rF#u{>9lR9gDk7Acja?m&9IJ!)2_0wrD^-tI7a!Yit?#SUcJew
zJl+y3K8|R&_^}8T?gS+4buzv>6zh69b2(cJH!SnXV;p<lpB(uS8AiXiJhnET6q<>f
z?Iv)PpIm+9I2sf0gJ1U&9p(3~B)YXl-^0Mb7)yS`ShQ<FDc#0D_mD=TopdFh`ZWN~
zUsNz6-g=th(~|d-33ajk(K3JflFPavXI7xH`&FhQ9OZS!hoB%x1WLq*RvOy%uWsuB
z=nMxh28Fd4X$!_JAJ!O~Vgp6t(V|LJzNt`})21hLJ68}vmepqG?qhVrk-z-*mrwcE
z4Uv6<;!_&cTZ5ep_h*9O6NtuCXi7pxCUR}SDNoS=q+~gxU}0IHA?fs74(jeM!YIza
zcNj}Kd(M{d)H@x|+t}=2%23gs>R*FR-0i)}Et;A=`bXe>inSB~q`5@aaDIM%j53Rd
z8kU4&CxoJw`vU^TP*Mkt8b%R@wZt#U82@Owi?V#DK>&N%M6lp{_F)fku*zig-K;hY
z0*ab+r*Ao@#NE&VI2(nQD#i=1-5-0fN9D8lGD?jH(AQ0h9W9n=w)%sYbiHoMbjAYO
zgXk7)ou<?<epF1<S#X0b&x2;3j>635xXn>-HI%u!9}I~TmTi7n2v%bOT7n_Ax<FpN
z=y-&Sx~4QD&Ct8#brn`%fs1#ZzIyz79UWrw(DI%0y=hUfxpj{OCQhCY(%s&l)nO23
zl?;|f2PBk}&fb|qF+;0HP4-nqnnwWVR6<4lX=?+GOW^-<@_MsSdLO&1udqv>{~6X+
z=|Qrwu{oT5$E~>>8yky{iP7((?H#9!=`5|3RmGQ1N=yu;cw*F+L_;P3d<zuhyqj<<
zzN&HtC@7b3-6z_;Q(~SLUO;Gs=j50P)m^Q@M4+ys4euksqf`sNRvJV*+IL$4n#z9j
z&m&7=oyt26C5SmW{bOUt^YeDS)<kM)$}{ws@Auh+tJS(-iY%kN=j%!5lp`fav-pJ_
zO0&z-V`79&M!tnHkS809h)|vQ^1wK49iI+ejm>;95#4){?tJf3OJ}4P1cD!gL*BKf
z{_P(n3B8NYq8V4F;fBRDu6VB&B#+wf0Jl%T!6ApP;)hvTg8m?HQZoVbhi8F7<|1b4
zqt@Cpzj`K1XZ`fLgf~F1M}UB!La~PCh_Q`D#^W(h@?Pt7DV+<Gv{_Nl8azIuI*55c
zoy^@bD)DXr1!-Xd)WKC<WHlA1D?ZZ<!R*6teGcyZ!M?ohjM<r}8xJUsX{o8yjdvlK
zg`E|;Y75<?NV>gH_WRLq)~9NtsFw)Mq@Ciru_zv|I*Jt&P0cn&xOGXLEOHPDJz2z^
zqQBnUGy9fTn+7YF*24k3&Xm;*P1Jc!R2HRmDWj1wP;H+Yus=R38>E#eYO(d(Qr2cF
zh^mgZBfX`oEb`Ja&Kh*lAAe_uv_tt}wi&_uQf+?x;#AQX^B<@385G?okOyNm7OSEC
zc`OCah-}v*+2Mof6JWCUncV@=<h$XjT7D18im-vI>UY&W;OhM>Lf9SXFpm9hq^^Sr
zaAh*M>Wb|iEDv?KBsRj#%%-8(iL!PZxq(fKUNK)GXgbVrMk41+eow$uUA5YS-Juf6
zZmS2?b}@y>X|vw@;MWp8r|G6%yN&(%!NSfvnvbhOr5g^5LqZ7ZFanvx`~D;I!|~S-
zO*T;+oSY#*FH+$d;SbP6XzNZ*47~sf5(RcOU3=xBwtnR_$4PgJdiu}8Wop0LbR2xz
z8nTAxs2akeezmSBRAK?{gIl93tietORj=P5J*g;hv7pdyJglwvn9YtBl-OsF!|6A~
zpzYr8I@pizydbfENK8tqnNl8h2Eo&!H`8!byNwovymt{8iXQx9e-<~1a=mx4NR^}O
zt~Zf5ezmgW5}rZAOZh|Sq0|g-=$Ee7cZT~jy;IDSce$@^_NJafmI(*&qsz-*evw%F
z9E{aJ`C<5#Fr8^E<P)M1JJoGBV}~VadpwX;b<GJ0J_`$%GCN#gjPGHMnr|#xR<3WC
zpRna&i@~}tNHGzs(4gvm$cT_BsgJT-(7k$Hm{G_up#D+SG0V|#w;%sK`j}2bWDUF7
zmhuF2*#9=k&!AF?AlCU%&HNC)#{c`9ow0D&x3`LFYRRqNz;L^Q8FhP5yf4u>8SL@&
z-e8qspF&#>T*cQz0=_%Tm%NYH;)4_=9BJKKl^6M78%t=Sup^f=b>);^6A8{Qup_@D
z$7e0YgkostHms^A48SahzMf3qd)_S(6-Gu@wV)ecpY+jl<-jp8Qc<BH?}vv=ZR`pM
zIVANUS;7h3TsRx$^;&i;WQV~LV$gnV_biNm$2pRS2WE7<KQuLRgar>}W+o)!x!lX7
zAq_f~h9z5!K0LH-=+FN0BOZfN<#M76Bk*(}J~^|Xnwe26Et9B{!Vu1ZJ6w<Ecbcd*
zvq2AcMue_lw%e%jOA9`Nl0t8W8BlDQEOq`JfyQHeW4^3bM&(or8BTW%9t?xhG#$f|
zv3;1<xl=)L*q}<ojYzZbMnqB@f>Z)7_A8JTy`oW}i*>nPo$oQHgKW7w)ci$pzrcU-
zlTu7mBL**($zVO_3)a`gL~NtU#w(sxlM6UO9%60PamTxUR4=4=zdWW@#W`*5K17vx
zspx#JR*S$>5-*JLji|o2C_%%LCHiMsON|dC+;ra2UxfZDwjhu(8GM6vRp#X6?C#oA
z|J^rW!Gr`|mXhM2;NX&RRvGEE0$0YygYH1uz{)CCNQi^S_B(6RFO5R*`ubgpwK_+H
zUX7BhOF$R*eSWFbF>%Lun^1vm|MgeoG(<K-XDV8id(xzuK%{&GpHfv;m<+4A>!Ayd
zZY&xgFRHE4@yL5JUN8TnFk0jMi^cRiWp`tt9hH>?)q){W%T=Mf*-r>{B%5>g`7Qz4
zidCY1%~1K67>9k!%V}k0CC<D`i^-T`&7>S2*M23XRZNkc5;S@-{%?Vh#0z6ZOx*_S
zN*XIF{fdV-EIL-FG7pbbTb*}j-_XNF8-x`f<Eb0uuMY9I{Q-*#%cgNZobfSxX2z&k
z!+)U;8qyfr9751vx&-0{J)=BAOl=cOXFL<xpSJJMWXMN=_jkDB<`Y5u?^Lui9tw<&
z(tErq`)E_;XmPLzm29W8jR0jXxpKavri|`H_{MA;<@Vt!qr}4y-OCG?7Gfa?StLQ%
zf%Yy2sXRO^Y@qA&cwIn4Lt3?DThC2ZJUyhuA+w*K23oj;Y*y48b0kz$^RCe2RW6xK
zkMJdbSF=ShLRix7ez7a!ex;%jtcUQby*<-_Q`2AXOMnsnTB4>~$wDch@8}wveKzcy
zvg_D)%BER`*ZlYiX>XRqALH@fJ{qI^(z=3IPHKpRo&6<gy~OeTnXbHnfm@yZxT<dt
zjmMXk7f7u-PWoT;y5Ps)L)zI`zpuBwL_9~$%zXy3AJtdFXQK}*db-NagLUtq4-ZrM
zRb47zka4j#zG$Z19T9>t7#H^G$5$YhfiCd!t}X0TG3LA0%il%|9#RvjF&$ekF$eT2
zvU<evA6<h}3ao*9#yuqt_V3=CmbV0!3zsK8g1lJCwo1dnxQwby<#`V3KQBiHtf^O=
zVxjeqSAS+0pct9W2MdPL6^)GYcz%NZ9~Ez#6O5}JWr&Z!bJUP<DO7D+4z9T&=HEpl
z-qU_HNeKy3KIw&yrwA8DTH2(&S7D9K=15*mQATLX@}37C^>m#TZ^tKU>cWRJby~04
zZ#Uv7e|-cUU)j_*>%5%W$|Cc)kO%_6oLDN$I1F}ov-kz`y33AzB2LX>-sdv9Iz%_X
z!;+;E-Wsurf9IPOoE{a`PSSTF>f$}S7EGqK%C(OLwt1e;m8a88DtMQHI#QhtAzAbQ
z7H=Y>cLJdDi(=!!Af@Mf-pMLyq@L(*WbqTq4GP~1`Zog|Bvb=Ju%U`_HDC~U@1e~O
zbt-Z$V%=QK&3ie+F^)yOT})#_og$S&_bEom(O!@E<q>8Fvof^(ft<48RPFH3qv-aN
zSyq&mFRQ%MNOVkYtAUlZHF#v&1;%Dwb6@no8NIA_>B(k`O3gA%*Vd65!u$B~<2P)`
ze_o0SBKZp&&eUF9CaJ&d4T>onlvvbj>a@$vN-XDtxk<~Zs6Y)0U*{!tS;+?2R>?=)
z4y*ZRU<H?{?def^uKJg-M)NuJ?qW-vAlNiQGT`>djG(i1Qt|$1WmLnZYPg3cY4O6+
z(+}qrdPKRZvTiInR7H(R^jw=*hZlRlOkE%votr)a&TE&ELI3j-IxGo%0zMC&u&}GM
zt#v4Ne7^xiQa{eC`y}1^u>@K(uA1XxTXHAy({Jc;rjsS?+m#(yu)#}LuP*l6F6R`-
zb_1%F>iIhTf;DXpL@Qh0%AhFHq1<MOJ1;ucRHrUAwzc7xYu#|QfodTunvAW<)D$iP
zVfu%zPvaR9*47tmFY6^0l$o|3-?LiF3`svczQTQqWN**i-}g{{^R(}NyCdhAiJ+YC
zCLRB)I52ri)|{5_f+OJt{@~nz604WGSJ3~}Gx9M;^XY*bT2L*6|MQ;jgoFdk&A6nb
zO%zfJiXa}|$&Q7j#BzsUU9MhUUfoF#2{8H|qXPpmC2L5KFC~2zg@;pW)EqQBgBxxk
z3Aax_--GQkj71lqf~=8Y?&Y=X>`VV109ebFDw`wr_gi;MlFRRbdc#D^5g*Of(|(Q8
z_DLUqET}0Q9x{}WI6cIqsMk2Bm-9>bmcwmqYz$S<G&`8lVttu}9^eAPF_JI`AWQw!
ze!DBzd?I!+eLmknn9$7PVv>YBSb02M_C^Qs!y#|S)1$M<6+HX$f)Y8b0z;5?O2n(N
zq!)-GC}kdWdGYbm#$RYgf;XKPFH#%(EPn~C6_${Zd3f@InHJ$-vGL&)LUZh)oyra`
zS#dB(P6STu_FSEoJ~Bc;a{@^`D8&3MNtn|PUWh>%!$MRBsuA_980=TzqBIoT00V^>
zX=7nQ+t{Y?1Rs<Iad7got}@!g%GW0{ZthgbbNKU{2>tc4n-;85@iZyJWYWz)Yj}SZ
z^N94^Aa}j%(%QYx|L6hy@e_I^kWNlcC7A$Z#h4sxQ#r^SzrEDPebPe=1c<LoTr)nG
z^uzeNQQBVa8=nZIAUpL%cf@pm6^8COZvUqH(<1m?T+ok^jJ}Y0s^=}2@<H9*2C3Xv
z2*xV8(KUfDoX|<&B&-{W1JugowIyV}V+4{bwgH~xIHC7`Vr*TrZmUb6+vPr0eZnTw
zhv8>Uj95Gio>%1tZlFk~z%kb54%5`y*!YbqiLy1iVfm3nUA+!vzIq<g(7)*_onE)~
z?oiH8Z_7mR^_Vz@3s@)&o52jL-}cp39L{>Otvgg!<9TB-MWRsDiKXmziHLqBJD(5D
ztoISRWkpXR%t>#mtINxd4ME-O{v$%U+6nuPy#=%DDZO&D&De(>P_w(TqUui6FM*%)
zWSepxe|;3q$3W=Cp@~I6J+$n3h1z^JGF?P5+Fsp8y-uED-hg)5u3xa<K5%Y)q<K>l
zP3h5=lRg-3P9b9P7NJMv-?8eS9jW(FD<#5#&;M6*%{K_tt5JbKRNeKj$07y$9bcHG
zeBt1coyOB-UU$C{jGL-tdU6TD>IkCzw84kH%E{o3Q6A=|xngl~%934E@105-mbV{Q
zI@OyfT26pOX14Eh(v4PKuUQ7oI#~Eq)IelQOcD5#6LaG5_{yWqEL|!B-0Aa`#`eqf
zMG~ty2Ok|T*HEfsur$QE%K4zZm7O+ybX57MsJ-mQ89jYJA*U(A{t~1=(G=1yDL_dt
zpVaLYyY;6fh63p((S#0%9k<)nU>UB1e96JKnA3P?om@rRE^D?Dgh@EcT?_A$G!w^P
zn=an9ed%mgWM5Dub*pM>Ff$7a&oL+62@oi0Bw5zTw^np6_=1B7ssiiiXWfJQC#YKO
zq~+yaZShH12mEtPMj(z1bRFXs*raj)v^vkA%;kJKq{W{376<@+??6zOqIJ7F_*Js=
z0&1H-ePnRFadt&m+v@6hiL7~w9xc>hXK-c#;(R?m>Y|Z^=jAqP!4<7zar)8LNO1?6
z%|x%Rx>o7+NQOB(o<EFp;Z(V2Pdm+`z{W%jDfTxOO<hnDlu*==;c%<1E>rQJ&Q|c;
zZ@P4tiR_uHYk}UQVpIYRpArs|oD3Q(OTX!^oX<NG%PMfMW_H8)d?CY?<9!3^lmmbK
z@F@xFslLA_X^M)AYco|B9{CY=ez^FKR@}Rq_)`2y8gVOi{XrpWs>vQtUsrrk{odqw
ze>VJmH(ou#TayuyCRr<z*vZ7XTIKqIXl^pfgVs5D1PkpUemiJ{2#yy4r78*TX3;d-
zao>QPz1dQ$E0?NXwwRGh+@n19zdyM@%b~5HK+43Zd;T9yO$t&JLP9xR?}s`CRZGh<
z^96d%`u>BdO5I8tVMr)kZr_9XXp|POPkzJ}Xmb@1neNtMKff7W<>fg5cZi3e`~e@`
zl2ZVlPO@kutSg0i_o~fi8Lxk_%}o_y{MGFt4i4x0_j&q!AJ=56-NU{H(~6>cKNfS!
z1At3JNg6(PKxOS7@z1_YJPomY^00@JwPrr#fdL#0d{5EI!la}$n(uI$nvrRUd?8y+
zui!nXmMgSBeKz3aCni>ovKMieO9;GLWEV<dd1cf8@P>oB9MZm(e;nn$W*5ZWLq|wk
zKtF0ZXJ%)okY8DSLVudR7v7HSivLd*fMVXGz5Q8!(XsSQ|4FmRX^wMgDmS#Fay~up
z>Ow(-dFaiXyZ1Y(WI-?SDE7^4GH8ji-H4TBdIh!r9drEI0iXEYyJmSkhVb`TMc^e|
z6}Jy4n@`pop!$qg3oFF*k_T6x^btN)aD}|)X~ctuu6wUChPTCdd(>=EG-%+r6ed(~
zDQF9_2Snv^M?OtvDk>_rX5N-Y4lf>!icy1bRh<-u!qTu>8$yw<K|AbygoKrx5~^YB
zVC0w9$rTuOgFS@T@qWIir|>}11?BAf1Hb(NXNxk^CQ)iR9F?%f94km*j;6}nKmvpM
zs>tgDGqb%z2@Nz)>oTasaXIEiOzX7hhN-wdZNyEMoPut!=&hDVm2xD5_FTy>u4FRE
zHX~KjJnY-}d6GoK2~^c1njENO+Mm2~Ild<+lYxo8mnGDI;=|O`gv012DKp7qbN?C<
z_q}tB@JLgKvb|k&qc$k@2iUdk*XJ?q#OE{O?EO_7{PPn<x%LKAaVrXcJ%0wlj9yh;
zox^4|CqG|rrJPh(w;8UV>F2~*Xk{g{_o8!HO7x0Io)q$Gi8}(gf6m*3hK7*!TP?I>
z-}~`=#*+4#L@g0hWT#(}xK_&*AK!Grgz`UL!}DIRSj{Q-IFzcie}hR#WAhY<=5>O3
z`TEu8hRnBd9s7*bW3cQR^$yrtp*)KDn$L~h4cALmteERd)NGbok3ygk6oINJDeyR{
zI;*g0=UGgv6kzU@fL{HS2Pn7-nin+ht!t^M$b!hZ|Kc2uOi}UeFFSkj;kqqQX$xkv
z){;2t;Ew|?JKq^csSv4<&(r$T(9Eg-=}jC$0Bnm~%&o`eEcM3fY7QON`hKE+pAtbj
z*!w8ea+Zi>&<aV)S@V3n$KfJ@A@I+F@LYpYUVoCS%13aDCWZDQym@%d?euB;GAK}X
zy>D3}9D7uuEn3mj)7kzYy8X*;tVz_>mM@HTZWO-%FSC=;NR!MPX<2)tp0IL<$JX9S
zq;N;RhjVJ>j1sgrZ$eAfl62dnt=pR@PnNmO@g(h)s2NoZ-}U6~apYjt9aYw!nT9wy
z5tR3LRp#<I^mY;MxQRBUi$VR<7FEL~_a^2VGk5R)JGaf2h2r7mHQV_A82bvSs<!QY
zK|(|tK^jCrQo1{&q(Sn4N=vtN3L@Rz-6eTwL8ME%k?!vJFW!CkzWeU=zW;9w2IFwp
zXP>>-UTdy7zxmB?N(8yvxF+qx?CvdmwfhX{D<Xg|I?^eQ@IVa~hQE3BE>(@j$NCbT
zGcdcg6|<|SCmWd9gCkpV9UZh0#dFJx4ib)ngGm3=xm)$K4Q{V9^!WQtno2prsnA{G
zm!_kQg@wZCMrvU|SX(;{G=&q{M<F;tM*Qx*ym)gB{j`XdoS<0WOnF`qUoh>N{Jme`
zmcGY1wrj{Y`MvdPdwYK1hldQjJhbr<qq;-(>!!c=^<j;gkP~|FgnElm5Y(1=eh(%R
zhc~azmwKUHpDtxF<D}Mc(VV9gqiolc#MqI1XrpUpCf49&hxr005IC_|$at|SDJeNu
zfs&g%_FL&v%H+$35U0`F?X|({_JEmw0JsiTn$&t#Vi`VsbTo?b?CK!E4W_p%YRYJ_
zjqHG>hk-1b!PQeyi3PrZRurU~(%~O#i_5eEY^B}XIgcoS>Mn-d&zBVFs#_T+(Z9|9
zlyGs4godWl5Ww3prgJNMhNqm$GGmx>o%p&W`9)Jqk>=&+dfXQ`GC9Te-#$OS9RQd{
zS3k_{wDWS5@nX9`z?mVYAMg+HId<G9dr`87PhF)M%q|0#U)#$rO`4-GzuaY3n^Szq
z>pY#OA@$8&Aa6+G7q}6-=gR(shyE_vYsCMgs)3t}BjkZ*a^4(6FSHjkIhl^6z2pT?
zE3qyt?7XnW{cht&^{3u>+WRD4Ad7;j`Dq@?zlqazq0%mJ>r(V#ya?jA+J7yD>z<}F
zC9hzWbaSRF7ZhJH;ePjETZoj2kDUEsAM1)?O*3$FD|Ae@0Hwtm2~^E0!f-UhtR4td
zR$|bpb__hHWGBa3|6+YF?`y!D*h>F-zS>kc=yV=B)!!e$ZTFsB10k&Kp(2%O!@J`R
zcaUA^dm1bj;HI!_<#nlBO=DUqyb*%dUv0{jtE8%f0M&`(yCk204`}30#3e{5JS7@X
zZQ?%>pQ~Z(1<>r*T|Q0Ju(Ly6b_;$9M6~1)9ts?``lBIC6+F%JwJBBIUQv}?iPE!`
z&5~Q?C8P8!7P$-cw$}J~pL%I%UOl6<`Qpf>HkWxB#=>f~VF+|-c^NV(qF-xlUB@2g
z;c>5_cW7v1v}9H`4C%jy`Yx!DH@u@D<B@Uy$J~16Bb6H8UZ7@W;j6+P^Ra)s52K5;
zHSL%f45U(;e2a@wpp>A}82*dhru&FW77&}dgD4b4Q*8^<O2|lPDjt9A=hqaOOuy%P
z%oQ@X&a>+hbq9B!eH73n4{h9fT}4et7alRvD^i^M2@v<4h!(uk)huj}H<DU$*Gd9f
zF<fmF*%!Y$tZ+H(tah2I@KR8SM9qF#_n_%Ttfs>cg$)6kcU;uevvDER!jh74E#|Kp
zR!v5)q=5_JbgIIIq<xDfV44k5xK#YOUCjEtY{&T96E=#aj9~>mqXdQpIEO2)FKWWh
zg)C|#JN@=w)bC|!(;_GmRb_%c5h(+6?j+IWZO(3PX*5NzN;e<ikR)+p$T&L2JJEfA
zJ4OK1J|Hf*6a@^^>@VaF3u!OI7qe$c@^qGy;PLHHKt^qR(OWS!GCG>#0kvDP^&S3%
z?V|`)u>&&GZYq=VUhQlEiN-t)5PNbldwFnx-{{@yoLGMB>L@W*nx?l)^fZT_X%U0p
z*EF$VIV<bx(37yl>=`4Ye9rnE&_qTiL`8!4pMdc95D`T#Rm>0dZB!Kjfg6KCl2Cs#
zU)xOx;ouoB`=-a*@5ynxNI@&B5kGRAI#arWIILL4w_Xydsi}fz*5joKpM1Z8bQFzj
zT4CX<(k}G5f#JNtv#ThV5aPG3F{k`qSx9pGjIn5D=iMiO$^aL`7GIKL@}o?CVqzlf
zDLD^%LVpSGKs^JYRu<Btm)=6@e!AtnS?%q!hbSo6V}N8qO1xEJ@~NgqIV?|cPhKfI
zsG%|MWV-9~jGb*}mDzoNNQ&i~YJmMvr;DN5ODhhq`q5*SvccGQqNC4?wYTf1fAj;L
zy}2D2WL;KFx~es+Pp~mCq(CCwA7EdurSjx7`8$YT=tAFcJiTI|`C4TbpkMItDwu!2
zt)pv^=4bX~3JoHY&|4c<cTrm}c;C{FTS}f1_IJ#ySFb<c>Q^D<vbQp5s43(a+D8Nh
zgmBhwu@F!%oaSt>4l+RM1_0gG?gGSaReKEW8%yN(|F*fMzI`A;Lb^xP>hC*oKk(td
z*P2W;NOH;8Z!+$4179&6b#DM0POy3LK`BoXiMxxsHm+t<ZePBa7G4;oNHbUFi^`-%
zt>oSIesM)Br@+Lj$WP*9RzKdmWPM+7661oL88JpJLyCqER(j$@fHt+_F_5EhbOO>G
z%8tJ<v#fM5pvgipH@^J~x_3t{-iS&dqelOZUhVHRVZjl&WLNw0d|2qQU@0%`c?_Cj
zUoE||b|S4d!#1Mk?9-2r%PfU8bSL}dHt6EtNQ8xjaToGm?TIAu>iylmvl7Fy2N}}D
zN-B}hudPXdoHhK!)Kq|yoTOx0PRh42EEzKrg7=MA)4%{ImRD8b<XA2UV>j%7BS2vz
z3Pk=dJJp+f4@x;vv+r7GN#+^-Voul(EoJQO!BT_+CKMq|`1NZBvk7YnsYUa*aEtCq
zx^HQRAbraz#6NlqMP!j%di}u$o9`DvC8zlAT{;cgU*dF-oA&%BcE<{>B$0W~9ziJ+
zDTc*s1-d3~OxIS-$DC?KXdqHfF~XUenduM0^*2xABUs`aP%+Z{m&dP+Sqcj0?Cq<-
zjHIcVjg_RJ$O8Fok-WSy!10QMg{|*wX_5VCve2rM&x%PpFpcEn<MUuw);};UJ>Bb#
zneaEyzs19>8o)NQP8JzoVcFQ)4#i~_6a>f;8-6jLi5C_TX=lF4YT22A9*>GpKKSv`
zqo9EHcx_N*XK}ntH!>oE{BP7N#^iee&(-K!V(j0Lq=K%9S=X0xCb(oMu)Xnurlxd3
zBm#}<EX|951vpZvF+m-v$=KEmZ{Bt)lSb_~s&46k^~F)0WA?oVsN|=wx4*YQ&ZIhe
z18U6Q8sI<H%T|2ZgGbZZJvvofW^i+{S;DIKU8c?8ITxs+8%h(oT~FF6C}|XS$)$&X
zK=ll>CLz4JCoUw<rPB?tTU%dPpC(v8ID-GLDS#uLn!d>0-kv2dABr|Hu3YzHxO%*&
zhtTPK*#a(xc>m&a*nhhbf7nNvV6gl&G!1ljMH`cxjhFFL=xAvMFl0YetxJ&I7mqLz
zB$x@FoF!fP`0(jxA8*a|t_31x1?_Cj5{wl+ef>e*klxI}3~?m|1&kt{rrCMA2~`Hz
z2eAnrK`3sSaS2QppdRp#y|Yvc)|6-uAU%(9#~WSI?Y5r0a&t=t`>`zWWbf!->p$|I
z41V-mR&4J2kN^8SkOba|Cx=O7j&~e$ZLL#UWjc*`6P?x-R%o_OEm~?j$V?X=TypgZ
zh#VCZ&Z#||KxyrYq9y3IWkmbW75siFSm>XEWuG;o|MFV|Q@MaC5;lne_3O{~*P1kH
zMeP}O+MYhpm*BJc)b$xTN?ln&<7v(e?37~8;IMMKKWP2b)rcvguA1K2)fHb8Y$!oh
z8x&xHUfJY`DRzy*1bV~#p9{CZB{E`xtl^jD=q3H(EFzOH*8bC8!gfAb`-r#MttP5=
z8&Y_HPOOM5L`e2=I`RYe{$>u16?}{%(hhfPhrm;0I#5ffFyzk{852*+R&>}P;)m)b
zpE0x{W@Uv0X>^&$<p-T3z7G#86>4f|ykufx%D3O1tc-A-TUl9AP*e=pnyoU^EC+Da
zFde3XZ!po<B|UX@E=ZlNB#;vp74=a9eN*7wp+b5fzU=JmY~@~D1GsU<=2!{AdxH}f
zO-)T86NOu8JnRb#dnHy)(X()Mj_lPxhddIzyR;+<ib%sZDX4PLHGy2P$@W|miKBCM
z=HlYhcc;&%ciRJS^8jnnJR>mHq$EmL8P{-(4y3xXLPOERB!K~Gek#Sd>HL|~ybI{?
zii5g|cQHMRcpt8MdLD7nf<j0sX%tPH1xJUS={O+bMj89;1nY{Y19|0>TtNMVDbwGR
zCV%7=|NO#Z83O<pfzBJV`APYwnLnL@o2x~}azdAtd>wLCcNDe>h4+nB=G+I%*Z<vp
zV~>dn5?s_smaNQ{%d2yX2w;k|Zn|ho@<maB&U5zs$4tf0u;gS}ppHg1w#<yfxrPi1
z;eBZ?170*{&OjXs4l>(7zmN5*sh1HM8Qzgub%#P{$$ZZ1Qx;8Z&ne~E7!|zG)(v|;
ze7ZPV*R@Qdqg035qX6maiTPZ*z*r_-U#&*BYp09jvAMPF>Q!W~&!g6j%!+{U-W^S!
z0m`6hE81&nPc#fk@8g}$2_%^}o*TRq@@JlQ+AMl^0ECT?KnW;qzy`KE*eV}c<MW)@
zFG@eWt2+FMED#!gkR-<6FCd_b{YIjn1@~lUCgJS-ClI%M1#T|-xi$vNp1|MN*e~A+
zAbq2cQD9UUkoyDcdqqW6Ma0j^u%iGfQ5g7u=VzEbaz?6oN*7n>hxsQN;&a(jo6>M_
zaJiyb?d|O}fYila*=u8OKWf~S9&lI9=8r`MwCgR&`BO=_Z6CNEbapH)reip+*&4Mz
z($Udb*t=C~!54K0<S*i2F{<Hg87#DA6XvU{b6*hSgaiczJ+F%8Ips<+CwO1t*fi_B
z%ZJbO&L`MNn5*-yCKxEo%Yx#!t}Q2jz+T%71XKhGh0Mi;1+oASTN)%hPfwV|WHe%4
zH65mdUt5wt*{<IXh<^^2c2A8}ZKqZK?9>s77(=5_J}-5c)jI24y{rob(G<nwxTQw>
zZ4DIxz(rTeI;Jphf*fY?$B=MYE9<a%JDNWBgcz;aWRNXOpAHRSCb@x(Zra+7aE{>j
zfiWtQHutjyL=|GU&CP;r$KvARHXE=z{xHtB(AJ`6W)5HJODa&((fI}_@6S2a%#6L%
zH<0<9j#3#Q=JJo(+O!Yh06$LJa5l03)i}+kaFhUuw(Id@hGLsHLTIN&TRI!cT`@aa
zs(9am2&9K|<c1v$9wO7uq#K=fE{4XjkeHwk`dQC@`b#PO-yNXe-iZyqr)3u#oFywq
zor4BSQ7;sc3#42>gWB8USnil&ZO)g}hNz0KU9ce~xdX<A!GS=P0FwkkdWS(xuUTi@
zP+uR9uvoPuIlmnAoh=v|q1b7<g{kct%9;xu%5MW?GuoK-fV+xsz(Q9M+uz>@L79M;
zW-#BPkjq@7tMPcLCJ^|MwdMoVdZ&3$#5E{rsB`#==xq$@r1^7H68={JbpVyb!Ty_i
z1#qS#BE~8}0bJtqrw2LUW2#&foiwn!y}M1fvX`eMsi4|zu)G}<k5bnq%hyGK+%`_x
z=3{EsHf=O~)=$F1!kN^c9Fh-D=U!l)O4Gb?AX3Vim9BrOq>ku#JTjKKvz`@mL&X>z
zI-KHm5!Y<dlsFn(%7&#cAuSE+P-Y`%#?_E^83L4u-98}fS5SPs+<}JhgAktDpXa}P
zt$!M94?!%-djVJm)Afm&YM;+f(T*R`YlO<>5Mwi0Q64*Q(ZA=gh2^?js}@c(S3CUy
zykX^}Ks*)=ASVKb4~_$?*cyjqk&1$%)7a+aS;5Wz&yE7$8kcisP(>SX1kfOP-~>d)
z#0-Nv+BT7$I{}Fe&;p2_yA?s@Blk14vw=oeXB9N}oAa1A>+dj#_?(o#H~|G8aUesG
zX_)L7ZEbU?Y)9g_gmD)IPFY<7vlRg7OdTfLK;F~!<{UTQAUQcXpOtFExn$zKH}js>
zYM-k%Mf|+=Y*UQ3lX{8W1O3a3PnQ=Lxye{n8~aNUa-Hc&$s!*~P2VXzT0M-<Or@s@
zKd}0@OXBHEiH?OO;!-w`{ioW6U##P1PT*)h>Bt+c#0<HSHoUzE{#?#tdjV>_(^82!
z6#9+(1EQbvdVRIsh-KD2-eAk$xj5Y|k)p){6Gw#--sB;Vvat=Nd81>l5kv^zTa2Kj
z{vbc{M{U#f2~Q-bvRbWR^Cc584<F7BG=jc(TLu?^2NZIU_lKlGgRtH^3tmw9rFn;J
zyh!}*+q6b=<K5W?Ac#UAv+s2O{{3ZE@eP|2Q1Wj(`sKs^yQq6YTwFNwF6YatU4;n#
zhzR-c((CJWySc1PIGd#u4{?h2D&Mrg<~?xurG5U}o1T=i!25R^Zw5wsZSQnfzNb$h
zmy}#(_Y;F#QSN3^1+{70jGn$pPPHtAMO`Zu`$;JQl7oXo!_3LXh;-ko_m$n|Xt%MA
zIN;Lf<9iixJa0Ntef$t9d9Ew!{XQ(Ti&0#@4u0VV=q6=%y^ZC7?#lZD?R)A7?*00D
zmncTz9Iw!{>&JOjj{`5JHx)8o=4U@4AfQz<=1lJzmff0dNWjFxs;t;#b6seKANk<s
z)`*RVm)E6431nxUYYe<mW!gf8|KHE|4<p^o{9s(|8#Deb4NX_~T2~m+;_~8H{FV8d
z4DgM^iZUwRAKWZlt04(0xEFl9moH@}QCi?bt(5(puM`^mnAR<Nm~j92SfzG-Uc^ac
z6ipdLCUWoeRQ1^QC|Bb{D$Uhx+s*am`hJHYmZr`;fNQUBDWW)lyX3Urj;riALNU(w
z{a{(3bA*tP&{m7*IlaL5$CXb(#ai}kgL8LnOH0vmO{0Xc@NssflA<E@)2G7bJ6nZr
z!8NIkC)}KzYRQP=<GeLYp71zALhlREzI|a)A#%$;x3;y#hAtVdp0BQA_M80tCX-J4
z#2yrv{8t3=M?mn`7l5Y>>IXcod!=Pa8{gSqOVUp{WQ7W4bPj$MPxf~gb(d=T5YDVC
zbF0Eb@<1+`R~_d`DHPRg!KW%A_;{1!yG=pJr=+CG#c!=2cL~@EpT*C24ZW@TF)%q9
zZ(g&2KyCbE2Iw<UB)*Bk?s@|>0t9aBh2yd~iW6~F_l}N!Xv%d31{7#>hDBspjgVCi
zH;#cMOkG``FTcCCS*H*H{<Lb)#k>(v6qkOuADzyr4!fSpsGv*(4>q3983!a9l)hYH
zJbo;8g<9H<1oyY;{io>U_t*d&(@lO)mB?UHiJz{zyi5h4g^(97atd&R2M0-T6%}6B
z<&U#uM$nk$gW`E=F>#%6sBZV8$sKN|)6trBKtINs!TOG}LDu>dQU6W!H?1yq)3>cZ
zgr+bNPIZPItq5>&aU1a-EqmEvD*0SYno#9P1)vNi$|Z4Ah!xbQ@H&=v9b7!u<6x93
zc-qC}Xu-$Jn=6;Xf3%Wt2r3FK)>;rrNViv&CJ^olfd3Cap4sB}T9H_`<07gBP@E3#
zw^xQ1Zf_k2zt+}x1-9MXu0+?K)z*2Sq^KCg2IP{tdd<0~r&)2}@V_op@z!#S79;P-
zslh2m(2|j*p^~!)XQPyjot(T6AoG<NpW1XMc{IYI${#>w(3eP2$4>qHIV0yIs0bdr
z=@WX5qqHvlfEI-3|ECLuK{vt#WPz`*rj$eDUYaVTe>CMwgRe!bWLb0jI@u>=LOE7B
zlr0U|M6sU(0wlR>h#6Cx=B*bEtvt$fEmTq3iXUz8L?TZ|>Kq@Y*~^HCiG9pRDmiVu
z%+5P_A1@&(sle9R*O!f}bCp8VA1f*;>CZIsN->B3gd22?{L(`z!^z9*Rb?^9K!Gw#
z{`Bdi=n)4YAhGWHC-Ia|b@tm*K-P5#L$b8S=-<*Q1-r)Yc>fO%;_hLw+$BUG$=7yo
zK3<M=U<=c__Fl%|ew6U4LzO;zG10`DSbUtq!y+d+zkWKiJO4`_7U<%e;dXuDKT{4x
ztzr&~h!AOTK8^P4>g~+{tXVFI4h9YmXx=<6us6N<^XI0?2k)QHsHh6M#$jPdYB)~b
z>@*m_AO)ag4wUJ}Dzy5SmZB;~ytD&#+L<Z^ZWu3;)vC=Q>p<z6(oHTCh)X|z7@`*H
z{kw4pifX<e#*!N({vawkM*gij8O18)@W;SITe|fJ5ZoJ)|NUHZpWQ7Z7tHjk!psBA
z-j@7^0>op-J(UgK6}LO#5m+c%dZ=f$LWuE;(1wH@-iXaH+UMjefr;$mqEq2;(9ON$
zV};uFai~KGmv3=Z|BoNaDoMnAPk{`h6!zoC3ZPbxw>~Hc#nI8RbNw4W)2TL~+9*^W
zfqMUfAzw@o)Uqh+mAl|jjIaSsnQ&rvm*8NDY_OJqB+&N1ft=<-xVj5F@<u0wlWd_D
z@AW>0i1nzJlHnn%?&s6h1?n9ySO01fe;=H?_Xi>$G%xz#InWC5`S)3zdDczuGbTi#
z17#s1ej@Vr?ty`rs*>!)XNMY2^CcS-8eV>Wew;xt_Yp!PBEEIqH!N1K7#+YiNp!!i
zyC`@G_RV+F@E5R9#}9igh|B3f=4Y_VY>FBv9rO(ce=(g1CwAUq;z|%B0e)%ZaQ5d!
z0r%uc2Fhf2H}lFJ?lTWpAfR)A9sNQ_7ElDOC#NxNc8^zjH9wt7JTwh@`y*EYXjxKH
zORw@94~Z`Fu{iAQGx2_lq*nSqHz$`U?Bv9KeLTiJxbZoSt84^o-E{$|<GrVofAZe@
zcj+`E3E1{!e3%kz;^bg$R)_fj)}Q_B${J}HA89s8|HPp9`<VSpBgkOZtcuXew%re#
z`3<(?NBcbMFJ3*$p9M-k4)qb`l_%#t1Pyg`&YKg^JP}a|pF1Q)Mrvir3l$sbWtNtP
zf(qrONq}agf&8=*D8!kn-c1GNyAhS7%nS4L^Mb$;C+6F4i=YWWQzT$;-z?%#@tf@I
zlr+GQE!3=*rARay&PM4?;)%gw(0VQ-Zf7x5SIM}`b)Zo*0FF}0;m53;F#+YyPA3zF
z{xk1Ok)whLI0k`X%#UYAwglQrDx(~rqK^hrW9j+s-8*GFuE8v6+<1^AkZnwRq`N{|
zx$O8{1Y{Q0fj6vZ(76v(O7gV=OE=@WY?4XM!q7NMe^Zp{Hsiu1A}W&lO<{?RVgM+@
zZw#b)uayT(MMp&q7DJ$c8<arUq|Ux5uH6Gv`-39(P=)J^aDDU-HmfE}>+_O3t&bNc
zqA49}6STG=?d|*5qxN5ohucx2%hU>C{|3JQ;p5zc1F7X!B=UvF`dLaxRdXtp(#QwO
z#v=apKj63<?2&3O5F?y7QJ2<sWKfCeJ14&df3{|Br{$ms1}ape&PFD=b9F0+o(BL%
zUA|8sE*{kG56Ce;DxFm>zkDfJ`uUT5RVJR*pO7eN?QH+&qEOh-jEJKn*EMLt)P@6-
z*{pNne!h(R?iye^!yxv0{_L60#mTk^xp=TL64u$gGmrwz%BE~c;kJuUPfv#<6N;UF
z0mVFD%Mi0&Y(rXTHsPS4q6%29o^?XrZ)q5Uz-h8`I_xA)S2aGZoY~A%+RX|kq8)p0
zVIc?d`a-4{K4WQ*Qh?kDAd?nY<CHkg)^n_Zd6Esh(tuH!@zypXhrkS=ijy1rJ?N2W
zVA6e#kbnTy<5tA*e%`|`&(q%qP?)-Ui}4cPNd;UHO0`T)CE(C~P%VutivwNC1-Ihc
zyShFDREA!I<t?bsAJ^{&`aoIFcJ5XHU|po8rTu7fcaKU9<(U^~3VbYE$_T0{a$o-B
z=HU_HR3LvR(_}4V46`2<n;>CWlAMjazG}3v7qavb9$Fpt^V2^Da{#Rpw7FB_3xn!}
zr-(>)I1s37x>o``aIv5aj$hE=^u8&Z5T07i9+->ID>euPT+T}07|$crl2lPL*>7zx
zw#VtXH~84^OjE}k3f+3Z+^6QOsZ8uZ<TrgRVvHxkpe!0qcm9(1=(S!P>&49_^7>)F
z067k(M9bWqj^*XN9Qn(@&~n?ID~f$D_}%rTG4YpXr`*itetk!PZY(5l{Y5yc|6S-;
zzYui5c?Z2GQ0^q?7Acmgcae~g+7R7G;B{A<uL-%VW5*{yDi#hw9V`|DzLx2Bz->}Q
zjS9Uk(I&5xx3aOp>OOP7f<FZ^=})!kg5^I`WJ<Y|)|yVBDJv+D=`Z}t=)A;u)6KTk
z=ub~U<{>D8UK5EYleJ8tXJST$y1S{hUY<|3;>Gk==>AV@LNJvHqxAi&h!(AllzUL^
z0o2w06pr(>J<y=RU&e>v;RR|Kpw@{Emiwf!PoBG^HUOpCsCy#NVCtds^YbGRY5Kp$
z4%{xOsfpEgTGt<3^ei)b1u0>7CL(fGFvJHsrNf;+1Az=xD9~;aXwaXG+nW8Vh9N1l
z(i|;gzjLMP%*kbDsOl*HOn;C60JMu*!;;zK?@Kt%HnJ1ZA-EI0^zh(^r5kVp`-1V_
ze2W2=jGm#P(#w}Gqi{7vh3|PLE)wDiOXoye6aG)6*{Bbc9j0^bHkR76Bi-zMW%*Qe
zU*av;DHXrGJPi*Ir`Z%Zoz?<^iIie5U*;FGSprzsu4&egtc_>4o>n6k^x;T18Wftl
zXG-RcwiUy09j*35p2QO^7i_MmGO>(8r5cQ{I;QJb5&4aDn%wxx?CxuaG|DR~=65kX
ze=ZNutb@aXl8l*RcIRtQ=YyFL3HChPRrjrNtIt6}BRd+hFEozAJ}`bbol*KUQ(%NR
zTL7X6U>^%?W0`1O)3R;U%Juw7ha|H=)?qU+tpRZ>*!v^;-KGGr8_mL!FR#gZ{pjsQ
z#dXqw(tg}Xygw`P-CB$m^Ps0($I{Kp%zScHQIrjLN1z$G=F%GGSD0f)!j5{}iCj@t
z9{vAaas%lievH>SwKy-c4Ev>G?gLez%F-yd-sPH_n$YTMjxruN{`$V2o<e&vmpyF!
z$!I`&k^yRik)h~v3JSO;dgp1ALhsen^t+?6F^68pYSIpBAO;{aXa`osir52{=zT$k
z7ccsagnKewFYTX3+zG!<RIKJQ=<tjgpl->2Ty61$nCy{dRecb47P`4{!zLyc8XbL&
zjoZ<$7THN(Y82wn`hb-Uw!J;xdn}v%)Hl{bP|#yO{(T|u5$H=~1ki)U6dhB4VN8|1
zekvSyJgjju70}~K>lmnH`B@5QzfFD+K*3eo97b=<HnO*FrlT0DNo#c>S?hmv=Gzg!
zp~z_Qzr5XCESUA_&|Q3%`*s_cK|-kpaA)@#DgE}Qc{C$9?KZxA7%^o%9FvukqiO^Q
z+q;_<{5NpAKJ=5r;j!pMKN#{=>ey}G(Bk;}`?KM{prBAeSIZpDMWMNa6a`h_#wSs4
zvo;TwyT7>Kx&bG+D4+Y+xuQP<IU8{x%XR#S5a<Q{8!BUc0c&h*3_L1kH6J7Gso)Wy
ziuylnEh`!9YZ;^B*gs`8StVg9C@7AZE$lCWsBnN29<n#94D91E+9iLUsk-l0qJO@C
zzrIf8!t!YMU#Y)T`vbf45JRs4kRHf`3TY!lX}bFQaAqD8fmnxzhShJ`nnE<5!t=<>
z_Wd?7UGdCJ3j}*o!tE-a0-f$pWZ=Jk%{@3cASU72@h3|c&k2)d<Q4M{Y><tOcUXxe
zfW<Qa$APj@_|=>;oZ_LPGGyk5LGG{W9{w~&tm1ds*A7TW{2yjD9t8$R0U(CHtzW+;
z^v0LTe}%Kxn$4zh$sBvNu`wp|H|5YjoeqpWD+jFQ$l$a+;pQJgKc!D#mzS5ZadE{#
zUOpo+kq~61$So`^9-^XBQc+Qja9^J8%Ed51(py`FRroP`1De|dpKG|DsK$Tz3R!F=
zG9_FKN;{;6K2Hcg4EJ%4j=f!PX;+rl7^t6rQ~7rn^^bRY???%~_M2svzfW|}Y^nLh
z_JGL9NKv4bj1V)>;Oww5oP$<rG$>rCtFJG1rz6^QbJ6{V0GkyJmR6P_$DQF?##_X9
z$c*S)DAXJ3A_>>Xe?{Sgh56_g$~=EOIl5%<)i_P<YNWr<M~^HF009@+OLl~iP!SLi
zY)n+-XmOB|dZ-BkIVQ4IvZ1R7oRgeG+etgAZ_~bZj!qVz!!-Y*r1X#P5EKl!%lZle
z36J0J4@R2I@@((z#!wbA5El6^{Z5q_<Yc3UKY@kvn!a%D=M;ZVv@HKYt8};Y+G$0T
zLQkc1q<Spb$|}z4_vQcTrg&rlrRCNkhbR9bvl@-UjdP1xT9)=SkB#BBBE`Kt449@-
zi<AFMS^U^w$i`hj#zp*p#g?8cQqB3b41}8qf82rRiXbVAk}K)X^705_bPyXpsin6C
zu1e>aUz3NCuo&Fmi4A}Hs06?`S86uZSbiUL!3r`!%*fR+QCE+n2@*YgIxs1t>*}L=
zqqCT{0)MaIk16`AtK<Wa*}#2x^*`nl=^JXeFZ8cKT&~$QR2r;-URqHVp_zrN1=OV7
z?__cAe)inAW)NMl^)H(D{hs;24c$jFK0-}@Ix0dZQ8t&CW5~5%dRmdRTwn1PzynTB
zIJ}#4v+cf5X>j6)oc%)KhMX4!`sZI6utPhucPX1r`D<P09A@JjS9vg^lMGXEVc<Zv
z`_I3)q4zwolCC*CHo;Ke{nHbb79AIt3P@pELr6Ta7=mSIa&wE<evI|ElY88QeE{lP
z|N1K$oFW>o<oACGqCYSq6_t{b@@7FnMvef`Xw5ejWn~E<{8tcy@YfIj{;7MgNf6S)
ziu;z=zrQ1B0{ZUxNW6UMyH-%)<Lk?v0Q!8nt7;NxR+)x%bxA?pflD6-qG$>5c<9v2
zMMsM?semJ<sHCJDygpf3Q0oesR;RaM^&O0;>To6e;7Jn%W`cV`#isN3@A%8T2wubP
z$PI6j5d6?w?bkv7acFq(?<3LcVL|4|u3X@Qb`bwSGEiVLtOgQAQ{hQTkQ@Pk!hQ=T
zGPzm%wz2VkQ1=6Zp&F0*c&X5l-%u@l`d3|3kMJ%`s4Re>|1$i){khfyn?z}u&N8Q0
zO!V(VxEnnTPadv5F41YyHt3CC-b$ZEf^QXWeO9OW#dVqIv;DXo%|G3QAr9%?$z1<9
z*`#Q*#>)%}*(#7w9DIZWPyqv9|BGOCW#wln?l-l7!ZE@TXqF^8?~~T#05P^lYQkke
z$N%-|2aMq#B(8m_PDcKH!c<`bmGLMr8}r3vf%GW%APFR#oPt6Ow2I0C$zx1BJZjLm
z1&2>nRyKHRx>kvXmR55qk?<KOd@zBvS7wKSgo|kXQ3wesAN153^1Z%D06NL~%W(p;
zvyVn_UevJRP>bW=6A7-;!=P-u&aU7b>j!S@lBUd?RuBInj^dQDpD(5x1*7#}?AHa!
z{(9U6Q!9|rIR__pIL8A1m<iwp54sPQla?*I3{4E}HSRMI{=;M2!zQ(CRq|o~)08F>
zoX>NVld!EeqNaNhSzpfklS;KKzl*y$$_nY%<LM#T{SaJ3c`_l&f4;`k16?hwf|qoq
z<=H<Cgdpw%q$4C|fq%HO|61hef~l2o4-$>&)r0?YpMPJ+|G7Yz7hsf|=blo2`eRuB
z*WpDJ;Bb>pYpws&#XR@`14{*agTo~Be>&WV9vrSA9sTp^|GI?VuU)Vi8J!bjulf_x
z|Lt%SB-^fL{~ac)@E;DTYqbBgLjPhkO9XR}6D3}4n!w3CV)mk3>>X?S!Jl-xGiI|a
zDcP`8^D{UCu+GL<@{JR|g^;|+5Dzh*?Aro*V837HKfV$~e&|y<Uj}<4kI#ycG|<h~
zzt;9_!t7{kvZ`}rE{<R|(I)s+GH>TI&Yyw9%Vixm^fsWHnO*X(#`=5->rM{pP%SPl
z&U!>emE*F8@GtY=mw$R@KeUYx#EO60%3{<i9Khs7h54QLt<`rQB=N~(!0P;-mvb{{
z&XHr?MNKs&gyocYmx%)P2MIP3Ct|-m<9}xI-K$h}VBUU;N(vQY?{pP&d=R$ZjfPBd
za3HgeJB$kY19{RheV{}Jo$UKoWA$@uA8?3bWD;BqcRmFcLbt?iZ6gmYe_;IgBlzXA
zFjDeFCE-k)cqZIhCp8;fRBp5Rasr}6&cqkd@Kp0UiR;6=Y7E|Tz@o%sF$gpRx_Bw$
zc81G9NjwJmMSb(m1*kn**12_RGk1Qi?S5^?b+z|Z)SKlC;3;>>30!Y+1^#)h|KqbX
zqZ~-PPo*Vo`2+^WQGKc>5EGv;RS0wRzDo{!3)WLmdEr55*$l%B(kyXoCeZ+u?32_R
zgW8)-m&j>rCu`Xbwp(wNbx472&E;&t@1!jE7n|<izI}igHpuy4hM2{4kt-wU6&6yS
z>sG_ha3%ff{idtJ?eK)!_8viuQF>t~{iB$@2d9{raB`o*kQS*9I}l9Mq=bY#>n}D6
z=xte10r3B~v;TGN2_C`;$5%VQ*&#|Am&PO#!WyOf88Q5fnS0dq{iuIex#C2bTV>_M
zaefOH5;a~i|3B;|e>v?y863CPH~%#_l=!vHLk2sPUCONBq7jv-bb++D5TXX>e0<(C
zbsFnxi@XYYbRK{W_E4~29Ce1awI!G9if0$9l?g}FslR6kO0(G+%<#+1$(b0QtFuc0
ziGm5UqPF&SNo(uynQG86iu%P1jwwKU1HwmBg&>TW()|L^SbBgVlwI0yeaD0(e^o~S
z=rc&R8>qg08)iCH)muAZ(vVeLVA!AREA8bP4A4Vqef_M7QGH3Eu}x8TB_S%BX*yo2
z4WM^2&?C6KgCiTDDevg)%42}onxu=17wG((Fjfb8_NX_xHR$+RYi!)a#qso91N4&?
zk;Em`D#S_J$mmmTWETK3Ru5yH1Udro$VYd@07cStqFe=sUc-oFc(u>;|GyfzYXoCj
zy#2Ozo{t$J$Yh?Q#t&@L^-WPsB#hNEa8;>V`0pm|Y}l|LRIv0e^Ch}^D$7Yogi15i
zssZI~GC=gpV`1wp-Uo@scxgRChiNNozzQ4Jopm{saojAb-mZFmq~=HLlsn@9dNbjn
zP2k3D3*4U5ajnGaZkZjc*s2GEHT9isDN0qlYBd&+Z9zNKk0#KH!J#obAYb&P<x$4A
zl9u~5iXsF;Up-@AfG7XX!czGmGO}2SJHVoXwdY1eP`N~Jj&g?YMDh6%jnUgKcil-r
z1DvvcCMS}SE*db%(F7Lt3Ohg>h2>uB#+WLK3)k%xaw5clkDUDLnt&Vv3cg-~GwM)t
z6zIgI9nApQsP(^F#Pdq2_4Pfg?Chii3h=Vr>(35{fXAu_7~@38%(V>vurs9&KUlM|
zrN5Yb8@;hdWhDHfPF%}tP0ety`BOdJTpSwy!$M2qf}%~p*@|$#-h7M4Wu4jY_wxe%
z#s@1n20Y+YnH*f4(IX#9Gb>0u+0Q<noXbb?@^nNjt`|hi`dyI-+pP0TKy9Od!$=qn
z6HpxRJq|+Lr|HPZZf>bQfV|8YQv4oU-hEWg<_Bjr;s|KOTZgB@r!q1!QBAkklw2p{
zx~@c@-Trj>^$**`DZjViHL<wAqzpRX_WiXl<R#R6n^Ohj!ltnQ4f7F-Uc9Ajlekv;
zMBo|*y+YH-p}i?`-8>S6U4&%AVOzr?4x=~o4ZX-)2$cUB$iw_BG>Fjd?xyYeL=aS0
z_S7;FvHaq=GCjSuwsY4>6EbEu2B8H#*(z4EY+iF%h*j8vJ^~-6^iCjlBRUXu?m|ze
zSCAD^9lijA2ZNWZa+1>0Y%w=`hFjxhm;QYnswWuzx@$ERecVcvuQ-Qnu+08+e=ZNT
z90x|MXLijQ-DQcb^82lRy*5Y(;Nz1qNd=2vc~d%NpPCGr9(h{z2i~kSiaGL#d4pPP
zX<)rxKh1dejIRD9tqygl2TQ}6r8>4```X?8a>@=9AAckM+s25=QeIASIN-0wU*juV
z9duG9;87hpu{}@YT0S1r!Mz@2wpvtR2JIOyEy2iSgk3LUKxckPX+mNivzEOdq0yy|
zK+|jS`gj+n7^K!5bkXXSG@O*b5UMcLvTQj&Sjz~RaD6Qnb35<|tuNiUKE>V57Zd<g
z+n)kzq8YJB3~8AZko?pi%9K0+d`)$TwocJyA<PqiI~34q)yTV@Er_#_lJoP=&Wi7z
z>c>C~sw>l5NOfF~qk7_xqY6Plp{S_1bhqhcgd{IMtm6Vc#nR>Osuakinz;XFs9UH~
z@q&(aU3FkQTO7oCp1{Dt%DgFA8f4~nv~bp7!QnR<%lqY~gl-BeM8uf}gDQg(Z#nxM
zC3(Q*Ui-^Eu=yvSXP^-%A_Rr*eUey}XZetxovm?DQ3bu2ssm*bWcLwKZIfP;e7-$Q
zxwSnu9`zs7c9sF~Ecuw0O{Iw@Df{F_9q0`}=`hVSBL)=E>45e}^*WpVmYOqAWB$5T
zS78kZG+YUaDk>CXkW-F{N|Ts^TVQj-0FVA<vdaOIe_-Kt!;mQ&3cT!^C#w<A_9BjU
zJY1;_)|8ijQ+<07W3!<*2+%iYz4f82li2O4>Td8+8sJ~C6(7p-uzW=DTf33t-OuEU
zet5S*3T`5S{RJAWJk%u62t>arljLKfhXflzL>h}1UYM22N-95xtY=`*_4zTa-p_AA
z+7+a1>zP|VAk=-G8ekhHjat*%cym7G7A<p5u+9GXPqX?z?v0lW>9cXltwal9Dc_2T
zLMJWjd=qz9iEY{nQ5WlYAAGd9sfrH_wLo6~S@pDaK|l5S*OM_F_phrbf)fMLV_62t
zLRhkXAUc~owxkA>rrL=@pcShGw7j*hLH~C7q*Npm4~D6<)6QC3KLh`9=iR|k^pq0d
z?#yuuVI_O>vFPv~_EZ$7BCVc*=4emwSc&cII|12P%j~zQLjNMQ1qCqovI(8H%9!=O
zqqBSf63#7)w1OpRcw2xIZhf(y)19l3kqHtY@8D(D+%(1>NrTK^RA&U$*f~!@nr;P=
zXB7^o$(6eGrg3$gK#Xkdmm<0T^DAsl>t==UY4QnTKHWhZ`=oyj``?_Cmgnd{Jh7lb
z77A6$NGO{$WNE}L=r8wts?%5P_|Hz*vnwx;G_(2+RuU}Y=bqc0IF8Oat`h0u`7-zK
zc)YJ(wkrZEtg|LBXlO7Y)?aDx=jUCXWL<*}A%T?>E)b}F5uL`D?<1=d<MoaeYvq)E
zz)oWuR>(r!=fG~ElruLG79anff#uyX=;eUdZPQa8udQQO8v>Nboi#&<`R?{E`-I<S
zOgGXa(5@m|Ht9W`9h*Wu{7<&!SK@?LK6ppjaphOk3kwT3k8~fwZc{SSnbjPvPjp=2
zMf2CsthD%V;&SRQ8J~DWanb6TwBSHxei^BFzQKO5(d-Y2qd$d7;ztj0&`VmIq!(Uv
z&T($Y;nL)gkg=;AGcy~>1LF|=5gC^|fqyeDZX4S6so(#)DviFxWPgzYMMgZa`$ge8
z$M0GIZ`R&ij}})Ptq*rhU_%(%Q_6uE8!Me{P|`B%_hq;o9N<1qR;RV!8eedHQnC$l
z8qf=X$?m=%{+E|xlq~q_Rp6@xb{P;0SukV_)@O|D@B#TV7F{v3kWUP~Y3?_hmtGSU
zh6yG3rDL-&DScdu;`cn~ah`;8{)jSLtf*x1zVwRa`=wXv>mmO6<2*ApElnthDWs+8
zCoqy?pUvoEWu_O3K6MfesJ5_JF`Xc7cZ5z7(e#ulf8v+#@9R4;k-cc<4<!i%&!1jr
z2ldGw!degKf|)Z=dME(-=cwYUl5e2D1SElVSj07}riT6SV~JIR6Gbh%vBrt2w&TRe
zYSF^Eb8_Mqe{i+y8X&>Iq3`Jk-Uf~piX~I9uqXj3vh9g&2hEr@OPt=wqft!@e*?k;
zIwv<smq>>^Sm2&34-z@I&`x$npasj9GINt=zeaT63Iyd5WuH3<^(9-3R4ea^=3<1R
z<30X)?Dl>@RKYwLJkXhSmvM-?`ugd*jkWy+Ulkuh)v_I1WJ^oR=INskYUP;=bU030
zn^R4r$1g=|Sk%vK%=?-A{gIL(+TQLPj}F!(ByybzL&#YF6=lVfmFjonoP*v&Jz3$b
zSRboXKl`GVv{+$aV4N^Q>?LEi4~`uY8ddi=c%oe8?=ITIPf%3NhcI!U2kJ08nvz*x
zH*KyY^sCU2R1MyX-%@yifPhy)Bi3TJr0alLw=;+a3CS#$EYyqA_Tb{pGgj6g^{B3v
z>2^A3(mg^=*K-4DB8j~o1&Eh+cAG16ll%CLZ{cOW{E#uqW8I?XD~Yb-555ap;0io$
zX0qL1S^($`P~2%j5A5E?$opu#19pMx6$a<W{LPhEL9*lnEZH%S<Vei5E%a4BUX^Yj
zR+!flgo*ePJ=I0rdC?Hav;g@^kwYrZzHAyEvg-Z}J`4UBU(8p$Yv9XUW={RmN3V!U
z{RjCdprq2Hdc{#AQ?EP2Wu*10_XTwHOBypMip3L6Y;5(u%%Gwn$B2jrR!{Xwsf*=Z
z)vp*D#z5w(ZySf$Oy#0uMy6Dy%@v9pdMk!r<fS}o-|4K%x-II{;h3}eR4}6${hq^q
zAi0p~V)d(BfqUe`pR;ZDArZRY2<h*KBgV6T)c;uS*5MRaePXEIn6+SPT-;eDtSed)
zR-Dl{$KOAa4cMK3kK+VOAF>iMp+8eyvDouLkXbUc;3&z@FBi5qpLy1B@hJC{#=#sV
z@fFsn=y5{E>v^A(peIaPI4{gOr-Yi^t_wxrmP|?^szO3(ZS5m&^8)XGXs4r<;M3ek
zsBvGFl9ncz%xc+&+Sigi>`CB|11(-^5l#;Y<+Zf7Cd3H-1qR^3s;jFr>wbHbmz!(!
zP2s)6h^aV$R_*-|-km}9VnFvwS&CANTi2x{E5q@z!WN9jBT?4ZyCt};9=mjWLGylZ
zUoy6}4Pq^ymn6qn#PnO4S8XDq^2_%LY`_9eLD}V(@Fz(|TNZG}TU6n3G1RAxHYH0j
zOSRwBf-2B>rU)%6`E;PZ_EAlQ`?&q)6-7b_jj&V<N!D?EC0PkEUEaF_^T$sn9S?+Z
zzJCwoYq^KtY`KFq>=HbJLa!f37_(JZ^?mQbL|6=kJKs)8@nL~sllJw}Ck65Eh3z_B
z(sT7ole42i4bHop+{>T0PS92?Wj_5H^p?S1WAwywy1s#vi@b_9YdxT$KDrSqu5?`;
z4N|P3WsF`eUCAs_SDzTlk@KBlGoP+OxKEXykwL-4G&oCzPTOJ+frpQ8$UNbHgvUHy
z((DhKHPoDGK2;;*;pw*P0RrYMDD?#q|N3%4=z}lH13t2|c&usLK+;A<XDc18{5U5+
zziTJM%R?zuN74O!c=tvR5tp-C-L6+KDlFEVZCe$^pvLH+9ViQ3!qo9KE36ZZY3>MI
zx;dVG^_!&E6gDv&dLNwS-POampEH-Vvz4zTU|oWw_)c%~!=+#KhN($Guq&Y_7BF!7
zCN0rb+-$4AGzzII@Z8GtK2mJhyn}4@3CLdx_O}^y^yLObt4eyeCk32OOwSKf`pZ`t
z-L5{w3Ai_29Yvf*w#O$eHeT+S?JtvUAw7BAZ$ZdieXfbtwwZ6S1NwbN0-E@Q$X)z5
zwpkEJxGrl`xIUGj399VNHqkpforh$h+{XX%Vc{C?HmFT}){Kt^X`E}R-l8nhA3tt8
zI_G#|#RokFw!9Ij$-`1>y-$KJ;DH`Y+H`TXaVzEcon@ViS`1&6-cR}%+j&viFKvhF
zYeskWwGv9o^@O@!Y?EU&HFTh|M7Ke&)@YYLuQJ5Y==$>-I_|EX>WS9z#459>tF@rA
zv9TQt$EPGh$B$bPqA|)4tE{uQqWkjJ?Mwy>aqH^8f7=TBrbtv)9>T!$4z55=e`q#h
zX@+DjEPjUVwQ546LEA}Le>ItdYlC#z`2BzI%i&;&7%YW*H<6P+NxlmIT&_snH%9@1
zib?bz-Dq1Vks`{h`3T%z*>C||5z=j^W!3)J8ieVcfcyd(%Ov5Sv!5y|rl8QeuaS#E
zKrppM4!>wO;-HY?!mK3Af3D{&p`j5EfJsT9h{6KxuPE>5zx)o`s6l2(T=vomW+K0V
z?2H(T>e^QpdJqY+xQX|Lf?YIg_G^;U28sUn(6p7<&!4Rwm%_xe>g(%gUB~|gJrB6S
zCcDpVFstSy*~i;%Yg}5Y80NrW$0rH9vzA%_|EnC-hnysE8lpadp&e(d<{VR#`bpf`
z<zQH}F;!5a#kem_%~nppDJ|uaPsn*j3Y8`~XfmZEVlwe}jw|0QwXD53E6|tNNIu2I
z7q!|T%ju%EnckJO#Y6AU61+ItBF{t0TLBG{rI*+HQ_A~sKSgD0I6<Qix|nOHYDf|S
zQ;`bVY(v7<bLOZOFcb`8CW+s`sb7`8FJ{Z^)rLB3?{KTiO3v#q+sK6e+6V-puZ7+j
z0e)|)KvJ*d_3LL$MJ3l}>~bY1sPRv@ZF2z{C<a(j<x49o_?ziXZ}h?~-KS(p!U0%k
zVm+#EI5}KhE@gD$1!|w9LAxywk;I{`^O0na^RQ*4&so|<gF+nc1etuqRy#I>Mf}`S
zz$XE{xXT<8xb5-_H7YfLpq0g`dX$e3T<uDHK~eU(hO+XKU7<;6N)U<LnZjMfO$<cs
zJMcDV4e>nLb;e!$y4w83J4tT#5TONibs9%gN!WLxi)ZuWPoF0b?~TMS42qLLsEk@C
z4H`BsJpjW;oBwS7z84i;r0h){wPD2c&4rmZ3$9U>cT<zK5>Xm56=ZG0*|D!1EFxP$
zF_n+gx3kv=YqcSgdLJ@t`+XXM!#Nt=MQ93WAsuTEg0j_|pgU9o*CDh<!X4O=*xxn3
z4G}7#rM%xAs#Z<0M@sy(y@DFfQ26}Is^~ws$sl=hf}Cq{gU?%L0_C~%Vw;tMF|8~b
zOPXSrS|~n&B>yb$W?=KCw3WS}S3pVMd(D5bMy_6GtDYnipY6QZ=5M{|PxamHa@$bg
z)u09ZhT;=?6%ed$az`3)ewg>XTn-gM4fDK@C<S<+kg034FQ<0rJaQ(}-e~-K*(z0&
z7f?G8(s%yIGYmkGGV%`&W@lDPe1^t%l$s<wgMWMWQ%-Hfpo#zX>QGTbV}-j<=jH&n
z_Gj=^?>(d>IW4V3$B><dQ|&l*vv`xjZ0oW4$G^oF^AFeNsQcbk+8Lu>+g$Z>%tcnu
zxlKK)J9^~Hv-pWT5vsV`277ybWn3bJ)hO`}+Tm~DUHaJ|FShbbx<GxkvMzh_LF9*-
zov~AK;9`t#2P+#FW>uT?zvzt7;ka2ei*RXL<WY5hXFEKr3q>9Bd1)$|Xj0O8;G&xF
z>*?J>H}IB4R*j?Ga0P^!KkZhlWE5*ET)ioe2-1>a5W~VS(kBSn%?o9wOk|t^fATJd
z?*x?5B8HNZ3&v%DZ?KR|lGu;G)$U-eQmUW_)C-Bzol0Y8yS&e!M_LbWWO0F83;d1+
z<%M(bNj-!6s!`A|1v6-y;7TsPELzZQo6M~Lc}>n$j71cLak-6TL6g~d<iw6kI@SP9
zo5E8$68e~JG)4l6{;Jy9IYE7Uz01<bJ{)rAI-!%o&X!B8&vo2Y=|)D4AoS}S8g@@s
zngj`4%2mdk44FQTpLoCA6$N9>_9}x9Zq%SSst8)ezVRb|xmlf+)M0v0Wc!q$&x~xS
z-BhDnT5ZZV8zmxYihFcdTZxVyZFTd4Xfshp6;feqgdSN*C-Lq_a<kT0D!Y-7pS?{|
zR(<~TKRI!X$hK$ANDW;0yn__aL>D85U1kgTgs^t9s9aFZ+fgpe+)+478~O5chEn}N
zgUEB<%?P<0@mZ&Ci3OfxLOk9Nr5NAQjrmCjuOB{qsJFk^ZZP0Oe3_dOeBhXvZF+Xv
zL=w|<z0F+$-54V4rQUXg1SOrClw7A+&3#_#Vd>wyxYshZe`o4-@uKl&+1Uzq0n!o$
z*nvu*p2wGag5HIQlZ9otCS)watQ8miE~hVe4{2>~H+dOgD%S8aYE#Fq%^<$g1K@F0
zUC-%5IN5Q+r1J9OWWS?E!Ndtl+gH|F<*#^#l4`rg8ehAM_izqkOLu=gk5`d*-?P`Z
z`)G^o&**@(yMg+~k~oKL^W$Uq;;-Tk0alg2ZR&qTr_e!;{i&s}g}mFSJ=3UC=-KSL
z-Od;T%dqGrqKq1r^L~5G(zH#EKZ9!;9vtg);U>Tt0CoJ)fDYHxNVZZ{!+AQ{mP}o5
z7rJ^Mua|D&Us&5t?W#7{ZoSQ&OSYQ|!>0|ZO-jB_Ueh~5lBMO>s%;2p^!0DtBV=Qq
z4Eia#-yEtlgSfW@$BASNa1}rgl>9OM*Dk#|_0zYGYfQFCG2IMMtv>EeI<B?U`>qJ`
zTa%U2|Dv4s;QnS}=h64BoHcIwr^@vM`a55!l{P=-#K8LcRW?N}N$=~)v{_K&&`~m8
z&}@f|UvV0Q59-x8gDq`=o22=rTeEs*tXTkl%c@Ad^F_A}5x;LUQVb%>FHk2Cdatp9
zT`A!%H*n9#Cvp<ajm;?ijp00;%o^`%Pn_<}S~)K0LCK+X_}*O_Tc&@Tj>rB-!%0rc
zP03nF(=wP0Owp?~t*=NDBY$*%Kw%^Ku{q7xjc1s+J~8st%)NNi6Oq{TsMfYK^cyxr
zR{!FNM{GFv6aWloos7&LM~q&gT|tFp3HpFgwJ3+~gP@k^c7YefWtUV22p$J#KSR2)
z<ao*Q^74jCbOa<N*Ub!AL4a4pg^SXY_M1-^<6$`eRy+CfZT9NO+6TjU_f<^IWL;wi
zR8OLF9(>m{rm!841eK}RlIB*|XqS9)<?p&5_7|sGaI_CiiH*St>-kjsb6p&CcXBSw
zr+)rLBsI_i$E`B&Gs^?1$|x^XPG5AEQqT^L#Hkaw_bBrcYFDsZnZv@&yadAN@|=Qh
zXDyd~3i~Nd3LrM?i$=0D3A!-ht3tU@T%Sk8O`M@ECaped+qCZMpQ|&d9<W<J&S?lh
zc)PZ%=-MQ=%_rXXFN-wa<bm*wE1(h4D0gj6I=)j%+9qb`{hF33nu}-tMqPIUE9>Ug
z6&+qQdk-<YNoUN#@J7m(ed%lAAdk6~$ZR$CRhR8r3p<&pNR=o_(eY#o5$1RAy$7dk
zv=jdooc%Ro_l!n=VC?S=H^n3s@bH=QVVwtRywUf&#**oIwZ{v7Hz1?dSyVl{c=-1F
ze2e!o$Y(&SHoapC3+wQx@VOmK%y)CgM&b<!e+&I=kk*)``!I=#cTAm%c)Tg_HEy~$
zVb->eU=tk7?eU(8Qq)X(PChUpWqjHw?vg6YN4i@1%%qI3q-}?ff|+jUpD=}3cy7oy
z|2K{5$u{n*Ne)X}75!CEyV}pV+OcHuV!~tGV-#c{5l6wt2XQ);t?E#Z0{sC53h?Di
zh>q)EAI5e5Hf4&MgNb&wWSN+DD6s1xYHDiRn*8q3fd}@FF1V|kffLT)@xzBz70QO6
z28oYGNiVMxuKT#v`5AqfuWB~0-PYo)Da8qGpp%`UOY6C=(rI;xljWlPxn0N8e}wBE
z=U!v;sg<N+^<PHF8Fcv|VLhWSI`KBSewl|L54NpkAPo@;YESAK$+kf^YHd}hr}evk
zIa{a{p$Q4JDk>`P;6<K2dj?XEK9NyTjtzbMt`{{I$PZy1;+V%ojo~7jR|p-x`HT1x
zJ}v2U6qBNr(zH#6&pHo(e<defUF;kkW4wj*u={hM>nWUU+b9-iSaK{w*n-|Gqrlyg
zxE)geFv$!+9eG5m`>PB*?CVq|h7pWXhYTbv=*i^fQstO7miw^zrgt<*v45}V=O6Q_
zsGMN{<2)%F$^!a-!alIogMmzT(SQtN7;uNi-;X*TPvaPM+m6IB62VZ*zgDL_9PO)E
z#lggU>ds%tei+x#B2B@?p#JidXj@-;rnvCR6sqK2?U#j8F?I9$;Pc^D8vYX|))8mH
z{q>)Hr5y_Ua&M$t3_9tHAPhz>O<%94!W90FgMbTxtGS0q1$%{X&e8yKD>^GZ=dXjg
zR*criN>ZLtokow3KN&>(!j=lM%)+cir-@uPOW<il0_K@J>eP-d_l8|14;|KT5T^~y
zH4hiaIQ~EO-ZHGpt!o>mLsAgwZcsq!MpC3yx<OL9I|T&=1nEveB^KQ+-5@2o=<aU5
zx!m`@_rCA#^L@|z<NNm>2S1j3FV?!at~uuz;~eLCj;q=UcZa@v%MZZFYgeAW8n(ve
zbJx>w(Ho}zVu^Q{04XL(0Pa}zjTD!l&l6i!#aFA;admY#07Hnw?z;JmIhH6jdec2{
z8W5$%CUJ=P-2SDLmQs|aTB;f%;rxlsVJ-r3x$633+(@9xgl3g8<PusAc{EF+?P6o^
ztnbrHaFC{y77c)mXMH;)<2?FdG1}_g>9YY_eQ^}t3G%*&*j?QNk1vlJJ3<)sX<CMZ
zri{LxvG3h<yP9l>4EK^pdeX^BTTxCVH+J13a^U?Zk>ii!!5<Fro@n4~pDE{*S&p;0
z1IL1-5=*h&;TMIh=|c%*zj`Af7_A*0JwQ~pAq?@U^#RQ)=k`DNa=MowIfzJ0W0#A4
z@CjC<F9rb*SrReO!7xWLmz0uvPcf{yGLUAAq9Snlm3FSskF96FeR{kt;ai4MVZ*`P
zNYLl1x}TV-Yb2AZnKW6SWhyCdD8{&LPJR?FM+Yc<0##k9KBu&f^VO(neQwP&7t-6|
zmpW<>)Ca1%^F42%9T*~!07Nsoy^)cU?3yu~rFExwH}!iVuJWe7&ryF83&X2;hf~l_
zTt<nELpD|WOuj|%F~aZf#C?NrAK@DK<^Rpy+N0l_afNo(xtGf^uJK(ncmq6HQbuOn
zoukgM1x2&Sz`w9%DBMpUA?@~{`sy^~i&OwnvJ@iy5By=NxMgz-kcJhO)PRxB+%4|r
zwU7ihE)EIb8rMymQ%^OnrbSCyxE4*WV5SC{Iyz~_$y@6O(30t1<9RZfdPDz(53kN`
zhAU5+Xi>@NsddlHva!T}SN~8kA)f`ZGTD+wN&oAK8sH7mKi0}JM|ls<8m;c09&d_<
z+}vj%!Bal$Sf%1|GWRce20VHcs`si{R}&{F)U0$3*)Y_hk6Z}0Bb5mIqETl-nq&yE
z7R^s&y>&Y_O=xsU1#*f6O&T4<P-$m{a<jO+>xHe`t|`%mZNNGJAHas=v*%Zu*KD*g
z7hB<^&@><|g#lF(RoWyu=`Or2otmjViO34g$N!c2{Nwh&(M<1|YnC`!s>NE#GuZjp
z1|Kv9TyYa?7dFMEMlnDa2jqMyaPohyshQO2mxwzX%ob$oBjj8E9Mu~DYKhL?1kNPi
zCTyp`&p+viBZQv6TvYyS>KaD8RYYqWWYs&tgiMdT?U5}^<Iy=6P2GNl60iCAS+|_=
z(8b$G<@jO9;RYIGqxn|$<JW_!^uc#}Fia+EePcIfj#0~;0ykGk{_5lX^-ADl)6R^i
zIQ>yf)BBH(`qg-UWMGq$eogOr3|Hvj833EkZw5DKcn9Id{ELGtO1;QIwu}{>)YRM0
zy*k(SwF4pO|DE3cBGQ1p!fE#=Ti{C7=+`d%D{Jv%ey;L@Zh+lO?HNl*Us`?C=@XQH
z+)`K#pH6^=F`2+=|DRc*zYG4E+bC+L=>PC6bp1l{n|)9dM1KP~|8)_6zT(mZe<{Oo
zG422A-AFKo^8fwt|Bhh)Ki?KHjUs)x!+%kHf2|aMVFW}JOb%GeQ3CYC8h<V5|9W+W
zOSKqC`4scFQ13r7%#X}qwRhAN>Ja>|R>K*!*xdj9@PFK@GiuzGj`(y^!2b-!q#&cO
z_joJ!>Q&XqNH7Sx6)1&SW&?H!92s!{#dxZySZxK>W7`}f;H{!W{I7@i`+rjLAq(it
zwMH|`0^Exkk92CZfi^pP)CXA+D0h=CCk07jM)N|Jmg6crb5*7KZ8p%#s>Pl?`v7!6
z(hXM!a<o-n^7{q`(Emyywe+cYOd>Evw&V{bYhA}X7jP(JJ}g{~i9Ry>EwwEjAH(Tu
z(|g&dNRZuMmaT1%^b(Bgi)z@^*(VsA#8j>o^AjQ5+|hBHM|J?5$)pw_+{JVUZcZl6
zZ;)?x`uTn(&2aagDk<?kHpT)(u$uVNyxiPKFbFiKIpHJGBXJZ=qQN;neMFe~!{O?{
zX?X(RQJI_hQ@nru!*Wo=^L{b21f6H!uT<^7cjK?)xU5br2!M|t?nH48$QRP8=+<lV
z*gW_)yjzf!pReVz#T2)+WCQ8@^eN-9vjt`K?ae5}hXk$ct=QA2!DJq587JS4;HO@H
zNs*oleE2JHqp`tbdGMXh1<(WH2KPR&h`S`<dt^5!Caa*}ygd~!?dHbkj~@na^xz*0
z;$QJWEQk=+Wb(e0el`xFhLG}jx_qoVnN;f<D0Di$w6K~~VNusD*EpHsRqPjSECfA0
zwo@=T6-U2zC|oS>4p3cuKvCk8lMEEB>ZlGAfPIaa!5tWh0h@0Q?tO5u`8fK0Lc+?;
zbAJB+=^Ee={22xf5g32`pxOM{pPaDlIvD7<`WEAGse{tU_+W{yR!~4d{s;`vh4rGu
zw9!=5)Vjf7TH~e8PbcdDIhOdBa)PP|83^u|qLmdNAqZI_K2G9X?Cq6bAM3k?t7&bO
z9AEbVqViuzBvP!HtW8ezipl#e%{CbpISd5LH@&|Pc-Ty^YqPL$skKpZcMr3gT!P|}
zL&$wCALwe$-ANwYfyPpu@+6BOX{j0jnBo_(dzbcI4;T||_&~I@SaqPI`PZ`6QcMSG
z2fY9WF1SoECpk=H2xzV!Tr4ULZQTbxVdX)wad9E3ac{uwV2!AB&i1<AbwqT1(~J4r
zIQ++DeF(|Ztz;AuYSoxc4^dICMP$(lAemr#=$w}Isg{$>-xS>oSS9=`ECbZ$CxC^(
z5H{DyxHy>6-64s}&`Whbz%w4tP|Met{}&<Sw;K!&{u4GnAJCF5)}$qpi^q+1_T+&j
zG8O#6VOT|N=l=B{xC(4th28xMfy9E<*aN0N81GD1x0mR@4V$RfG?ED=nx9NF5zryy
zdZR(b#iarp4*{fdE(Whp&+f^t33k`z<{rG9sGcWW_nq6Nf87cHQdyT?Q0;~)iLgKV
z!-CiQ;B{u=OGTc_w}F9O{b3;{*VC2RTu=>~tW><wyztK-h2%Zxa%7FI*wJ_Inmx#V
zL5G}RNpCyF(lu2gey5aY#1UygLHF~jpZDjGN2vPrwmpx(Jzza4pV-;`6wkI#+|uU~
z^GL+8E!A%-eirfb?Gr{>l|syQlDj4k5KAN+!rX1Hmob=U%ll@bn!r^e9Q0FqKu*je
zB_-9b@Ou*aS_DFaXa+_}&qFpyF6SbJa3TfYUBXqpAR*Dl*YHHn45NV`fpI0VpiBPI
z_LTa|mmZ{Y?*cm^x`JWZPkDL(LT_n2YVO4l`t>W*VLTw=MMg){fl+{<wdDe%3B%||
zg_<XTv;|DAwu(2$3V7eho$#&m>d1tVn0STo$kWi!gat`$nw%dHv?udUET+J^IqRc&
zUuLo$_g9-ECow66I%nBA9fJV>c*=U<1B89I>;Wq)C&V)eP^Mq1L3Gynr)|D`{`^#4
zzHFu+$a(Vft!lRmV2tQ*-<VGrd<(l~n_t*p0EpqTUM0w9P1v-z;juvz9PrZN*=csr
zEHVDJ=FD56(HP`?VNBE*^i5hi4tJuMR=L7z!XhVh{Ad>|21p|0q@`<wtu9aGnVEi;
z+PH$AA(_|SllEN|CBVn#Y<ypEYI3|Ws&GMGsr2gv1jlcF{)2=^M(@sDt+f@UZgs%y
z-z4wu6hT)QU2!JojTpzBwaWqTlZg&D(NBhTj61Jx6t#(~J#Yjy-YK4ixNDLyz0iC~
zHIr!x&1=uWjBL0hr-j~}-r+yWWTbl_^n+p0FZgH(e<|r!=Ya__ze}Sk@uOuLSyJ!M
zmXwy-##WK$cH$Qz_<d};7K^KKx74ZxShuHRwA896qKht@&-L_I>s@M%3tzjrr<T=!
zjPPGnEDzs5HX8m6^=Ew6h^Sb0S(bUIuvQy~$+vXx{J0*~WGZq3vOPJNj*cZilm_@^
zT|iQ50(zpRxEd+VPQOj;2jP(f<mV&}4QJ;3DTKw7yh2_X&G_RZBU@AQ-39t8a2Tb+
zsCIbwSFY7`K@7}<Qh+&bsGoD%Q=D6-+D<pemHLHU6EVs72Cs@Hriie72JbC^5NTD9
zlkaTPe{T*@1_StSDyD1*bO&a1u{o1SFzo>}-vzoIx=BiW^KJ>il4_<BNTop=YTac@
zeYvQmy$6|4$G~<Lh_7@!x1C+4a@P<q5BmkxVX<MzmdOJUaHJ0U1#Np6(|Yqu&qF!;
zIS|-RN-w!JmLuiZ$|*0VNXcS=+*uv45w}tS7qbTdLgtmE%KV%8oMGv20=9L5M=7N<
zW<i)o!R=W`pJ{rS$aA|`qmTUURv_&3wBU$7kc(q;v^mil_jGSYUhM%bxz%CCMp>9Q
zgZst$Z6Z909*(h-g+Z(PYKoaHFgw5jG+k(f;BK;w2wX8Q9}CE5R}eec8<UsUvSBzc
zQk)+OQ-$+{E7V)}%ZTkqWn46Acq}g<!mct$A@ELHR6<9`as(ZWOLMBWz&!nuM9BEy
z9@-Gxd*s4#Z=A%6@p%vgbWqO<?#A(`e5^WfKi_Xl3YEXNS%>vHs^JDT?SXd(#pa>T
zg^2wwRG*c;Iw7-}qTvI|9tG%gJ+_(VJG}mKGu4s?XQtngMfuz4Aa)N8y;YXmL@_(t
z8Ih5OCeg<|^-@ixZ2K`ez{FwrcoI&JH?qRlD4)4+&>GLHecxJ&AD)~-3&AbRklLN-
zCjltun2CeeM=k5%9!?A8_&ndR9m2%8fUC0^l-$1S)O)n<+6mwr3&F5Sm=wVRhg@J}
z^kfufhHp9S3f-2K-P#%nCAqyhHOk2@Oh+fDBqyggOY^R{+O~B@WT)^xda+0vR<22M
z#5dcnxhi}-qO5x=5%A*3r$S|Yw*G`PvfpT<-h1JFM|Rp>szqY1d9p93Yk;Hag8YcD
zQro%DA+u5Y7&&=OLpaWq$Q|T#pj9NJU3+;f;9awujxOwXb7NW52AJiW<NHK_Q;SAL
z1(0PMW8r7z%v@Ct!1N7<sWnqYBqu)rj^&YnKHk$ywDQpWd$-HVwg=Z{>xQk~Cxt`N
zlM2m>n~UuHiw&u7ko>;Hn4g97r;ie4X<QE-j3&YdjN4WR5?6mVY-s~6(dF)^A{*hQ
z^wM4K{!Q#x$H`Ak+&>u?>dsv-&sMiNYD7({4F>AzpCr1M%y*pj9=cIj{j}8-NWPve
ziCVve0*{$a%G)y;{_~}%z8X`itlw|<yGY*!zDuofA8l)&PMMvbJIC$roq7nLZVxm5
zIIHj`q|FlFM15`^i_oVww@uyXbEy|%#_@LN5MYYIrry9-+cTwyOmsFSp_yMy)NTw%
zSa{%zrL^eLV1UE?TS8(v#u1<Nt?6;ianz~)=()tVVw59p6zZq^hrOIjn}v-PaiN_(
zJ@~q&S+2XrhY>Xc@TgntqSs4;4~zRX<I;;hr0y<;&rpV1rne*FOxvOaXe{QdlkYyP
z5^K!xoN*o}))d;Qe3vK}Aq3j~rbYgv-!uh%PHUkF6a4ui-lGOl(A(J*ymP=3C@mc2
zub|%~S+WD|@X>09`o<a_XL)(~6wgP7-#?W&Z{9D|<l!QyK>6-g>wDq()rZ7*@qxez
zFkFtCvZ?LUxG;`!j2gcH-o?6&oB~h7x6dyNu8rD5KLIY(Sq!~IhcYN={QDoIH(T{L
zE;=!@`94;5Hsyo}b0Bf8$#BZ8DFNJkKz1F^7@(1lVgsh;9D5Ix(jpZwPK@z}mzh1V
zNG!wq^aS;Nyl?eQYxC{Cgo?};n(D^w1_vwN+jfiv*$i{vKrA=3jwOM017&05XOYd!
zvg@ia&CH@_Qmq9FhVHBcB9|8^ZoCpsHy%RzzGY!^az3dNNcuTQ6<R%@&l+RWc5-)N
zIH<>8dAIyFG<cWuWsS779GDm@Yzm5(l^=GV+vRb@5u3zR8MlgqnD>In9D?gd^u2qQ
zCs1=hKKajLM9lAwQ*hIJn;CKA?}4do3ne8a6UA9P5`LChlwrWLS0}5+6^Hxf$Vs$j
zX^HN2!4MefM!G4KKNek8gZT#XC|^qSsmN;bw@moEV*z))gA2UDX&7#)b+Ij^tJb3F
z^bIyXNDSud>dF5xI{Ka?KgM<XBnt_eeIK_vX#&emMU7X3))V|ZwSq`MG8eo5K*L<*
z^UxLwp!~dDLoHMrLR}=(v1_=ywI4r957QuDoe!8zY|BP5jFa-s*SXBdj_aOa?hWSS
zrsABg_9Za_`9e8RHw^ZE%;<orTzdUbH<ygsw=8>Iql;4y@$!1S3`EWP$@q^3CALL$
zS){^Og$h%LYZwKdi@J?HD$sRe>p$E`c6yDw%57fM0f-j>Jq*}hPqzDxu7}82cTE98
zLpY3<SS&&`zHH2ew$e!(UN%tRSamXK8FuMu7_e!e-N;G8cL>g??&)e#U?uqe{IU>g
zIzq3LJnqy*AJ>^3r)N6w2TR@0)gLUu8lGR=@f?4#bo8~$=Y5%Dz~5*bdfo57;TZ^Q
zSU#|=uXyb)lP%_(5o_Mhk1VzMBxv`l&&x7uDPP-syd3ZDaH-;4t9rO1XT=Dmn69cG
z&Ef5?3oLipTI9aRXNY6<_5(__&+T;iOI1Bmu8c2TGXM`3`^4qudzt@2c)0HYiA&In
ziE76$#B2GxZCo0fw>m>jT4qCjcf5VSi6SF|<z?*=jyB@J^5XAc&!15T4aGmbzkr08
zn1y$SOOnFfxNP70h%fF`hSG!tx>sm_%$>8p7+zgsBKOTQ?y!H;(wLoy-Yogk&W3GQ
zJ8%c12R#wz&hx|79^k`l2{>lb3Tc;Vw?ZbyQf^Jhc3J`WLWsy*V$Fx7S0Iu!!W1->
zfE*H^_-)~%U`_~%2ww;V=fj766U(I#N@J))Pl0rLlh-BU@WR3?&b{xPZU#S#3?YkN
zKw<!~Bo=TAwyZT<{F*i0;{;PqLa0g3(&g0odOUaQZISSWj8Qn(g1QplKPgqw@jm8m
z*Xon%&u9<0#n7>~2I^VgUYxfDSQZ6OsMUs!)3^@<Q~{wiET0@lyHCwqLCN)2@8&SA
zvg!@P(Gu|EA=n<@qEH*MqW8WyDo$M41VXt77XY0HQV`O`#&Vghbo7~=@l(K-NNkkr
zF9wyB^qtkHWL=TX4akkY4}TAczy2gY4<{`PiF*P^MBD~%&d%Jt|0uIYXw&6X_~W<+
zgZjXT@Z+s!2Bb+DF+`@*DO*umv_pCRi?yu2Q;L2+*_0R&zwx=BV1JH#*{1s!-hdW;
zg9&nZ<0*ahPN<dC1gUedW_QR55`*?O<kKUy(S0r7!9eaJCbLq@b(}t@Aw7D>^GZOx
z%CEN4zKT)h*01f@?uwk>xGKolO*j??%AiJe;8py=oGP|5TZpSRp&=+4P{+vZTkk^B
zjcq%!asFH^f3GY3#qeNCgxp*bVs4gpjW_8$_R@-qZ?ATJlfvZhOeHSsD3?xYoET(#
z9rh_MwoFXIg^rA%83{wbnv&Nxq;Mblm#*>FA3bR-%%r3cM8rF4SrNUOKZVSLM_HLy
zkU-Am=vVmI`y$2p4cbT18$SJ(Z69wqh(BRNx3ZG(_MOndpw0eFoStJ+3$-Bw94xwh
zHKDlm!DS|)!gY`yxo+nsP#zi9Rc2B)L7j#bRvzCSbGepIStUCTSOhed9%u5JvLH6<
z49c4{Plyj`amBPN^cpf3J^ApVz9UM<nh>w`<kBG>xb1Po(dqu^iN`IDTT5M0x|cRn
z6*HJ5_Raz%yA79mDO6Z}OGD3x+&4;?Nc`ptVAVN94D0$@Q9<FDCtBneECoe!dQEFK
zlrDV-KqcwK{agm(&@WoVUy~h24AOuuq6a7`4NQfLN+A3lBkE9H<?Trw-SvLSFB8<s
zQqU+3dZ8cJ6r&ri4I7Wi9(5spKHanb;ks1}Nt@yJj2#=^uQ`(OBp8q<>35G_8bukh
z@I7^NZOV7dFNMJ4U!-awGI2$GpL#5I;Zxvyd(-~Ixsey~Rr00s?+yeps^`cSwAcvF
z?~Z%(N*pRxR7Re<xmjOztn_8Kd(`dVh;Q;s)+arCmK%nH7!qcJ<v|4XJFIVas7HOh
zB)y7vrzVfBcK(WLd}<z$!}%8zEh!^?k5#vMJGlxVj^5^2xNd+{Q%~N$GfWi-R7KK|
z8jAs~ff~c!`0K6h1{SdK_RG7r#<#F93e<ILBtlFr2jS4nSoFQ&d|R-}6PR-36Bh1Z
zK62%{QHtvs#4#zzgr`ew<IH-?=KNBB2xsk>?{Zf^slp9#_&{m0TjerL6#y*Ro+dZb
zsp~q&<ZG6;$81Z8Zs`}ldTR+CvobfuVI7pPc0vyWq?Wc#=F*Z9DPOM`kU-b)%s37R
zLn<oYeFQyF!tKi+dFt$kqyruU-Z7b(uhb0!EA2P7bylQGgRQ2<>YA8rS2JLHWep91
zL~=Dj${f(H$mf4ly~762yih1aBzpW*5mYnBf_Z_fkMb*4FU<zT-sj$NrFy%?gOFVt
zm{{u?7FvP5=z+C4ri&6TDsi#pS{4}iwzlHj!U=uGQC@#ayR^|bPO#_Qp$<V?b$?Ev
zi=~%eP=o83ud4=p9~gy{8)fo+%G)I+{`Yh}c$(*=_PA8|7F%4g?Ce|!7#63Ku27BY
z^OcOpK3=b^&G0S9bvQepa!+*tIdLyO#{H$P-ULkrp;y<nuf?8xU2IXkZgK?(#qqAO
z6##sBA6wO#-10SkS|t{mn^uGR$34(om?R@8XZ+bbx;~^)_p?5{!?g69C8c1<DlaC?
z6mlGOxgmCQPbX&)&=(yj#(-T3n<fzTjm{x@2siOUd+o`;C{do4Fpo)J$Lgx7ZSVTe
z3YwYX)GPKC4aK$*3uUbe?^G==6?af@b4Ex?U)&m2<+!@uP*^ZTY*|5{+#ln%fD1L7
zTmdfJno0EyHnTdUdyCF~L+d(fk{ufUybbNY*ndu@{_`zCQ}9+BMMfRiw4G&{oKbe$
zPw3Kd=8mtEI78Hwzw9R1XXe!KU<6W>=1g8g-*OIS%Ei^(N<JfZjwf^8w*0Z%gnte0
z(;*+Cclk_gc3IQuCGYAnkE^0bm<Kd@momvy{^YltEWH5vjlg2ys~OK-i}xR~qa6F!
zjq<-G8C<-kc_VtwtP948#uXpEq0P;_TT_D+jAF>wGpuAAQSCTmNhMgxTbUZUp!jK%
z*my8{k&*t`VS7c1>fH{oVc`1NbTOwTiaUxUaZFuPSOSFT`bk?i7bQ3v0X{e9X2iTU
z$rB@o;pDYxpPXMcluum2X${|MNg>Mc*v?vU_o*w%3HP%W)@_k20`b$li<ehjrJ-pW
zn;cBFI&v<iBN}|7)8DfCM9VG!#c|r_(i(zO;9UI)9Lb|sL!tLbd8{~o==st*u2dmP
zCJ*nG4a-yC+{Y@i^BLynudduLcmZWz5DpNoOZk#c1=Z&D{*~J5Ate)gIF+K%y~IV6
zgzr;J-%Uu~tq1;MVao&3iJ})big5{=<rb>-yP`>6)~UCWgQ55$&%D~vh`krMA=Mj$
zC2z=v<^oIJq`XvCwb@O1e82%pct2lL{;ZzuiE<r!kYH%=*hg1~CLW3i49qF*6*vkx
z|7QpEUomb{jtWj>$nqwe@V;7?4CQtaBI8l8y}d3yKmYg6pU)>h<71Mp=uK(FZO8Mn
z7s_@VxPDn$G9G_^9c%6=C;mOv0B@5I9AV|TSPdJfWAERWCkTS}wDF}2l-YL^BiDS-
z_#-@Eo8|xs?Tlya=2xubK@)*wsQF<pUdAPuj;yV((>9J;19?J$Wx0+KZd3Y=@~rV}
zLC)c1!q>%mtO-e1FSDSh#(8roR@){<+qS+9+s(fJ2`9G(4lP^NoY$e@WGFFvuwGE9
z+YN;PrzKy9d!8*AAVa{H;ZJ%TV-araJH{Jp{p+?LW2`~Xhla}KFxQ|xz>}lUm$8Co
zP!WLyH)B_hTQIRfbl+=$fRxm-u2NJ3TVRcf6EVqD!m=>C=ADuNlz{6+kx|M6k4+Kg
z*=1o)ogZ_Ebgdl@l-sQ{ufB|m8gYqP&NcZ%=r@uX2j?txzwZD9DyAK2P9XfrpB_m6
z(Tf5K(KTFu{0|j2y2bYh)k$ApS&rXTl;4_MYI+}tbXwCU=&JVABzxC3v%EDdFF)Uj
zyxox)V_aI4baZrwUz?cjYGQ^sIel?zgSt}W>o~nsetLL@L{LqRAdqXjXg7X41M=#L
z?Fz`z#&Z8!#ww+d+jDKD7Lha&zj&T)9guJ_17Wx1K0#G_BPu9X(?ThPwQTD48O9?y
zxVd-oX%cy+pbO`h%kB?+!(0AnH??Dc23UJ}lt|TQD%?&4lIc=_N*&6SdTj$@6pXp3
z9`OdHA?M4NB+&~!P2WQ9;LM_;A_caG4}@O6Qnr9jsYWmLOs_&7#a`I4U(YAYYXl0y
zO;tZ6+5~GJ8ov2b3>a95us;c~=hhJCOn&hnH|)=>42{Ph0Q(txsROR8EJBWZ7rvg|
zJu@)wbvZoo4P~}Ht#B#7`MaQ%*c8E;2_zJ(-0Qi@3?sqD@?4|R(wPnm^V=1xH117S
z{^jVXK8dxU@(T`NdXBt;y54Uh0N~wMNWJ&Q`BhC#bMll*&8F>I!XP5PB*z69&`Mi<
zTGI9<fuNzXHpW!9H+Kj3eNwEghca*o07Dz`P^PiKy^}hK=n0;Y<O~?pw3GM-BI7+E
z?AimsI`-vd&zJJH(47joXAWlK_T)`jKqtPl(bauWUr}L6^^3R)Iw0l|Nr$^K!asri
zVxqIWi*))!WCuq_7|r<c>_AXw1hqsjJ(UpUkIl>b-fo4WHJ?-1@GBjbpE<f$k0n}$
zw{neVaK`zn+YU+^>y)tWwUj$XaB~?*mCBhj@aiW_9eIB-#nG&DE3O{VkI<zV{;lCn
z(|uT%Eh9shj^;c0^mCo9%Oryezwl>I`~@#1PIq>UE`Jti&ZOd80!R5?9A@r3apjQJ
zn(qLs^C5pmStZD+xW<c+#EH|WxIuITY}mWI7}Jb>pXL$Y<Fb1NOw1teV5|}2$9jvr
z)F(_e@=|(wJrB!4VhmE(u#+o`fx0g)ldr#Yok9n=-zZG-+KC}bk90cxxb)qr9yV?b
zzIzhQ&9Ur<h#kT2xDxN3+8FfWh45A}mTIzG?b=Ur!RaSNSla_GzjDzW^tH<76yi5W
zQ)ds)PxXdP+w{=5^wM*3q(KMC@Mi7uMW1-alPCR9Tj5+3RWcxUF!gJ@y@uX$-$?rG
z+{Ihz7gyI*Q`t?W4K)!K5PzYqE8eC)glXRhhVoj?)=iA#Ui{Ss{@a2@V}ZYQ+(SJx
zS^q)OUTUSz{J=_aF3?lIk1wN{xIpuWRNKVF<b?TX{t9TmEGxZLBO^V!_*dn*efl58
zzK&;LW@bJa)c4i38ZXa$9U(00=7M!r04$DuAU57`&{(NbO1|N%jf-(Dr*rf?a}F@p
zcc3B>qVBAslxJ?|SAG;UI-WcZa{-FU)ks<GPqCzYxjWOxdpl!;`b=sZr4gXs2g6FD
z)j3X}sr=Kr+;wuj9FvHnX?7<svzeJ>%ZLE0OtaFaesqZdw)4^nke$})&4!k7n9z`F
z{TgnQ0qqY|KewESLiNaq=Z6gy{Mc^=r*};}u*fzK?S^Ep>0WpGi&UZxqnN>!bK81{
zf0eVZ1MU!+Px_G*G#=Oe&d<sT$saq)o`yOjZ_~#-@?9p4>t2AR7-HBPgwqC+XfW}D
z;rzTDXOWaoGKyz2=+nivZypeKEjs|pp1bbH?<9^r4?#VP;N*^NnSj<;_Z*lA3=MgX
zX^p|XA+@Q}+o{>Ku{;$hyufMzF5NX3u%S}wwGT;PlCHI5%OQ75jt)Qg>uu#tiHwU9
zgSAQm?)oCto0G~-5*>)dHlsqK@iq;6!&#=)bk&fJrBnbPw%`^=tx^Cch0mEG=TEV?
zd+VT`Q>_rE#Sie|U)6s{g__CL*?zkNgXbHogM$O9-8j9*!i96s`}p{qBsHJ`F#$@z
z?FMjtPuLpHUJV%#=r4a1v~jimVWN@@PXq~rdB^!HGNj|U0{Zm^61#^;@{x{>L;}gh
zp-N*6B_W|%$Obg*VwDfs|07MhCKK?Ow!T?=>2N_|0*gowj0>C#R0*<Q>T0rO=$_U!
zhO7&Vp-{Ty<fmSLuz$8lN!A!sHiU0nxL8=0NWP+aD>P(fd@*YevR?9)nkwAi<_$u~
zu>MV@&CU`r0ReZr#Ox#vr!ae6Mn$D}tqXT1qgHhtFrI)kp?jnGg5c7_J+8BO+)JqI
zl)-AA37B|Xb4{8@)Bxv{nb0MX2bfhy53s^9IOS&@{sN`0c~_=-gg6{7a`DrmVj|Df
zuIg+dWUCt3i6BF8I-y>N1s<yh0H3HrV1yYBjqAFmO#9wm>zxjxYLR@M_X-{bMyBH$
zGdb`?{RiJM*ncL71Ek}&Ge&*P$Nc89sVCL@PcHyy8WYs#vcNnC)z;)-NfuaweIa_n
z|H9O-oi<#ECABBiZEB#j5V-Q1)>!1-e$8U&1b$jEV2ZbfE=1jI1$(9lV7lWjSatR&
ziso~DqBr)XVEmjl#9mEeH;Qxk{fY0%#Oj!-9ylZX71`5?(?C7<vM|8(%pPS|GXQ+`
zwnv=Lk8I3jsoQ>PyFO;|dRjm#=en5P09^`B&R6T6U&q);eY})VJ_?SC^rcJO(p_Wo
z>3wjhcskx`{yz9w#Ngg!zV=BI3JWuBM^9%KJA{*kuI$9S%4Yg>X)`;g#%Av%SChRn
z2bpto3s3=S?#X~gqj|am=m5)+MH>AUu*V%l*f9_AOSQO;%FA^?l{Kf5N)y=$nmwj$
zu6ORlJq;>KY|iAD^Q{WssVxU1`d}JXOEC+J4?+i>jiG)YuKTDEuE%nHdUkew8@po8
z#at6P%|5PG9weKzhY|z3mW8cI(d%_3Q`{$MBHp3&iZ$_?c-Z_)xbDCw3}!F^DF&k6
zav&G!868){(iNOwxxkXh1D?4_P=T_^Sv^8_JsJSUI#~b6$AlS>SC_qK69t{a*C=Q@
zj(wvJpw$O(Ev_|#^Mhr`_3g!YW8$So%0*u-=!=<fhsooJb^|-`t%}JF?*lb1J}FL5
z4azf1gO2mnv{h^K0B?P-{cOun6t`*bQ(aTPP{;Rp!a=4TgX(7IN5ccj3WqhqjRitZ
zYtM(DBC<H`TzK+1t>MzfFWesrCG3w(sFr9rTfi_Q{FQV2tKkkdn!%in1P(w<huMrc
zNy1}oflg@wAC$FX%o%cVA;mmVKI41_S}}BN)?bgFK6OS`xVNRj*d|z6(|%#mnu8q+
zx%<M|Cx7eyn9t-14_lp#bq=wml^hTxP5|QzJg%Xa>13#X=16}-uBhg~R&9U3J=L>e
zpp+0vSJ+S^B@{RFm2)sF%lCGt<o0F<hsM#NJG*Y0JYud`JA|8ivk8b%Y($@rBW{-9
z01!d7esypz7z`t;?kB?f490*5g`%GM@&?d3`H7ehQ6X5m2MGvXk9`9C{XgVpl^%_z
zF+_qDJ6b;y!@j3EK)p|U7Q=6+^h6|1*Jo-g&pF)>jMIV!d&y6y9SbclVG)px@Rjoh
z>IopOr;V2BgJA~nhc}uDtXy{U$&NYQAj$t}R0f)fyIYrr)_Y!OCda%-x$tBd_aAWV
ztP**CMKK17n)Q`%pF@o}!J*3?O)lClK-LhdT?Wb=u0mRx%oEaR67wv%`Vn;}ejKdH
z^j`~q<c=E(_n6IVy@%YRZswLqJ(^Otb>rE>OlVFn{xjS=CZ{BeFH|*8p#+YpHInbh
zogqgvw|s>`le)?elU95m^oU#+UhUNRP8eB)o<=u6&+U;5Fih;d`<n*==dXqj%c`oY
zf&1J3zOHqC3-;z~p=8DA7}gNui=!Bq#=>XP(w~cazXLv0f%kK(u<P?xp}fhB!i&Mh
zgPy{O+MSxx{sYto#RmID>FVWJ?XbCz4uukc`^5nK#*&DI=5^k+Y|cRijtwtFZ{0)8
z{lq*8>LFl)AFv&_SC|LF7MF5wZZ6KY81<V`v^P~#<u|p3`;&$5KrdQUcav{3k{Q;}
zu&e|G|DTo{PAP@`yCcfC=HcTboBF=OQv~T8wzFQeEv+`{9AMJ+)V4Q?_K;r~NdBju
zB8yHq%L{+3^n{$MB3d5_)Db8Qc(oCzlQago$_}KypM5v7K0HT`H3&p#kkT-0SWdx-
zVNSIGtECr^NchG{I;{8KJBT4oiW$sIS4#QT#eC1lI_NrDthauADN?^`oHpeoq2L^I
z_uhVV{>=)(dnHP?N6d(Q^a9-<Tx4IIm`)TQpccR3Zt%=;nW(tHu30!Vlk(NdH8;h)
z-v1I!ur#tcKk$g?w{C!9GI(noa?WcC?l<RQ&N~X`=7d9-csJ3VozH=^G_h|XjQ2{e
zdUL@2idb1qjX_=CJM7#*kbS^&@SVunm^Dz14|gKiWeudGZ+Zc(exw|Gy}ao_s_yRO
zDnGyAa`kFz6!3NXHfx`{`NfkB^;OFFxt7|Ba8V0?dnu$RoG*k8alWUOzdv_%b+re0
zT(Q|UUVj88f0{GSdfWyJ;K@ZcUYR7q63+7LWXFDclY+rHG}{T`{FGT>{sU`>jB+6o
zv(;|BtSunW&GH1|T^EB77k%-MTDWtH!@$1um7e?FCp{+~YrcYND^;jmxLdP%vjQA4
zCzV#+z=P@pjZ#CDB8}_R!t895mEC#zI2{%b01bY)b9ym-bJc&3ur@AX-`VQl`L6%i
z{jU!mM(2-;b|u>C#n4lV+BBH5-HriG)%KyI*KZRCTyt`Nwg6O|*NsjH1$GKSl(WNU
zIlhUXbklhb!Qip-WY3-NC<8pkPoqH?<#0@9&>Y0PukZEAL<o0w$h61lEb%kj=^!XI
zyE>o7<>p!p9rqk-=kzfH-}_8Cb|Bw+2CQE`O?s9BU$Bf>)TKUt{q(J=QZuENl0v|J
z3dvCf103q}_3EX$G_r+1n3e{Ihv)Im%@z9Azr+^W6Z7;)M1BQKg8(ChUO+$#_#m2q
z#xrIP7|<YF3K_l-mY0=%w9Un59PlYY5|Nt;jcU*xsk>)tb)cu8wl@YPvq_dQ#aK};
z;08<%BMw&PTIB+)qC?d<@~N`d%1!-I?|*5AeiL=K9~u<Yr5BQ$e#6E%-Yj$kL^R#U
zZg$ah^v+SOt#*s>g}%kqq`VuC5qm;Wd$=Q`lnsrwzZL`OP9d14hj$IM7*9g_q!8H?
zNxg<%MZIo8TwYotI^~sd`W7n2ln9^M@Bm9d21~;(7J#{C!)Cgi(!D8y<Etm_Hbp)-
zq_vcbzpZ2b7E0j!#R%5y{PFMT>gmzS#optZ)H&5|Of`Wg!Ro*+V8JCIpdYK0DZqan
zi~4(KtN&>1iX9>g7|%%_YVsi<Y_r>KeDjU=KAjoY03tpx>3kdg^#?mv>(Ck5-zh%+
zi*=nYi-4ra^*$^G*WBA5Uy-kwfWt6l9|&GcbAMZA{MX&*QU?5eQ-l&h1Z(<qO$L}b
z#`!`B`{YJ+^6w(*e}4Je9{6sjGwohvlsqwj861Im?4Vwk+JwPgR?r4v4fY`S|H*0m
zuNwjnqm7Hr-e-90*9kOdsEEJmg8x@%T#OYXu<T%;U+Dk)t+3z3Edm#cv{hjE>aTD8
ze|a@H3Eo~-!O`(sK=(iI0myCr2!Mvlz!nStmvPkJ7tL=&;TX))yZkM`$p7lvk@Cef
zn)*ZkW9x_o;S+Hf__-_m!QaopcJ<c5{r#sQr2$>so88n$M!!Fj{_ASZso{Y^Gg@TJ
ze=U<=|GX0QT!p8QDsR{iSHTk}VGhLgF#n_%jZKqIl^&dFAn{~N@5Sr;dmrizT6}I_
zwYaEmVG%q>8j{=nfv;sw9iewNAjk*wu@llR5_q$_?mV1ddil+KN(CoU4pVn&;qj>c
z@$=OKi7EN3$9O0$!$1DtKi~cD|FU-%{tlxTQe<BQ9QyzMM@1Ono}x;<W&7Qz|C3)k
z3x<1(FM`lz`qU5UfB%z90WL9jmU}T+_W$J9yd?d;qf`1DbJB?+{O^BM!@(u0?k3u|
z{_lSWyi<e*cPY!|C+6Sop%^_CE*aSaP(Q^O(2*gaNBD6f%s-O-;nPZ2@3uY8{`925
z+T%hV3fSZkiyh%<>qKrh%T&0yxKxIQhLKTGi!WG#D{l<w#^gC;U|_)bYmvZQFZ`nk
z{Vo2}XPXbh2C6l-zkX)YzeyC-ef9z48v4ld-_P~mFZi<1p7YsD>)NC~`19h#OsJnX
z`gj92eGCb=#a9UyHnvzWFUVcE4j|}&Fs};>Y2a{0j*{Y#zcN^`2Xgch;GthQwG0pb
z)*D(}ozhrIdhTJtVC%tl+wbqI7|1{CCHXiUDAK-ssX}Ghm{4%)UE@l1QnOXk^BF|a
z$cPB4Cr?a7Ur;0T^!KanhJnOgr0w39%U7xkH;aplCg3;(SiYH@ic0iN<1yehy?p+h
zDhQiA5|{-%gGnivA3k*E1AMl`r(i_G(G^gT$|@<14^Qt?`hy8^z}aO;u*o%JdRj*~
zEM;;ZOX0LPLTf0}m1|g~L;ZcX&%n{BdkOhJw~Y*fiBdLMPrSt6mdKnDLVPj|pfQjt
zAL6K946{REeGQw)hpYHg6KED%+uNVP3=YAB<Hx=?UZ7DOuB*E82@YLF0>N4PI68JU
zET-ry((uH*p0Z{jJ}}^gOoQoPxobUKoxXUusw3Z&Wnd6a^;%}g5<onokumQ7R5h6;
zmN)nwi2m5>Cx`9>LrHl1SAfe08Z4U6cVWCQR!G%%Bc*%o6)cN4V36Tw&C)2EeBd71
z3A*pBiySE*(bMdMMY-=XOQxv}1r7&z>pUmeNe~e+;gR{<-}c8=FrXHj4@5?b`fG{L
z;UIv?o-Y|uIsBFNT96QRJ{YMMFrs{F12}RZYlUz|n*iPO81#{dXl%r6_r^Rry6Mu(
zmUV$Ckin{e84#QHr&YVnw8&vdp-8YXjjyLF3Lf<=iwGqelr+?6gxr6KG|OYKC!{)>
z4;FQeIf9Ws=v*PEiH}yBsc{gw{NozU=)k7$@9gQ1`uB16l?eeL;g7)_`ZUFnCZo5i
zT*aQJHs>H8T>`G`xx5(pV%E@xdJ$@WTna)xw+t^ZE{wo=V=D;hX*vRWU<aLS`2K+G
z^QRifCmt5M&G;Wxx!{$E1YLKcfur>|_NtwrIZXCI>da4mF->3vl1t*F?E*c<ea&iz
zY!Zts;O~fF{{(md9Nz|wxx|YIBkk2ArP=lY|KyQ@hS-zS3YHnp>%KSJ|2z_t>BQ!d
zpy+?Q-7*N}7NaEu3R_c^1Fz$;Tw8{w9W0MIhR&vJ8(+(+3Khcuzha}HjRieczn?Th
zLRV$g&13D&55Y0Ai$0RC+o8r~Pv;%b`Z-!b@uI<OSG#V%om2spfRGSF96MjPb}Tv^
zi9y}Adig#uhCW0-Hm3u@-E|a962T7z)beIeRzX4SfpPKLCejul17`(^F|gdpjdNT*
zy4zHahKV_X3hZUy-KpnMT~GZcv4H*O;qmYD-cKL>Ip4f`omKK*XL&Eu<HwI-zAA6f
zQ#T>C{c0+PBHxq6zv2YW4r1bq0jhRwESEJWCubYW;8!razJ_F6<r6v{mA{3|+*}1g
z$<5_B-Rkpqn8`=QNbjOW<s;asQXGLT<`+fsdgfs2o8v;?E>KV&2`ysp*t6H|y{Q90
zz=rp*M*B5qT$2LtjPU^#ysaEKPUFB)sm*kj<~bmI`V=?^$!ZvCCnOMvrvp62Lv)X?
z^i|s(VQ&E!mQCS9ry_&2zn;w>Tf{C0FWqiIzWzYS_Rmwp{|+_W_;5U~-)RuNTx=&8
z*4I7CE~G*9P*fDUe5ViW#dslYs`~=d@xvgvT`2*@3%J(qjnTYiVB}~ch#3|f!!RTB
z)T#bHo|d569mmq;wbZ^6+m=`SWk%&ai*g?@Mm-f)R<cXxgLvt7&2xG#Aa_W)%&Cqy
z$JIN$ug>h%RqNSGJ(Bz)dK1jQ|Kww67k(5d0~?8y>^!FV0~8LUJ=hF=_E7C|ix?Ii
z2|iTycRaue?z5V|-C~k$!wbeGe0==nL`%qBx9cb5MH3C)wM}{O{Vn|#BVRM#S^nq-
zYKz4(h?>k4HieKzndc2KF9Yg|Wvx%!_rF(x`d#}tckt^A+T-cdof%e*uG<bu-%bFK
zS%nWjX0JbbX|3L5K3nJRF*$+#9g?o!=X13$(}<x%MX?3YoU!bh6wnM%9ttd8XbwOP
zldZgTqtpd{Ye4t$`Ji?648(+3fSP~LI(;b6<hJkgy&mp1VE!5*^*$Is$zBBky;yY#
zYhq!OpIG^}(1wlu_Q!6sgAbUPo`#M;@9E%SWR&ryBt7h|#lcato-F$W#!qy&hmqD>
zuyJ#%ii?XM88tP}tiCL?`uRS8N|GdvQ=Dc&nXbw-aLHslj+U6z<TUp@($OtEBWKY@
zwc1SJV>17LuL=<SXu#3g*jb|c=c<6mdydw$*#c}5z?9ZOMxk!O_X$Z!n^E>fcfngc
z5#sBtMss7zY-Y65j%GpqtvxU4Rm%3``~X!x?41<-Q<ayTuLoZjZC!0zYTnMU<~SH3
zAcUMN0l!(~<=apRt|34&JVtItV3?-1@k7fO8q1WzkbU};gL@xXt0w$dmNj^M4ZK$F
z>mX)5X+pS*%ux8qUkKo4aZ$5ifNLyRr5g%jb#S&%%%{w8mBhH<_Tj$M3m<gSw!d<w
z?1j{9uz1Vw6+QAgv#WdnCaW)jPaT~KIHhu9F5wL31Ob;05dG|#+UbO6!@<<c=Wl6G
zp}vj75sV-y;B-fX4*~`>{AJ%v#6J7)5hl*-fKfvmuJf&+s<OVb4+l>j_`ZRM<E=)s
zdDY4sOgZDeT|T}9rfKrtPdcHFt^%h7Su3^{y$-1t162fkEr1VY8*VNv3w|164BfqO
zHFblMLMz)n+@Me3mM{XCP*+iQ$vLJ;>j)H`Hb%O*qG5B#qEG0CEav!Lk2qI-W7$b4
z#+qV6DEm}$arnh#VDc@vrI{?#oMDU0BL6(ZZqbp>8Zl1(mLi(*!0W$f5GzhkZ(1@$
z$Pf&D^u6G7K~(fCq@ui{g9{wM!tnWY9mXsSUA0c@nIQ~YmPw9TQAu)NUYsUzKK%AB
zCFtp)kGiHqpR9f`L+`^6AYaJEKZwtN#~1`;CE9sz$?e8@LuGd2?RCmCX?*sX@(GWn
z2$}dSQEAWuZ~WYv6Eu-&a6cI!Ovm{5k-JVCYPYSe!$(a4cm2`=vtBZ8i|9wpK&i=_
zU5<owAI<0$W8&b3xpts*yr3(j$?;vv6Cwn5*~Izl>2gc;hp#7JA^1*~z0MIrL;o>6
z43Mj*P1^oLR9gGx^Nv;o3PhKF8YUp`ctrq5wArMMyn~TSG+7H!!zF--a=fM5U;6ps
zE8@U?pnD^nM(r0q)zRg$XYp>y!m3j>e|H*Mnc3eyBh44gP<B#;Jm5k&^Khu^Vdw<*
zWz2QzI){PjKZ}a97(aLBkNUN*7XQAz8mQpn4*QaL)sya^p*?5hBxG~aQGFjX*pB`<
zzk8<Mvy%N?6Aw67?;$idH|Lt6yT$nl`k1XK3dKabJl=w1*ed-o-ZSK_jch20m*g7b
zm;TuGL__!b^v!AX=z4a4&4H}Q4uM*L7{)1i-CQE&E4b+p-0ttnEp&}TxCc#y@47aD
zglAynUO#-^9QFMGRII@9L7^80FOT1m+C=F4oJ&o=l@ZGV?&#`M?Z+^ebrKI|1_tT+
z6Ro7LgCMM`MjM(O0BXN1$XZ8u_E1yFVay_7>q<mh?8FQx@P(9@ORP`=qhX0!xYKbd
z6r1jg*MjZ!HC4i{pJOCN#Jgr1kU}jc&rmaH=M2BEX(Ce4Q_&PTcmNZ^(bGnktL_+9
zT@U@ijq_I+I5g6N1h&ZSi`ysEf&R_Ph~J-5wLWujD7k4=7c>Q(^8+vzK}oJ=nx+?(
zNP@|4;5iUljTW)AAO3Q^2i)5jUZ~e_Mgc%@H3VF?%)2{0m1`^9(&hwy5?>sS4YJLO
zqIJN-$8eU`>htA=c%k)#zT<d2OA=^Y6q$*@U*{OML^k=beBmWs!?y&bo*N^R^(o~#
z>)Fi<7fdhvfg=wpp?}tD={lf9Wg--zkpC+qB~UT|=|XOvo&4nYA`+4)5>~bR=enPb
zq`0Sl&_d1Q={|$RIyw!GL8#b+a)HkJ$B#*tRy^GMAjMG=LN8W+8DA*Brx3g4J#~~L
zZYd>KNU9$>R}`g3fe;{pOcNq(Nx0^GRa^=fU(N^Q_&H%D+<0hZq4x<0vhP$BApkq}
z?G57sM*Pw_Q!ah?rsikfS=9M$Ad&cd2er)WNEleK>dw8{1nGNa7f=l4tJ+sTWMO&P
z@^a3@0>u^qMi8E5kh}+ST4!8bU@Q3yv~G_)_Tv3&;-f1$qZdUW#DTbcvlj6NydN0$
zQd`ciK<g+cH~z{85F3tf>=itZH|Sv_48Bp|;W{~OjwxV?zTvtV5Tk=n1*-<MCM;z6
zUAE#kn4b*n9e(82L6*e2;XotDWotW|efM+~dV5oOQ;mumINjOZ?LdUk%23sgivr69
zbIreJL`K>VNfCY%rzqG0?aeX*MKAEJZ{mh<H>3|O;4?xWIejQj<-Ocv3AiL}kl{Nt
zNB)E|8;ARxoX@Ulab+GE;}oZF&bghXd#HQb+7a8NGm>{VHuH+C-a`Ib&EbSQd~=*J
z=SiZ+?SpQ?obmmRkBvJCH$<#cbpJpg>=Z#UzG|hYjjm&3RF3E4wL4RLS{4>S{_kX2
zMG+yM%oE6ZN8^ttKNB<1!YphB4XX5R*T1BV#Qdlrh?hm6n~R01#+!~skYvvqY|P^2
z1Jw!T89Xk9ecHY##Y^IwH&QXm@mwENBy(5E6X9xBzK6cWUn7lb2OXg2j8u>IQ)6RS
z=29u&+>wVYyzLqQnSWP~LQ=9vMsP@o#Bhz_v9~)G>t5I!OnH?S48PG$#MXPb&kPW>
zInhKp(0999w*mL{%LjupqvE!}M|E&iUjC+I9C%tcpinrnBf+(XHJ=ZF5u8O^P64-k
zkghNqD_ivv-Zfv{DT7jK{=qos?ZiZdbrMNC(rWrd81Jk(YqHomXd=_>)*XJ_F@am~
z10g#%>inTrSp=-OvXtKUaS#Uw#gYnAruxzR$K%6QoOz^vj5lPPo`|#bdlbBP@a_8w
zUJ)ekfPMo#tRdRnIl4Xoe5hfAd~nN}=IT-AAI!~s&csYJaWnDP=w`AiI`IV)FOMCu
z*~!KR;>#hrlWVfb%U>3(5jy5Cu5Nr?<?Np%m?NCaJm%^2f9NYKZjqoK5?poRK<AD4
z;o9P+%Iw0q>F=5Uzu=rEe*m9gKUK6v(W#ns9GKZa>}D+_%M!}hVFH!>#yWX)(k#%u
z@O#I|>FG7-fMFIkAHPnv1<z>Lx&(UQ0n&eWz{I}lWnlLs51~0y!4s|ew?HW@({O#F
zE!_970{-@H(}q!%O^^mcCc4=>SxNaCLsiBwq^C`u2zCSEqvP#e?v||aI=TSC7s$Ai
z5m~8bcNP42!t4Yuy}a1-cz|JEQX~3spw=any)r(%m5y02zDQaFPjDX%32jfs?>VBN
z%NDMiW)ofBP(FSME@$+3KD7YH-AyZTLi{baW@R)?1eDNoAP{in$Mjlty|0CMYM5pB
zodtV{<lWB#r8E((AK7*YdRSa7mt8hqdoK-+Q1-yPr#>*0x!~3y;@{wkG|kb&uZC}0
zaxYQqbbtyLa{36=wcK=Vz_mS{;tP3zz@E_a7bwM4?FGc`iAhO$^xhS^^&aH`=HixQ
zyU1B~2pI-jf%so-JJc;Zs@gK&OW&d~M&R6)kV0eJOOUJz2Z^tsTkKFfs?z-=URyO}
z{AI(i2CiKqbJA3yx_z~bFw`k;QXfZL1@mRkv8z{jih(lY1-SEpW1^7i!kq-Ir0K|i
zS9*WGP{9N>Im^4!j(QlICI|HifMQfAHTXTxR_$AS@`>)+|8VB0K|^Em3|{VFQ?eYU
zre>VUOcR1O4GY8$&r~x|4YeCOFXk^h%KZueb09mu`c9W@kI)4ntO@{x&X7@bBKZc@
zmEC(Ti)Iw)$%+UtQ5%?)HbqV4geY#`R2#^c!DmH!&Ugq)C&duC5R7HX*Y8Kr_|EG&
zAF#~6*7YR>TJJo)eU2^+e>k--Eu{YYf>b-Q@quj^dc2{TT8omR?OLg_8rwPrZ(;!@
z;5lo_On;gvl+LNC+sAdq0)aHDJDzEDr_Fg|q}UqUTFfBpZ2}x`U8P;!5Y=bihE*P`
zp9Y@LcX2pb{slw$fjkr=LnmQTXPqreqLY=J!CG?}uK>s1;?agEkZa}S;u1D#i%TW0
zm~=tCX^vtz1JsGLp6D#U_otQ=47=x#)O!EyHeVBXhE(L)++}Nlq6~d1Jr$j0U0+|{
zxb7oNHMC=EIN<TGz_xMp@pdTfO||-N6lvG_y7*w0Q>iC?g89Ew+T>=WZl7=Jj%f4E
z@OXq2Otl~HPo%y+jkY^?bOqK_0+6a=;U=Yo_8{Xm1RUyp+|Vd89|XOwL|`ag(AwJi
zHLJT@ATxhNTenNPbN-LyO$7zv%-3J_hjhzlGKQw2H=II3Iw_dVpL2K&-*w&1e|~c`
ztP~bxp9XdyGW@2iqsrS3gkbvos4r}Z_S(^&t>vq4e=N|TWAZa6qhVIy;4f6*Q>yd1
z?WJFVkxv`D1c3))L{UF~YACbsSr~Ak(c>OSmI7l7>(l5;wG4zh-Kxiy)r?WIJ3>ZH
zrAl^tvi9ZsSNV$?RdyMe<N_*v?e*?wd-Jf|D<PM-#WsB|N=f8Vj3xSJ)%-dlyDera
zN-{d*AhsmKnZD7rZ@}Z=w>youK3i&EH5vDt@3LnxwGtvaEK9X)G<T5*v`+dK>eVj+
z#Lab`yxSwRmZ#uYiQf9!D>IB%=Hu5{$GMEwxB)5v{k*!{XUE>z**O@gXX}Ww>+B(K
z*nd}9)4)8Q*}Desi^G7Bu8~RO-&0)JYk(`D@!=~9J?0Xl*hr(o%IXn9))=UjbBLcF
zXVkMmNzn^O2M6Ta*XEn!wz&DGS*pGWxLxuo0#d;8<-2GhY2K~uA?6=IcpZZuLGGAp
z5^Ua5O)e?^oA{%qz#W*oEHI~dg-HrWI1z>kX{z5zMg<S@YhJ6a!pF2bnO9o@Y&e3{
zU(~0!E$rgU-kCRTD16@`vRuQ?t3<0cnqDSWUoko$qd`$enGYG#c`NW^!|?lXjJv>V
z+v9isMXqWA9Ezo2==77dyMm=3RJJy%dP?z8G{Y149djf)?<DU6L{h0|SEbf+3j_Y+
zaozmGwgh*N`exVuWd3f@-PU{0Fj&Z##%Q+4swC22<aXhHl9Se-BAAqW3nL0<*DEZU
zP}+F}e;Mz1jp)O+x01TPno;EbSHb-!wvFL$v1^Z@$3U?aN7ePIUkaZj%Ej3-*O^kw
zP3$9Kti=RDjZ~dVYYQ32oRG=!fHa`9+P^&+=vSnK7ZS?=c_nOl`w1cdKl+-sj-`Hp
z)>z@Rd@yLO@32tsqpB%_RE>34(Zl0$;5V6dl90gRZ@V1>GWzv{=F31;Tmzdn@7xll
zqlpxFA&RCRByk+ROA609KX(Uw*5mmUan9iCZp(H%)YLLCA;%>5UCiE2ulhLZF20-m
zAj3s7_AdLw5jg-P%g>YI;<Y7cO5s4n<@hX(K&syV;m9jEkjs`tivd!3-$Ak`uk)cB
zaXtN9{aQb3aOL7*8@De|G?O9W<8o36I6WocUl1zu0hIdI4XM_tN1oc0X)>G6fw<oQ
z>HbHy9AONY3v4+WK|WhyogaQ0@u&<F>B*k?3pV9eLDfFR<y6hl{!feG5B>Ab{(9k`
ztC+5Z!AKSBXO6Idu2dkU^R;&?jS1%_l3C_J?*F0eEugB**0^y&lx``dQ)!TrmJ+0u
z?v(CETDqmXySux)yF*0!fFKRuX6DY^xik0vzwf^m%XPp59L~Gny`Sg#6*tdN?%5jl
zX$bq><|NxZ?jQRQ{~57Xvf)ydQRE=zVx3i{7>9N;jJ*>hqSzV|l?NjN+>>!&0b(>)
zmM%u@fwdlo)P-oieXOho4(n&np2?{i$H@u95hqpJF@tA0x;$9B02p2c2gXo;20|G}
zOJC|)%f10$=ohfRzkh<#Uby){&#d1qC_L2_3B}KMrr>|t@e1$Y_I#C{Qu12ixDA*q
zyo?L~Rm}s$gTN^QclXh)y3<xP%Iw_i?P4|TagZzrl=S<pGcB!IX{QrnYZl)e4}NHk
zv^Be~5gG)6D&nMf!V7?s^$i%JeBhe|Ju16v4oPVHHYP(b4z#3y7aGct>fTuTmz|Y*
zkPu{%m{)N&_<6Lbf@;L`&+_(PZ7@F;g^ZaGrlgL5o-b(ve;mrN8r^%w5=Fx-?^DNb
zO+rrm=+gLoRtLNCCW)&5z8raQ&_GC;V~&>48BHSchLWc$K-hG>yd$=JQ2lI_86$5O
zri>F`V;xd&G+&VoLKg#=xM4<6H4qu!_~SIu^7DHJh?ucD$$#?rECOcnS@MMnD20<D
z+dh`qXySDzhLyn3a+AckajTg~o3vJ;SjD(8Zoiw{9mI0x6X|wv#D};jlHdjRUK+cD
z`Ch>q|IdkWK(3JI@MKxhOn8gCZY<C1_@eu9+?wyB)mS#*yfYaWY}Ogn2B^byn3NKX
zpA`FexhYtfy_27_7=}NzAy^Z&xyfqIJJ~q}7R_fd{Qg@*&)LoQi~340(OgOJku(6a
zxj=M?n!bbQQ3pa3q{W-qrt|5jK;XvDkk5XfAa&~jxtPUn@=I4IDau%*sk(pS1pivZ
zo&^$VDhO06y?z6(t{W8GbrLM)h6bUu!<KiC%no;Hjj&&kB4<eXo{AO_kcYk62-pd9
zBqeLi>nLGTD`7L9k~y-tzmq7pp-PPSpjle!aKy`VNV~*mzh@s>!Aviud=OJg*l4v$
zd6u5Y)Kl+PmPo+;t?e;4w-zlOovdP5v2vwCQMu<bi>_)g>}$)TAhUx7bT3$~ogKUr
z;9K%uN-Fe#sn7fK>e^aG?ICbRTq?2c=uC}^Gi)Aiy$9C9@MJ}t03HadcwYW>LNS;#
zXK3gaWVn*%9wwH5C>4v0MD2%$9!imgjMWMUeZPteBj7r0BiQfglrDKhLrWV0Miqr;
zCNo8^fG4Zs+zie>+07t`@k`>B=>DQmL})rwlz-*nzBM2ZJ=-?z)SZPA!}V}L$#lcd
z6~ok|M6fDwPCS!Rdc`COT>`)M`te&Bjf)akhG%j6Q<QDhnd?|NpwcbK#gWj{jb@{)
zFHBg!=4&AW6XV%+{AwGJxfTKLl)`O)cqIp4tV2-5HyWOkOE98<BO4g}+c@}f(!r{F
zH;p090`7aZ%7nH_QkSqch&>l1aR0<V1!Wb$CL4N=*pvX~d}7;PcgsGe-f-Dq+IS^%
zoH!iY0q_4n63whdMIQrb&DKLFOpo7T@%14XQ^RQst64*M-v#*U8*{)HGc+mc>gp!n
zeV^Es|AyUK8vF}9eKyW^jve7GJ_65>hiE!?OiD_L?^fH<yBn$A&uz~!o@x|wIvf_Y
zXdYh^q;sn^A6cR@g(9Ah?q1z?5}gm7s7Vw4UdH}qc1XU)<5@9pa1>S?_0F~ghceQ+
zM@&=;+0`Z0tS_ck@l(Kfp*O(xN7|P#;!if+;wNaN7AR-rZ1!G~@UA&+v_FZjI4e6^
zPEqOgU?Kb_335dku7Eat3n=VoCg(gEA4Cz(E1=EGF4DMEB6M@ip%xfJMB-91;shoD
zm!MNdt{-s#Lk*hDcbe&Z&nAr@{F9cu2Z{g+xw0jQae%vr&GfOf$vRj`J;db9yiU96
zivJ2^l~%j<aT`tW=%|?m$$QkUI49cIbz;+$r?}e3?06pS&olG`s@Zp$bGg^PD9tht
zd?)9*{A#;-{n-2@P)<R$cj{-p{qbNVpc~T?<|j8(0hA~`Qx8TNrM=5NtSw-J*8kQg
z{vgZ9`6<l(S-(B5jpqb3z6E@8MXKzwhfP1FjK<PDR~YQkDqr|wJt&4-5A0-UAgI3`
zE&M*1ZTCD93&!8gqnYjuo>SQ~X=~rQXH|DUU}6R^Yda5?chDq&UR=Q0Z+PPtsKBV~
z-*43fQl%re<hvou=qap8c$5<B=0upqE4V`S57LYzhZUzQZ5&M(t9ozD3%8&$xP*1C
zdYW|@Zf@M+>8#T76ozx~JaKvcjB5BJ7=;zMowb3o-TNh*(dk0sn_e&rFU=jSeEfC=
z{3SY9s}H%cdFzINz5Sa2Km&9OjPe&6!1|6D((`%j2i|(aUP<IbXgqiB!K7|Tx+yWI
z6$Q4(qbEU+rMg22xN`1G*nT-tn;G>!^f4sdXg!Zx6^}0~5b_|+q)be*t|Tm|hd%b7
zZcM#8!9eh!K>m{3eff1EH*U%wZQ8$%8h}SLK|{%#HqrYnHfqzwFK}t#ND{O3?%i{d
zTGXRU8istwj;1CJcwC|NF244$_m$(1B^WVrxak7<frFuVP)^}8D%iX=wF1JVMgl%U
zPRTgSFJBBh9EmB70K_Xh`JPC(zVg<jv{@uR?>_d<vbThguw$)#y-0a94>hCMj?n!E
zK5|jFXv|BgE&i>)P7>onHO+EvMgTCxqRH?cugQQnlkg9?1-kV3p7dy^O4gE@axRpN
zXI;IlDW&Cvgf755p>nsnTksAjqI=%5XcvXSdr+mi2&lK~4{iTG%x~KvD+9FqkK0Pa
zM(XIsMOw+^MS(P{A={m<7<m#fjCc*ew3AihkwTO%^!UhNV&joz^iC2Z_Ar^Zl^Plk
z@w48gdYdO5W){MjDyk331Urq~l&$C|?eph~_<l!OAo$YzfvaUAvI@|w-YZ^vG^t0c
zP6tREmPK*1MF8^2ZAGlIUp9NFLME?aHkqZ81c_@cR(WHGT|m@^&gltM7$We%wsHzq
zfD2U^eW8L^0~8B+&rgH~1?S?y`g<qY(YXw8-(sx%MOZ?|Hho;2kNQLuMH=+Pq@Ipl
z(d}QLSKQ%>H!WWKdbEFjks_0X*Yz^j7%kk;*9{OhawuFYd>D7Y4~Pa}s5Fo(k)X*d
z4bR^qH-+e+ED;qJT27{(OVC*4{F6R&^Db=xj*4D1B%G^p7JYbJNV^~2N$2?OrSngw
z(jU=LDd7gO_z__<1k+)HePKJUm|2k<!x_vA9#D^?`j4JXj;*=2jez-ao<D}lB38Z=
z(2Cb1;mXuNOBDJ~lQ{NiyP`d0xQdDP^+PCC)D0G`HcN22QmbEAS+M%^5V~0U8d0F{
zu4x1B=y=7C?VZqs*eb|`%z%}WWuSWl+Vip$`XebNCCTo^Zn~ULV}8q*{HD;Q#3G%Y
z_EXauJ<R(imkTp0<`SFQ$R&Q`mPylXc0Iv6fY(1Mftr_m2Bla$W2L&Nm+%`z-Np(f
zLCr6eTg*FKGXr~|(qd(jWXsQ>RBhhWnrY_99vBq#8X3A58J|N&9od++tqaf@MBC0`
zDk>|d<!9sMdUj15v-1oK)4koqMGvS0=o%9>SfRg22$si?5j@+tP=!5zF7c={5{go)
z9D3P&V`{1{5k}xdnWt47g9vj0PEk9_yPMj<+si}gar)zZ7<4pT{;_mC$}j*g=)*#>
zxxIc+)~m4EaapWz$EG}zh<1%@vv}l9J4VaQJaO85lbh-`5tw9dW%g+}L7%$y0i*$G
zt`%65;GPvn@0FGj<^@ZjbeC?_7QzSbk4nrtj<kWX*TvhU&Ci&Hceg56RSWBg<=NI{
zsHkS;1G-B21U56{A%#`M3uHJA$RQdAh7R@lJ7^Nq;HOsbceO8&z0&TlTkmc9*k`P2
zOMQ%|b|n*7#E83?+(N4=PE3z^JuIP9yMdXg$eEtu4ZY4R8}Fz{=WS+%vV5I^0^2A2
z-#72SY)x_o(BG*H<xeFTB!i-u%rei$i5O_3{cs4vkzo-|xh)*Nm+(@@zoD@H7^@^7
z>^Vj>8O2CAO3y>ydT2}3I=gr`@KIA$KOs7rLTRT)um6MH89Jrz+AllMP~^Z`0aT-M
z3D~8es0%oHG>CkGdqgw9dw0<a7$?Uz77aTh@?%=b5GF#CB|pdZAMdgCdqW8ni8?ye
zj{whVT3#ApoeG^ohBPB($;|o{7}DqTx;DGix%BFsdyztUu%j4}RI$Y~?T?#YnB!V-
z9)jkF%rWmkTyWLV&^ubU^`?R!RnrUB9s<#}T@3cq_ZKdbR3TwI{xMFa3;SiO@hC;D
z-{*MUdBt{em=G0flm7)SV#(~y<xi}h-YM82GzS)DIMHCMv|||})QecU>yNIM!Ojo_
z9b4BRODZ&(sPnh=y;Plnztw5OaKu$T08KbLDY7K;8*4XCb-T*P=dk1-<#oHMySckQ
z%88y;;z0}(tdq{fKR1<#NSDmijxYkOq8{2q(3o7rJ!%PBZzR-!m_I6I?2%vRJsg=*
z6H*JbeQwwKYBZtEHGQ)$f5!Ckmd{~eyqU^J9@hdi1VyT~QjFTWCZ7RcOP<7=X<r5a
zlhb1E5W&@pkj)(n<SIXS!(rlQZotrD${wPQ)4{x__hw{p_sv_b7Sftjmy>|2m9k$x
zKYJ}WrA-0&1MIF8B4r*$PG7V_Sv-Sac&*x8(1)#x92SA;JTyu3I59`tJys#e^O3}w
zT)Rg`nnmph0jw+4!YjJlwJ)dzgr}Cxtb5aiv1>j*doIcL{m<Of6=qXa)jEUd8${1;
z{M{H)%GwPOXK^3e;MmWmM6Rb_uM#zNJw}ncFdgxp++Mgn`kKvvq(jjJN$L39BSrqS
zJnz>Ef9l0@(5Rh$Wr6i*k?9f#;lCTQ-+PR_5}1Of-T+D_63TI*Pg3O)msaleLYNEP
zDXnL9Luz^4EOG*lZP1U6`=XzE`YMz%o0154)UAQrct*Wu<1M_-_(;lagpq#_Y*Y_)
z5q|}*Tu1qX$dEpP-?eK}SaSsq4R|`Bd|Y(2d<{g{cHNjlm}MZ1xDR*{6mWYa7Uop*
zL8iul?-^abMR@`OYBGxnD4|XPUqpNWAjjs;{QmN?{=x^SUx;-_l4@<oVXoQ)hd_la
z=ESdOZ@}pYd2)yAwLs|zY=AyK#A@ef!0UB1?@r}UO6X2LwLJYHd!|CKe&yG)fI<@w
zj9mzC9gEEY!dazm{`+Yn_1d%AWEMd!R~0$(SsZbfUh$bbC*}A9Wp9r};$fA2eMFfA
z{4aF4j`w@b2Z5auk&^l$>Nw0(KlrKR&E6o^Q?vogBQM;ckK-_*?d0?w;!4ej+Sbp#
zv<nTPH5eeOFeyY*v2?06Lx3I9xCoDx6oT1WiA}F&Nc~jMf15ZsEG&%umXcYXg}e=a
zoham<3mnw%E&;^=xq86f3fW*NPBtcepF~a+P!lAa?j+V+5g16(M3s<_h>{|YU5e~(
z;(IK%0As8@9npUhFl463C>Q1+FHkbhKQbj<gZLt%MZxw*UI<OWq)!(Ia>L=nqJXIE
zgE0C`XYtYFrq#mA%j*>7<oV;Jzmr<in9=i2Is*7R@%H<uqx$*wV}tieQ<*f%*)?-U
zMx#Ii1Fy;CEb{tWL_*v*s_mZ9qH)BtNT`Ovgs@dNzqR4J*ejTjwAm5jfx7#<Ye_GJ
zM(4iH_X!Plm}ffppMheE%az#Qv034~*<R<%(9q)(aNqA8=saY|@9q+GePnHT+AWw2
zQk|FNW)%Zg-Bf8o+F|A7_p*&aLo~08LGV6i@qVi@xesE%ry6`H*;E-Y*3JO2CoaKg
zwxsygFwE~`vTc|frZ;}@ban9#RC--Pq<5vHyv@tsBDM|M6Tp5H?a43pRXNH8e==ZV
z;5xCJLuy}e$mi(r!DpKOre<b*0!@80#V?#>WFI&l$S;2J?}%S_!0d1aegX>$F5mY#
zEKZuy6Cb3)Hipl&(VCcU+?_zdC6D?TqO?6itZ)g+#3ve@!EAurGWm^@n?PC66L(LS
zh_={^+e8U<kEumU5Fb?<0WM4zYeebVOY0sK6|A>xH8XFbSyoc*ea~s#UUwp<z3#lX
zyossxHSnzK{df%`NU*{@9SR7uArg;{Yzo)e9fjj5k;bpS#3DPa%2zeq&BZ+9IJcFJ
z2FRvXC)+<us3DjE7nOvcg?iM?EHW9!PY1rbtnxk+&C4!QfM<HiLXDTa*=w`Jd*f*$
zQ3pSRv`z{-vP_EUx>Awz;y4a>z=k=sZX|%ifiU(Z?;Ru3Gd5E88Y2~DS?fdA#xmcb
zy847Ojg%bMF|^*icmB2i3c?1}`DV#(R*0u~+V$>o+w2Lnijz|fT238+An(GNbVc^$
zNlA_Ou3J{h5u}0-R275P*W+0!OUm!A&R%?L`Z+RLsiV91<9dnYw|O5V^wE-1>(y@I
z3c<IxW)dE6h5Y5Km6X*0<<3t3l~6<+v4A0pgu<L;hT|A_A?PhG0v-wIxNuG4la9(O
z^6{?62i<PMPBt6Q%BNz<`--_VL0kz}@5@Pv(hn_B#igZVTkr2wLE7TcxTWPN(5CIl
zp<-SfJTA3UGD3X|#ckNunM`#q2nYQjeUwej^A1PK)q$jK(|n;Kg%em)PXn{6T?;<%
zAN)U_-u&t~dYgm;Lu1e8dS%;aTI&Sfm5Mbx&Vww`J0?3gw9(w`?EE7#M|{ulr$=Po
z`POGIo~5fpPP!mm3zO%tT};3W=tC)NkIz`h1%a;>$v(E*3zP3gi7Kv}*w7gMn$%yC
zfu(Maw$hW!9063!M4TovM<<=jd03tnRE6%(IaEkWfKB>0X2aSPoSf6Tkj6Ot);f+_
zLtvNhlL4}AioVTOf++dxeMMKtAR|j-GrZMTB4$LrF&y+OkQ%YnS!wCjt(sxi>tBi9
zn3l`NRWWp`xRJX;L9aT+bk25J&3!P36B8F#s*EZlX9g<DNwFg(;$XbiJyTyNzWJ#Q
zte56@1qG(sAHT|^(`-=#EGR41*m5bSU(4NrexSg6`_{83YxLJK+T66DKDUez!7xRU
zI<3m47Q}MeG#WB&K}h`ZH$b8XqfH1`0}l_+fc9|;2YfjHG^NK;O6V$|^g+_v85HJ>
zJt2Wqad&~uvnKkr^MJ<Hm-5@eO)re}n-2{JSl=qicq2_BWl%UW{4r7gOR*QuFHbD9
z<%0<~csz9kyES4yfH3%og3#R3gL{lhBjtXxjCN_g{<HXA_Xk^CYe_%D`aJzC4cn$N
zxfE4rQEA1P<Yca5%%xDW!4Z1I>2)P)<9$_KHxXZxFf<kQq6KS%@p0K4YQRK`P8Vcg
z*_x-Qf_E!MBH`O#N+LZ1`j}Y2dK4=xuvjlRjW_tTW2AY+zqTH*_;Ko(QtD@ZFs7?x
zg_o4c;^*4q3%RksUsrIM+rD}*sZqWMr_Xn#fd9e<B$p9`2iG2^j(#PY=1pLpw(*f8
zJaQ3<XQ0Q1W?(oeJ+}<6a_Rx=6<T%(*GN7Y&vWm+UecT1U`=Ly1BI_Cipur?`WxhV
zR%gY!FjK5gFBoz;<Jx88L-klU4%LL9&;c<@6`V7=`x785x~2nuN?2kO>hZ`&!BE^V
zU?NM!gTaOycKoTeDoO*lX}!DQ;fns}$8_Xxd4m8{*zJEi6&6m;^7kqR)G~S0Fwg}9
z{L3LW*%%3%V2Q~?J=xVUyOBT0&==TN;u-R7WRub00+`i)tQLl(-uGvNRhQQ^*@hjF
zHYZu3)7Ou5Hl2-gNxdLdX1Y8Mx5O=t(<8i%g{(nF|K+z4LlI&2_4j{m{(N4*5J>5Q
z6g&JcFy=2y=OWo-yK>Ww==~+voNXEZ;jK}tgrYYp6YJyYrwpKBoh##aQi0!=RoYnK
z;@1%hmpDo!J~NKhe)}?fCy;nkMnmipRw+Q0!{x%?$QIPRud|aWfMIx7avwCRbTA>E
zhKp5A3qrSYqy6Rl{7ADOF!z@LstW=Xz_<;kRVtIQKU~_8=|TGa^>1VIeE7o);J^Mw
zfB#}08zEJdc)cKeHq%+}Ei?mqLb5ua1R*E;+cV1aE#=yLJArQjPyv+VT{E3N1-Svc
z^a+oGfZ#D9d@cY@0_#o;aQu7d7o%dM?WUs40X<hwU*GAr!nu3wxumFnEC`S?67v+7
z8D7iQ*`0co`|P=p$(O$X2LA!%{0-LupL*_!r!Bx!S?2#DV2F7I=H9o4U){D;x_sVW
zH?W>n*%^TSD&VSD{K>$KK6c-2U~a&^*9Vhn<9H3gEZ%7XaRlUykgQphkDe6cEv{VR
zp}N+97@sqQO{Wq!u_Xyi16?V#yTHx&$`6%jCNU&1Fanf%dpiXcn9rZ9$omdh{gYkr
z=h*5$9`Hv~$k6#<);;%&9(z6+RYu@WM16X-aZ^ntO{f<Bs$ST@*AUvn{%D2H$?1}l
z#-DO6zdgFza9qv#Y<H_5Q03P_?P|g<F_P$FjhUp=3=FsMlGAo8Oa@$2383zoV6g&6
zcf)|Nu-QRN!UsRa6ql1%Jg8itrHP)JlKZHkFI|V|`C-0y^!T4k^gmwcpG)^)%L5RP
zhr7fvw$=UUwf@;1^IMO`pp(53HK)_rFCUaXU>~+GGfii^bO&PPd=wKGj|9zU{7ID%
zkYGI1?v{(pg)JUx-~qHRF#p#a^?j)`k@cAzL^_RD9)iK+@&w>@iiw*Pw=C4yA;C|i
zy?u<wtmp6cQoxq`xC_(R8T7O#*GJ-~%=-_?)X>oTt0$mF|1Ftrss5-x>5atz&<=m%
ztRck!K~Xu3WPni#NZ4}d>XoQ}U&sGzA#v!!&yA8QlHp%=Q+-Q+0{bm2n7h{C>^5fe
zWGLbbF#G==K>27J%&udBWhrJZSg-IxNC|yVUIBpn4U8SR8CJX_;#f^$#GXA0!w%y<
zDWh)T05X3HTH1%(aLWsEBz9Kgvm~eO53T3Dz?#zJy`T$|S%PxiF{tarKYfR4UIFwd
za$x1^{9L#7Y)198%4&OnrWcOeFikyawi`#2+{((ThZ?IQHPr(9lKTcCfyZK)wo512
z_!Ns7&0gT|8|B~j%|Aaifb&dyz0Mu<jHC;k=nwl&ZZ6_@SI-yy$bBgqg-vLQh0*xe
z?*QQ@H<iL0hJednPSZI@8+M%s8d@q48EGD+@j-a&z3=fu;I(&#2Nir%PZ-1AN1E9h
z;ChHv$Q}%CjR)bAg7Dh(23W2SlYUq~K!jFCzD&n@-~<B80s~;OlN^(6&Sm?<@I9H;
z-Q|~W;C-;^J2&V7u=O+47e>xFXi>PGQ4bEUALQh+Vr~9esr;>Q`Sa5>7np+PUU+2G
zBvJe!y735<#n<XA=}?||Ys2i@aZQ2%dZqJ*pUjnx{ea42+h)?`N91N`)}!y-A3<>f
zR%GIC+iM}9D3f#o{MO)C#T1~Hp;WCg9go=k1!QX&-tCMFF?8-PB6sgLx?8!vU2^Hp
z6dB03`&GIn`8>B$NWJ{?-TuEmD1lF6>VTicrIt35l}$HdtgjCx5kWv4CWHlYTFKry
z3Tx}7+40b8U?&9_%sGQ#rd~xm`3pcq1+e}v%;SgwvnGex|CQQ&lT+#-kiJm8U^lm=
z9^t=Mtu>GCkIe1+Ioi55wghY#O$St4T<T31s`{f0Bpy0sN+tm?iv$UeRpo)Z#Ty{!
z-I(x7v&F>+2zZy}-ifC*aVsbpw)FJWSX*1`0UFTmWutDuCa}{z>*UEVRpj+azHw<h
z&-iKc#)sY!?hnZP&#mKsJdoq?e4d{_Jjjlywl4U|4@)c!w1yK!${&rU^1hPtzLbB0
z3P+`#RK_=b+_onOs-bLP(}{tj`0m%iVyUy=T&2NiKAZC4rjD-elMdepaZDqfCX2^0
zvD!N=tu%bVA0RGDd)VIEb|__J!rdGE+U~^CI^csrI?w^8*EHz+OFFL4t2!U(%JM-$
zK~K^rs59k#m=r|J@iG7RU*TZ^Z;1H49Qnj-(zLh%y-n!0K)!G~wsf>OFHaQfy^^5O
zMFWw=0+-808T<6DMr}n%?-A7y%73ZD{#>bleURn_&nWlq$zubD|Ldap>l32=07Wr+
zTg8(6uV4MYKE{&p=m<b~I&%2``tp8zsnn<sl)2IBHPQcn-xdd6BNkH9^8f3h^V`ai
zBYaThrkJ#U{qHB!|5{#*53doIqw&A$ivQOEkjMR?H|C!8BKy6M{9n)e+t>579$q7(
z<v$gF|6f-?#t9BaJ|+D>FWD9a+Oucm-QC?=X1=`-L<<j1xG9r`_vS9U1hHoBS4+0a
z^=l@vc1ohq(aCKTJPTqvwq~wzh_mKj?YPc&jP`@&cFF7Vb-C9Tem1=S>3nQFQ}RXm
zWPm*=q+8zlKE3d%xK_yX-MQ8)o8+4o?RU}Ks7MP$vrPjXYi)m@1Ee7UxmX5*1`A63
zAN^t4E@qx)YfDy6&ifE|N<?CNr7FX(vs5uLF_fSjjr{S$FkiVc$Js?z_Upqf_zNhi
zz)lpkzi;|4oh>;KWu~vAV`y+K=uZZOd{B=`?e}S>$D=83IAtQ4gKP_2o<*{QqDDwY
zG*9h~S&a7-l48)w&(Og|)D`36o+?y$r2R1g(oX3+O_562P(lYZDWtNg{vpoqGQAvG
zmCq@~tdn1|4!*2ooXI!79*)>JC2<fllgakMysP`piGTRdRdkUI)}`CKzuu#1!Tdm$
zn*}yc40LqanEd@@4yz8Dbs<N`IuO631V)Lv#;^fvYg+lLwIx@^vn9zcms_zF7O76r
zg`IDQeqSDWr!Wo3^=cT;Sy)3VmHo^sP76`9@`y*HEF{ROdy}SZ(o*a;gz{TP|BHn8
z_lgA_f$D<(-)qeifq1Myo(9Z&3lFg}xYd2Vz5Bp+O~J@GX7(Bi3hF^+``|`px>z%8
z=Bn`9H@aiY)tlE3;V&;v2~XOqZw2;C$DhPOlK4GNTD5+7zdG6ZImyH4&-(Xk|Hqyr
z0d5G!buF(y7Jvtgi#Rbe^M~J9NuCh-L7*nEMUyn0D|=gGzDy0c&Jl5OFF~ZwOtT6x
zejmWp9(a4!`*Td1$X^Z~-h7W)7;tuw)7XUV)NQ^)iJy>glwR9!kL_>5xu;tb|6lhj
zB!wSn6d`bbt>vWQrwZf;foQZK{WVDTC1+)wp1K93j6&bbIUue9-NgeB{u^LT#R9%a
z;_lgx@y@7EzyB?1&S-E*2r+MGmt=XQd=1|I_sS{vf%=^b#o72L`=7%GUQbW24-^Y8
zAF>XBPmL3DhS5hG(`%4l_8_4V<jT&@J^{aTFaVS4v;rh5c%H*Q{~hi>BOBX`FezLW
zI}ZNuTW6XV+{5<o`HB6{ox_0AGa>>*zNrjY7lUXfv3fy$AihfAFHtJ*h+?Az+6)*0
zWH?GKumB>Gl8V0L?fpht<%0pMlnfAHL7Jc9V7j3G`pX9?iHk8#^W+!RSn<1ZL5%1r
z35<kPy5nI^F&RU;{(-rdel?|0Lx37DtFZ-F`LR;L%*f7O(`YHDlAPU)uH0^qW}W2y
z)(=nD3inxTWyttmh5I)4?Gm*$6=!<NDK48xL}Ip>o|@NGU|{rzEkYM!-9|lA4Kh_l
zy2#d8hM0{Efl^;AyhP&1B`uN|9}-06)YRci2`HX8y@{|n_17bqqoHxXe6K)vqfkE^
z>%3&%IYW@OEvzV(oaMW#^hMD4{mQXv_HbuJe2Zj^3#+2NnbKAbPm;KdrN0V8)~CAD
zX452V<Q2=$NsS0CTFSMuHb!<*eAR_FNxBv0$1Zrb2d!C7xr84+sL>|gsgd)!Uld%e
z1c;lzbfqVtqT@XOaIbi<Q1`wi@wGU!gP9Gx96S<2M2!0Nd*j~2h>48is}$Nk9{SHU
z)Fed;43S%Wt|U&qp$%ra1qyJ8@G-w6BeFkMJ`*d(p;CTxS;6a?TC~#gjx8&ZN4lP~
zH&2B%+hC7!;w6c~MuxGNsZias*r<V$$M5v^S_DtdQyy37kG_2+%X^ffqQ#GFG?|xj
z@;)Nw43mPJMG0@wO}T|aaAtpw%%^+BF9seJ`D^I#uDEKpdXj~dTYAxay`qBYaCoZ&
z5n7+HEH<vAb@JFuGb{xc`|3e>d%4}0hKUR}FBb8@$csF<`BY$5briA_k1)DyylDR7
zMAirJm*83iNuMp|!<o6VAhG?`IpDX+i@~!8<$B)WaO9ta$~;482pkh&=)9smHP0BC
z=g7>=loWm!iqDi?8~~dB-46IDR>LtMk)Z)0Z*6`sUQuF8pvDse=88|!owa~QodupM
zBT`i~5z%7yvpVaMk=Xk^3iy2WGw%JVz+$R?vr&1<`yl=K#`A%%r)N1Qfl{_FI92Ey
zwxH}X78V@j)G}BMr==Q@8iY`e2E!eQS~@cW+)cQ0BMu!dVRqP!n@9~ASBa`?7;8Qq
zjLHf<*~DrWENOBcmG=s8a=?CuK|RZRQNbB+aW;cVh)2g1(Ep+JQrTJ|42t>tiZa+3
zU+eY9+NiT7&XvWhy>_i3XJPz|+VQqJLk9*L+Ml|uysnHtrOrHjU{X2L#O+pU;k;4i
zn9|ldqVE1j;vhv5gko^y@w+?$lwbnrnD*Ia3hlrjLX~yj3bS<YwNIul+O5y`R^c2?
zp011Rfuy>8E1bUeWv*&dKRTrl_kGEHJVI^iLITX(GE;K1&zi)7R1(p(pO#2p++B3b
z<#LjL*wFp<wa`y=jE@v5>7#(HnNbQp15Wa!2;0F(lpo)XY@iz4v#V+|O0v&2iar?j
z61&p@5jHApAA&-+vHHFoxijFwR_+%hoRD@1Y^Bq{iZ914<lHnceYG}Ul<TK^8O5cU
zYCvrhYxtoybO_hA1qSv>LIIn+Hwwq9UE{C*ZSk4Dslk!SK?C>O#G9It>PNYs3q`Dd
zhHF5l`;BjqnusNk=7ie_{lXuK@#DSFs0iK0E4(lxBJ3e0Bg+OMie56N4=#pq?cZxh
z<{AH9a3`h1;1+BmHAA?~{@C$71IgBC#$iN?B)g0=`Rs?zs82y%QC!ea?Oeo&#SC_E
z%K?}T;JeZ00cAZcuP6qfF?`;_lIP~GcQCL(q3y=66`tgJrW>*J{oAgquCnmHZpF1G
z!*Hbd;YDq+VF%|^$8^I<-89xk3!~F52^Q@G78Y7H^Uv$8SKckvOK~l_zj7xk#4W-E
z@ZZ*<X||RhTl%@ek&Wdf16f){1Qf|zC7~?!uPL#qiJ5TF*guS>j-1=Gofj4f+{=;R
zkXQmJtE|?W?e1ZNBs1WPky2RbQ%}8PZ0Ar~FL~?F>cjAbFlPb{x3By(ai&V8o*p5i
zYO>CeCzPdV27QBxXFVhhKq@t&o0wEjWVfYG7^AtZe9Y8^sq6PXwG!Wlucx6uaBjl~
zo(%k$9!?1U@i)89U}X>iIubu{sUnQo^M%+t&ho8;Zp@%-mECOj?YElrX5a@g^LVdY
zgnHXHAd6Mb`x%xYn%Q)zrlv0v9x2e8$AE52+|ttWNvMbV-^=#4ctH<Bs*xm<;n)A(
z6rREmcjPHonnIJ4lM9{vOm0j=L8en}51Q=V6$Xc(hXtJ02|@}51OXAzW+9L3Sk7`d
zvT#c}iG#$?q38p*xM{eGUBp>9fgx_Bftl~}t7~?K$PF+2T-VFYwX68j!W67vGo0_+
z11krK`sXorUW}M$2{jQHQ9T$KyGdV;9o-Me)Oyl+cC7W>eV;SKkdUl75m$e7a5dF(
zT1Wl}Ms2M$o3-Z~RwLnq6!}(&lZ@ymkJl+GqRPm};l-ej(DN|S)qCYem32<13}Dt-
zSUS&E>fP#1HGjr_qt@o!*kk|D;mHzxm2Xrd0DZu*_bYOnP^KgIbn*!y&dU^n7}x9a
z>V#P%&GIQu-`RldRhP6A<HbD}I@MKkwHldY`f|awd2+@d-?}Vsrz%gaH>JYX72lVl
z&pxlrDkGM*FH)!fTx%vLkd`HyS;-k+g1lR*2C437qV19g^RF%7YR+11QxGu7(7L2A
z`oz1+%3#I2z3o~F6J2lX+pBbH`@!)gZlmN6if0_@XY%ik6D&I~m%rsp10wFrS3D$*
z%&3DaWb+Yj#NzLxMlrd8ZGT2O#-~j^QQXtdn`?v>%J9qOipL#V2AB-HG_28MK>Oa@
zV!zEhU*y>40ULz!-Vi;i5yRH7SLelZeDYe<*FkY>!n)BIp?ZGID?I__6D3v^)THf~
z&c^K2q(LM3RGslgz55?WT!%xOtr@xAJ%35a!}&`4ZIz9uL0BVJdiMnmuUu!GVK2vG
z%yz=!?P}XOUy}iPkM3%VYX$K2o^Nz0tvrmE{zq{Jlx7H2O)x#Xf0jw)mYncyU%X{+
zJX{q!;7trs;phy(e{PY<)S9aU&^LLiP*FOysHVnWtQ6qxeSkEvb#c5oqvLlPFoAKo
zd5~{SuKPs;91D~@R823nW#NqpDQQ1mtC75La}+GyJW8Gl<;jv&dH0chFZPDkCTEpA
zdmt_Z8x8Gc?8;f0Eumuo)8f(f6Q^DZzVkZT+ug^Pcg5RTqVfE-&$$JbAQy>VKgUhu
zHayq10y3+!j1~_%Xe4$RG+pJe-EN3Jro<S|q$fT{(V6v)R*5;NF<LBf<`se;U1k<w
zW-Fck8O(+D^t9>Xc|UKI(NN7YUjf{knqmz~$;IU27%~ar#FQ_3!xpQHGY-)^s4*(;
zd`-7aL+%ze2~D>?(o<vfDtH39O-u*QtWM-MVFQ@(j>{f!8)GZB#Ra=(Fzf8WPsg9E
zM0N}N^qAr~ZA*B<iBuL6Im!|?H0|@Cp`)*VIL#v1?#E7*&U~Af7JwYy3W}R@rRCZg
z<=Vk(F$nU`wf=WlKGA$qsj(tZ<X8{-@Kk3pU#61ERvQnD<G)L%5cs6G{e4hzaHij3
zkbS}T%yF}k!g_B^W1?9;UNL&`vqQM@PwZV+LoSFll$G}<G+l0vbFNEObQQy=^boc6
z{J!;#Lo-Q25;SJLlSIvd_04*f$bz=bauWtQVQlA|AOgp3#uU^p0*et%O1_dgJx+v-
zkbbgj@xmw}RwB|sCReV0RlZxJ0zdCFXRy@VA2`&G)of-9q5=Y5JMPFUCctiKw=gY@
zpUr$J@2<3+7trMXXoCLrU~LMR!&vR^JCgtVv;t!+;5;*}UpZs7*%LzXdh)VM1>mt&
z1-op-9$yzE_~VG7P~rJ)ZD*7X#0F#NBsDaH{d6~w%YV!kDQ})puT`%Ou>tLnxs`Sb
zt=p~ro1;V2Q}gGx&q)*A63DVCx}8(_9C{=^_e|ZSuDX*F@xGal%B3LAx`6b*I@!y$
z5KF_*$jaES?$>=H0Hf%8a=*l-@yV_H16l*rOr9NVu3y)b<jmmOt9BrKjjkzDBCRyH
zC9o!DeA)L+cw_A_SxOkw5ah}p6)^07)=A}dXqC8XB|0tWG*7U9-vRGlHubdHx?ORh
z#8kPyi#%!WbhgxaK0&i})(5lCyB7^eHg(|Os9D5Ut5k5*4V@N#wN@TRMtwIUS3cf=
z3JMgDLfJ-%#^Q6&mp@*ddHKw8CV<K=i6H3ari0Y!$L&$J1hZAeFN?j}d=09nwl9As
zFgHk3Ib9}pqYO7+Y?Y$)s?wz2#<pnC5+vrlT)~lYt65)fA1OIp?T)%lC5i#s=$GC~
zx)G!<j+?(^Dc^eRw7Fw=4xGodC#%E<9=cweL>fZ-K%N~}kt)Qq8GGcHRKj=@izNPx
z%ru1FdLrC?0`cP;FsW6~LDYU~XZp$phu#4#-qD(eCqFX;sEpLTaGG8KPowv)%7QiR
zmAKw6jt8r)nxKfK0MN1u=6{isI=)TYNcrT%^itu^GZFORWmJ!5hvJ&1k!a9?agntC
zR_$h1`ZA0~8iqlN2oQk3@dU{tb^-_*lu3Bp?ZCcM1FTGPiUIP*+NTznjf(fCpOs|Y
zLaFoo^WCjC82Qo3yVy+0U~8j&UX<~S!N$Y2Y9k4Hmf@uG@^zXGey%aMRPBw$S^@<}
z%UZ~zb+#%rd=(D3;-xCqAtBh8=aLdFxfU9_1sjskgbcyhs<kc5+W2b<5N+<BX}9ks
zW(8=OZa*XMiF7a`pQJDn??QTRI!;od_-QkgKV7kzDJ~z*fB2R1rfHOW=LNbhiqAyJ
z5!$Vif3!xjZAePZqSIcxs@_5);%Uar_UWV#=Ec$-kREOz%4(ONT;>_7mVFBPINli>
z2n(NSnbC|v*g1k^Vb`d`gQ_i5bHtbRS;K?sDVN|J((sy@&bZ3Y>X`xJl)1RC`L(%Q
zs<p$Bn`hzVFBk3B{PhT{&o?SRZEFCViqlhVGt`|Q{)|RZGHfHR??U@g2ZvKAgL~JP
zNTP7rA^5B>2#FFXy5XB#<-9>4b3bq}npTvM2wrO>@~)gYvIRE5%pi@ORS)To=xtYQ
zY^)->pdQh`kC)#8Xc;=Vx%-J??A)HnzszNJ-)VuSW&#+m!=s`qN~53-gEZ&gq7c7*
zkEt(`0$>;+&%n}GMLrB}G7JcxCzEauoWjoqJjx2Rz{i*$Q@l6IOauqHfMXIr_xcdC
z!rjXROK3ae?wLZgb)n3e?`Q;tIIg-co_5aHNh|Vlzb9uirL=p&9y{0YDhKPJorG1g
z69E}9)~l)FbFM<1omQ#$I}sDH`jflut+Q9NfmSD)45wPK8OTj67C1o8|N2(=axFm2
zI1U{(!BTZA(%>kTOXEtSlzpQH@1)D_%js$U{)HFCRW$-Lg0+oAXa8V7TQ-URn1JR~
zAZ_BB2uED_7-RDxyuQGTbPi+OrdQM9&yAfzJR()e$66^h@>5kPdAWfUmK%uEoIlH(
zZNrKy!EaumzTANJuJ8}xxO7cdki7mJe~i1|*(oSs>;3$Sl)fUSqqs;!GDwM({G|*+
z(BPr^*LBvjJ>N_=>JDgsl%)C5!h3s~Bu3v`elEmWQ@fd@g!@)Hya}4(fI-d><cxqw
zENRhIwqc3w0@k!<R1?*UY6SrYxhPA47l<{WE&U4I0P`6fvA)D%r*j8CMaAmtH32qI
z71r5%i~>En_5Ua`445B!-fxAYHdKFr&3O?pApVjVbhk6TgdnRKI7VkvC-J+OWPN#7
z3$X_{N$9<~qMs93HdOF)0hAB4s6Yy|h)%_r*e&O2>%*_EIVBxf>q5eD-<$dOOtyXH
z7tFI4bp)F4;}Ww+vuDMJA#h>6IM1=QX_A!gCUKy{UL;J5z5n{k;+DL(5+y%{fbHfu
zs7UpsQcwSIyr6EGG)ri+l5_8DWcQ5>;Vu)uneO#Mt6nD&;*=r?(`XK5=Ysfutv4wo
zXE7`w^gYOT9DuNjBYpSYaB4GDNcY}+lX=&VcdhaiO5D0~rsosP3O{{QJFjhUeg+A8
zbhw_V{K4`N?d(xBS?_>1re|Py7q#u!2rs|vyHkr*HIZM2RA_vT#w3B^9WRqa0|QtH
zc86YjD;SNYXD*aXnl&rgBwkkxk-pgTJd8_o6AZG<C}BQ?$FZ$t+hSfW(r6ky34FN(
z9O2e{WIm|8M3q!3JR>4dr+hSd@}N-t_Z{}z<1#9(UpU5^e)WI7DWm=Qot+yvtxWJS
z6og0*?MzLJ#8{x%zbWCB;;FNlkk?Uoek6M&i$R(1V&wD=wa%2D?>a4?o4dzp4((&N
zHRW1$yJ2H(5j!Q#FfR;Bm`k<FQ*|3Z#SC~bA;tVU?-iz@*y*e!jgc;{Vt+t}L$iW^
znAj*vm{6-Gvi!3ShSR9m@g`}99h_gmPIV4sMIya-o%%yn%FI81Vp*?Vx4vH;?7=H^
zYP#P+d@W(ea5*cOQ`P9rr<5UG*c*`H<uWN#WRy7uy#Y7;JSV<6&G2%?lmsas#g`G+
zvA&`R-zM%U988gK)BTcFy&C(PX(@06fz?6EoG#QgzlShY8ldZ{?-N;n4CS0*BH~cF
zV|zi~m9}H8T(<72T;l6u$#}=mKIqMA>xY`~3G=V-+rwi^5%e<6Kt~ahwf=uI7x<^i
z9()}JLF2ath=dND0YPPi{>!2A{t40SSspVewd9tRXl>gRq#gUskLbsbcYzIB!vsz`
zCkhd-8a=-7Wv@D+1sy7Un6>h%qEC+umf_DljFyZFWg)qurMnJyikDsZzG;kniWR8(
z1%#w0HUk%Irqdc7#-DqR0?NO9I}wu>^|SFSNI~8o;h`n{@G#$*XgH5GuxJnkbDpxo
zobOxsJfx@~i?_u60$I#xeCF9io1=`aOT>n-c3{=sYo(M%eed$VgS!|k@o#;1%LTZP
zqt{u<TikSOd(*x6lp9`n$SZlu5ZGfASYRW2?xYm2z&nQ$Fd=^3zsg5&>ZZ^qVNME}
zr7p@NFuzOk_Vew_oJIPYK+>K=X?=pI-?}lpQMOS|TAMcXQ9e;b4CANt57bGhdva3R
zb=oBLcL#HuPWomhPBUhC6x^cPvgOr*uLxv1Z?Do`1}TPw;9XDKu(E!mEH{sx#|%&0
z<z+yT5h!3WnUO$Cprh>3fP=n+MXAI7e(9oR8vgehwBP~ODu8rvj{P~XA2Egge17;~
zef05+<trGzJFdUI8qa*E56B_LKTwK-XE$uV%#`bvEIX&p3pxEF*P?_xSUM$h+GPRX
zz=<+#!AS#nn$L-BW(6$(Zq}d7k%UHNfQ#KM_7Rzrb~ZXt8bl0@md;DB-ZM|khNB3M
zJPbhosE+V>sd_u?1hJ%bkv!ogJ#9E@N*p;2j*HpiGTo?~7DBAH>Q1VJ#P`<wi{+E`
z$jI!UZRpktqfik`w34KI<Z&yAd4w8VDm}cX1>8Jt{)LoJFmFd!odc$d<W-$DY^$^E
zcS*!T5(|4(QN8P+p#w`bJ`bsUW4`Sk4C`Zk{b|omWaZ7r7RO6%o&(d~RNCaT9kaU@
z0{27|Ps5FAvDvtjCb0(xL1vrp5*8>{D(4g846II$)+*!gp1?J(j|hAjw);iI<PKX`
zW|APr@>Nrbyz)C;)HK(=;Fv^HU8${@*;>`&t+GBTg&abSKVcDUkC3-=CH@3#Xu@I<
zrm{Ge9f#Zv6&d#wEp&OIpH&T8QV;4Ndw)a-*M5OQ1Gmep$z)DQR#q0rl3!K(hWi9i
zHR*vC0qZJd>S{aY9~YMT;ll1lZ`S>JVMW)7paGszAOo!fUs!E!77Cl1e89<8cjlNQ
zwkAPk`D2Xa5=bTFWj}zvVtTq6&|%oL-%4D9VQwBn(V>qAbm}{Y!s2R?4${qP^~K_9
z?rn(qqI1j0Qmt!cmi><scGXfN@p(uugY$wWmq>YRBk#f~ex4%K(YD2ld`IHBv~6Vv
z9gJP&%B37}adEwQ2ckj-ITQqxua$nm5kE^WWBWe~f7ryv0QKX$jR-JgXTEQq-$gX*
zSnPCCT&7;8$2UW`9(TRKE%m`P0lDUD^6B;x_z5wTW{uQ3VM2DR)2V@4I|c6212v_W
zlXA%E9|v^dEVc^AxK^4h248<VP&$P@7Sb-a8O4;X9_sKGod3=U(2E4a;r#Q$d<$2)
z>rjsSlyE)FT|o=}`FWE!HKB+{&p7CL2lmH%=VEGFw;{5iSnZ+dfLDB~?ZdSgZ-kxd
zWDV>uZk0o2OwlgefGQ?$-o$@~;m{p!s|E}l-Z+*yJIarbg#3ec28>z{U2zqrMCbmh
z{_z-vuQFSlnfeYG84^a6pi$%|lL3~a2&6!uqkFkuIhuq(24<4kKvrx$%sMOD>UK*`
zfB5ZNb)g0+#`6a1n7#)6$i%!jn>jbux<L`Cbj#VE>6}az`yI3Q*VJDVll6_Mnc3Q-
z?4#id3G#7>6uY2HgfR1PkHg~l`F=dJ4-7)kKW=i+yP{BkqVXnprcTm8cVhE)^BwBo
z1D+P9`8g%(S*#B!96a)C_*dL!kj4AYDy4z&zuIS4vvZRVl2BqsdNye9!7Lz>_!adC
zenaQH)ii6XQN-T0xYye_nKbV@4s9rOGc>j~#4lj{iV_lJOJ_T0fi5)_7FKg=D8(ja
z%iuC^(?|QwaF%?2$)94Hy1QA_&`+2{mT%;YgHBye6hk9~c;*F@j(6~L*7sNk^8u7-
zA9jIDTR6b#RKJg=N{<Wqs1f{~y(FU!Kej1k*IdEP@JA`&`8tIk7{Yn`L>IFS4-Lt6
zIwl=!!Fj+8h^_T~C9BYChgJr7G(e{dXgo7BG9-#gO{Ks+H;u!sP=`S$Ou-ttR<`gV
z%3)~AH%4^FvIY3l*r0rho49*#s(BroztdyZkeAMdqG!s!70X_3kT@?Wl&m)^fMMg#
zda9@Wwxz|Q*5+`Fy<mlOe?W>t`b_BfpqCl4yLi^AyO;ChI=8~cQPX#Sr9$d?m1!=K
zhAMi5p1w0xjB-w}$q(;*3~Z|pN)c08*()hOlP7y8F5~dUPr?lLQg}PaGP7M*Nu&fT
zIS9>0lz}JGgTl~DZ1+T^{4M0eN)6Z{MPp|wNL*XZ&alrg$+=mC7`PH5bB|28p!8$a
z&~iGX&rB92;P=+A&@q}c0krg9X04x<GXz72f|OP+bbH>9@%dP~Pa*wuMe+5}3T6YF
zMP5yqTM>4#_njfy5$7p-=zO$Om#yLGjO4e2)Vru9FM*GDI}(6Fs+N&?@Pq(D?|J{~
z;h%T^g=@QtW_epU%kC=YNRyrpHSl-{E+7n5RtLk+zk)-8_jc;`OHN%K+RiGU#>r1{
ztY|mS{bkj(BJ$Ub6-AIpZNGmPCYA^=#0j|Ej%7Q2+2XMY6A}P1jtYC!Bm)RbVy?m>
zBJY6?Tt3~~4g;GM!69bhb5+s(oxGnhn!LAgtdo{U-G->Ivf-L#co;LIa%ziFbyn5O
zpK7mvt(NvpvLi7$376T=Zcps#AN`W7xGY^Q60R|FRC@V}{sT7+OyO3@B&S%}hEaN6
zn^nf_0{>f$&?zLodIVlhUa{rTQ6BSRN>-C;1p)1)jqoGdOzl0Cit8gg=p&4hp_i8Y
zJc`hMIq&;|iwk4xjiu;<3JtJB@wt+Ae&IGE@D00)(Kl%as(&?0X;oUVR|p*<T1}<{
zQ<j`s%VV?GdIuXs%NjJ^f;-%X-n17#kZ<R}RLKdrp`6;vFB+|8wFpfYyn1JYFD#hp
zY{!^9QhUGnz?hRjXA$z9mHQdFCnRQQ8Q%8VXPP*!t|HZ7Mb2%tOx-zkTFzo4;?Qi1
zPB==d`cq(Sa0Ao#vUf9_q6P$`k$^BFrqbD9Y?YSr3zuun)aka70%h8wDXmd3MO`F?
z6ys8NQtC}(cmL?~g(fMZpWUTy)rIB*g@xWUVjp^%brRhLDd%rj`Rl5|(KGOUI5B!#
zEwlrDl0W`$l{@$plHhSo<*32#<c!L3e*@$6Yo3kSOvMI|ujT8;Oj!yNUc`^_G#y<*
zy$c9=H?mH}lC?Ny{F};X?h7q(qm`v<uJ>Wj4Ja`3pkdZVnjI|e>$FOsb4N)Y>Q;|c
zxV3c$zz{o|-d>=#-TPJ$W3luUHZ@7K3dJ0F3p~&wJo!5=ESsg0IVb9E4C)~rh?19<
zTTKq7^Vv<+k`EeUspLnLRcoHmhZE&z_E?sk^f>P)Q!*tUdl+scnWVC8-8TPl{kX6i
z@aDC-f&f{R<QN5uA@wAm3UvT-;u~86a0E)E{LI|lA+C01_p?^S!%Ljq?S>lIy*E0#
zBQ;tcjT|epoE8@XNVT=J%_)MV(D7KBvX)Hv($&qo0#Sj%&YEN8<SoxIHyrO~$dtMB
z6_3-mLRRZeT^sUxWs}9utFU@y(1B#eYGYjlYPL*F_7FfCcH-;bCl+o^1cbp+9v43?
zhr9ZM^JF-baOvnnR>pMYq5!c>T&jtpUg9=GOigk$naw!Wy#d144>Z&wcenGJyVu<%
z^VrFs`&%^<s3z~P{S*Z-8f&Ok2`O(<@f^N(&7iO&9{`Z33%3GV$Db&M3xSFm<<m~@
z6WAvMQR3HJj?spBjv;ZblcJI52)D$E$>%t9>{}_T`O!#R*R&rAg)m?DsA&z@M92M%
zRJODQuwuNUmFBpBDgUWwd9BGlXRu#+*zB`)pK%l6u$hppaT9u5tpMG%xW`-4>U?US
zLRv*jUO0x9ziK@cBnIRIh0AY|(%*myXer1b{F(vZiec~{ZmVD$F<|yg+qFG;3`^NJ
zt;i19dDU*y{jEQr*>2alf2hiVVP_I$6w>oxA*kD{QTWmE`oKYMHsATF!;Q#Vyg^D#
zRu*~nEzonv!eg38HF2L8-rTSev;Ai6IqlC6#zjf)E%VbYXQyai2=8Hwe*trf0ndAb
zBks1syc)J9(Ifc$EWZdDfg^deG7o|mHHC`h+U>r9SDK&OgPJw4URX|>D5A+ei(1LT
zgd-vG<aa(gTQ%v89~z3cvHsu*Dc;62IB(ugw&}6_#crZ+@FFN%)ymDhlHaSirbYpQ
z!Vy37_|pn7t@uPMLI}g3MgRvnr+f8Ej8H>E;~{J3_z3Qr`)QYCLyU81V^YBYLjU-D
zv>Ny6I-hYN^-Ht83VWsMGZMtg*M^;8spE5qrLr%Md+wHe_&!R?Q$$BU8?cs6Eh*@Q
ztJZ#vA)eA0`<+fjc;NL=qX}`j17b1LV!c7PanO%kAH*Ly1}}KvY=Z(ab6e)$*Y{5L
zbq@<Vr&*psrq0T#I`_1o-Yr3nPqe~t^@X2w2|UGNcQ`?WuSC-!KR|m??iCPkw=)45
zfi5+gI;Ht0OTld%h5b#|$_>TI@miK&DXY%ywh_7T{=8-0(muBM@=907(~oCHgZ3c4
zvEGc=byuq4I;3>kd?=ca!6h}0YL(02n85nyNsU&4{Vq8?N^g6IZ&L&_9tPRasv?ll
zsBMHLo_|QbxWhegH?fC<65L#+awQe`aohOmgRuf(eIv&p<BPy|2)ddkPQTE~&(_eN
z6E5P`d@l$PH1dUTw-eH<dGlx1>sGXNa(wrnd%2OB-J|{HuF?6$t?mGvoqt^T)32gN
z!dP3_u>;l4jg4P(RdxF?tF5@GIG(-J)=qyW+14n;)!73fegyp=9}sq^+fwFSMr;NK
zs)p|ga6vSA#l^W(a@Q*r`FVNSLlT2T4NJ=eJ6C(Ecc|7u!s%_)P!<-=4yXq&suZ}=
zGo}IFeGTNTgu$!kEvFNB#e_JIJs!b<4_kbwUmEGA9L5G)M2qggw08iQx?z(cLlcid
z!OTq#0uxsM(HdGRr$&`wFL;MlEyQslN&Q#F*K35y=djfuxu{y4Zmq5^GZksS+gn>v
z5Z!Azz0_t?X^7%pf1`8R5!;0ylh`;A_i41wTe8q-bU`zU@?<FS`&;zoes)IhstkCP
z#;;Y&6V0t9mC;C=skQEC!d+)nzZ$epHQGrySKNQ3DmW+N{KQok><H*|h4Fo-Y6>|*
zTcMe8`C0B{z$LEea+2^2b8fOJQ)!_xCTAgwVn3_)usLu*JkVD1lGmya`%bOl^R)`&
zG%IiSYb??wArZIDv;V``S3qU8t?deeq;yD&NJ&dKl1hhkr*wBpcPJf_(k<Q6-QC^Y
z4R><({m<U#?0xU}$M}W=P~l^(HRpWa=Y8VV#Yy_Jv?8FgTX3Rp@7i%n6kqT;V-?PQ
z%gMK~woOfLArXu_T1mxZ`}}!)$nW0Y&a6;h<Ng78CN}G_&b#$1)Q#g#$J}s;B{rQ~
zU6A{t)6h)RucQ<rUQ^>U4c)TR9JNLo&jpoAg-s`~+Y)InWoxA{bmD|1X4CoFXkai8
zdx(bk{KbFX<!6utf~ljh<mnmn?FPjU)(=-C{s;9o*xcu15OtPWnbD&Smj_uMkDP(<
z@OgG_&gaGts-m?J5fGk{abL5u*EeSi_TDx^QNM)Zdj=(G47q=twFLZBO&{V05@AHb
z2{YS+vE@`$W<K@91V8s2{lRxrv`D!edzo8Q*?}QsHKDC?-y!iiA=X@F5!II}wq9sZ
zlQsTVc-9mKYYDdROEKPz#U{t%>E4_BQ-|&GS-Nyxf3%!m1!D&f_>ybc$XHW|Mpj%-
zyxfd7T%~*hCgVB{29+C$QhKVY{746#lefLu#iM1D;%I|wDrISUI0#fqOER(%CKaKw
z%^EaV+-}%3?iYlaAGs%0u0wKOBEo5mW~DrQp{PhULyqB6wV5nb*A}X|{z9yOiRBEE
z-e*dk<9%~PW>ZG@;NDuza@=fbR^jAJPP>|^b93Jv%W_cH3&i0}demDpx|Qf;C|9Ud
z9>s>9Ee!7Fg1pGhSRoXL`cq7OER6hnHW~HNR~;g%GE{<zQXUV%u*lZG&zzbU^P9eh
zjRb2l58_SSQn7SZ5DxT>1`@!F_8PghXgeQe5N#`&dt>A4bJqxMq!4Ag?=R@p-tW_8
z4rSyXa)wu!_VPGi1ZzeguzCM$vHh{+{_nzj1F5c~yIRmRVgs*E;lEwI{Gve-7O7af
zxC(AH^Ot|1%>dj4=A!d1(mPs~M+Uh`lz1$3EjpN3b^G`k50JiA4pK6h!v$|qm8y@P
zpBx=UpdTR%mwj0zh7t^Au$Z+l2tkB=ZJCFfQ&7M*9y4b&*_#~S($dm3I2i8g>Z*5z
z<X-keoijTttLKQ|$HfZgRSOUU9kqQ1(S6*Gwnu07Qj<V|J6)NTweb_PFA3hH9M2H}
z&#x^sJx!4->tf-0Ud+~X&^Z1QDJ*TN`rBtZmM$^tFj?~*+7%Q6@<=PTz@sVmF`FTZ
zpgryg<NW+>#~uidgzCia_EQT#%?5WZ?JiTN(pD*I54GTf_CDyhLr1w#hgRO*F=MVz
zW7D=*^T5EM7U@p0?MyVVLi@1z5N^FmZivtQWJ_&CM0&U|vzFChCC-XWx5H?iu9o3Z
z1zVFlxIiCA>>}I6R&e=DYi|+t`a)}ZVfO+7DMQ0sL{9upnwUQ?GcU-xhr{}#EA8b+
z21%Dek2jrPEReiw{bgJ~=U}kzakz%C)eG5#2pFEhBcva^Q4`8(3P-&CCa=Vwh(4-U
z%dTrQ%Mnn*I$sAp^gE88*ggkSoA1P^7)7U~I=!NUkeaPPxaO!aZ3+|JZ-`X)1%-0$
zcEw;|tM!!0e66!w@zCpSEAQ4sj97WtLBe+a)bC=xndFmYQwt{ioG8yA{_C|1g@MYQ
z@}q#2v%+|%Z5BfX#N4CvV$EWw3(QJ=I-FP4BTk}+!zp6w#DS7@f&>|toIk)ezP7PJ
z*8WaNDAZh2>N>a;`stbDBPacxOg)tkMMRJC%yZzw*9Ng8tM{sI4UQK9{f0b}Wck!|
z8Qi<>(ITpa!Q3oBIF-#cW84??3vHV;t+2x++-k;K-=#o~lg#CO>ZX_VWGE&DX}f0!
zm(o(}n}ArMsAH1WAX*0s9u0xicIS$>K&Q=GT2#e2duLms;NZ|RJI9OKVf<kz2fc6q
zdJF&ct9p)x^JSw-M#b#Ri`G`NMR*HfA7^E1NDn8ds%aFZWH9Td(ZME}Lglq5dOc+V
zcUMvuz&!1A|Mg0EyL7lt%&kiC@-)cIe_MKH8LWf<I!~WLivLb4)5^&ksdLf;r^y1%
zq_3mX_N{{AB>L0U`LDP3$ETiQB=j~b($1@uV%vA$j@LHQ9~=A>n~7PH>+KWFKcw7M
z3dM@N`0uv^-km9G$=zgD;RLyrx{*<6`wkcPkDSz0hKWp}=XlWW?gO<mEiEyj8F+1B
zA^!d_pn1)q2`3tSO{(WrR>s)g*(sO8(?H3^m2`57ptra4L`qTGFwQo3>*eij^!w`r
zNc<(|vSpLy2TY@>Qg1-?O<)k!l?$uj0l5}IVPRQAL*{MA;io6o?Hu7lfX_0^HBnn!
zOb0@l(`moP>**_pYtH$u=G!0AvRz~lay!dD#WyZA_}lN#2w`H<1S|IFGVnH%n*!?#
zwAKBrvol*eb>PUjc5py;iisKh{-9pPhy(-+e*)xb?3BQd#84;SC+*j|WL8`>RAwqI
z29ItU>bcg9PfkzU)uve#CZyXh>p+MJljG5AcsMxJ$!KAhi@h{3Ekmmdw<vOQa_SzG
za&&xk{G}`}F9;xJlE4n}#KvgQ(bLlt17)e0MM6>%H9gz!@bI_ib5f}<sL!YR`+p!2
zNus7)-;<jmI-b9Y`0sn@IU2{8T15_h<2b?`={G#iFW9Wj!S++w_o_;xx{1#B<~CrF
zs11+FLsi9|$4rbPUC-*p-yZ`{GB{h@WkIV_{Z}ugq&mqUluVX(^RXo{FzrGtb^79l
z0X|P{rwp`hnWSP5V!&GsRUOzof~mbzuX+7(O1Xt5WW)W%tUVmzRi_W|aT%?)(zWBI
zKKcoiNs%^_6B9lCYtRT9zf8m(92{z|H<X!l+F(bSPf~#`9m4)xP2|J<AvDd*=U9Z%
zJO6el5b#rA-WU=hUJJaBm<w^g^YHMTb&;F~Km)agT(v#mcK?#m*C#cby@*}wnp}+f
zVKXqjlB`As{c@&qwS$>{tpdn>`QRy%9arGw*_u!1EL(Xi)Tu{+-|tW0ZszCZ<wd<y
zy%eKrj&<ou)Np&?K|xO5SuSCN5Fg&;;l1>=_z?sulyN`>O94kK+EPoQ-pIp8ps;**
zTe`Fi+8(TxOvwCI3QPtD2HQ~yR@uR1Zo5^=b611oR)BPGc_U-ZU@RSNMnIzlai0yf
z{<;SS#vhWCU$&rRh8d=dV_{>D-d)p)4vXm$$o_p9ljA`=uo^}b$8z;ebfgExHY)2Y
z_`d&#1zaMUI_k4SL02`mWp870y^eFMApfJ9o}hl&Wj$JP2MThAvxgVAWYQb>3ksb(
zrxs3TIqBXsTt1LMqs_duFvFAN<lqn;L<Bad30!!)71t#t^v=75Rfc_W3<{H7`%aBO
z+8JDF@jWFa#Xi6wdz#ZrhUr^mq}Y>>SGy8*2xuXzeqtl4PVVjOh=TOAG+=&~$Y$2N
z(HBqBhRmu2GDO^_&^tia`sO8YiBz4_yYa&-!d?k?DF`BS{OadIC<Ou+-nVyju&^80
z;FXZWnb-r9p%D;FL~@u$lMLF2vyDWHA)GHs+GZ5W?i=xuYYltA7f5~>id8S13g}e6
zrw|D(Y1=F{Q8hF)tUJ>Pp@%lq^fL}}Nw}K*Wz*X-gtTLpC*UUCcn%hTr(DqQfhgM^
zOfOhf1yx0<Me`{Mho)O*eax6C;~<WIy40_=wi|z^cjwBW5bSH04z=+29uZ)L7GS)(
z6&9*NVEBN2yy4slPvJNk-#}^@x>&y%YKFyX7|I%>>A37vyI(mg(aLs2b_vq3#mxCk
zZmnt?8#NlEEzS&^Z7frOe^2+A7!<;5pkZ%pS8?o1NO<wk!BB&Y@O}#YH&Bz-7?p(x
zp%3ytCQ1HmULYWJJ^H}>*8BZymrO0G7Y135(e&195@)~^ChFnv@j-tg)V%4Q1((}7
zN{E1Q&17N$&%hlx%ZN5&5s1SZ^w$OgJ3}4WQOocUerSW<mIRlBnn{BIv{49EX-AMR
zG13>$NaGw6t0=9n@9PT#Z_r!M=IXC}h5g{VXx&SLwQA*AG05&x;|O#=J}{B9ZAsBt
zZWX>Zn>?xLEk|xE^lv(D2i%HkHjGsoob7^JD-Ab=aQ{3*3Q)Tw<|Pt&evs$y?wU|O
ze)OuyqJa6=zJvlbu_qDZ9~?>2?gxYFe{h8D4~|UH{+^7r)tV?p*%u0bUoNkQbRd85
zvn}uJyk<#!Zin*j-3|p~8NcF0lDKi+1JN8IVHlH@&g=UJ7ke8&BRf?grsl+k`m{R3
zVV!q$bg`?yzCP~_B={dMfUm5X)4@JE_1^{-;FFy;ltJl!n#CGSRbJ_OJy>qgk1P7=
z)3<hWb94T;$5ILO+Fmmu4Rl9|SG@OUkt$hl+3LNmo+q?gff%#f9bxwHZVe2_NVVy!
zO*_kJAVW<>)SqN$V)_h%117&EC({a|BgeyYvYC2MI5Ivw{r!`}DlzR8W7`jhh1}Jy
z1>~uGPph&NfzL;FhN10fz*mkG*elA)zi!re&Bg?`NJ2tnrfJ3@?2{kI<@BpEAShVO
z5Qxyrfo*Y3OrzUv(BLu-M@-)t5YM7PhTht_&62b(>y*a;w>2L;soW$brWQh$xVn?+
z^@~Y$2ZDx+8Izf!wdG~vStA7Hz7vp;G6LLv3jJ1>Tn4<pyWijBN`Me|5b6OZg*lk7
zKY<o>83CN#t-{@ZHa*PH@>1=2>I@{+fg>EkSn=TjIJfolPo4Uy_(452=6}4(nLQJF
z-uH;jj!v}da6K)ytuv@RV`C!=W8v&3NwwF1{?q^afA~7lOAf-DRwqaHaOMFd@J(c;
z&2NvdR5>5{zQk17&(Wm5Xj=Cj0gG8rc7_NZ6ujtkf%0&<)(4N;n;qE9oYsMQhCv-D
zaOcs>w3bRcAHu`%+0#`;TwS@24a$ZGcpqKWhruQ(kpdjo-X$#c1O>sPPOK2z0P(i1
zS!Xy=cCU>Au%vGzBq#^sY?kG7oyOX419n^+b%zfkK7~rD@CemOtOXU2u(W0R)Ru9)
zkI?EVt^UZPb2Z2bL1a^9zAPco!BWX?7s`~+y1Tn&vUMyl`xr<B9#?zEa$}N-ln~RH
z2_uEx)lUx^wS!jrBQh8Lq>gyz!d~ApFNQYUBxBX>L7h|(ECz%KAZ_Z^=yiM82^`&T
z&{OOiH8+3YxS)O&&$vlA-(Vnx^rU-U4-!Gv7zHtk)G-~9&>5`X!Hhie;j-xwASMTG
z8lRHgZ*X*$y(g|tTU#((fZW-w#ij>c$82_NP}ImM7enL7xnd$)ipUJh=pVMj|1LzH
z_Ebs9r6?@Pv9U3k#|NI3{tMww9Cmhjend+_Qx+nV@xpxcQic>~;MINor3e;gh~hUa
zf=xy>Td_ju{M-PT;%5M8Z@`#!0fohnI*!FGLC6J5qyBti_5@r_p&DX~;jKfj_Tbp9
zyjuJHyk47)`qQl49x$`te)7_dHe#HuvWQLG5yc6H0{JXDq$a2MAgq<&t3GG8`ioUd
zy;JxW6vE7hxIpU$R|Bgy&*wM&4rVSHBB4V=^kx-j_^2R3h)NYq&|aN>EfP<3TKguF
zTOfYeAgEgWlbs6|K>$N{7^1l9XB!voE-+>?+@GlswQ)-3nLkP1#Vvo2j+KQ?xwf{Z
zLhwz9XfKd|`LP8dCRykytZ(-b<bjNIgeKbR&mbavo_g*-L0ip7_hMv%(&(VI1;OMZ
z<*`2d7SYMcZtrq-rdAs1A8Px5+V>csa4}&B7&Q|IWYyKB<mK(wRz`9j*{pvig#fgQ
z!$?`V@Tf!jT|Jf~JTj6w4MCRt{Zw!>aHRZVgLuJz4BX)Yhp<_5_5mIyO5}c(maqxs
zpItKPxSGffPeBNwrlv++YuvzYN$Nj8<g8w@^%@?F_D*^(g{dM)K$=N^Z+od7dvjM1
z9o#(Tmm=u|!8Nbip=X?RIT(&pi@JJy<zk7roy!MEpj@bzq{%BoCXdc17Xzd*CufX>
zN3(w9=Szu-ekT;N_4Vt6A)@{XNW{4&PnMnKhO-4SuhG!Z#DUE!F;-g~4ua|xeHp0Y
zQT#1sLWF3+oBj5kncF5V8ky&c&o5mD7m>htyPH2(ZonUjl=9OkW3ZgkTuU0~)D!}|
zKfd-M&R<G_e|UEPT@!l_NIgBoNBf^XQe=5PcWd9UYVF5;-=^q8eU$llM=s<XY}ijz
z|M;MxqdTQY;KeNkhIwyUR!_%%T}VbnMa@)r*4b=I&dUNc!uEPY&rx7@a8MCbBJO-$
z!azhsq#_6!9iQVTC9v}@-`;MST3l?(KVt$%SDpf}mbFK{SY0%3q(R%$e@#KrwISV6
zf`ZTALbxi8A^}Ifvf{k!_iG(Tz^F^d`|i&5<nl6BNJUsQv68C{)(07s*6h?Sh)ze%
zHSfoIflGTfNST~HS6(0JuzV#-@jYvz?n^iiR<+EW&V<LMxf@X#3rI4~v-H}HC)K1v
z{PTGJuh#QFK21GEX9Mm}r<+7?EiA~F&4`0KLX4*P3{czq;!$--Sfv~#ax8|`*HB)o
z3_~HGEV%d^wfcpjOB^M|$K$vfkAN`I%qp0LK7-L9+&+%7ssP}VA_sgXd|5-Kmn&L@
z;7Ow%4BX1~=R{2EkLL(k+-iC7VF!oNhM`<gwZc(>DCbT4EQHIbmgI#-nT(PZpn=rU
zvQtq7vz_@By0q|P7OFcgL+eSsf?u6sUlXyiDz(pHk?=SlpTv3-0bGhl2^{*erpqkI
zu{z$8k&TRG_7*rNE<u-KqZUq+)GlA_;qdRm`4*?tyw@~|iHOiD6s4&mPYRlO1^2(*
z1cjEOuqBV?DQJt*^n2gSFGIy%U$e`73`jik8v0e$aeH>WqWyWb1Pslva<0Qf4O>;1
zn8{tTk1ouWSS=`A938tt4a}Mr8eB%}odBg~r((Td!r#Ydt5(mzVCQ5%zGgF-{cI<{
zc$ynJm<~AJ;MPH-_52o=@v3vtHH0&d1j#~7W+!U$@-$q`OwL>M_R=kahP|PuCc6ch
z%5%fXErH;S`y^?$@xgm?cXLw&^h8lG{_nNvFo2I|u5ZbQ<L_x|{ta(1%m-IOzJ7g{
znUA6k6-jeQR4ItL^ZMhz5Apy12T7Gs_#C~_<m9okM!64#r(d6KVreEfH3b)0n44qD
zD^70raJ*Sv({n4EXKV6qT|5?jD9XtnEx!CNMw``1^cbrSF!ToP-n{&LyYYPjGJekK
z9GQ$Q;7l@(r7ZE3gysCvFc7wxjlv)JC%NpGbWV|Y$=GU3HN})01@D>~YhX#ux!;<q
zfTUkvdXd@K_Sav2*kLsQ6U#P2-f{)i{72JYm&h*tTQwP#l^qL3hA@Bbx%L2()OQsW
z5}KZedHLaQSj@i{gro%I#i2qn<m9GSgy(1Z>4m#0yHC;4H=*jP3y`LvqcgQ}aj)w9
zwUE(+N{`ag)A_q)tIUaQ+c6b$oFqZX2t=UiKYw~heYcKNdKD2Ho9#?}1%h{|S?Z%9
zLM*OMRUh~D>tzNt5FwvGAE$gc4&QC7ja*B^!bQVYw<QLq#(at@8XCl0{-$YbYZx5X
zYp|FY7+of`pr|DlbBxqv$Z&iMGJ$iyZvtxq^#v7!-_P!G`({cVUR+G1P600`A+T}F
z|FTb+rP2$sg6K0_Zb4p0B_xzYCkw$YfRPmx^lAU%$BPGIdAa629-r?3YZi9n1auG*
zHL`A|&xRj3@vH1y*JwB5A3%kFZ>fL%z%vULAPqhly4cn>qb^@4Xw0q?w}gb8!{G@D
zZ%Pv(XBE!zotp_)S(nQfUKksnO}anzv3|>zFd$c~>L@*}Niy@Bw{+Un31q~#Z)r@?
zUszdL*_&icQ%%Oa#GRcvK*m~J<KqL2^Jzcpn1oX!U@E&r0V8_aca)S21W%NtiRi<*
z8adOY!AVdubR3b)a7dPQt>xtx$p*8l`6#ntR5ULJ2BHtrV=1p8z{3YZ!v?jt366rc
zK5Fli+lI^8^`>T*H#Udi5FbD?6780m0RH?lJF=%o)QLtI6@GG7x3RJD=Q&&RN=oHJ
z-*g#LImBNt!T<Z?EiNcT9$d+Jgw-Kj9Xj<d?d{ITUyFVPipzX!q;pBqvJw_atgGX+
z>hjJ4jsx1YWE~}F9iiLc1pJ+6=mmqzZtWu(kcOwGr(~ISZrIH4M=ap?Dp7gO+uM8V
zsq5~1X}cQADoTfp70Lt+)Tc4*7e9}{irQuAX6NbxEq8`dq14UQRStB04G)+X7%xyW
z0FPSrQiXsP%-r1EHbN?l)t7f5>O!(RA$gF?1}zjgeU?kA#>K_u^vfPDG}v9sQMN*&
zW0jXE!WWiKqO=3Bt?=!74N#M`>HNqty|TRDOoHb7U!KJfD26XRvmD;3GCIRtoL@Rj
z^pjn5`;tR8Tz!~K4GfWCYfeX`D-LrQYEHZaE=5uO<G&Px#OQvcnUsML5A}uicKO&Z
z$S{?r057V{)1NO=ud_8f0M0jLLWF>S#RgC#_7%3o0S=Qq48yG#rQfETJerP-k7|mb
z{XMG>8(r-5MTK|cQ;Uiu$!n!&D86iPY4LfGQVkj;BTf`gx_B;K6FF~vQ0FB@CnBQb
zrlW9D-CXaD-OXdSh4ybO(XZcdIcyMdTyPX8q!u=kN@TYo18(5>PHHau%s(-+;`$R~
zVzQ`^5D}$M@pm$-tB2)aU09v2mi@<^%b*4wKs~UV_oT<_C3*hm-t-S;;9p?ie$pW$
zAM~Q48?oHHyo?!@v}D7y_;Wk^1IKXm`a6)i27m}viDI9{5s#f*a=T>&$5s!}E!JK@
zLtoe40f()hy(Wx+mxgzo<so+g?5K7VN?-!AlYh~kESVf#UMk*NvV9}+P|Mrc|8#fM
z8eR@;8PrEnNrZ>WjW&0B*yLn}QLwy5sng@=wIRuALMHD=#1N<jiG;(^=Z--yiKao`
zW2XyTMB)HLkR*X|)4X;ih{|xHKv}0gR*wR;jKTKD;{d>Z<%ET^RNC*K&^G`b=jnH}
zfkp~;x%;D4@lChx(r<_kviE~?*fcj$Sace1g$OSk?dkCX8n~Z0c7&Th9FmWoofOCy
zza1DD7^||-oTmo@x7vD{GkUGx&uRe!#@4JHFdm##UXHh{-?3{}?vb0J|NQ@K_5a@U
zpFT*PhB`C$HgMo|;uss-5<;W?84z@0cnrC^Qg7=v?JZ=&@3Hm5<bz-9N8sMJih+km
z#hUL_mg4&i#Nv=$Utezvuf5y`Y3AzFfM;&!gtUMB1a1m^DJf0W2D!d(lG+h$J8-^i
z&8YMO3hfYRIBmzDkT8Hrib|o?I}Id0#hCsSA#(ExNuviBPhbx&z2;&i_%Um4PEEZE
zBrr?<8pguqCM<dF)9}8!rl#9qczBq9%aXm}DO27LQKn=4+`21#W=19RWAe4T<;O5F
z+L|~33W@i9V9*fx^eMvuI&;qPY4^3&U{Km?Uh#1{-53TjV1ccbKK}k<-@3rF{RI_Q
ze>lCpgBYZIeE81kV!L##wAOrCLt3fb`a-=56c5hJzMDoPKR>;bYg`1iTRI5WkRrEU
z8lnXU&*=FhFaXXiC=gfd(4g5E_(9cJC$qEZ3Ve=F2ur_U78YtW%&gcH6^i@?I{J_M
z@VAqBk9g>~lzdNF9$^NbS3`Svch1IpyKFG*JHwuzkbuC4%L76t9UqO5h)6kbPWLaa
zu_DgznJOs6ps+&qx&!mdm<3YPmn{n@3r?HrAO?DRc_o+*HSzFeI)wRei>oF8j#!s1
zY~gtNLe#^VQ?nx7fm<>PavDfm;+Wti9D(<k2_cWb_8{IyFgBgcuYQiQY)^2T#7(oB
zip&R2Ih2#Ez{8pQ26`cG(phMU1^<l?GGVKuSzlN?oW!)}a~PkvWmIR7rDVs|e?!3I
z8uxHs+(}AO=4^(8K+UGtdA2<|u7kw|a8e%gMyD7MlTf16K@qmhVvx+H^r{RDPghYS
zHbD9;9>?uonH@2Q(vl^>bGy9TQK@4XaLXR9R;8!~-&6BD0pzaT&E<0gwyTsM62Tkf
zRkj&dclSn=FRrOH{Qv6<t^!8;j!9jE#bi9?ELJ+HM_u$EeZ;p4X(|)KLTt045pG7y
z1~1SFVR4~f%xU+=K<3}il<5Ft$#Sqm*JUkPB45tg&>g?19CkdtNp?9%^MdT%1&LzS
z`@lgT@K2cZxd19PF98r3i@aQwl!OFPFbvjSHsdqX5=k#9k#=@ps(9C-K?Hym98xiA
z6-VH!Ctlp@*bh{0XLqM`Id1G}1geU}?|}v?4WO*wcy6|Iada|%{gSQR<e`RNHd#AX
z($co)4Oyjhy1)g(SWOD$x`917FKB85gNte4X_KuiSJ$)ASK|*d>n&y`#F?7ao-8GA
zfXR)-Z3#9!Rw|P}>Y}2Cf8nhz2M+vyY$8icBuj)m5s;k=f@zz58C_zUX>lH|{HTmr
zNd_2_bL;Odc+$T#3ZP;)ef+R$PJB6()vA+Rjj3z!58Vcv8<^6Bqq`#T-cUpz)D_1b
zm~(L06JNa64zH=>3_?M0Zic$lwZPJJk2fDg*&p$1;4e^S{M<NxxVoy#0E2)Jl$#P_
zG1RCU4DV=mqP^17-)w)=Ua0q{q@^7g<NTc_;J*dh^Vb))+Qp??OO3Y&*&shV9AINy
z!9&DcNEX&*Q`)V5p=V(Jp+Zobm)B$bqf`f+`YVmDlr3gzX$qxP!TCkCqK>%N;xVLe
z-wxeh^74U6LB!cy^YXj$j$IXy2zRFOds#HW1SIev91lm8=Co=6SnCi-)aPyI?IzJ&
za2SHP9Pu?AtgYXJ)pV<e_$mE|f2(qde<-M>mHRHExkbvyt~AO}R{9vpKMm{|wVAr@
zHIPtlN1RbKyP1MD6lmK?;4s2GsV0FR(<=V8`QFCbdfT6<F<a9^-N=Lu0o9KIKR|gi
z2!3}Fuk3>2X&mtHmuF=BSHNb(poBsz`cR71TR>BVF{;YM|6vyn*1}n1zEdd#ogZ2H
zx^zD3;@UKicAz{*1mbUKCBQj<2NDmFval2#N8h8D`LX=48~Mps`i+p5<q%KcMO5tM
zhy<&dg>`Z@8=dn?AkVKKQ?W6G)Cxs?Xv^sDIjO}vqbMVdCJH(t5T6Vsy#gNdOfJvP
zeqLR<V-OGs)YQ~ipC&cnm9Oo)XliQW^0>aTVhdR9WTaqV_?9rUrhu(O(hLc;kP{vf
zg0etpYy|8RqLSTLe8^`q{rvsq0M^&OQ6E{o09udlI;i~ovyC((goK3UmfE^Xa2GdL
zxBF%LxCuf~;LvCzW&qvCPlsSY4g|3<aq9Qc!mh>BO7%MZV3RbHKWj<Je#(VXkyCd9
z&COWT<1=epTa;v$k+sc$R!eZN2#?QiuCIeE8NzJOwot87kb)yPg=h%S?!jI@6UV2Y
zY4+hWp46m~|7wJiX`z#Wy$T!ovTuJJgFsObv=i{QKmAnQ;ztVXs|3iDluX3boZiqa
zeO4klWtX3DdUHs+!NU$`i|QfJ*{>`#z%wt7-PIE4gDsLUkyi2&4t81a(Sx9bL(6LA
zo#_3ZLjHNqpLhG;w;fcP9*{kRoGF~qop8cc&URr(#t|Z=r5Y`*U#Xy>ssmoa-If#Q
z=IWnqW!(BWrb^b&YmhFeSzK>exXgEqjL6Q^I|Xy8aKc!mKVBp{!TL^w{D_SealHd>
zsf9RM>Nmf>W-z}ABTsfr0{o^k<CgRoP$<r-?E-i?EB^~%M|KcXD^WCynDoVH@#9R+
z&#Ql8F+ryzA(4aU7#k=QFTWtHuy(e6nvr<g6aQXtdh(5LccC^|{ZjNMY3Zf;!=sD6
zedQINfk2sna_O^Q9*+-W0KC=lB;8aFY1YVLs~-lnMqsN`^B*UuBr>E1H~E$z`Z;rS
z)Oly(XM0=n@hCkxb-U|rh!sK2%&TVoN3YVgt>NgT2Jf!?PB!>gHYBAbzWtmB;?^&>
zB%^C6$(=Lp2Z?ZTMZI6Vl$|ZZ{)nUt_aCe2kL&9>z?V7-M}C#{Sz%&0nY-VE^T%!G
z&nP>;+aMD|a!7nM-_|b_9m}Ku8d}SWlFdqDr|x>mszz7ujHnp2=5&1$c}O!3HmC0_
zNw6$awpEBYPYc!%)00vztBZ9KGtI|}9*d(S&I=h!@rVoxfnx7i5cSn7iWa>e#V&rQ
zS6tY^j8na62=73U9eF47Kq%M07A)T;$r9F#l!J^&V@*mBS^^SX&aRJmB1#TrKQYg{
zGGy6LC(e0=)L9YTm$|xiFV49#eb9lLg2e1f`r#JxZzMNRm;dnP%f^tjjY;(0WxIw2
zNe4u>_veohi8A#ZSR!0kOKK}ecyMrVBcm^x_VLir-qa_z^;Ef6C^j#XNyZSxI(nM}
z#q4{ik4j2$_VI7HI%L!d|Mjar^Nc~)Vt{f<D(S2ya0x#;J<ZVXjhWtC+25ClRkIG<
zscBKsCA7J_I&O(ns6fotD<tUo;}qh6fv8$yoA<T+2s_pNA=U8Ff@9gIOtY=Kl%7+e
z`LSa>i0ld)682#KnLpXz8;fj22v~B-cvWBDWNIh?{6-v9>sFehhp<+Ils;XXz`gfw
z3-uzVmD^oCptTwStOe?<wO2fcO^=>J?C^g)XET1!g7?`><rEaKtm48_Q(pskcNFe5
zu<fSc;aSLv4KNzb+P*3A4+7TAINyU<S*8TOPb3cg{1mCT6_%HmS6PD+0{O4*$5Ix}
z()LtlQeIP0?7U*!m@p7s?5jYgVgEGw=S1$@QGjEO6<PrKUM<)AzyB_PGlu@va^-WA
zw~~iHIzSTl)K`EGFtddI)_n^&5~I*49eqC&A6`Z<@9?Rps3<oaep3@a8Dee-|F54u
z1O<VWNx<b8;TV}#(D$DDmH$Q@gRURqWEvu~{hm^O3)}@uGbCGKp;D>W$jHc8I>>4q
zl~+_3qNSz%6~Zlr_=^53sN=ILKS2HqXic?2&neE`o5OYtQdd`(&oysX$CnCC(Yvxh
z!g78WlafLwlqyR2<u6Cm|7=!Uh)|ND9+?g=M(i~NoNpLbB<$P4lU@AQiYE|uZGC+h
z)Fo0NpfeSW?&Smp*`T4IA`%l5U2kI-H)!bSvghj@Mo-px<wQk$K9%420T##FM^7Js
z5g;<OSWrG*Hl@f23AKN!QlN%?dZ&{5kN_(9p8VR>$$5zbslS;YhO_{NH%0li_Qs3E
z$Hj~a(29V4M6Gl16c9poMzh0b$~BwZQ6zJiBL2PAmiT`io^1mniT!OqmVdfCqNw2R
zyscBey*$kBB)n~kG?iBhV}=A_m&81hLR6HLY3w!!?3l4(%ul4l-;_dMxh1A_sUw!?
z2~~hTIV~-#B@pCI&qwU3w-}06Bbn6z(h>BF7ihtoT2DVO6(t}nEN0ow{r+502bq0>
zn#~*o`Vv=?@Iia+fMkIOJJ~c(6d@;_EfzkUR2EQ3b7j}el-p8se-Twt4v43<tbSTM
zz!oRA(xqTi2$^RN2`ZDNxICim;i&fQISHS|l~ml^*%r~hC;ui@MYwi=CtkDw@mW(*
zKq%gS{RVynS^9%>I`ya>lU|Y<cdqJU>B~&7&f^9TSu+XD8s}@d@KVMuI&mNVlZ))U
zUvJpWg<CjkG+OE3_YTejHLKVMJNrr=ac|{Ybakw$FBndKg5CNUM4W<7FpuB2htj^t
zTz*oF5Yd8SXRDL7y7|z<T^;(}LzSNy)0qx_qNsVCHR4UD+DG@{`!=@awGC{3yEh>p
zhriuNrPL>$Anm8RT8)iQDB*cQuJ}bN8agOzT2sg8wR3MdU7TZ#IWR?U{FJ-dSdXgQ
zpkf!EJa|swyt0llXF)BG6^NqjGCAr=w3t<!kR=eyR^uWQq1Ak9x6dBH1=*6rbPKyq
zYL-3sT$R!${E9U-^e|`~f$alkSXh|s$L-x+vE515!*xU{DJghh9igb9qVlfQD;HYg
zZPI)LrNNr-8s;m?#$DpJ#nGK0v^?tW>=Q5Xo~fo}>+cQ$G6lRYSDgE!h1nc(Hv@}p
zHf^4eb;#*}w26Vj_(aX5pfd}{r()Hw>mU5a5g~4y_KZO?;8o{*aiXI=)VIid7<mi>
zIc?$Zt_B$R5~<eTEPC!TU;@4<u}&8-ZBncUyPFa>h{&x)*sPs%vT?|LlEhsn`jlE;
z*qf7;r&b99E4w0y+X#uLXZ7vuMpKk^J=XrC^#50LnjrP8C2)gL0Qt{_Y={k6kCTQe
zdE}Qk%+Jr?H9f6NV=#zju*^HazKK8X;ya`C7HB570YWu|MGPqGmbhq3o4sIn4fIv&
zVf5u*h=U`CtVPc9#O@<zP2oe3?IF{yYFy2^jPigVZq-(~T~No`kMe@h!EX;cR26f|
zt)q0G*%$rBRTkkTgzGlg7=Q6t8zIZ$mYvUP@a9E|P$_ybF)MKtJ>%e4SonQb4F&mF
z?9mP>qO9+G9Yew$JjoAfOiOol<2nn1H2s{CtzRC*XjY+u8C?ZjWX4Liqu#ObUEbdn
z6(uv?iH8RUeuHuO2}ZFgT#^%^LlBDG;_eLh>vm(GqlQPO1&mH27bB(gEaoemUWmw6
z5l2!Uc+GANW*7f_L;SPEfLdeAr5oS+5LaiWjk6raH#~`UH%}Dau-`^em7sW0|58Tl
z5cQW?O*OgsO4&$zv&;s!KsqIxJ2mt<o`k>qeH0nbg)axu<aH-f=1`iP;W&D%bi-6c
zr2%TjVD@qqt#qgSOzD(2G_Ea#O!qN{%4rMpXPKchgW8ct!6aqsZjC(P&$qq^b%$eG
zWU12@@M59orpkOi@2y!ff#9p}51aEs+Rq2duUvdmNEezJetE17+4#og#@M^oeSMEM
zkr0N%xWW%l#3WSMi<O>dRi+UMNme2KR!OV*O=wU$zDm=PMj}702=Oyq_i^+w=JewB
zh7E@6+j-`98UznV8$=X<xISL5oIW^)x6bIf3v?@6lhBOq9GddQ^4qP0{Yz8d#%$*F
z%a>PSBvM4c&ifXt83~U?99|w|TYQR-kMBYG2Ud3Za|nO?SLgy>|3kn4vzzj-Ulo{|
z=SN3JX@r-ngenXs{90|UZf{KzbB&N5AwV7X)NdXx{GhGfdXoU4ORFnFAtvq608K{=
zT&r`rtaP|Cp5zuh-v+EPlQ>_)mZ_>iW!7y$#17{Hhh4^rJn)s|MRy{P-o#o7C0#t-
zWE{l0kxIqiTg#g=bMccnbvq{q2M5;ZPpB3tRuu?_J2I#(lEKqU;_6R%q``5%^G<o<
zkFC-VGN#-lJEG4d_#$)8K7HR#pn@mkt&2)0>!VjtUYqy*Ed;_(sYrx>WTQ(M?z(2&
z$c{OlmR{ou4?6h^&piZfSI<~Y?Y6Vi-4hGq>Xx@lWbf|Un&Hpi+g?|89XTWj$=ne%
z0aOq~9QW{7YaMcdQ@d>tvHcwtm0g-pv~}5OfJt)Jk!R$7LgHb@o0j)@y-F+x8<R93
z8IFazFV3;^7Rw9T438Y!;Us)#ajik&rsTEm9gRgqSz@;A*qYN%tyEaSKHM?~Jgl#5
zY&CK6z3;Kgg#-nMoHl=m0NzOjMhnyVTqVb=cYl;kfBn-G?Q17oqN6n2pCB-S!0+Z}
z&nbdRox6#ucvS~FI=ak2uFZ{&os;@*2JIH83TiMC1x(uU`gm-F3N$dh^pyPcH3bh;
z>Tle=r@OoFQob4_lfCMQ=-t?6;kl;S(REP}8$`Q{saBMZVr!edTj@6~lQ31~b6S;U
zK$>n|Aa{Jukh4iYPxj6wO3UG4`jbS{_JGMdG-AG<ldwSMtRB{B_VSO0O;#=U?yZb5
ztZ!g6ERit-P*5|SVj!9IC3@JI9uVX8grP+);4bg|^`?;Q_lxI`LU5c=3Dg<{9rq3A
z@L5l(n@?@Fp7TtZp!l22m3={$mzSrMtK8Y!o2AgmEu=6$R+2P-Qy&Sd*xaFwV2#Ei
zqi>abcJ&()svSQmNxwRzP5+QmNMX>`1AY`O=j|#zCV|9H4ph;0s<*<9NpZr|En2&8
z_~{W7nKgajrfFv~l?Z~V-ogK(FlrYWGdt27NB14^+!R&2A+ol$%huSulcUT!Lfw?z
zA=1oqB4x0hKxiRp{|qJoq;LAfDq)Xh$XdQ$30|a0FYC8%ABNgAnq#R@*XjDGFY`L`
zX~?-rklI-pqa;+nXzOyCS>fIL7SyzPSF<u07a#9N*gr$5FW`?f9$KLb<3DCNqtw@y
z4pnHymeTiph4J%uav|h}m6~Pj1rfiU;mR`d{he`nmi)q^s6pSAz0V8^7O1tlB{%ri
zwpJNwvAm)l^>$_40zHE);d0+?1pQE!*<D*#^j@LpKg0TfShI&ZQ-39s*|ihDxj95&
ziXY>XVj-{ZI}+?G^%1#($Yn!IM)>5Wc<jAo95?dZTpM$sON%xa=*R*NJC9c{{250i
zz9Rk&=lBW@ajMx*osjldAU2g7?nySy>I&kjXp8kiTHru5=FAgvEcD70AI}B24uQ64
zGGF3K#Nid-?{AX-#>=LTdPT4Gl@==ExJOJ>l!BP}gZaYbIJ5bc4X3?)@k<XGnItif
zMmq#hrI;Ua!Z!=_<pg)rrH5Muk)7Tux__j^YZ|Y><60$Vu79Ceg5YY>5(pS(dGBa2
zbX^7ftEe#(r($+z%l0I2UAv$E40!F>SKa-Xy06JS*i9A+O@hbk77+CQ`*>whvOCjq
zW!3mgj|-*Wt7RpE3|Pfak!<h9W!2R1Yif768IKs_1t^c2@zVCf7W*P2-fPHx8Ql8z
z^IS*z+qa?5v1GfW6Yc`DJdR3xH<S5hs{>7;D|Aho{g)h<!oSFpa%kz&deYT6s_&kQ
zKG>li8&nNfdYruqt=`vPp~ne2zDiuEmIKo@MQ-;}#8|7NY~-!Gs;cj0UosT4)Pqy9
z))r&B+zBDHF<9>K<B<Xg3>ab@l%(e8sNJV4wkRu_Mw(>;+&Xwlq%n<30@5G*`~x?C
zP38r^?`r2&VR1ml<D<6CrR6fPa8T#O68p9JipTW+@rQ35^#D7FY$$3f49UnKDTSeG
zH#Rn2E938;<*>PWS-5|*EHAovo>=)&!lpWLA+i{Iu~5J`o*V9A;PLukzirt8Lsz?X
zDp7+Ni=?C!8{u*5fxo;&#3(%(oM4#|q~uPVq(vI0cJ4^$jLQ?O@*jlx`uHf5bRYt_
zJ0=@;{U-%SI}W7=tzr?7nIEO=9Iyu^Gb~qt$#}#9{}s*vq*CE4zfn-*pJ>s&4!Q~&
z{rmh7bjV*V)7STg(Ep^d%=kR(EZLA?EG$&5l1!8z6%I$mFIHo4?`7hs)n@eTeE?o`
z*DQ=pq=k1&1Buk&n|cn2@i`?wWkX}i;1tKO@<m2Q8eJaDe^yd5EKoSTtE`v^Gu6}v
z{6H4!EVl9kkC_eoOh$B8<p8qk)i8?<xyi1^Jj+%p`tOe3(cE&c%sQ(O1Z7sUewH>8
zYf5o8dH8zi`j+t3!wqyK)9h93FV^RvOISAbj6iaf?8xo#-Xqz)N-^iQZGkJIprXon
z(nNSSKpqJj>goNwQB&Zs*+SyElCaSy8KVf3n@RXF-+CjrwqE~X*3j3*!?>^fb$c>a
zWy52H&|q8Uq3qn5a-MW^dtLMMuR;PcCF}FIw&@6EEYv+y7Yl0J>|WgJCBBGUt>wA0
zN^&yqgwREK9*;EO!-(?rwy!j)#%=9egaLP+kRqgGnY}y<Q{AxFB)`XK{?23QtcoSy
zE1poUII}^s-tZml@P+)yHD@D$O1!!kv26Npqi&}6KS!rzVK6&wNZ35odGgZrJT8X*
zxUz8oqq~_Z3!(}=fgiltK`4=(3&7>{2qhg`5oh!B$zGsvY3&Sdemb0a>*995*n^aj
z`K8nTtpgyL&6Tq4((m6Lkm6b!t$wK-97{C3Z*igND8vHn^prZms9AUWs13r*Hu+#s
z3*(J3wD|D7(;sy(UQkI_a}?Ab4j4u%y!~Dq9#7oj?%4hA3o?-|dc2gF7zqy>lL){>
z*VE1=J3^I0+LMK^y88N}R`S8fDk03D|Igz6e;V3ZsMkp){V)}Owz5M-P>ymd>A|!k
zX0Aub3lj@$Eb!z}63m2O!1Q@X<$8Yvuw>&mLy_EVq9oXR5g))zcZd=wn0Z-P6wJHI
zEL-}N_}UYV?<UwS+NO19BGBiO7t1AYP8nTlXXZDCRCaZO%guOY=6>#umA1f0Fk?zG
zRUGFcO4GIQV;H>6C5D<3@Zs(-zbK2WjAM~lJg<{vYu4Z}#aVpL6Xk+ML?q?z?p{kv
zZHdQbnaVY#+YTTb@k8aUa*uCiQUOQw%VI?k^WEK4A6X@v4~TNKCNFD$Z5Uj*oqr#v
zjjx-`(ZFS^f8nC3#o+C0#3ipZW(4o(-SFD3c&Fd9fph9T5>a}EHSvjb2yfl`b-ZYd
zXjxc}kw*T++@04)Jm;TGjM3i}X(w2QGo5~bz1~&8I~I<x*ktfSRGCLv(T@u8fm-CQ
z{7pxl!`G$&c*k(K6y3H<e}73oE+38NlF8PncG&L4+6B-7x(2>i+_4lk$B&1|2*qf3
z@!h>;gCt%fiY^8WFA&HvRySc>1WIR_E|VH~OO65sw92C~^~ri8hzwTs-xfq_e2Jpx
zpsxO9UI`xfroQKRV6hGUhRy8RV7EHYR@k*cy3cg}t-XL>n<ETs(-$I8aKycy0r(3i
z3!oUDU$Nl8GI$D<Y};36YF%L~{5@f68s+(yy7~`V6cZZQj=n+vMcXm73^l-gsWuWs
ztOQ%C(+;1%YiT|5c-^tgHYFU2n_0WP@e*nOmCCZuxTg#RX!=Caz_`5%Mbn7RN5HD&
z5)#O|6OH;y-w?kaO7QsX0Z(K}mU*a=Nn>u6zzT;D&J0`M_u|uRr5btC(H5@pL|=MA
zus6EXm2ZT<M;t6G+E4T>b`Dm@L}?DI0MxP}5>f6Hv%+t!USpHvdFFRcJT4(Az4fKt
zFps=nS#y=|bk5-0Xm6A;Ixo#ZAXF{u!*gK`69#!u(5#zlyoEyNl@{7?55C#J(%ZXh
zHIDt2lu^qum<s!j%bHKoAZ9t#Hazv?349=#11f(;@8WW1bzx*P9+V5rGCie%f@<!f
z-h>&43Clr^MIr2FI`f6GjNGvF1~x%)A=(4X4yAKT=G!rvTI&IdbOh|;qT1TuJS6*A
zk|kfs*H=xtNvtWZFL=Wtg;@f;+4NwDOqnxlIF_OOS6%_Gskx*X89BL#vyYb4`#V-X
zlR}5Xg^^y*_ecl~({iB=3JDG&bFPr%8{V|;Un}nqjq)gZWO`L1*=lt&Ll4f|mRY@4
zg>%i+8tw|=X~u-#EbkpiB(Kyo`$w91Z=x$(pv<z>I2+d~OQ<5ywGs5d<N9(Zf#Zt$
zB5pWpeRESRTxU<7nv6_1$mohajrl^l`3)Wqu>Yi+0XBb?xc@+;rh+<as#i7g(fP|B
z<5@{gZ$8JiU8If^&pHC;aGZ&W=t2H)naG_?m*?l>4LCit%VJ`9i#OxW@k{Ja_|^~q
zuXS~GlCOR%c6jB1(2Z+*>kl731k=UL_bJ9==M%#@rg~z}i`);^$pye6$=aW2MkW4|
zbN19a=CdixYrB|nG+%&H;74`5+Gd5RI6d~W2aPS|MM!>k`>3L-KI8uDdPyeIB#Pd_
z5_VyAi3-@qWs2EXzBnwL59-~-m`{GK$Vd&p7svpxYpd==GDf(&vL*_V@%YJgK;{0$
zc+9MUsfqZ-jI_FfUd1P&G<Wp5Po^BIWwc0P7>wJZJ1*VxYdh##h4Df)63adxq|?sr
zn>C2b6?9P~s~vB0Ti^<-;0{(X(F6p(G^7GO@=Q}_D%q?dUbSs#dMcwqq#}@U>f{?`
zD59Bnc_5ci1PK_Hzs2w$?-pzyN)s42en2vxt(54WjbtNhliy1dW<b)m*_bCn<&`@b
zu}46rou#0&t3q_hC^s6Y5r<_ojhBg9!a*^YXIow-5_J<|3xAE;A>uSKg`2pG|05B}
zrDKi_KY%$OEzP|=3*Fd|%Jk=S9V`)bwJg7rVSDx5_+FW=?#Ivny)XPWk^pef=*`9I
z%D<r^NeoXw)9PY{h`zptxd665vViF!tLHoc|E3z^k&nlq@6~zd14!JPX>_YAqO0>!
zEMT_?dFN&cD0gfXutyHb4Wm<a)8@N74>vpPxK8^vJB)s_zYy+<WR6c>ql$V9p<jz!
z40|r}rg@!ZaU)Tj%ExT8B1K#8$8&Q~5HmZL&GudGAC;DAL>C?O@0dli2fVz`D#)!`
zn-=(>ievE=mm5JDk8^t-VHz5e-RVVyOO-nYn|TcE>@s<SW(oH5rVrSop0OQr>J<x&
z-WA6o>vrSO9dFz;?mT)4b%|TzrQFB`oTf%KX0w8iB(?jm%F>w48Xqhy#6{iID;f(Y
z5`6$1l&Ks%Nd3EXaw=bN?+4XqI?}n~cXaZO@XF$tIB+eTekh1IMg69x56PzvNxXDs
zlu252FQ|JyQ!_Km2Qfv}b8lvFD$0(P7_H%9Wt$w(wn;6!%Tc&4VJHu1TaGx~3kT+7
z_ihFhm4=EtX~%@B5Wiz^tX%p6g}@v#;c-JCYpG9d@vhjBuykDV)``ia)8n!tnsU&k
zP`a|Pql4|wL;eq@l_dvi$pcl}wjjjhAH#uveVO26DzG_YvR?Z*A3~*A^dx=U?df}e
zXYgwRXaL@>s#EFr#?mQ%KQW#AYSP<}IWO1+&Wa=y$UE^RdL)%^P)*GJi7Bo}s@r=8
zDT|^Op9*g4$GFQ6?(2-YGLgT1`MQAMW!=0d@tfEAS?Kj9BxUkPjmKzN{ZrF3NUa&A
zvKqsU{^sfa(a%gW>N5QL*PXfPY*LO`6f*uudptgB4fo^q+<}#IOH7I3i?Cl}Z@8V$
zO5P>V*E!5c<CFSN$R12Q$_^$rzMf1~Vh_#8XN3-Jihi%yV9a6`sef))xHx5Zam0Wr
z@i`Vt_LBmx{MwhDdKIWkA}Mngu3)B`Ei5L>Q!_-$=6M_RDp{vwGdhwEqhIJOxWNS*
z0)uX!$rC6fZz4x{nttq<6#9=WOXJ_Mk2wo!eUor?t>;p*t+80-xmH)?cT`sAL&qc$
z4jHP@qEnzLJtyMfbIW>&Oczn(!%uGSQxocnB-EwLphtxS)!%J_voHNc#d^2r>;zuD
z$uXDkF8hNh!Y~x0fdv+3dyNjwwN8@oAZgH4D_huj{l>I@g#^_*CAQIgMLMU)I{S)x
z9>RoTa!$@V%(7If|L$*-G@$w(&z+qaevki&obmaiE`^qYaHE|K)iQ&ZR%+HRA>5*d
z61Te7$=oghz(l2gRF24h*7Q_jmJn?Co^rv@JT|duR0M&zxQ#y#jKJohj}lk$Z#=^R
z1+1nfAu39+A8uAI$u91}b<^JZ^5u8DBnbYu%XnB~l0`S02vTz{C+96M9~D-3B;tdo
zK3nwE8gg%ZR;g_`<Z<>J7!{O|XE%G?aq9Ur;j$pJf#ZBlf-&L}@||1zOM8Vo;AeFA
z_V(Hm)NebTZOJ?xMCyqtcG0A^XR|Q5n>34gt4@N*ilgLjP&xO>eq_TTWtVP;a#ETM
zs*J9O)ZUuG<Jrd;sk>mt7-Y$4rO50YbyH!F4omcoxvG+Ly}@hMI-1&E94w=JYKq*S
zCTXQd-`mkT1`+-DbPnY}1^pzgUTJ~}BPb&n@akk%F*Kxba$)sT>+b4$y}C%y!837s
zUhc8(Z@W|#PRV8u1>G5%Ui8hayOmds{Mqt@`2qx!V~5(z**4d1tC2A{noWbK@zu`=
z`FeuSRv<234V$!x_Xh}yINZIPs2gIcf5E$(K$A2Sx?mq45rKk}O!NNzh*!pY1cV(W
z>drJZB_)`@52;JSpZTC)Sn*T+c?=seLxd^w+U<OvXG>(Yh{21m<;RQv{=I`WyQ2T9
z@Z=>Pi(#-{0;^nw!I@H8p#Y#vEsc>z#KZ`@Qt$^>SF_<<YPbkJJUlSD-#Oy4n&T4y
zdM*gHl>i{^3>nMly6?2D;r`=V^UL{rehP5XX2$W~l5qu-SGqs^>@TezX>YCSX2Hi2
zWN?2zXSn>FJYR^KN$Ihf`}4bnS5*edI-?hYxGoUdhiD+`RUx*SIDX274~XTNS?gu5
zj~hPAB~Z0G96`~lpFbj(a2RpQ3x+lc64W#{hAG_d>b&dbDu}^B*O=D{5!z3t<NBq^
z>R;!PL%W!TQ>s0fCXYeIS^L9S^epj4^v7{u@>@s7BxEcJAWKtnjvjWuWb5}Z0T9Rr
zHDHhUHmty8uog%pvf#uH?{O_&_O(fzEDfmRC*^=K*O<eO1jixWgUo&Rc<*A?YySAT
zd2)cY6d*{}XqaTOi&QAXA8@N|LX(IUSX_=w+L@K(94;A}Rkn^&d#!K2aEY_D8xQ7>
zYCk#+PuZm|*Fh%zhwgvlsr$d~8+!g{_n#o~brB_r$F25Y|2Hst1?-0n3nA6S-!o*J
zAYoqT=7kez?Ck`m(UAlvA;6d&D1x5_=O{(A!&oH$!iIN$0McDW<<IRf{)g<q%zIAF
ztf(Zf{&l4N{SiFD;w|~hrX4st_+q|WmR+aFsKvXDP<cj1zZc8bAz60Kn#n2Ja!k!`
z^KOL*SRuMq^2w|<)2kvOC=zTO90^FhiOGOYT@G|YJ^lU6X1W&I@)~)y?1x(u<%-BI
zoo1gn&89+s6_Bt9p>s8g@O2`n!pmN6)An=L6ORQJm4v>>pAa^Qp8hmbFmH6hR0gD;
zE0!;*zpqHx5fR-tY#ece2>NIdkV1&Dg3o68JMWdhuRH`qXgX4IMn#HH8N$jD_FZ4s
zR8>sJ;tiP-v~XU(YwbA(p~=ZueT9#dA)S1H_CyEOM><>jpj_8>E)_A5l+_xbsgzXd
z<p1+p85Ivt45TTOAZ_aQD@o@&#u}Q%VVT&Z;{SQ||G=*$u^~|;lV}}qC;yFITeiR+
z8MOIgYXIb<<W`Rn8C8PjyMWn|u%Eq+_q=r?+#5%m&vn{8cs6%fj6jpLboTnUHsRG0
zYm}32^!y#(qJqLs^}}j7FAJs?vk=wo5KA7aHdE9P!N5TbF;`!Qr6q<%@+BS}t4#k+
zUAXy~!te9Un(df=pCf(-q*3kOr+HTxt$Afaxf6ju&y&h<+-e&AnT7L-pS`M?^Mrh~
z@{i(Hs<uaejC?F@4pZf`wq7A6WMox|nam=3nh&hzW7WZimmVo;JMY~Lsns)BddB1x
z%Z=Y6)wFs@9W^g=Od&uckSR;2F=NR;k&$^|8n0Fm%%T%moD;Q<<y~+QvSh2MGp~%Q
z@<%P%Ub|3Rcd^?Zg_CAUTyy>(#;!7~s%>2>A`+VxkVd*ux*L%O=~lWs1f)fz8>CBE
zG}0X^-Q6YK-Fe5_XYX_NIh%XW{UHx7*0a`}bByuj`@Qcj&Y*bVQj>dL_sQAN_nN^d
zWDeG`{A9xnq!R*9zs8(Lc3|!!Lisza?l2ge%5p}~|6GZphL`<kRpL+M<t-~Ecvrk3
z>lR=Am&3yO683$W9)NDt$^?T>{Uvya8ucWnO6hD)7k$>Tc$NUCTkFC#=VCwGh~F*>
z7}gd>$eML10BqqEfDNVt#1f_e()*=C8hZyPip=pRW&HGCY#dBy_N~l(wRm1_<EjQ&
zEUnhQSzBI|1&wf8br=5n6>;qpmQh17vv}3Fum=gf!5oTLDUMO<%5|~09N%1+jr#A1
z&rheVH-M^7v`=LvhD`ZZYx&##yv4SC+PQapt!pi_4o|VAf2%f20bU4a3|>h5GB$P8
zbb_uW&678G)smuKSTAQfO`<ZvK}{RP&ezk6!*T*yZ02L~paR`GW0Wdx1z-_k@7}#L
zb34^*&gh9vaJC8lt#eSxv&p7`%0E!=s=n|WB;IS+SH^$u<?5ScdA6;ztOsA$&!210
zhx6+@xL9Vlf062#oYmAEd2U+f)|w(RR;()r=A{CTIbjAx{bvxR{{d3@ClucX58bOh
zV0hhV>CHbweePJVpdch|r%6NZ@ojpo*I<s^HZM^F+1m9>Ywqfo6-+8wB{6jR1V9ma
zWC~FEEk&mn?WgDG?>8DXd7iX4d;<AI(j4pr4>Ixf%)%OMowu_+%h?Y!u4Ap|>|ZE;
z>VCC2{}j5bC2`_d!R<w0r9UE&GH$74L^P3Ou21*#N3g=(`%rc!S0&`h@4~?dRSj8~
zLd)dV5YU(mN|&@7>X^6pqIb5jOGj7blhEY%^fAlFn_oUd*m%As&#R~Q+mO)X`jQ6Y
zej;3u_C8KRQTae0pyiJDL*QGE;mi!G>5UYJf{a+E>TmNojjX>SD5wnVHENzr3w-z}
z>@WTN2?P#ZZ}|(-XFno*-G-R1Bj#u$WaD3AWOm0FBUe6?%Y<`5U3Nn>OScl2>|=I#
zs5D~<<&{YSngkyHsMgljxJ3|Sx#t=s7?hvZplrHU8rT{YZEZ9A)|;ffT?X5lA`<3}
zX#HqX=x_qMKc2`cK;8){gzoF;7l%||(m>lET~f1!P62rA$*wYAa#y)Z?#BIUd5r-!
zW4+5YxFP9q_!Ql(-<0(5P350l0OgD$o|hJjjw!E~t~xzA4(DyIfAjv&tPb>2i2+b*
zDvaUPKgXardlBBdx@x@lv9Ytupi#u*K(u%cbU&l4{qd*w!`4B290H)Uxysv)i?v%t
znR$7%i(J9hw1=7j+oi<6W6Pw|YHKwB!;KMvfB;Z=X87UYaN!m;J}eM?nd(f{D%T`Z
zUCxvN@DO>lOwXP2_pqMjKBCp`u)fq$9aCx($P-9r*~5Px+(Cgd|BG~va!p=DL+X6R
z-BLw{sz^sPv)EIi*Eu8*l6&U)sx`io)Zw%LOtAC8zVa3i_jkQYP^;9F6S}T^FRrF-
z7{DFk+lKjBW5PSYUAIBlnD?}XTVHU-hI_BDu;tgwq?v}6hEp<CYtM>XQ3_7__7tYo
z;bwCp#kd8W*|0u$LuBPRY{`R<zCm;)kVnS-v7RYOytR2t-J;qd{PS&GD38mWb~H4q
ztO%hHPuJKNvfqEX>gnl?=$*>juZPc(`D&P23xDvus3TxskaihSQGH`*OB91;&|$+h
zC!}CzLTvaNTYY47s^2#iJ+sIyG>=YFG$)PO&i1SXzV&BDVCnTz*VE1TZp1LE2x}82
z^)`K|^QL9$iPS%sn!Ty*G?(XbwDAFDHhG`D)(z6~&9^OIQ2x`I(ZdUJzVn8C{I6`#
z<`8qD){zeA)hht4cdL@^l^-Vc2tfR_ce;Z$)EmGI1=lFTV`9WUuo~9abdbVo3V*cJ
z<z?U?PQ(k^3i??6o$iICm8{)+Sm&m<L00rF69>IPN|E+08KFprVdMi5O&((nSbd2p
zjqfhe9?Zlx$Qw{trVn^va!x;Q%V3+U-hG`<JJ2+{w~QsqMlnfP1M65c<2y}lIBGm{
zBaPBI^mcnR-8{@&QiZP!ConiUpIUFk#Y|nC66NL)K{@8>z(6ACGs*2=(?^?xs0q6v
zgJ4lOGf&u;1IcoUUHa&(BjK5k*cXlTH*W6%T>%-<ZTjJhx`N1U)+s=fW~7{LsQ#o%
z-p0Z=?l)r&rp2Eo^uZICH7DV8*98d<<HE_DKW4`daa)!si|+z!@rAvft(kA}-X-4?
zey^*+pb+v98vQje{}%V43EiqYmPuC@kn;n{OO0Wp!(Quyw#CKPpnz7)-#wcNiud-{
z!sv)^vhU-mtx7dd)0@`As;ts2o=bllm$VNXYztcp<fxaDsoPIn-ogO{i*GgGe_Ml8
znSfX`w<x>Ifq-$DqhGbb!?$&Mt%9vGwM^wn`5Ohz*=M9Jl2J}fMYNoGiDc)&ljKfq
zj)prCxw$Wz!g%;^ac(Gt-+dc@XdYYUiFxy350<u9a+oc*Y!Fgesx@B8g=<NTW7$Nu
z)dX3wZ^I~tG|oA3#vIl!IoMnXYn&}2PdzWluH)oX82C8tcmir1wI9TdIX{SlY;Dw(
zD@jdQcxycRc+E5GMc^GuiQ)C^{Mk`m`Ko|3d#5H(UudyzTJX)581d1;uyZj+f9REk
z$11JVp~(q8hl0)&(au0EtEa4!#~m}_`3)w9ZQw{Po(wff#kUv)^VCiil%U;zZQ?&Y
zRxb$@uikg9o6!3VR_32ROO_ZWCWgvGas4>maz5rTF=N|>l!Qd^)A~Y4xQ`DEE@q;L
zbF+rrTM$;*p*hvv9rX)Tc{DrWd25%H9jxN`yK>>~0Iaq>kMh{0!r8=Vck1<zrH`tg
z(Qq>|B|oy~6w=0}kWAQ%#=slD4U=)(7O$8*a5wkk2)JP0TO}0yZkuUf0!7YrNzBRC
zmrN4aJJ>y+-=ABaE~IjS`xs<H+R9u2Z~bkG?AD}Di^^Ve-0N9j!x7FbhPkAD?)8M#
zhD(OVd#;YlC1h=PaRUPFnU9bFp=BIQxw-V&ENB0r?Mw%YEyVcU&upyDDE;9khdAb^
zC|fkAy<08ZN4Zc0!PlM4t{+L1{z!?poQ}436vlgR4?p9{P7TliH(L$>kU5nZ`oh&;
z7@XDz(gFF`+X}O_zGT3Q&(1bK1?zuxfH^O5%bzz#&@xXCLQ&-Y&|rg?V#5Lw$n^_E
zh{Pk$R=4AD7_&5<N9)P4-IDT#>53A&cpiprXZak9MzG^VYt#{i6{R0utYQxN5`1(H
z4*X$3%Na}kSat03?;*EfnmwAl=*5RuIiY>Fa<*9iTxiJ4hqsxGpk77<c?qY*4Qvw+
z##?leRqv1;b`ddK#w^RLT;-*sSF~=i3rh}_T{AzUt9I-UiP;rf7nX4a=Srds8Y}A;
zKEhL-hq#_DH@D~NWyR;VhzCi-!(NMP=~tMK<*CZ$nD~f6)uvU)+dZYe*<>(;G&n62
z%Y=(-hUN#i!UW9xtb?-WEo;SkYPn`|Rj!4_I*1eh8MpokaRp!%VNfWQwIj2|{pSt*
z>z8KOP$tg=T4qd|_ltxr83+@dB59=d0)}@N>{yfqoasS<At4l0khav17?_w@RT-GI
z)YA7cYEXp>E;U8UEs(xo`_Ix3w2LD+jh0hfm|f2hwDN0xRf_T9;PU#Sgm%(wZtcF>
zw6u?c1tuC1!4Q8c!;e=Z@-pf~qfd<$WlT{H8n|%jDJc8^(s>l1Ygq|hMJ<E>!hZ9Q
z4iWh2APmwYhaZW7QZWC#^MCz9DX*#UdS#>T!4fPQHTSne*dDX_=+V(phwF3OE4)ms
zdoDQ%4px@#*T<-Qo{Nu;RA)s(n}vn6blHd37A`hD$^dNfw?5VX`bzVLNSY!NRV^o{
zykP&sW&FvY4?o=^Rpp;4#4)PuS&1nSt&s1g72J3#NUWmg@5qCe)t{E+k6#A3VH~L>
zI(){oAG-p~t^=$0<z;PX3dYgj<0o+4+=VuzX~v$L9&LWhzlinDEFF#xAfJClttce8
z2S?tWhaM`TPRtVDGmT$>IdR@8BHX=8g8$TzpmYw64SE6l9Nxa3jOm#?_&-vVVsI3+
zEs-bgxmm$P%yrNKEDnd?e0hLzh^a$at`g}IU5Z(y=puxo{B*U;_pW4T7e|zc)WN?F
zP3_!yk4o63rNb)a2T!Y4w~^v*I$!khm8z0@bTJ{y-}^h>Mi?CerN!}l10XqGaG;Xc
zq5hE{_;-q2aLGFoX^IF`dTlb0oIztG9pqn}n_FgnYI;uyr*EmS2ze~JN?3W40U`W!
zwNJfB2DQaH?$a4JYDZg#r|JBcQO+i;J2$6%w0*Bx2p{=@&!fWejvx~s07F#yjGIAB
zjcI$0S3139e_yEoShqj_i|8#&mbCtILoe`|Q?{M9Qe=!Qf`A7#pLC9&6L}!Z@OtxM
zYjo`{)u!8bfzCS3r#0{252w-XWq&kGmA4wQ;(2AN9TlhR5paETvxE0FBg02hQqtt^
z_K}|cIZsz-r)lXtV7L+j6iL>l$%Sx$*^HNvGu$LUpoo!~ITDZ)(bzdU#;gF^MCdrz
z=F~(~iSv%K@~D!QmNXclb=aPGc?meJw)HZ#eQk?={167i#6*@+*ja0R?p^>tJK6}y
zO&rc<?MLb(7y6rh9wT*pPZxs!8qKlx;e7ucn7X1$9L`cKM@AX*U$=cqO8x&n9$(Pc
zpZ*Bg#bg`^pbXv9kn>k@7ja}8H5#{2RR`x{=loiE(`EHHM10m107}c<bKw~1W708q
z?#BczIgohI7ruM$1DGoP{QZZ)n3tcIo&W$ml9r_XNC1ey92hur%LH0ydwcV|fTG*d
zZpP8x&I~V*?+=a@PCM)*bWPMbt%A`HkkF<Je;o(|<Lk7BhK7S@^LK(xceiee!yT?m
zTA(P%pi$<;jEahi$87NV^VSUYr~QM2L3V{<fVy1Xo#X8@TWi8RMYIXN3I7N6+J9CN
z{$+~(w9nqdeqKLwJ<=cYEz;O6KRscN^tcK{xxMsL9{d;tL2XTO%sM6+v>&2aUfwJ^
zWux3QH>WXOiL>J^vPaYV<bl&mO0;B9!S8-KP`B4e*7}rc7*C!4Z8;KC{eap?kqb8e
z%!ecT%ceWGV2w@h1#s);qj<&Di+0H-8OpxtEdOu&C76#eu{M@AI$YlWph&0jsq-$I
z-u|bmGZrW7G<}{iwd9`flYVghNg`Gr-lZYdqH>2pp_w~Dx*1UD$<2hXpRqirA2N}g
zU0<2;P>S_@*;FF~-R9Po*z4d&*dnFvFsH1)wziCa#dtL^@Lp}RIDi>d%ron*q2Xam
z*PItysZmkpDi#{-fRMuuOl9S40m4H1;v%aWW3;jgo}jDktu2x5+3yx}fKF|YXRltw
ze(hGk%^8MR%w6F2P6j1X(5mAhf^oH64HG)n;~Fe^g%ORyn;?yR55B3q(aOqG)%?no
zioj9VG-{o+&m<hAXSmCa2xugN@HO6djsATv$|hx;L|`VDPh5D%lKXp%`H$k)=p|-c
z`mc^YuOH*zMpMcpJlnn9H6~gr?S}gj<k6Hr49IbArmU|{2|X$xFJa(GydL~tKjepD
zVYqEFY*U|O;3<q(8*#<E8E$RUWa%_rGH`1MVH*9cJ;9g!pz(yO-ld|ZYw4=8CRIYo
zPJan&ugfmIn+oOJ8FN~{-LQby{j&V}7pf<Hg))%rTDiUQq$nvVQK@r1*{sQiRBJ%n
z-{#3xeo%5Yr|q12{B6)2+JA3?d|SPm@Eu4Su!c>$tE-PqfFyyIW0qAG3@NU69D}iB
zlhptKA!~{I$vI`>d3QOEAL`hs#Ok&DA$x8h_Z6T9mC!{I!-qu^eDLu9{z3d0#wjm!
z|BGwnOgh9i!C342V*#0)u<;EpX(a1myN{nzksDu3ySR><@*F?AEXuOo`<{}Z9qkBZ
z1e|f6FD7SV>bJcHCzxv!Co=<=7|aJ1h^#FybC$l<avW72tL##nsIiBDous=`((bWz
z*y&6_N<kq8V(J~WHK{B>D%;3PH)z!J<tTAAQ`EoUUss&N>J0{sf*P-T&y`IdW$533
zBj8<Ly_^w4j$R{(i0p4eEwt%e+EL;H930kO=}U&DE!aZ}z0ulFEg0=}EyGijDg3qK
zX)vapqFjsUu_6L!BBN^hA?|c_gEZqV_1A}VhwGVZ%+xLI?W(8my0<+62UDmtDj4dH
zV$`mc1X3iy?wFXEV(sxUG0H}|Yr}5=JE|SvbnO6hqI%N5-kq|6ruM~Ve(qww!*jgf
z?7%2`_e_m_uT|HFaSM_Vd=A<&ZDn(LzzUVCx;L}-8gl!h@Dd<@03I$HG*%|7tcwdY
zt8`dDi<f<^j?2lR-WbV^Dz}=|a8RFSP%mxS%Y9Qm-_h}UW3mj=T~=alaY9Z;CIXl=
zsPWk?pjpeAh@$v^TXa}SEKVFDd9$*-suGVN*|9Wc6{hl7Db0a}KtS$ERR|Y?*~@R6
zmm^=<bE$S1N<?eP(OwxmdKA)(pgoyp?>WhQMAm*9qz;ucis%)BG!I}95Lnc+<}B)A
zodsjyeGQLsRI+L~!8U&ldStPH2)8>=bxatH;Pal%%&+7^Jgf<Y3!z#afEK#2qA$)*
zA@kJ*7N;#Bwz(Lxj4`(#*KT?NL)7DKx{8AQ;r(`rxY(oDJwS$)Ljkkb^$^UyzXsZn
zB{cN((v;HG)9?;21mbGbo%etUQR=)EEO$L1GbnY~U@oI8-gBJ+L)cX<<#eR82Fo4j
z8L3Ab!;o%&V%fu~C;0#UfH-@5CFO~*@O>0($6bqbTlS*UZ^1r0I@A!@?s`^oe$sAu
z;dx6Rq<d3nV5PQOQ3yev#O2Xer#!_=%)n<o7+KCJ<gs53wmq8Q_xk)9-tEMP(YzAI
zJ)VMvMX|K3%n-22hHh|Q9&cE(=N>!vN{6R3ez#4cE2{pXaHga%4e|}m#K@>9QQgMa
zxrYAa%((>tyXDWtbt<_|3EGPsO)fp?tnY}^Jm$cmw;dD=+~2ox0TAS`s>M2?1!SkE
zcxngDk5H>i!yQVB8A}S{C3IXjQeUC@^F8=EC;!Or6Dl#|-FbUZ(b8nqx8VQNEJBUu
zdmQ+V=71bHnL?JXsf(zJ?JXbK{)ogFQ|aknTl}X^;?7BYM#-0*7*92(8#gi-w?dY}
z!|f$RkBvNKW&6bNhrhhcBy4AgR1V}4fvFBt%X~#h=u1D}ii}8{Y?;JWPT|Z~xuLaH
zUB;>IyA#m%qWG-lN*7(R11w&FTFDP|&PB_nyz1NUPl#<kwACB3)PTruIo|k|eAk;N
zWy+kSg)EGh9*lMq$*KF&-JVw68N=#Ta}3<}<cjoI;u)k*GEx6G^Y7)w1hckVdNouV
zSdI`DTJ<W@leb&rv=S{UfzlBZPg4H1B?6GjTL_mQFWp)}bcHV>q~v;X+A)V^U%#WH
z=YAWI*;cDj;X}^+Qn~cZl4)>Nub}!+(s=db^|epX%ip%XB$zhS<F&kWzpUAK(RkzZ
z2|R!rZOGR9(@EoAv#iFgXv)^sR+R@{bJft1BLKFDbDi-+!s%l2u!XFLd|*hRcur0I
zS~itmd(#6*k~>)3E%>4?cT%M~6d*+hy6hrh(}#mbpd^@zHiqQ|1kuPvG;&4dvLe%2
zU%x(cthfblH@v;Rh)hg0H+WvN5_|B964Cxi100{LL)>0ds%25>++M>OQTL2iZoB(V
z#kk?sY1!SW!xUOFisAmk_g79qfHEpU#^wKGX~2d-uunkYEAv@0lyeCmX^bOx=5)qv
z`uKS(yHOyE<jP{<<1VIp)4Le>q|d>@(bHCSy|#G3<2j5pC?B^q%BKG^SFdv_q}OfC
z7+JNPu5>iOpC~gfUS3<%yjl-A)4e@p9Hht90LWY8nf<W`K}ZUKfPD4KtFJ=7aE5TQ
z>($tdS_Y5d*CzlQI_)kl{q~ae#J6-4IM^}+gYCGU9ucF_;xjN`S+f+HdR5UsZGG2X
zeA>vG0!Co#kNWCV6mPZxQ>Uig;j#oS=yO--;INXlM9JOiI88AJ6YzhSU`uWjSOE;n
zg&=SrG%N1j^~Ox_%K-8nD)`!*AI?A1iL_>h77!*lF3vjNZ6PjqgoC)~=U@ur{}qJ%
z9-_!62nxc<!uqGUFY3zC_xm>oFwDD?YZ`fMcX1C2*3Mjqk05fpl{K<{8LC_{PVKfs
zNB7*#es6lEG{&Bc_zpNPJ3u_4E(GsNk1Y89sJH3^cL5*EM<yO}a`I?g&X=yoj-f?H
zy$KsRTjx-m8=(DU88b)wu@Z+G&Sk&KJ*BK726>UI+tfJf?hDshYO6o#O-bx|U1DN{
z+8drGwj+g<G(Zo3dI;DyC-XfR%(4A|ADk+7r{%UGWnmeHnx-B|s)q)t&0^i25w{QJ
z_6|h)q6eLGu-?V~%1B?G<@H36QSp0_u@DGhp6-+x^+uu)PVtngPgIrtcXL#Y1Z%MH
z@rK;zHm;<(vCsXY2X|Zvu}Bn->&cnqZiH`JIpMD5b?z1`vC-fLH*J}T;CIj4qsn#>
zz{zXW26qM*gv}6HP+<R%Xm^^ftVrl_g6$7_Jn~;D5`tASiKi7<oara#MYwj~VW?!2
zItE2FDEMz@j+w?JQIWt4FS7k#OG&X*wzalOfD1POOcWFvTNO3Skx~UGpmLruP7yBU
zdI?wjbG!g`6B7%|uwt->bgnCwL6aa6Ag7md%(DQ5Gt^Pnovos$ha{nQ5zIFqU0VMf
ze2#U0wDXtf=l~|hZM-S+eSZ?a;Rylu&NQ;My?@{rL{d`5@7uD0Nc}Pb?+ObR{D4C^
zI6i#Jn!d*2dHcZyutn0of4Wx7<B)TlOUX*+>uv!Ub)$wM+TZD{3`g^nGdQMuhjJA1
z-q*TVSrvDjeg14C?tCk)oS{y&ZFqg2xT9?D0?rSL|Bw%SK{Bn45Tr9_9XQ*eH+AK@
zayRs@h}1862KqlXG}O%95)l&{7k2?;LEvZ|17ZP}=@!@jc4vak&(Xqhsbq=fm`*gE
z*k#FQ`kN8jC*#U6(A^kqNIA9yx!iKkX93=XjH&V52cQ53iu*jz>e{6mzVE0S7qtOi
zRa-E>f9W7Tt22oI3m_!eR7|r2L5$G}X79IUXbrizxu*vAzWc_9x|+s->AX5-y5(wS
zI#Ik{huR3h6F(S?ajNG$K;jd|ZwIF}F@0HD4=`MSzD)dssfMW~qXRZ(Z=N30t~%}Z
z^maEcE^bk-+UBHc33SIQae1eul^x`#_#oxayv0TP-w*ky8VSiGs#2CdnIJSG`(M_f
zQ!KK}wLYA*W$VaiV6Y>W^CKKC7}oz$atjX6IU(z>^)wjTh=_<GpzJFy=RA9YG#CfT
zh-ck4Z1(DAe7zv56wP8IY+Zh(Xw;WPlPRuiyqz%)ZNfRizFJozg61A^AQ6d*qLR~a
z#QuQ!&6shp`KfN1Nsco_me8FCz7WJi-bf^AO?1c3zOsf`n3!bf=;(TIvVgS=zln@B
za~Sj|C^$H(w8)0^O<w4}c@tT22ZDb?U^rBgAH$--OM3&SBL$pN!FTgdHHWta-?-mB
zygvt__kMt!G(oe7NR2j*?BmM7-E~@%T9;RJ`IuTLy&_BJ=(H{3FpM}NsmDFWRmmOk
z<gCfFYw6|fdAopQckG%E6^JlZ;`!YA9+&O2=9m`~uGG?35F{S2h8K%jQvy%-*+?~~
zU<k-Hj3d(-H-DN_JA`}yBuKBmeRL^$^aRBLR(1vm9E9%jUw=C+GvP#0L#A6rex)nR
zz{*PES$<(>Rxb3w`@z$Jd2~QrUIjxjBlnz~yahgcVBQ-~3lN-J!OEW}1PFWb>)3Tt
zv~}|-$^r67_#~SrkWfJ{g!QH^0GiYA)W^Zb#$ZK%J0AXv^q#y^$=$n*D<l7wlaP#8
z`3n=bwm)`q9$As8X8UPZ0eQvN^XI=DgGC5tz7;T|DjUrMMS)VX*TRsXYT&gEcU9w&
zLH6J|HycLCb6S5zUFeHW_KAo63ZFHd2L}r)Kz8ySc5nG$iT;z!yzzAHI{Va4(24H=
zjDiO2E3>E%-98~Sn5I=WK5Y<^5CUmKUZ5A8$T{A1)<YLUZU^d@J24RZ!PFr4%i{>(
zvlLyA*PrhSVWynEBZPs6O%aS^)GkOvAiPOnGl$tDe|CRrt*k}zmbjb0+@)efhLeXv
z)VJ@3+`Ro0lAyK}kO2P{8g(&jXMUkaZ(u|e8AGQk31*TDexd?6R<`uTb_TCsc055w
zX0qa2ldgkONiD6Ua?{~9Gr$U=YF?9p1FB&miPEPYYyG-!i!bZ1L10*&?R%a-dfSF?
z&FVw*Dhw2@?A+Rd_X^nQ&#C0q)RwzYFf4Yyref+^VOPuH=sPyUfFmmZ7#2hglz>Sq
zqNhiC(3BexG=EjjR|#E!vUd!QTqn5yP#oN-EvjBbZ0ApzDnWS&3!^FMTjUT(TxKGl
zTa}7rgg=M=FZ=wL-<mzWy}(YdvMc)PKuD5~?nu$-!jr4nlum~v_UR7BV>@Et5+he}
zZ@c~%70PyGeWw5QM4eqi<LzbBaxcf7<!lZr3Q8=LZxOJF?ZwzPzi}nxaSGPoilmTQ
z2K?Yo1xG3_OCg@>LO7Q#76AHXcySnrDt$4#=Rs#?fStU!0_ad*=6f`N4xA>drWn9C
zh1{@qdmE)Z<J_0bC%&<}0$#gx6FeWA{e_37Q{}l8QT(>*DhnSyJXmM>9)t6nBMEbP
zWd!7?Gn(-2?d_$0lX-;9w%>Pqln*j^9qVwjZ+>prNPMqez54WWMLFQnHyH4I-UvR*
z+4ih6!)DQi93XUH8V%eVdux&Zo?{itVqtfrWU(MuYE)>+>4j8l`-qswbw0anGG*UJ
zHh&yPD1d>!=8ESqz-eCPPPeMwjbr}{%w96Pom#Y`9k1Gf0bqhHMp3af)v7p9bN!*i
z;OKI&NK7~lR&^sM)mjYl{(MU}mBE%pA}s&Y3WFj<w#;etcr%ReG-sqxa~!nkXSww?
zP|Y7Bc_09hm4QKzfwX)vmc(e46xYo&6%qy0orzDt#A{J|gXpLOoCvbZT^bYNb_F#x
zYF*Ep3VlRI<lxVNfwcBtTrrhX1;_P!5>?r5`DyG2Siy!!h2?hMwWt_g$N@V`-4Xl#
z>@#f<7KYtM7y%^Z(La)wKD|mlCpWbnMJ6)T!>_WltkdBRjVF0GXiG6gUcODgQ{2#P
zf{B5xpyw7&N0K?)!9!8)R9&+3_VP{VOm&86T~NjEVP`d0F~`2=&DIsux(y&$+W4Z$
z2WCkChv~}EvzanxKn=gT-oF+)gSUz43e0yj5Ju2WU^QKwa9tD)tv~Fd3w69z0d8gE
z+xW=F>EZ1a@kG9|Q4MgOhk!@0>#GED7f_#}b-l^c8%!f<ka&xIV*!dpiW%N7Qo7C$
zIHWW*5+E`KBEZNnCU_Yo3^ac(?E+9^QOLnJ9Bc3Jgu&O3C|Qxh;H2rb)-Mw~{PicU
zjBp>q((0z^G`O~vb6@USn@*NyjTE^vzW4yVSZEW^>{XDg6=QCkmSqELb-jxGXY#L(
zQKur59fp`XaUM<Qka9wYIP&uK=R#SqVdiOhMh$}&W>4>pKg@gtCv&m$zWvx(B%OS5
zA~3XZ=|(|Kt`s?S5<WxrL@S=!i0c(0HZIvq<V4&pS)!@62_uys+7GcV?fUuCg)lAs
z=Qa}%mo4C)?09ycrGBYX4mblObc5R{95XfzY(&Ty>!6TRpj|hnv1a)zJF%@3P}nqB
zo>uFG#l^%JTH-@9ivpzX*b9!{Pp5{dr^43ZsJM0^<_ST$p&qkzOKr0zJ?PfD#kw!H
zj&W^mZ6m*YS$}P9Q8|n+>v_?wOTe+xYk6D0C36GDEF^&zx#V`X{rKMW+QpGdMhPli
zWMt%WAJ5)?`brHYkZy_rY4h$(;2i^?L2Vd&O125Q3C{Ry3K_q|bRtqyt%E&5nm6_u
zOuQ_w#OcO%Mp1QVhy{sGvsz9mS=DY(ZUEV;(NN&<1xe5zvm!;_YOzZtb368kwb#iS
zXED7w<x$Hak*9za78d>rQnsO@WOMHCcZQ_HUW<Us=$x(5YPObZDvm8gdzgrfBI`)d
zJXJ(97S|i&ox;HwxAwq;plm*INsrTa7w;B*-`EV{e#^3aqo|k#khpD9ce3O3W&ma+
zu-BAaVSRrVrK~`b_K4~!E04baHR}$cDaWR)s_QL@>6qt7QOfMDRotj$B?a$y9yULj
z2jiM3NEruXOc&RR(gHrU6+wcKLIgvG#S8`5Hup;Us%`))Fe7N@U|u1|B4F-9|Iw6f
z0e4Yr#pz66mfYa&VQUU2`|;B!Nl+-<Nn8nH;&&c#&+SQVYG!M?a#R@x%z=45%?QXS
z2UY9C^>X|dZe;R5=iT`#?)HC55Iv%rDKmLLHJ<8tNl~A0u80EEgh*|Ki{s#8C!|D0
zt0N+QrqVw@y`i&LXURL>oz(;YqJp1*!W&PBd=5r}^(_SjMXOmq)QzE0!<+(#Tvqjf
z7lsmMC6Ku<fjm4soP^sk8II5dZU5qF@A=!iIuB5_)PY<cI3;;FH;})JSc55<nf4PO
zk9&C5NE0;gA}VXJ>o9LIy0o+eLd%DCK!qaEs9`{wBjLHf&wWKAK}QVu^<3^ABwK@N
z*GX>kQuUaRW7=Q4&+npY5mp*(HKd>=*P<$3i^noaT<((WGIz}#ChrJy0vWE)n)bL}
zL5XC6oS0ofesCb1#Y7XqSo24antKp;xm!8k9I7|v6y{{abAeQz9O!20`aPCepJ4Se
zINRk5eYaWCc;`{6516LbCuW+q0l$S)^3UBoX3=&|*8Fx~RQ}~!qei~08oL$Acpm4J
zOjKInh6G9AVIMzMmjh*&leJX1W(73Cv`s`4K`6i>q(>DL;={r0BG)Y=yZG*&5;vGA
zdEv}97e}wYm~-{!r7tDxm+NM^AcO8})Rlostc*KdeeC4GZ(Ao}iOO5rEUq;;$uPyh
z%G-fjTsL6T3O2l{5ralpf3x{%-0-j;+7OONw{`2(gn``mu!o3tzL`X_tHjVwrTEHv
zUr4F-3UBAsL6rFoZdpzH*}}jJ3A1^{H?>-n=m!BRiHd%YOMm4D*g1?-nrj;}u7^Y(
zMgvA$++oKFUt|yfF|ZhMLd*sdm)A7y>|`~xk2goVHO3w%8#nNRSY8z{ArQpFKm(h2
zX2ZbI<YIkQksBXwP}qMRbUo|L0<9FO2sF}9gk>qZMXNXj15$3UQG<iU*0EBEpN~)3
zq&%-B%Q!gxx8t4DamS!?)EH6n9MooyXB@6m_?__#-Z8m`NYc%Ps!s8*vY+Y4Z=Glt
zFFiu#CE=KRpZOb}L&bXaY*2PpD(8Wv!WGCTc-T{U)i0|FLvo?58XSo<K&cx_W==v1
zLXo^|K|8xr^cRC52@3PZ;5NIdGuav|EcLi?1==$Q7orY%TyEJ6$+rwVJkx78JIF|K
zL~$2)2_#}JYs{je6znmL&W+SU-;M87zsYKqws35asMn2Y)|rvy8IcYbIB-)WxOsgH
zm1B`V-kDZ)+MalxuUZ@nig21&W%tDIU?-&^jF?T9DqrjlsSdJ)SPdu*!G%WTd~FLw
zUnT5~&aC5*x-Iz`>3RM60MYKTq-e`Xl+8FDDWlM4mLr<`W|xj#7(sYy<85&gZ+U-X
zf+1|4pO>t0iRYaMLV5JwC95&;oF*!f4Q^+WuCA^%*3?QtNSzWSHr|gB5heKpK6v}f
z@1Woi5;6b=Kl>T4WPtk~&*iRv2n<ALFUP!v<ygUMD4bW>IQ<$1FE~%k7rqGy+8sJ8
zb-E=CLzGu6-gv)wB^Q?qf`OrQktcw)F65&>&t2+wi(>B_?$$n#z6Upz^qkz*o3A3?
z;J4F*!0CkMN*aQW`dV_$d)2D#YTNT#8quzlV5>ZG=Jd@5^Xg0Un}Zw875@NK4aX}V
zqu62du}1eRjNyjKX;T~jTbWAmEnZjCLmou*WcNJP5rT(D-|gIs*>S0Qy5kx=AqBS!
zk0mw-G!ssU8Pm}t+Oj`ai>lhR)X-xXxmoWe3^|Q2;+9&sYKe1eTJNZb36dbL<6L>G
zIiy&-gOmNhdy^zh&Mpj(tqYwsUFe<nB}*;07G~eWhjm_X37ZZC35Gv32h+U4;L9_i
zM}~&9M`Qj)<I*U=mi8{n&(XM*qFS9jV@+=#%;k~A!GV^53nis}vD@k(ck6eoVE(fA
zy=n97I;S08xG<9kYN`D0UqNN36ih*=ml=h;%u0svtNY(;IF&JToV+m+3v_o0)vDA`
ztaTUyEbF8`Xt)JfjtohPYfg!Ebk0yc8IF@&mFw1~v2>Tq)znC}fW}e3o0572E&E=!
zHz0pEw+9Ut^Mpd&-!t**_b_13o^gtO34IO09nR%st@|jTXdCUszN@$ZI!Ry4SF^09
z>s(c6ru#d7?c|e}jMmVc{UBXxfYbOwxY19Q+$N$6L{>Pm4^4)?2I$kG_R0?e&fTS~
z_}*-}RIA-So_i}B$|`9ZaI#;fS|7VambiK!AUer(qmQNqj1<nxZ&I>;%U<TRzl>fc
z<Rhm--HVHgccbWMi+KV~F@DdOs?lITdV-nk(LvAcI0V!fpL6%ZfWI;}3aY881qc}!
z7(Dxqft8H)>QN2|2nv@r%3mb7XV+73&}EKj+lLW4SQKkAWdUb<h2oD&91G&~XF{0V
zG5)gp7{tWZ)}){a63TslbuBMXumUCNTjtgXe!G)3yUyv!zxF1MNE%?PZ3}sIG?DPq
z91xjj<X+H#w9)Y~G{kY*DO1!^TBfdZ-rHTb0`T_G+NPNLrTDDf$kd(Ro)zQI%a=M8
z(m4{#;j{e|H8IJ7ee%R@s)zgU-T*8sjBr{TtSoHH=-co=(j|E^Sn!QxfD+3gX{$iJ
zOmuik5$dks*PjxAa!}|)3QEerM#j2r=1I_Njc_NWqw5}Qn-7H3`<j)dUWbK^4XrsA
zxVm5m9?HemPUEV6!goUm3NBOa){+I%p*~G`>=x8`yuWe@xE(r%&BmVJb0kURS770j
za_r(hKK$d)f{xe&(Wj5#ezQqh1Q-;9tJ9rOM<q1Dg+(Ok6khes(R`|89_LulkLQGe
zW&P;`$FnX48J#FMjRF!6LWqcn*F@DuX(dmH!7a7z@y|HJ2L&@YZiXyO^_jjtEbT_I
z1F2Lbh_mq43e+iiv69VxH}n8dJ=lzSf7s_uBDf$*qD9g6`H#akDog@!fkm~OwCy$Y
z+O;FqlbdQ1P%jeP3=l*HfRq&D=~MCqhHNlal<^Su6nc;b7oNDA#y&<)8+c2d>;oyt
zxB+7#V`e~_lSV>Lu4;2d`}1en@a;!)k4hct8j^VH$8{=V9nB&^O#)v(I5f0!td0rV
z7l4l)peMLL-GGq+EXsm)dcin<Y<!qEBs4S<fUSJ<eV$fohfal=vS13T@2j+Igd`^!
z%k+onmjH9eQYsJRN_!5hHDo}2BDjDVv<KrreG^yF#YEn_Dg&2*_5Ba}sV1VW4^j@k
z*mgEY7{#-ql&rQEJn=EVa?I1>LK(QYYFfAwkb?pP4M4Qo#$`5!{J%U)TJS8>bhz3=
z{&<!T$<Tln1c=`qW<JbR+h)@1)N{V=^Y$k7YUc6=#oaE@=!OOhL#2jNfVk1OrKKgw
zd_iOAEj)6;K%7y*er!NGa2;bF3F&$#o1-c>AF%Npap^Tz-4{xN7N&k-Bu=$WWw$eQ
z@w^*#JJ~ce82hGD%>bl<0%fU6!DvPmgVMbP7I^80FjO!{wJ**7I8X3s4`nO`T#rrK
zF;^0Pc+S<kJhX%R4f7#vJ%WkRXXrE^(@m8}Cq>*dZ|H<!sP;B4#WubJVlWVqFdqfW
zC|1U)Bnl2llxr_z1R0McoF3~QOB;GeOpRggQuyxDcnB!(x49JQHi3@w5#i47VanfX
z8))k=;2d9K8C?H)jtw81jTbQhEm5p1nGP`bJ_#mPL4h};$CjAKNxDAk96*}lz(h6Y
zWe(_zW)fjz8_l#-6!SW6MsLqGOg9D^f=bK-@9k|1vPZ4p$dNNJ^nO_th8$BDI&6*g
zmH<NGmC(xz71x<-arMjFrN|2N<Wc1%E0HX*J6jcP9QMAX^_)bkUQt^>RWoSn2W=1*
ztrGreeE(9jdf;tF1(v^}?kkw${>SAjVR?f{fIEe9+}7{o#|}W+=#G~G$0?o4KdV0t
zt@?t>6Q31}>gK@{WIO|v5NCJcTM&OZ6l8*w0gEc_J6r;nur9DyuO9fxTK>`j)df<#
z2Zq=;XDM-U#wv7xS*}oHXltzLwSq_JQ=DbVozEtq5VtMnOKTUlTUCrfSR6{h$ES^m
zghV)<b1#NRp71d+QK70a_QHSqN2v1;VhoRpA_J-gr<|ccXN_}=NqaMi@n=a1K}-)r
zH+jj*r2fZG;(?7b-5_Q$yb$-a(Y1tik5=nMyw^bIl?ckS@pH%`|M}eDO}s&_U%WKl
zgAR^6sDT4M@c>{4;EHjH9P+{f>GL7i$|x4sLadKIK}xM>2|!jWVwacGJZ$v8nA%L(
z4o-zkMh>c=Kh7S`n}zkk%tKJrRO))JTBt#BnE@it1q5g;|8ku|DwcB-OIiJ7qwEbG
zwb~+nRouh~yImWWjiZBHEx~lvWW|TP3=|Q8zwJ?|p@*%1;Enmv6M^f``}utzz(4f{
zfD~x&k8K9**iOJwUEnIlWa8Blk!&8KDt0F0dGDtw;XKUV%wbfGJo>loM9VZ#sL9d(
z43vyFa}@8*gh1<oNw6&d$+{2yujf4N6C$uQY5;&1QYHYP6rkag_DRxa>i%yh1hycr
zui`EFU;ixM`&c%Gmj?RG{&=2${i~PYDEiyH&^&vFX9)MkH2?Ny@BvzH!Iv<;;Pn4z
z6!v@YLaVvZ6F(f|4u5%XUp#FJ{)Mu5MNM=P{9nIiM9G`sNFcny+z1z<`z4M6B8LTf
zn0@&Fwitgt$|kVC_Y;E&{}C+x@v3(oMY!{I_<GR2srdt#Tcj7t{&z;(-uK=6-(DLP
z1+K}=?l~9oy_^5vz8PHOzOGj@!d>sgqkFISKR+Tb0Bp6<WnnwK|9qzRuFOIcc>8T)
z$&<f6uzTMLT~{Sc=-PMsEwldTMgIBt{_S#_J;B?rIrLHg?bW~7jeonN97<r!m7<V3
zP5;;L|LY&T?!ep6t=owHU-v050}ZVxaUzHBz0$v3(;ajh%+oKN!UKN+hV3Lk=^Mss
z`?m=JZ;c8w2|yH{1quKdSXe8zYu$`>(%g=l%eMG*e?3)y`%LIl@J^sadowIsot<nA
z&M6QHCBkk<_vmI=GTfbUff}C?)=y^cjR5O=I3R*53COd_0Rchv*eU|RAfmoD0yGLC
zpFf9#+OZ4}4hz2Ye)MD+bYz$l4@3X9&;IkljJ$rxEUR?X?J+E~M8Gk0b=IVG{E8>b
z6@I<qdV2mg73$zRUZg){KE-(IP{i-F{fy2;c$%DwN(vN%cY4)d-FruWT|={^2e?#u
z7Ze<2NM9hi98-W7d<BTktkQ02L##i8=xP&m@MFMmt;V!kP67;2_wWQ|(>HoH#(hb)
zustTepFeX`OabV1teUE_%Dzhht*VdhUl;wJdz5c@48v?gO3y8upv_%Bqq+*Jju!D;
zlS{WHA(|4>W(gnLN22!E-w#&0sK-YpI?9Jy$i;!GKhar!9vu)8p{v;{(pCF8{p}YO
zAaE_+T=judx<0LHdYNwrP~!0~ei7yO36DNC0hMw6w*WK~Ij-Z@%f{FKoXke}5p@r<
z%b`Kd_2EMmK`|Yj6c7OS%xGoJUGS>pc7K2SUrtHR7|cUlPIL?vaZtNsI`gCH>t{gc
zL?8cJ!MejCoq@+nGihDs)K<G%L=wm+Wz;pdV!wQxyBN8Xw~#PdX50;e=4GJe7@6uZ
zMGbHkhn$jUG(^1YdWJC=0}DPNl+e)Ub~*gYdvi=&P|If`tZMe6XVzIR9J-%DCM%uD
z-fN~giha(jQbG6Q{eQdIM(D*V491bAk5UXdo$oBVK5ZH)@)h~{HJ5H!>_$b~;N&aL
zii2%u4|0~1O$7VyRE5->tNEfBH@ANw{li}Ncc?EW8r{X?{k!`5VkM#|V<to4e&3@p
zOlc2oG<aoFmFF^nSmkS5+qbaJv1bI6s34$3a=<(A8Zq|>7>5J-Y(y3@?}j7K{jkEE
z+}|%TI*#m0rH{_G*G#<aGn~*w_xIzhH(KGwx)hKg#6nkxpGHGQ6PBTA0mH3+b|3bf
zxGJ6VL8UUNGQb>!$5hNO#Wb|IRM<V+kxh{N{E!&m_Oquy5pZSQ@(J^P^m~W-oHEVZ
z%GA_!sM1n10077U>~MVkneihk)&Ze1IMCO94RpomfzS%Sqeh*RWv0Lm2Q95+xz(vU
zXk&44ah1BAS*cfAsQbYgpR;n}J@*0>#Gj=t=zl4k)Dvm4oIwjJe?3=!{5S0@6s+`g
zl_1X2o}bQ^eUPSC3RZSo=P(&$`$`#wHKZjn9Jwoqp)a}v9@QE4F2@mm$EszRW78J*
z-|{ehtVZs<&46o;E!p>-Z?$OcrU)0-$EVMzfts2+8sw3eBgT4qJ}s@SxRxMy0f@An
zF^_leis*4=0Mf;7|84e5Ltl1yWaJpY#E)yqCfK5L{7DuR1`Cv_WS3uqzNGS5<p5}e
zn+|690p+pRHa6e3=bPpoiRywAK}|&b{Z?lE7Cx&92`FSb5b})fcXV<+hn5h4BpfOD
zHagWR%c=4R5TimhK`59@iv|I&B5o<DDtC4rGRS}5eGjIWxNH{EUScDEs0Pw+U%^g(
zqo%fyz@I6|Zaqhj&tY}!I!w>cuY-ZHiGKyj&gSf+VP_w+?JX@0#pC$39df*?@w#Ku
zd}oU-1R&u6d_WS^^uFpeT-t%YtbXv;I0RqO!{pAD@$?`kV(!}!MCo`<p%5G;T5xGG
z0R5}q1L*uJ`0s9mLn^`MZN7m2jev9D1R&J0Mi%Dci~<JUBD!z%ZvfgFGOr(+l!3rA
zbfgLSlD~X87~#?}R}81H-Y?|txIXaxOP-Wxll=Wl{rmF&W4)t!Lk^1rBxLNjlS*9Q
z1*9QZhF9qO0=$BB<kVUDlsJclM!Gkq9N&o>*+esMGZ@)f8}7X@PPr)Ck{Et%&*1`~
zUxvVfztT<xVn-$7g_cnCBCuk!Ip#J$0o#G4Wf_x6v)@(awAEGoQ!JO16a!%Sm>t$%
zjANGnI<+b=oVEV-LyQ@yIdXwKsiKh-`#Ad+bR6+H!g)_PfPlpk<t<%tJt@#zI2rlc
zQVW!rJ4aP@DO~Nl6l;JARPfv2yW2Cq!Nh~PK>l|Y&NB^eVOy@elxH(6LW~W^Z^Ah0
zS(^<&5_!1i*+jGZow91yDIXelFa3i0RYZaf1IuBmFV+pCF*2<xx5p3xjrNhWNZp%F
zk7<>)j5&*8+e-8CzNvPLmlhK*^esRN%#wXO@Bpm=&gcS2q8fHZM}C)Cb&}h|I&m3!
zdA2d!jzzL~ec;rJ6^HMy90!_jL7~ae*iH-nA@Zkha)nA$FDsJaxJ_Qn08hJ9V(Q>f
zPEJALGP7!$b<0Zt$c7K>Z9x?+CE*)DDdYt-51plkFN9BpmTfprm%XXd$<rsqf^FD`
z?f;Vt;NDfXK}_mJ-_cSnGc(5IRa+z2b`>7h<f=CeK^IIHdU|P>mAXGxuC+Cr3QNdt
zVG@6168qR~;3L1fHJnUzO<5{(&++`}ENgy??%icUFfL1*`M}4@aSIsNrOT|i+l{Un
z8^(^GbE+<}o(DlZD<DeP$76kWn%h3&<p(tW#<W%r_((~GQ#@~7aM{ehj;A5mi#H73
zfk@z0QPZufeT>{5z?BCb@6FF|$*?w<Izf^4K#F|zWWzug<?DEMeHJJ&ABK6>Q-di2
zCdVXDw*biKhI)Ul;+q+PFxL>>4+mmD$M{Tsc#zCG0pxi%K$5O87nisT#DYM{I}n2t
zNJ1UdX+Ty6yk6bh?4@XvvayYx<8F7qbkt2=6}cL`^|(F|SFMC3Q#gU|D2_?bYk8#t
z(y|IPYQ~NjpQv_%;$cW&ert^_#(zdTzlRM<*<MEx+g-eGuy(FmZnfW3d5D-h$Xxyw
zvF$!hK~=Uqf+Aj7h~uuTa&djsPskzRdbY~|x+@;J{!o$#{i{GMI>M77TG!0hl)>g3
zQ?)C0>znJFy?zPMAZhQdZE{OZXce?BpLailZ7<<-l5gt*Ad>cusf9V|uzdB$$8a?_
z=d~YxB6B<&{tR0D`MY(vCpbDl)U#{cJ=3UDp6QIgVs?FS9JhUt9?mcZ4mmP}hG~1J
z+!`6?TbOc{c^4ozxr?vAIrS`9<$nChMSEu2oXkFvF<;0fkiYY~hsD#*K;Y%oOF~w(
zHhS*Sj?d^nd(CR*``3<gJea`A3RoZ{+yfW@tt~RqvYZJi0HRz@_b0MT-eNf&{k`@Y
zLz*U#T4gaw3P@TGI0>WR6oP>)>-nTLir^zchba_mu`({GlwypGsZ4-{Y^^NhV5s>O
zOSr73waMF*+XkWg6V2bfm$y9(8^6tB^Cd;m28XKz!+3})0|4h_Z83y(q|4+l3tnPy
zRl1cW+0MRbLZjew_XSKVnjD^N9fFFETT!`llAzu}kO*`o7jxoNCL7$UwmPp4UST%m
z0&v8hdhf{>Ov)MkQ9cH+_iIH5KAwV7H2ruv0aA!5pMwTM@?i!jM5*Ao>ff#j+||&L
zELfT+Hz7@>$~wMdO0Zl4hB68Y#V*{PsVTcYjC01duTP{qc@+)!l|aB_M$52%-nN~P
z!iN%+Fv+az53K2e{O25?^KilV&Y2NnKerdA%*8u_)ZlWnx9=)#*q%|dHyqoC)5*0@
zQT!AI0C}oY<P}**$Z=i_s-qX@OPx@Jb7n79>Ic%xp`i+MRhQ)m{}98Qe()LE>a@3p
zquq7;>zQFdM5Kqm(qeMc?)}d%DWc;WF6+IVy`1Tkt}^{qN&RaIkiZf-%uEhyf!lNa
zi^J~Xf_FeL@7a>FVp+NQ_!xX%M|U@i>H#z(P^xZD;<7gwFVY5na=pTOHe1miipf(U
zNrv+Sfi~{Lx2J@Td092~YhA0oMNJA?0(<pP94VfnfVRs@j0z@lcG~|DfqN+~Sd@F&
zYlq|+8gGa195vdclx@AT5l$=`vh9K0a6d~W-w7Oi!|}XzGCR^tD)xGP-31I#hSoMj
zCM6ln$iEyn{U!oJ2lc`cXXNtg-P$dJ_JQ&R02soLXETol5OjRGrrZ6WsE7Un*Cj2O
zWvbe21L*G;);s*Wiai`tGh>Xf&v&dn*WeQd;4WKs+|O<#Ss(nMcg?(8O|)jtZv&F(
z)$3oj#U9}ixgWm-2~E`oa-MbLMH?s8RWB{L;HxD4(lbNdv6~Um)N?jpN{6d30mg`{
zy}ODf$}gw+!-iTp0IW+UAthx`U<J~b!>jqbImCp4kjv;JAkIk+<gGI@cUtotHb**b
z*K-viTt1WznHq9Q=auWo(q%b&72~n|?m?5W&LICwtA|N2%_vVpDAVl?Um~K<RkW+Y
zL2jG|75k+#KR5icqV~$W#-Zk_sVr$JquqAU0a6MU1fWN);Zg19msU*AE6BbI)!mNK
zQCA<oKmAy4r7~Up%5q0rxyud&GGe|VbasIalDO2#_aPxk<b|LIQkd|pFo_Dk(Nz<G
zKWV<>;i1#eXg_&fHBH3EtkA-4rJNxnR`i8=g+<&Mz!Ggoc49ywe=0u||3@ftjC>71
zDiNq79KY(vl;hnvc@5y+x}vG!Y(aD18bKZep#ILiE$K{dF3_olyW5*n<*`!SoVQK3
z%ez4JdUOo4u{IM9j`#K)Q-ydJ3B)BVrJ57t9M*F)U+jK1_6;Al1YjD1s4|6J0!%+v
z%T*24yRd{=(&=YiMdO1&vqMpiZ|6iFuweqf-EY*qKeY~HF<>gQ4TV;p=ILL65dga4
z#><401a8MXeI95hYC#Y23+|_$mm|4~?OOC_byp)Y-0tY0NkJ<o2yxn)D9N08zZAl3
zHbOnP@qOk_C0CP4j1l)H=frHp@pbN_T7w>am1z_accd|fil5Bv+1c56xJwQRJjl$W
z%^EjXzlRQgJ0yaRSR^)!o~oz&v23N+0-g~&_DulklmgNGEG-!$J3dcW2scj-fVgxk
zEa~4LpFVhmjAnC}G0JNL%wDh9lIa`wu3KR&ce_3vRwQ2|_k9&slXpX3!w3?YKp#qc
zc0BN^*ImZ5D4s!*&XsI4MpY+9P9RyYe(u8&gSh=!$@){&%Vld*!^>l9vEj5tu_kGv
z7irt}8r3!tH9_rX73SldW9HbOk(6gxI6ho%KwhCqn6{7i;BvS2w9@0^_NB!`eGl2U
zc7FEcAu&kgOI?t;oc8|iHE@)h-DyKWM<;pw{V`k-mrS&i!xY=imn$XZHOB`|pi&?u
z2zgw0xtYH*rfD4mO2V&aYaI(M4H-uAlpXJ?r0+Zpps<%|%PL&Om5ryu_cw9!5(PK7
z-sMkE#@h0Os$Dl2018$$cta*(HZB5E=C}d)wYZc{Lf5S%<kAZsV-i8!*{gbWNbNHY
ztE5pK$ksU+!zrv~B&Ve0&fb`SI*?VzluQ{z6)^8bI9sf>af9Gl_6s1cwTIPb%=rpe
zQ%WZ+RLAPFQ7YqhrkyA9b>gIuiav)qXUpjT_0e&UZT#a;4L6jk0H&!OFR(h5$QjGl
zENDFwr*f<@C8efT-Jp@%y(`Ba7hCh4Km5^?Q+zqasd4R&mC<}v3DEc|6k#_V5(O(H
zLzcD*AfeF!fiuPqg(-UH(V{(lx?DY&C**%hlibC!8~t=mNq<+-I~pQ)3SiRqFnC`^
zinMu_lr`9KbhEd(#<yB^hfL3Af@DX>^OWh9vL32|W5ZIKV=9RK&u;Hu^GI(&91@!!
z-B>+b)#Aq$?zeGon#8C~T{m6?e3tp9LFK$n=3iA1Q$UDc;D}YR-^(!^GSX<ot(C0u
zgU{xNdqSw`aAQ%<&#RHJtLt?zkjasH%F-`^A9uQ9XPVsF*2c|lJz;Y@p60Y8FP_Rx
zRnG*?Acq>=dGd3wo|2Azx??afj7dUiYY5>B0?9^K(N+`?mi~>jaqio6y~~jpa?-$C
zEEzIFLPATF`I8I8IPXWrtU7oFkr5Hk!SlxH4Sl1sA2^DD1WmghKmBGLIrLLSG~Ac}
z#EJ=^S1MFNfy&zs(FDyF0F1IgW~d_n%}o`LK7F{%RM0BTuv(+WF3UuPBiZgNh+8SL
zGlzrU$LYA{{sn|WnHX~Q#Ebi$TBx8PLQ<U+p8U_EFW)z1t~I{P`V6;<h4%HY_b$og
zlbc_`Z8%M5Vi0N0PZ5om%VfdIKE=YSX*8In1aqe^LbKv=kGmz@%yx+QYBiSzYPub#
zyphz816bTjo`_D2$5mR$5$b60oLTOgh5=u_HP^CNd-LHqyS7-a&vK?(VO!DveWFS$
z!9cE}@>KxumE%Z%dhyEsuhK`tA9nJ2caC#Ao)Ep4*LnZT#TK<-@D^GdY(`1ezrNgR
z4}`0iPGFT78txZZ&*oh+BnAetSzGW?6JyOXM*F5%kYwsq=ir2hSn6+8#?C|YmUJow
z`vZ~6@FWXCUT`SR>jOg2-uSOyDJ(vw+0T;o#LHf8&+jEk_QdHcWwAp6-5`3v^L`F6
z{LYV&s^TtB`fr-TLzP)pKyw_o81&M{=T$aJO@}E{?_!H2*Sgj2%ZAJ<y;#iBKB<r7
z#?jAuoZ?Tbr$&e|2~a{1rDU^g@^S=G3hoADT=c3(8?Ag;ZYnC$VXzx7H|Z|G#DB-8
z>BP5phrj%dAzK5Wp(Qt_D!Sn1nD#);2GtCVygj|isLTlbANIZ~EUzuuHn>Z0mn1-N
z2<`+(fZz};xCQs%?gWAacMTHU-66QUdvJH>PIh<i-lxw#-#z#JJ_3uM#awgEsv0%M
zD0hfGQ|qCR>8b>fwOdyMWEhR)X?;ye3gE3_xG~=S$Oh8Mmw*I>G0>eMBRUK9wjW}L
z``-HzjN**tSiGw4PvjVy?|33*Sjj=3T@L2TWfBRLv$FUuy3$*Y2sS}L!E)M9QI|uS
z*FEb(kbS%S0%0qPBSE9hEsy)w>daDZz&rabRMXwQ{!(=wqbXB2!0*1rKDgy7L^>jp
zj64dANIHQ(9|NG6UcmQ%MN6BXmrAnsUt1vmT)GzY+z~I#TGjXrd<qlQ8B7y#$qxxr
zbQrCb3#oKG3dW?Fz;Kap3}Gws<kQW?z8;M9HzKY!>v<3%R&%uigYIGLNn|WlZq??Y
z$Xpj5LCnR##WiF*oUe^!Mgd|`BBX@M_M~hf7M-oW*l$QTS*4BB<=)d%aJ^+I<@lWG
zdKObfg}YyS&J9qte6aF9TpxE)WH2`R0|o`wz~CqVOfceKvwE%`)ISO+)7)hiF<uM_
zn2IZMd31s%i5HdC0Na!pz<~<9OmUL&Sw5@SdElOHrb=t+qd|kwO<~L$p3QC}Bwh&&
zOhBUg(l(kZpj>seieQEU(wqiWW^=8N`~LdJnB$g2xeO5ANF}gZ-!+Uhm$LT7HnHw@
z0?^rQJAwUgYeMypUIfIP)*ENkJzNzs84-kPxaq$qIC^)&9>`&4L<{Ze(zKpYR&8&n
zIK0ry$<!Q)1}sB-88hSN1QWH?)zO@pz0>Ga&hL8twCW>W4EX|Xx@<3Aw3%e<&4CD`
zSlkbDx$Fx-too+#`-=wDpPPEH(ng{LOv`-(XF!3=73#7srY)ct8}B3roPG6^BL_7!
zlz_76W7JFRhRV}-n!}0s2^))&cE$1HogwvdMGYq(x)c_k=6uOa-MmOe4G;yrW18V&
zEdk^4t@$Ah6q-9g5Ep^E=~ZA=c@iVpO1@0v_yQ<sckVJVhID&Af_CUkK5_e-;3(CB
zmPnFO!gKNPs(W%WiDxkk1%xdHr!7{><KyGdv13-hgiMJ4fxZ*yd1#CA@jHa_858?Z
z+<IKXOF9}Q=f&e66~ylKtOtB51e!KK0e1bdZt)_{_Z^T+T5a?jbCvNmW(2H(m=WnK
zJ@q{<ZaFSn4`76$ZZvtT+Y-7iOK@l;70OwrQw*Wb21=8~4xa@9-0mk60KmfVdH36)
z^-vyn1~Bc)Zf}hruJV@mG_<n{7{UmvNvX@67TJzN6|VA||1yZx*yx=dZr?RFvJYy$
z-+$zSeBQv$ABJM!M&h>p$&#q)d{P9Au2&`+P^&WA{zs3LA?itE^NlcM<CvBB0VrQO
z_ymXN5BhG8R@#YG<5`)kdZVc27wKf0h$7kH$5|mzstN%gM2g3}crzbjBVoHUrLx~t
zkNv-;e^0Fn*>^A|Upf&QDXGv5yE}`QqA#Wvvy3Ue_5DzAcvW$r+t8p<ZC;)uX5Wcw
znMkYO$o~tlA(>5sya1E0PTncC?<5WGdarzlc3tHldAgjj#&YatZ>C%W0^UI-@r%U;
zC|~KhL;R~Vwp{_;+`_aR)~!FDWh(Es?g-FIHR7Q<RXKLq2)h7Q*9S-Hx>bo(d3!x%
zSzU#Th1Jcm<f=DeIF#}d0NF}zfQ|mfbn-H5kg<5PSQWWHV=VTmnNa|{ehWVGHz=lT
zT#wxz?=Sl-J#KkMSPw5Uv?3l?&}7t7Wp1m2G#U0!r^nf(x+|wb-=J>SZN3H|Bh#p;
z3!zVTOjT?Ud~eBR*Bh`TAf`y4{}@A<=>wdkZxt68b`Nx>u*raup;Etfm<4oGA6YB;
zLH^Q9mF5+D(R^7E3+yC8a+A&DaKKt7qi+CXKUsRR1psEeRxLm$taxB>INStt8V>Sv
z|BmPgNb)cyuFJlf*aJkRCqA25#!KWFOAT&6acMYq)Ak;${q-LzGREz(E9F?88OeIb
z+??-z%|2t7c;ERT4~5-t-_)=>fbBM_Xz6b{lGAy%5$r+<Th55WdNniT{&_(g5K1`S
zpv`+c7Qf38vtq2fm+`pCT%){wxW@;)^Mj__N0vc_t}-BeaXP4N=1GZ~AQa@L4;;)f
z!*Oe~zrXo16@_HluQ=%<Dfw;Qb_hDZ2#J79o6&Z25L9DvGQHcSz&${q29l4`kvDa*
z(d7wQH8>O+9pm8K@lqKv<uD!<wE+#p!j(i-inGoZz(ae*!65^vdp`gU+PT?bven+U
z-0A}`-O^5!K(Kdv1Rk#=x`yHeQbnaCmVlZ4?v}GTfDu7EPP-65!H6y{T&Yy``}cp?
z6<pDzQSZYc<1HH%z10Gm0EdFpoY7_vj}iBQ417v{;5LhR%hS3S>i}(%&;rClA=Euj
z8l1a*<A=fm)EkZn*u@=MK!Sc!KLZC1bd=%3E%|(<2{Ei(g$g^M=jJrLe}s{FmqRdH
zXO|E38%nH4zJJ?i2ZZvE`7K}X^a2caFH^bagKgYy%NRD7NmL)Nn<;2&OFLLisGl>R
zzv8WGf({sux!a>#vs-Op=$WlrglDoM`hh{K<$fIv0^um4QD7ivto4(hF}AZlidf0z
z<EDVX%O~OW?)yR1HDg7WPKd_Rd!YEoizn@WyG7Jl-29MG0Dv&NG3V0fXK6FffX58=
zl)7yQwto6Pn^?PoKm5J?tUHT%PCp*Nh+F|JeM9HlB~UiB+Kt_l#sn9+0`UE*&09oA
zl=^kBwm@r7)BXCHUXcR}nb6$!G?mPQ2yS5pM;!m1Rm8mWF8yTPQ||y&2`0RS^;RoF
zYe>iI>#snt{PxoGox?C=Aoy<#OqT>TWlg0>L8pYL%Xq7DJl18zlndyPyX<T&Gwtqe
zG<?ka2~i2IY=Gm36-@43kAm$Q%VyuEoF(fH3ZlyfJW7=DVnaNgdQG<@#z(X?2-fDi
z-;5HHwB<(MH=iMe`RGzSWjra6z;xVZLUFLA9_U{PIMn*)DnAz)O&!b+ncdd{{?tb<
zFucO4US9wjy#z=zDF&*tTND04`|Dhauc9m}u(JEsoO)*YdY~)~0_%n&=)vVI3%b^u
z=>u(Rx=xmP(YSfSbv}?gJ$2Q(qPz~^CYqbsRD^uY0S)wTSS8R2f|ZC#uX*F?@$+$$
zrr0>GwX3)C^P(CW8Zc(CznD3nYAHA?>yI!xoCj-{Z%OUWSvD^e^qN=S_kVYL>%$Gw
zA}U}PQ#SjgOoOK>G3+d1pT&8&Kjh%cMkRf-PN0@w9-II>!)GPb9G=2z9AWzDYhvMr
zv+zR@Edz(<lSEz1?L2yox1W;Rt}83{A`<BQ<MY+Ef<y@vT&HucpFWOK+O_@@pWJ0X
z%TTv3f<y3ZtP-oX$dE>}Y&Bei<E*Ip0D#?HKzTFp3*+#?mE`eu>GB&HayceS6h6CI
z-0`Rf?Wes~md`v=`GpXIPgU}=5Ikr_^ne48SODpqaxG6Wzt_zXg>#&+^5SH_dZ`ys
z0`~G%KrMubJ}jt)5;&|3B%NE$0{8VJ_lJqTzR+ujF9x79@vB&U5@4~XC3Fs~T@>3g
zcX@U$KB(w7H11s5SnH%zhQa#XeqtS#D3<^XfLKn^a<l=ZDyP%WYea0ju>V7SiJeQp
zr3IyU2pMvlXqg?$IocUQNIa$-Wh5Jl4V2_)FUi{Hif*EkU9JZ#-Su4McA6H|G*ata
zb_=W3<H<Li%}&<BBt8^q)mN>b5zZRzj2nZF(Bs@D)%Dpl(B+zZHN(7sdN^<h>+6lC
z-OvA^G0FdUJ>=ocmn!d2v`PpBf?6lLT9328OM9bt__}V)j7ofAiMCkZILuq;3~e^K
zUI$@JeaJ~XR=T_9-BCyb5P4abCmu@N5m4{TI4%LZr4QeF<{VYRK=e)u69m&mUiw5`
zWHtBUGHR+HSe*A<f)kkMVk+%J@?a1+q@ro9z*vkm%QS~2H)S09Pp?w4A4Z##*-C`U
zyJ`*hdwC9!f8=5=4exp?@bHw6JDP792wN!mS7w3Q)Yo^Sa%U0e3qb|2(ZE-@tcCO6
z;s^5`I>#MA3nGOMcoB8?Zxk|4{%ur4hliY?SrZ}ij5Ykmjp8kBoF;Rg_->Q_G7A)*
z+zG!oQe0O1OIsDWo(KSE!@@QobQ5YFIM>bWHHE>Vf>(TqK$WsHlvt1V`^Mt?-J9{p
zGJ`(#x0skAYmO$FyBl?oG_YtS`flKy>XnW^iLc&xV>qZj<vN<Ep&&T_nfLkTcCbcr
z=L!fdogwD{3Ub=-n?IVj^}v;Kac@VN0+Tp{YG;p&HZx`5cVmCW#|IG2eaOFhvuWqv
zWO=GvucbC1y(&XZ_r;x^cRzpg0>nP2*>x3MLc+D&UCj7{-=HRWpRf!1ildGua;YC&
zH<KOa6IJazKxgSxE_L1=kY~ObbMp?=7f$VOjp&_>h?3%Sa25EJ{=rnr5ClEDr&fm8
zsU^w#@*SgRpPVEB9alpCW~3PxR9;Gp3{U)mUh*`LQ?uEM9>?uwyX4Q(J{0qhp$zz*
zuJ4~@2*ZzW1jjAyzcRmDrk>(<84(QFxbK`*zHUsiH44*9WmWb_{M@{&vZ-lJ+H5h^
ztaq+HRjhT$Y@6glI{vp@Aoy2ap8z6oV!pZ{$W7b%i5&9gOM&!Mx>nN8{Gjv8`hpAv
zJ66j@NqGfAd|ST5nesUxrU@qEu`ejlAfD6H9b62&JUdItOfSq>GXtuD-3gVQDH*G*
z_lw(g-<u8^nx-eN^Ag!iX+j9t*ex8l2Rz&&9Do)LJLS0Do(7`&>T0by63E|F*4#lN
zybdhRN_H;%fFXmj^R9|A!L`rDgaO0tt<!kRS0Gk-vg4v)WYkhB*4)3`Ea`tc^302X
zMpialOL%DhaSRLrteOY8hc4R2Xg^;Qtkl+_%q7-i0=rhKb~PN*&N$Kb_BKC?6+nUc
z@1-w)mJ^JN`Dj%bEvHHc$SVfJP8f|0sVWZeW5Db2rtaoHvX709eoNC#9u*FTg)?o5
zYCNmoO~pw5a^bvvlj-6SVL-}Dof9+&JK{eP63s8*q4`1=bH84EFnytHImCr{_e1{H
zL+ldA$cTPl1DgKQ>><Tthn(qs{MfHa8xSAgmCqW5S3J0mEPvF33@=1g`71c~C*6YV
z8T8pLBmIr^vdA-aCjY<|KMbSs-0x5RY6b1aY2XyURI!sm0<@2lHl!h*l!CkSVp1k~
zP8X9Qpf-Sa1(Y|}W`F0gGk-#hBR9C}80R&Yn=hMD8X)s}0zzvl&l>BrTOnskbbJnZ
zhDXuKtTI;l;U@sb#(<5FZwxI9?8&5UY;5)tU!}iu*ycZ=?y6(Skr7`!7RHe05i*&w
z`+W9>@P?2x{Z`}64YTp^fqXeq*dY&&2PI+iV_0e7yI>qZOf!JizmCZ2*9#~R`CBeY
z5YjXhm3Q8i3O)(wdkaDg{79D>HMu}_15jQsU<Le!4=O>+G3bjq0h!U-bdjpimmusv
zdF--dFsv#<IheL+39_-mYOxX)lkRZer3d7w7-pWcmRe8F$*XTIMVW<4Yeb(}YBIl3
ztSPRZ+V>&=Rw!)QSuc&+7&@NHf&Yx_K=A<obC9a5mfRB%{8Bw0YUl0e%qK&i%sRjs
zD|&`>1|SlGQ#C3|%Gzu_@o10{<tNu3ftNoqxZ#hJGATz;PHx2MLe}Q8cdL9|PQ~XL
zWD`7{;~L4fb9-b&_++JsZHWC+(-!8;@!IC-YFT2zeooL`D#Op$k3X0jMS~yKe&_^1
zU_6g}{g%A4kYDw0w@F$y;CzZoJwjVOz&oN}-7cj@g2{PkY9F)!y^SuO^LT%huoN3;
zO*B1!azj2~*g*b92NYPFG^d#?N~wtzzqF2>z-f`MmgAajnV7Fw8;aJ6W@zEq>39z%
zF)2_x{+<|(UIM+RU>9!Pru*diA?XF)UlAapq<&KQ0c5>TegC|%rbcDa<Iydid5x#o
z9N5<WYn7K($qrSr_iP*g2Y)UrYe12#;XEM1_M%}t0;1#|z<)OY4o9OE#tPyeKE%Yu
z86hAdVuUn}auoyjh%J+H!OsIXnqv2wzZt2a{&tuBb?2c0zNVv~4mOCa*xkLoHU<$_
z&rm@^^Ve(s`<H36h|r32ENdPAw+sLAF<x)LKk*tWaNxghtv?sy-%BFv_QYmynu=lh
zTafKP@9h77_<yd*Kid5NuWK%pclgu#^M83lg4fUq9F`V)D(dQVK;y-rMYZSmHxCRv
zItX&WVE3$%M8^2@$o|{A`sYt+gaO&QS2j!Lzi+L-`89ZWaC}3qzF`*oUtOMy3@)b;
zj^_W{SpT0pn~V(XP58jR4zmB%<!MjLnv1M>^M8G_p6=Dl69keMWDJ--|GUe3(cyo7
zlimiBoxi?VX(kB1ovcw?lTZ||xW$EDVp6;+YZ8+!*}Fe`OFcM{_sPeA6~I~)&^HcY
zQK<AUzm*ouhSLfZaj8;t{vreY?Nw-Q3cHxP%9kOiV=Pk=_N~W3yGbd3`4jMDPb<8o
z%lz@b{NWZYujL~napF^Nk;<C>wW3O)cD^D*P<f7<dBt^WJDtjeP;l17Kpby>%Y>F5
z-wT5_)Ixzt=*sFDQ|8r6p7B|F2x>u)@Od&!_{VbvOzW19#BBRPwoU)sY2dcKy}d=W
zuvLYCqEM-@oP&d=OzTGInO6&rk<|dErVl0LZ9g6#=(%UNERjl-dQ%1k4|S7jammI9
zWLiR_*T6$wUNkIm@ATf&>Q9v>{~-hY^C_Do0P?fREcT}BKOgV1H<A&PFwhnQJAWnM
zDDVoP#E1#685m-KJyb7Hdps$;fkU9$##LK;dlqodibzPH5f>MiueQ*b3JKAsHOk1%
z?cTBlxl5UT55@>LD7#Fu1!awVJM5b#txr_@sKhU_53{a1-g0Tg88+|`$bv>80poCn
zc%1qoZLiIhekXGeEvNYeh+$qWxLaensjR`K7RlZ9`Bb0!=>8IYWig*l!mrB7w*O>#
zdm&LWSuG0!XrLDR^@_Xp07iN%*3Ia0&>zIc)idKm4l0Y<-#9O2+Zq|mNeBpNfbO$X
z!iP<%NSzvVkeE150sn+ejEt@{Yt5`2O#8vt68Nnm`cyeu;a+te$`>jon6C~MA6D;x
z8xdSaf}TK((6Ud|PVO#qlh7YJ=KGK3%@F*x5m5BiJBj6A5l!|FFC}h@fX~@rdV&u!
z{+l0BB=>Vax(*f_>yJ+?Wj?+11kg9UjM+YC2qvK+_YTlbK7(-Z8eg9sty8V3be>$r
zl$Ukv%zM(Edod2PWL0<gcBxRE%*dqv$NDJ10KJexG4JNTw0gMjmZwYgY=GfuPk%pF
za`sDd^0z=5@Eg8pn3@w<C0gpIzBUgB#P;t61$24|VZaqCu<5BU$FEjlw6awW5}`7n
zKp)xW0r6PY7TUY*1u>Oclx??M&J+4ogT#9i{HiN2cB${nI8eWV1^Q-Un{0>CbsE-}
z-A-7@{nQ8j*AY4X5xi9<JJFjBf9^d5BhPk#1?qzd%ujo4wFaoOVn#AW3CHZ>2tj9d
zm(5BjXR#Ylv4Pc5H{h-GYY-hix%B~xpXQ5~Lkq0?Bbjhsn5Yyq@E<)OlwS~va%rfX
z7>57R9mpMld|Q-?uY4X-h8#*n8#BOzRPc01=vR>9c9B2q?%5~5_RsRSfBFpalz+dH
zbWgA3^^Wbqzh230NZXD6?+%MjqGt;V!@j6#B_*=JmdSMF8B+Nc7NMNnriFSOFf)Ln
zs<K$vVFP*uqf`KEPQ1$pJZ06tY~ce)4&<+q!{N5im9>WW4i<eu7Z<vwg^fOdYfyW#
z>X69p$&=zQ>-9!@e4KX3>7T`Q3(WIjNz5j!<j=yuE(eZ-)o8dS&b>YMp09GG01FVM
zFbD`t%$^D!UteE51z*QMvVB287;jTiF_Y94oX#c+Es4knJ&LSNbcEnMD!3`e@MK#m
ziHk+4qN<hAFD)peCAVZ>10`ZIc_w>8XGnWjr1}c(CDa0q$3N{<Z&Mu8*NI6++P}z=
z=_}RPw$VSe;i|E3S|{mwZGMR{X95E!QBG?SQL~Xu@usxYw~L}@J42{PAcfjVl!d}}
z!F8s3PmN14PD@wIk{0mZKg>=DMCL}}0OplqTgI;VNROFvYQU?@BTZ!wmRBrp-)l0K
z8tkks8fjs~bnE#e<_*&Fi{E3&6?^%<7ZKN-bdOzd=BjfG(KlD!zI2-Unfd}n-Ho#9
zkZOcsED4I|ciOHxT0sIm7o5WfF_9nRmJ<sEU9EOV>;1+<_`wD5i~Iy@_%DuQ44pax
z-HY}lpLZ4sJj5~3fBMmVv~vGLE)#mD$*oy3^&!*s@g7m{wnWEGf4SuVWSS8~oZ%Fw
z8-?G)1Rk2k+uw`$0;tRFheT{l(a#E9jpohFSDc*P(;mB%jlht?UbXIwip%{@|L6Ty
zrx#ScxbEr<S$9E!Sv<4e&yLRb1bRDD#XhF$Jw?<F(s*tRpDLtdfEMihAsm7^)LQcT
zATCq$Q<ix#?W<Z<+RPp=;>30R3psqpF=*rY>~eiW;)qJ5rf8?gr3l@r<{li4o9?Vk
zi)hOIIx$V@Dl@hEk4>)o_|yz^JoWFAw^WRm4AXwt9Z*oy&q;i7%^(tR6}+&}WK>hS
zC(GY7V%pgr_5Y-s7`irUY8mZ}k|6fwUIfAJ9<Y~_c~dCjU8?$4jY)eCQYWLPiz~4C
zV8gy&xD`iSt$+L)l+U<&b6M<`Vx_t_Qz4Dxeyqh6vpqLdGu`1oYPs$xZoI;+HFdSq
z+0kdLJXtF2;!rc_l5D0{{;{e+U4J@;o$|IyduquynSpSptU;cjx>3YiSjb?gldbIG
z(ejYDCI595r@PpY)L|oL#Be<;gfY&KO!<#k(Aaw@^}N(UHy=NK?8QX?DEM3?9QAFG
z=NDhuQDK_x`whyKfteZ?2MaWc9;rdsr7{-78_USV@asda0Ec$2i-IWZ-)*)w#|20W
z5s?wkjLjJI5V}GRxX@qJUwEbEhPFLK|IP~kj!wn98R-HB$$WJ}viWqG3ST)vBgWN~
zr70lut<*I4=HP+v$Io6xgK&))`e<rl=)h;s$sk2Mfe879AoQm<UP|A;n@e8pN=v*K
zaiRM22kX#LAI8uU*Y96jCbfWW9yt?}tVv)xA8_@hkG6cp0w8N~POtk|dbQ3$id}~|
ztCy$j)%<uLU@)Cg!0vR3T+jsE!IG+-9TPDrDf5V3)&RB_oVKbtr2%_0x7J6*7yjdW
zC$YlmGy?Bvc6&Lmd|OJw>?IWasBv4c-=UQG1{~CXM)Nsf;fKBKE-E7!M;mYZK9u5H
zz*3r|p;@BD`Svh2#!FP6qc*;8jdRmI4h^BcX>;!evGCBHXg1VC4&8mr^yMt3L$N<g
z{t|95_aV+6dTHPIHTt+A7SCbD@XUMG7h%oKPR~cf%rT|riGRIz)4V2~vs5-R(CL}j
zrg^oe4rAyMmy`dY4~N|d<4ej3DSf@smEnSrtmBpNRk)}Krdi73cj600F@u3`T)d<M
zY)eK?n}ag(xg`hjX?Sf@QyQkZzk)fuo15Xj;g4zMgQkD;iVxbP(F~76sPB|kDjfoG
z1wl9RmbJ-9hL-l}hR>UPd;7Ic7`lR3A6Yp~O$5uvN@V`~GyIG5pBL!lhjuGMZ-7I2
zhBF|DKbW%Ca84fQ8hFqL)!jC@iuqi}#+t)4m*m!+W8-=^MwU-rO5go#CbPeP<GAW`
zSkc)#RELN}N(jleXBgKs9{ZK>{gAV$sk+ncY6H>L&NUoF7fXz*(5LpOOB^2uE8o&=
z@7%S_pALk?)nlG6I`gNt5HKX27)92t?NI0J^`>pWB}RDc?TWrD9Tqp8)A@5TgH<>^
z1V181`UQEat>F>8t{cxn(?NeddGovNmq+`wXc7h*_*iL@k5(|#)Z^)^taIsBpC^)3
z(H*{|evY1rg6mgDM05~nRa3WE6&K^IK}8&0?bp4xSF%4^yGqTfOzG!^IK3G9-Wx^!
z=QjOgGt-B7Zov>7`aj-`jdl;afBp9c9}a|GU!=6c2S^%6B>|Dl8M_zMiVpWzN()44
zJ4(pUqAl|2*6?OQ%FrPiCP9=X1Za-|ZVjRmtmNa&-`{dj<_^a;%w77p;1a)ioq*o8
zeRae$d^r();~%m2y*)=bK-@CnRYHq2Lo2hqmRo#NaiRBelO8h3aFE+~IOp);*n&Oc
z7M8pK@eBl_m%7tfc&vvGVC(J@%9l7K-BrCEfo3;(95&l{zHZ^O)=fL``?`C|HUFee
z1e5ckKvnMxxFd_LVUp$T9v5Rlm#)y~lwT=J=n+W)QwbuD!;%}2l5yT@^Ee5~;H0{~
zk=UZG?mIP~^KYB2v{l(+^qVi>I9%7J2EQXW$rim>)k!1EnkHf8n?m{JE2S0hS^u!d
z9c!|%+T3hAOYmfCoZ;daS5ZS`c>qU4lL^|FEyJtb#nxXaDOz{=PyfMEZzs+kF^Y#w
z)%GG9iTf>5B)HG);2g%qvusqifOxPH5N7+>M|-i&EiG`V!#pHPSE3y)gr*nU*izbr
zM7tA*_S%!{tR@?Cd-#PMuM=8Y3kuA&XYUL=_Xqe^E{l{!IJVe+zr?#+B`|W^gf1y#
z+rKR=y&&1|dA#FEJ(ba;_uHWOua90T)Kf81?KyqmKaR71Y=>}9KR*~w&hf@~L35&h
zyMU`{5$78ji3tGhgx%D*xbEnmg3y72r&QW&ounI69~a|X&eo?Z>Bir&i-g1>Y<+#3
zf`~DMn1VBW>gD6G;EK1{mg3jb!hfQ_xkKTo8BUs;QSHCSa+^+eO~hkmgWm9_yHUll
z`Vi^+B_D+Hg9-!bhh9CrpbNAn%4lYvbjDHCM_7ZYqB7?FR<1M@Bp3{+qV)Y*`y0g9
ztb*x2yes@HG6(*>ZA9eIfwqD_&~>5P^~X6@@O~*53yQzzRnsGwu66WM6QMc^+NMDH
zje&*Yz*~)n>YjUnMXp%(&G3uNTW#`c>flqAz{q>LanWp9#)H<u3AIH@%SH8+utk)4
z@1P$)Bym<>pdK_<$HpwDHK-$a+#TaqnBu}RGn0>+wFg{!DdvB1A$(5wdjqHRh{&m*
zP!<(wKoQd2Jw;OeIVuT>$;i7@{(YU<iraXH+@)U@&WDcLrpBsNWv{8J1Ii6C(`ssv
zXRFZ+b>5E;5xyfXZe&LQY3b!<n5*{#pCcoLH3G+`0dhMt(ZU6b$a#&zi3s^%0Et1U
z`7KO=xq15TvRno}_o5TWo?5*KO>q2A+h)IE`-Xso)jJ|Fevb&h`fli@VRrPz^m;Oj
z7JeK$v!Qhk0l#WdhY7+5y-~tc?~vr1a6*sE54Bbp5rf15HaPO_v`knHJ}=0^{h;2C
z_)>4LRP%3k&~0g~td`yj#UUaWdZkM?__Vb$^7iIF6S3vjkBR*b3p1lk&O@Pj)W3p{
zj`)4y#uMc>sohr#_j1TF*>9f{dHWcbH2}R=VUs?3HWT79IodUT{~oKx`TDI&0ExF1
zq#s3gc2g#aKTj8bCtI<+lHiE|6*<fC3nVWL==A-1ugv^_aoD-k&;^=)T6{}k%7#l$
z_+7q@Y*B{B7(`L!X6kR5@+JY3rPfwn-4K!Kc8}uWscmgJOpI7gJ%*Ofi)ws=QHHD>
z>sj-`>hXyG3giEX>1h<0WGf;P?l%<<AhiGUdp+n|iyFi(B)EzyDn_HTScot@uE&_O
zpGxCKffL>G+FHAM(5>ygA`Lb$*9k0_^MXhB+K_5#n|z+6H*Tpur4%hJ^-ivlBiW4-
zN4n5abSsCh*KaUvAi7glF-mancI|i_CE~I;;I^5Id?Niykfr~9HGZm9fZwle<>g^f
zg*ZGf+@NcFeCWoM+fOIM!v|i<WL)-qxxK+z$G;@SnoD(+YH}VMi9_Aa=?pQEUT*}F
zoF+}W>NYx})thF-VINS%4ET@xG~2M3F5^r>%$A+&h+(?@j3G|R5PY>c4^eZpyD1x2
zz;ovnsl|z`c@$7#i6x&F_cju3&}Wfyo%*mBf%B+Uzh)5C@E6wbspb~fE>fw{nFYg8
z*VcQBlD7uHMw-F(_1VMulmLt+%1L^*j23)+ypy+aUrd-_dM=OT;X-|Kj1}ZN<cSG3
ztE(e{qy6f{IHMO@{83S)92RNIBSNg-2<&pi+Yn0cfA<+P*=~5mi&EQRO@74;XgS+{
z*+J>)jqKMJ>X-P2&KLgd_d7X!E{+3hNUF!ZZ8;&8V0sAwUl_GPn-_i>`OV(ROH*#<
zbtUaLfuVeU=RxWGKYo=<$|j<s&r}xcxA{DPYocy~vGGWBaZW#whkEG-AQZbnn{Mzi
zvacMhCK-vywPmR4t?U5V;Zi13+EN^~r;gwm#o@BmAdiTXIC+2SI4RSf-)EsP)JthM
zeD4e%V<l??gLl*)V`AIB)0^sa<-JSO)rB7L6{^5TQnvc`{*5K-QUj}aIkkvgvjVzk
zAa?gjz%?U0B<Lh9@_jCz@2SMx{jxwmbC~)v#nmTYsI<HHG6fbZw0rCdck^xW3g)Y^
z%tLn=TdLgD!jINSEEkfTpEG5VqAb1`!G#I_++BHWgkCgv7IG|RUM3ii!R$+O{PnUT
z)9NRU1o?RfY4{g?%;llJ?C|-$g<6Ak<#D%c>-RK&WUv3&;vkjv!ujASWLGf^Co@O+
zXMjjRg)lTU+?uatsU}l+hYA4!!KB}fzCyrhMF#BP-$}3nCs8!u0gL%j@z|qbgYpL?
zNQ?)9JfnT6e5F6p5Vx#t1TpS6rSp9*Z+B<zIW?jc<9r!N$rP61zw_Z-t;SyR2bm0s
zd7X~~C;`P4m7q%xLq@0(ySXcI2k&bHO@h;zX8EpyKE@c%xAF7_TWwbt*OWDQk}yfT
zUE*{wAA6^-V-0`GD=JiaijSGzKWx3PUT&uP$de8rm(8%U!J>L_YZMzn-bU$Dwq0vI
z^x2{9W${15rBxT6vtD^0ew%tqWs`wmmgsIq`07BD-k!ygBWF|3>LrI<d`vb!)=&@i
zv*^4}1ciAYD85n-$Hin{WUuZOT;NgIPgiU|11;k|Cc{Ao=XaRX_U-;EVv_yn^$5D(
z!qK&Un!Q$#OZUx5x$(u6(!K=>d6cfO{G}INKJz&#@-BA69NDS3j7i<}vWHq)q;3~G
zG+AT`=)1)lQaI&p_Z>wc@?0xt&#5hY+Bl7}MHlZQShg{ww4t!@=n}YKhsV6)xKV1t
zoGNoqJIQ8`LIdt?7%^(Msh@7-Vc61Cdqqz;{RbJy*%d@`G?R!MskgvyzpSwQ#EaYH
z8iO!|{3ENJG@x449u_P0=|{>~Zg+=;+eu>N73R3fnW63*8iP%nUBz4@&`PVkq%w_a
zM<T6klL~^&zDWkNS>+{n1IF{t9YxKq7wkW@<dC}5dEL_b$o7XgOWnpAwE~j*L|3{m
zi`x%mC|j}`^V7;yZcW=~2cN&V;fEL2e2|0R^wQxY;HjOdwU&5YXhPtPY9aUW-!;`A
zyD~(?lUJG*!!aS|FPVwhGvO~_Fny4V!ai^x3r|ULmw0CI`EwhfMWkm4xdmEDz-GS%
zziuQCJzp>NtZUMtjESI1dyV9U`Uwn;Ehf2b;;e#i!=MUDyLjMF-q=U8HXnB<d7Mq3
zXpIH(H~zcfIl0eedV;O?c5&0*XRVu^Ksx6K>MW8M#NXOVrkFc-=V$Sf5cEbmbUnyM
z*^67`d1$gz`cqn;glX%rVeANmHo&=*&qYN!x#HqFLpRDAWvB6Haw&{9RYrLF<!i$r
zTVwFAKbI<3nkh&Lo7}MsA%E#3a79O(|4dn#O6O=*chR(^($o(f8=G!?X6D!%%9_oF
z5j{g{>i+6j0-fZ5QL)k(6P}t{RbEw#lKmp8iAJS#6>V#g?^7N)W%>GwBYW%KEFRpY
z2HKohsB_9`e(I2t`$CTd`KcP)Z0k1}Ba2jCY%q=NI=Re2lb2^~+=r85V<)injzURL
zFCMPw=TEPKz45zD#|jyf1RB&9zn!}JU~|GbTMXavu5ja1YrjTyLNr~{&}>L=__^Ea
zrd6Nt%4x1-9RBAk>Ckk(4qv^)hZWP(?ghE&@Ak)Z&|P0v_v#RnVNqlIugqc_*q>_E
zf}0^aM_Z|aj}ui>8dfHUhw|4-hHnOcZq~(@(jrdiQeSgU^xBB=-UVB6Il~A$9+oao
z;dqdoz96ek!`tGwMnxi4fH2On7aUzdNu#5ULYp9S!sU4|v{jA%bTmzdlqUY?xd!nR
z#|1GdTONyR5E!Fk-v7IL_u3F!27c>0ma%zjrpii6ZNP|5a?!-xyzuOO+J+7ks<#d=
zrA!L)?d4%WFz$q9Y633=+bc+s7CQJEI~Vl5`y=fr8NW?-;gOjES&T<2ExE9W4;$|w
z>sNFLNtkpaT;f`63MJun3a#EpMiIF=L3lO>koqD!3g*Qcb{s4AOEtbuvN}Te&hh=^
z9kul{w=S{YVDAYp{%R%{SgFv@x6Edx#ot@F|6#F^dV>|}`ta)GI-x*+3^#sHT1m$U
z6&8`3aBJ_PoC*Db2CE9~4(h?LH;c(Cq)u<v6*G7lp@zp`{i&Iw`nRv~X1fN))8XKp
z@`{v#ZPpj5N>KdI(IZ1pJOpWGe>)%rEA_vO!o?K3dMg{wq3uY|3<Kv9th!Rv=L0jf
zywsM!#$y)`qo%GNRPvsuzOIss%h*L@c+bpG?b3~YmNshVKA2tMaDqUyXkC+RItQKu
z**`O!iU*D=moDE0iNAvH(f`42(qY+WES@8|uCfZUaySE9?_1AEG}=4Q6>3&L%-5_f
zeLGrcxUX5`P8O9*E;6T}hp<o1;}T@}J-khW$c1mh5)nNtu0qR~Bq64DF-Hkp+h>_d
zMbW7mDyvG@{5!44Y{GCEG@I0K`#U7|&{H21V$rP3Zin9cVdC@?hKKZLcG+FHQ2Vc<
zr=o>Y@xMI2PLq1DeZ?eyYlvG_tN3%-glKsJ{pZ;ynxut0u6i6VnJ<>`yKDsWka{&g
z3(fY(_d-Y7?6~YvUJ<d<8Le_Jd3zTcXatg5zrIV!5c&6>`p0%7hB$v5{|f&XlqgWp
z2V)DU)OmOjA~r;xcK{;3isYBEr6Wl(v1bh(>+9>#{QUe@U|6VUX66k@&^;l%9fFZ?
z83LuYrNIV9B3qu-d8IO2FQll${n~aS75jX~S;~NGiHMKt&P7SJP)<2BFKX5Vk!o-L
zs(qzM0awgiswZs|PL0YzHfG&+U;F6p*)uXQsO#;=0T$^!-wRBw*bbt}3u&h1h1B%C
z3iOkrB+tEa4<U>B=j6z+QzL@p`$v|`6IIpYZEQclsW1Z}7)Dr&8-}Q-spnuIS2W%k
zg&ZWnE$Is7%CkgKIHe*WVfw&?HAl-kVY#e_|LeKGd=^3*f~_;Z|AjM)oeeW|=u2D)
z?Oar+i0aC!swidaYX~TAB%L>|u2=1@Mc?1Q#o{rFs|*5(<0tmo^ok0|j?#j{kjHDP
z;_%1&_Vx)!(recf-XM(ipFvJc=nCd2jNP&^$888y95UjZ&xw8otXkV&`rjJ%;{?3f
zE;`gE5&qEKC{%ICfxK}+jOfROAAUAu9mqpKtDX_qKCM4Pee5j@0fVGVaDA4@<a%S;
zPbl)Dqdfc-Zs;BivXs0+*wVRd5|iVJB;HXAYl%XxM>Xc=utT+hH(jlj(AgDv6=Q!7
zRyp@!4XK{Ett65}pR)iduBCw9Se(wiU3ZhCN=<<oG1-qUEBFI@(rGRyD;H~B5*h+-
zY-%S<CM6stS&crALyofqBmO^2jXxm8;g9h1SC8I_y{JaSf2mHGgdsKRzJTE?6PDBI
zrfY!2B`Ej&v8(^aqVUHL=%b*pumCWdR1l27`axduO_NGC?d{j6LgXFU{w8jVH}Rm#
z^y`*EDuVgCZ;`yRoRtS?j=vc3VWL&fJ$98?l3<(U=7WgWb-<~G-aE0=Zg5T56|;w;
z1|BNCvW}<ogWgw5_Nm4|hI0|-_N=8Q|E-ZBG4}p6QMhIXA3vl%wthb6jh~HH7XeQ1
zVbG}I*afH4#FudfNoQ$zp~z~MR94!UX@kK~=hhG_o%S3njdm%4$v%bHu1%q>76h9}
zaVIX(QlI4f*f_sW`k}fwPzY1TujA)VnJZ!we=5*iw?FLc5Eyete@GV1Y><xaqEb^M
zRH;2dq5RCM!9*_oxd$~hgyQ<{W)=rG)+;9`ST@A;?8wT$p+VPefSe~*fOi6UA-y^?
zG>8CY#aCS{9p7Du;`F1B@XAVkoU8C$;0$4t+V(Mg*-2y0N^)hut71$}2pgMI1oWaJ
zA5jEb9L+voA427~dpEz|PaUnnF}CVGUi+W!Y4<b)FY_PmaNNkX&Iu`v8cdgcAy?;i
zZ&{9ec+Pw@AKUC1Ep;y-K(DVUWrfjfWw(Vxx7LK5HGifrJRzhZR$ugf4$suHEqo*C
z$dJ@I9>mdw5fvAPy!Cb;&N*&jcNj)7vx3TzhQI6tkSC>;B7|FIl%_r#kooiMso;bJ
zWATQ|4P`8r0ENN7U$Wh!WrI6T7ECB(f`*0lPE1T3CO`v?VBKXP_@_L}rUV}vhv}8)
z{n5Dg_fIOa$Ez@OCS4Lt*<4{AZ7!V|&Yuf~Jw`;+yId`?q-Sdl-hnIYDb9><6^qgn
zt{i-8LW1K&zd~=Fb-Q?L3r)4WMul(C<GgYpgbm<#S3e?3&rdcAcJtt^@GxQ*L3WG!
zl~;{3FuySP3uzWP72>Vi`?q^Z%(AMvYH8?fHrX*okZ56jW%4R`A#{{2-3Dz)m0Qri
z@ckoxHLt*w4A@~VVof4HrgK$s@skel%^$o$B>F90PFLK17eP^M^p(;iF2`?vUI=&z
zd9CW6wa9X0H#bw=It{q!j}Xa}tLus6`s`ctI|)4xAYTztD!MU6zjdl(8&3V^SaCw(
z<0G+f$dtiMd;KPAefNPMbIxdSWXz}NqteG`wp3?+#;38u=%;4s63=|@)f?~PaQ&vz
z$2@PfN9fv@67ewB^EXL-MVIao)p_j#x>^rKv6!DQTBNm7NOlhvt*MiikzX1)Mj1g)
zH`IfDUZZWi8}Y*Xg)d)avrO|$AQ*f>F)}=CiMJ*a{<*qjMeRRZQ+7mp;w#C5!O$)B
z{*(gd{B&OLOAF<28usZb`tUIW{5}^(QiHHv5xjsfA`8QAL49(k5ZKt52vinS76gfZ
z$(Ti2`r%oJAH4^@A=1bG<@?oN1sxqZwWpDtxUH6-0f}<2R5e`~38nL;Qhnm(iF|XG
zYaeC0*HbR-3_a~7xl!e`JZe$1><5W!v^iHbGO3ypJ2(&m83;N6-^&-wR(8JAd&a7%
zz`^g?2{=}4qcXHIf69QvdVA(>jbN5MkvXX5)ASX;-DA=nesju$&UaGq5c}Y}M(YU2
zN7{b>#zeHUxLSBry0{-~1kRg*B)?qR#bzE^lJxZQdn=b7s+Bm!N$4wJZ>Q4e1`SuZ
zA$=qK5K?#x;`-c$d+1Wb(oxuKG&TpnqZ1YIvvxs^9yTvQ2;7xKo_-`}I86_LZI6@*
z#R{feFgN=W?6jV2Zhp<KTugvNloX~MFxzVVLU{M^w;=yxVK=V6p;ZdT!_B=Y=h<9>
z8gm5`EXkS2aX)8?trbSYTM_$RBzGNi!IkwqHn<>KS;10+?SM~qHp0Dr3f^P@Fhjlx
zbr*q$TgAqLW#3{JeR)oL$(c0s2&YXt@a3>VnNtRHLh*yj?TD!rw|)L+g>>HC(@OQN
z=L7G#jPDK;Uc)m-S>1QaE1h5$Ap}vzG_d=Xv)PlMh039GX`e_jX3}w>pn6=EwOY@6
z&k8xFS}$XdNS*Zmn1N`Qq9C0^rlzWT^PK#VFK6b$K8i)+dRY4HU~9O1oGVXu2J>HF
zeUKD;&O9eu@txs&^NH!tL`Ay@dib_IoLso(H}I=PW>C*vN_3ik_8!s6$@R`wS$W^*
z*-K$rHgNst4{1t@5WiwCJWT_hx1k<ATN+)2F`=<wcr_fd+`@!25pAGtpnTcM5(H(T
zOe4k(=lB)j7b<bwCVWFM!qjt{O-`}dY9-d~My=vPul~q>TJ(A*Rh3U(9$_wN?HwE~
zgNpkU0QiTabuo5IKHBAu!?e^-nT4Wic2PKV9rTiO-t7oFX+Q=YG|S>lri?nF`;FRZ
z>4rHjmmt+-2U~Z3yoe8H1+SLWZEW8B$j;*{?cTL;aBuT%oyY2nwe(7L&%3=@p?RS9
z4Y=KXLs*gS0F8u%<g-#uL_7g^{(7-xnAm^xC(`eJiC=al6=oEy!SE)oD<a%HftGVF
z;T2}cnbth=6sJWcw*kM}{MIt71IWX8p&AcUJA~+RAHPf*j_YT(Ay~Uj6;ZZk7cb%l
zFN2)*J?}XsK!74oEtq$<t5<>zD;pu~wm2krf`<-+4ZBz@QLQ7SSk^YouXbPar98SR
zq>3V2s~3C9GUs2Wd^xZz8XTGMq2=)N_Ni}1r&;?vrMp?6=K3wQSjXX;zo)cM>#TIO
z7>Y;edIxEMFO+HeYnF%4u{H|#Lk7t!H(idEem*}vY}o%3_=))-c;DO{^TG2%>d#n$
z?gdK*fK4bcGlujs;H2DesO_i1tR>!J@9%KgRi)7%rGcK;&t*3#t%9p69L%v+pcx?1
zZj+&2_??3jg_Z{fQz6QBx1QMVj+RR2u^}LBt^E*Qhogf_J>C$J=`AOD74Bgr+l04a
z@R{D6_E7`<GQe>PAg99Z!xiyp0p!o_^kKg7z2<mty`RH)nK40cnZh$a0^O5cSKJ@>
z=k+S<2d~dS?X+Q5hq!U$ibJQ;f_g(=S>?N!#DBF6Meibv2MKuvHEFkdL6F4GJAah;
zc*E_mg^p@CxFz6gXJ3R#qvMe!pJj<Rm=craJ^YNYbtA3hnO`GJl=8TZIYC)CK^N&s
z##I`*ys=ypne)|Y?4kBW??QwlWaIm^@Qm!by2ZY3>8}C5EhYUJeBQSJC_VC~{ubtg
zlT+tnk19<}nH7$|2<G(g$Uuo84UgX?>I&g!l^@t+y9~zeZt)HMtb%d@cpDwRBGDGo
zi&Jao=nKrqO2*LPx2**@onf~Zq~FP*z9L;fHm0gBEsm#Y+$Sh|(fEq^Bb%bOx$33c
z;$-k6{zSNGdhLHyx(Y7^+rDOBh#2wxnK1~Kzg#{zKn3<#Q4hJ_2s_XTJb*aNe2LZ{
z_Iu9VovYLL6L2l7E#y@E)Yt5YpfLsj#HuUQ!)bc4<WE@YEgjft-k38}B{6OIwN5)9
zp{#cBnWl|p+WyGCAepsvRhyj_KaZ1(#y`4hZGaaEaZE5R&JV}+z!16#i_LoxFf>e?
z1i!=azPQiP_*smx#gJ%Iwf~@+TD~8VW3IYdzLujWIdB5A=nrmt88%<2%*p)42(6?{
zzBn^itXUL;EA^#e@2eH)*?<dc|D_A8-b7X-{_8ezi>9p<s20#&W9oP>{Nt`5Kb*va
z#5<Eme2lBsMOX)w^gu9=mE0Df3r8(|NI!;&*)I_J8h3a-v<;$1t;7Prlsib;-8vsD
zJ|6^KG=q0s(+@nUjhQSWms@DKkCXf6X?l+?=P18sXeEMM7kl27P$y}mpSG+xw|})F
zCd>`DH=)Xn>&i@&ik5^X&u)@&EmCIk5+E#Ncz{8Gn|doQT{fL1zA*GV$*0JD!I#ai
z#@{;&1`}#xQVV(f2m8C=|7gKhdwTw&$Mf<3FDTfsaLddLK2XWf){NmKf*{@YaDV$t
zxA9;rLR|ql-O>}x4?nuxL_020Us+-wpNidkdg@+kQp<NYVKa$6J5cK-t&y#Z3s-YJ
zg>f8S%kFwvOr#0B@{X{cA;Jsk$)A%O_DED6#9qxJMhtybE#&d<6O=*ejL3Ef?DaM)
zWbo_R<Vw`4PFGje3~X>9nC2uv`x)iDtURa|AR)_o<v>bF`k`A7KFoeiYqD(jP2AY&
zNaaJeeqVQYbc~PXs>Al^dm7Wvi*A?9QjtBsrISDT1O&{|dNsTZqFFaS-4H&>SiH*%
zaZ+FKU9nKFO-I6}co%N9k;_W&pB;a<u_-?z+bQq@whk3Pt6E&7E5&(t9XsWL{NzQ{
zdOq6lZ)|%+QFya4O^eZZ(UpKoN!hHtarz)xrChXIjmEoYT~pC}L`f<t-&O1KD$D}d
z-G*jJT+f9|K5MeFj+Ka}MndBx*d_edFvYRWW*!=3rde%4#X~h%_K~r2vlLC|q=jHO
zynV<n9*>;M`mM^8?)8~wXvp_;uE{GIsjGck3zuDW1iHw@<AmShdf~p_*5JP%t)9M^
z^yfWeO@D@7uQ}<K&Q93QFw&t~^y1G&$&nEeX+U)No>4}|JhpGz5-<sw%x77*mYM~$
z;n9;sQ<x^7wBS0+EnYS(xgTk|`}^0;p0Lt1gXb;6U7a8B5MSuz+zg{m*<5<)aWSHw
zR8q%X`ZFkOws&W3rp=xCEn|;KXwv_#m%e@G@8L#t;Cd>0WHBXL*2nVNYK!@lr53?v
zZ9Je<9flU!(U9+(iZf1~z%>HrjlZ!H((hp}Oz5`(Dql0g_iR0a-fgF(T7Bx(%O1Fw
z@s<gAND8Ta<;@T_<adEKu(9v_;p+Wq)>89|$)Te?vq(r1f_;&ucK|{d`+`n4++6GA
zjE`wfv9|P(=n_dn(EVuEM+@rH4Zc>9u!iuFiHYa#S1TIyJX0fLt)rumO^*-eM;9Bv
zP=JdcFEp&Pcw=-gjY_pe*hluLuQGB%&Q;t6qOo{532j3A*DbP3bBdSuw?l&FQX#Ca
zi56}vArrSPES|Wm+E91u+Z>+}8}7#-9F2Pp0S&4;%l!n||IYDdj8vyJru?Wy0?Aj{
z)roIIPL^q{J=#+ftK(x-Vj+iQSK3#ZRwOM;Z-*&T|JKNqm^PO{x8s8YLU=~Txn3vo
zdK>xb+$>M0dUQ;GIH!%^bI%tDe}JQLXu^SU5%vW)NrhVXuF3J2-#DiBe5xAZ5O(d(
zF9NI?`(d!8;}Ra`kBG4}6&~HcwuN7EkObJf`EL=u$h%F3%(-;uLIfRC4MRd(X5Fpq
zZ??C~LzXH2_gX`q<Cq>L#S__wwJTP$<mBoB-A+awe7Z3Qe;)XMus71)VGhTLRT~ji
zIQ<1*nCFH>MMc#%Hy=PT`t@+c=Xj(&m|Yy6kbnrBu*OtF*1$*ycwBZtj%Btz*|)a*
zPMbja(i<EFXiaG_=(%zy2iNr2d!B5JKS%7{-4}##bajbT=B9`rD$7cIL(!U{_Nf|B
zqy4yKGv&RrD(R=|91$H9aAtcmq>)$gC!lz>)L>rIw3PPR$g4KRAdm{h8zKo<<VN(1
zbT_&tmG>YOPQNYni)Mp9$EQ$dQ^b~4ZRu=?fmNzPv_kwAbwPF^A<&E3uMZcIK|CcF
zcZXKvKiT*-6t4b>coel+#(9cOVMan|b%cnqfq5He6Sh=E^l9lHkLsHd&%wKv-S?5T
zys3l>TEgeI+c|tp7W0DCAN?B}>FKoi3Cqe)<EOBn`L*FBC1K64T!$2)bZOSxqhjI4
zBCK(7&zgqR8;?O;xIiXOcU0VMsyiOW*B#<Z^eHhJ`w|vB6dnt?>8OOdnZ~v(_poFU
zJ6^%G?&e<zDjL+HSG7mnH~Ep^o9&(XHHOzA;>(Hn?;qA2zFo-!?QK;Z{wS<<@3tOn
z-a8+>zPcgYQir`816`$Ei`IrUZ6W5iMg=W@7ZMMIJQbsFx*O>kWd+bl^Nr8=M7uHl
zZDwk3kZQ$yACH@501@Q3{0v70O2gx>b$6d6_QluRN<~hw^K5;SI8TSEo#N@)@l;G{
zixeii19^qIU2~t+n9ZhnvWb^dT}zKj=*DC+`g#NWbNfWe6>%Su`(H=e9ivD6&JyOv
zlv*AlvX#J#(Q~<D$9t~0`5mU+{&fMiY!MAdb>Xn{pXb{j0B8$6Mav`FQ4Fe-&+|XN
z@lQSxD;5Njy;ZIZt5-%4P;8b$CGPouLLC5%IzdeGG#bfGCEYcgj%dO<Ps`N<R|E8Q
z&6~tTf_I2`Htju(>NS~;tM4&`m}OtD;Jd*&R_+&4B;<aEEA$w2f%nBU!=x&$D20Pd
zML)7wLYseCZ}OEgXso#9n4)-#c)xh)v(Z-?t7bf1sLOA+xMRNyC2GSdGc-;aN?h%j
zuyQm;3s!sc%3gGHHu;oq)5h(dj#Q_1mSqO6jLA$HOC7GQp*A%gEbr}+eI-0vcI`sF
zUzDkUy`GX)Riy}|=x`=dh{e-eYEmfC@A+IBFMdhtF$AYr`N`<G`}J5uOdRVK3j1u;
zs>0QN;&sv{0udtG)`BY}bgB2x3<Ng`!D19nC95w~t%-iwMyqE{^j6DL(KmIbGt81m
zh=dK0?PRa>G66oqQ*ghf*exzKz7y<UlUaH+)S9eLjEHW<iz`Da%_>)z=Y6H%VQqen
zZU0z;=YH!<a+@S4pr>JuX8x(LuV5^OzyTJgne#c#hu~UgiHjM3-RD@5(>%4TNF&e|
zN2801R_FZ|<ycaIXhypR54JkmTV$m{|9PtX!T<z`V7Idh>pxGGw4azQ!vqOnVx(Sp
zTpWC~^QunY+!|@e+UlzI@7`#u>k|Vf?B8IA7?DHgvHD_a-hcM=t2Aa<cqg)DzVcok
z#l=NUIgf_k7Yd0ILC9yP_l<_sE5fFpMB4`@qQ?u0ZvJ{L5UiA|Jm98QL*W-`*6jy)
zL!(P}U8XNwNn6<PK3EerduEJtW<tWA;aPt^_s||vYeykTQ^e8qA!bAy#`xAf<>`%z
zrIn=h$V|19tF+?*g?GL0=7804r~+XyLp|!uY$j%GUskfT&xoc!mMcuJot$oHf;uER
zI553Z+)!BRsv1A4f|-0iF)?eIWVz&y^?B$4_QQuWf#!^iH;xb2jM|&hi?`yc@dt;*
z*Xyr?lHM5bum3)Vo6sd(FEg7tWO6w8Frt4#oUBkV8%I@%hE(BYu`hYLPG&DpZTXGj
zLir6NO5Laz3a$2H2M=JoWQ+(uo~#OSmYQPHIql172*1^l_9y%Bn*QUVf}!x|jw7P{
zO@1WPjpnrCui65bw{WkLxbnal#X;lP!8R(Hd8z_Ai>dzNBo@pEm52Yc&U+seZpc-h
znSFu(Q|dz73+pa@mh36jV2J#8EaZeo2lJOLipySUsR9SK_}BcdFnjZ(ZeoVmyQ7tD
ztUElP|7-hx>|4X-jnPZbE9EgnGCto~^GIM##dpn_Q#bK?DlFGw=UXZ_Wm(ONzbYGY
zLZ6$u8U?i>4Ko2Nr7Z?bYn7C5OH7-w-9TYWEIi#DFkoD|=~4mns$2u6Z{NN>c=?jE
zudlBm(NTo!S<?1BGQj(z6zuKgySlns1mt+PEl9Ju2uxzFcNOmg&*C+|Ik&C7ojZGV
z+PWQvSG<FLo^5b@lBW0C<Xg|h-%ek&>l=ad&R4!vZ528d<nK`GX?6v;4Ch;%*ynwl
zJXYnu=n<_>zGJ$Dd53EWi}tgdjQll$ECI8ovasqLVKttyN9B2gM*&|~Qk*tZqzA8>
zKw^GPvPaLP9u_gZ$9o(PHmn1#DFQAhEBM4KY?H{5JLC1gAhB1ARVMe&ELs@%`tU!#
zdj}t!J66J($34xgEMVSzMpn*r#qUXf_wr?|o%vS$xc>RQT-PIis2Se<I=?q)g@A|~
zaD>cxjZszpDd3`-N3%VeflX!LfkO`k1O*v1HUZmw&CTrRjRKRS_J-{!e9Tl(SSavo
z%JlF<f4`p>`}897(YoEcoHADE|F&H)skfF-FV1J>^&7K#BezId>@;MP5h;CtTV;vX
z!+GkDOlO;B-PE^{iYkA{DsgDhG|t5VEE6ZsV(|PwN1#P;nI4~WoXd9^hB(KE4}i^_
ziWU8GGDeg27^{L#c&*$2L*#ho-KFLgzuFD-#r_4v#i+ErK43Wc-28?`*^$fi{4>(C
z*EgJ4SF5P9Z1aY5pC&n-IPKB8e|x@wQ{$Cv1KD1~nD(t}W!3jNZ1b<(<d(I!^yhJ>
z6Cx)QR35*2t8X*^LRl=UzhdZA(Fv2MDR3AEY;aupk#ooG-G?Vlyzkl6ncuJ9Hut0N
z_wRR(sk><_Fd?;fGWuAKh#P(IJJk8?M@yzZOeRm6QONI(+YXbG$*RC^arF0$Gp-X7
zfQjVkNsHq=%@5f3U%LI}(sO3V&?yVI&(k_H|3HW8@`I<=y*nUloB5_TeaX-KRjltE
z<`+CFTPR_DMpSH{kOHs$$EPY5b$;8;IaUg$&f;y{Enm&pX7{IO%lxJ5?b)XHueKHO
z5S?O}%{1BCj_dI)JB2q3V?x=2&Fpwgw_Z)#s~%+oA8vC14Y;h}XWUuP<Wzd4U1lrV
z+DxE7W=J+Z+A(*+r^h8L&LrIvELmDrQF7tx+#KK84h8!+PRd{kkD760Pep(dlbXPf
z(sacm%MIRhU%lR%{U%`Rb1C6n!NSJs7wX?UzQp%|zw<?HbI@ny4G#}hozOeYCgPjG
zRmv;+?h8MvgEBf<)<iv8mU$i)jPN0b#%V4Ko}8*XuzKoL-5XUc8!yP}B_u9xhzez0
z(PbPh)RngNdgJ?Cfp5jBw~IXf&)yk+UEtu4GAWL^^40OTK7W0^wcy`#|0PDL9Sw#|
z-~IBV9$NOSo&Ks<IOBG;fX$z8N*&gl__wY9!Lu&b_mNfNi%G!MQ;lmEo%7}mJ0^Qq
zy+!JwRM5gmffZ}kwJfi%UljSK)yxqwWCdzy<V|A$j(|^7_=;GD4|Dts&c@eQy;hvr
zm!Y<LX{wZR!uxmJW$W%;D842h5WTi(Q+6gO|BHoPd+<b@k;}hy2CIyA-ES`7<f*ju
zv{#_o>ljOn?cW2(uE_z{-uUkT)}jk7^x3_*iVj{q&3~tc>A)qgzt0cdnkDrk^Wo~V
zGdOa4QHwzVMx_9EhrjlUN=~SbhPzO;(Q2cMg|JV{>zMj)JMAAH(*J)o(%lW{uP8mn
zYWMU5r`4Bi6>E`FI}!E$<m-UIpe3R1Z1Ca~Jb4IAQ4YnRA)sg9Tr%x3B9Kw(f)YnU
zMc)Iv#RqO3bbVj9TKn{aACtlrKR?mio4exBAC4<muFSf>DD$XqlY`qMSB*0#8N{E(
zE&`rFS9N^~u>CM?zbWsjZtkz!7II;+SP5kD7n4kVY!)YR%!xG?|FEgFh<*Eqz5wxE
zhuK$6O%0e)GcWdk!>T<?j(*5^Ctdq`?a~L29%<wlo0_iPnLqto`D_lA`Sy&T)xM@L
z;^gjlQN#YDZJVG|iN>551>>JaDsz8JUs@m2@cO#voZ{JXjJ)1xVe23a%K2))5;7vO
zILd*=M{$A9$#&qLh-D^A&C+}x9BNH5j<eO>yHe00(FM5rzh(8xwY}HS_Iv<iEQ5zh
ztk+QUtS6d%h?VoesKCl;T;>2A74Utic|i)h0^}AmFwr2H)99uM^o-j<zsW)<;zV$K
z8-Y1v)}i19rl>{|p|#fu=-%F@xoViD69KbkF*W{Y?(8Ty6_`F@9Rm<}y85}Sb4q9e
E0OMvXk^lez

literal 0
HcmV?d00001

diff --git a/synced/convex/docs/auth.md b/synced/convex/docs/auth.md
new file mode 100644
index 0000000..5b7a813
--- /dev/null
+++ b/synced/convex/docs/auth.md
@@ -0,0 +1,110 @@
+---
+title: Authentication
+sidebar_position: 30
+description: Add authentication to your Convex app.
+hide_table_of_contents: true
+pagination_prev: file-storage
+---
+
+Authentication allows you to identify users and restrict what data they can see
+and edit.
+
+Convex is compatible with most authentication providers because it uses OpenID
+Connect (based on OAuth) ID tokens in the form of JWTs to authenticate WebSocket
+connections or RPCs. These JWTs can be provided by any service implementing the
+appropriate OAuth endpoints to verify them, including your own Convex backend.
+
+## Third-party authentication platforms
+
+Leveraging a Convex integration with a third-party auth provider provides the
+most comprehensive authentication solutions. Integrating another service
+provides a ton of functionality like passkeys, two-factor auth, spam protection,
+and more on top of the authentication basics.
+
+- [Clerk](/auth/clerk.mdx) is newer and has better Next.js and React Native
+  support
+- [Auth0](/auth/auth0.mdx) is more established with more bells and whistles
+- [Custom Auth Integration](/auth/advanced/custom-auth.mdx) allow any OpenID
+  Connect-compatible identity provider to be used for authentication
+
+After you integrate one of these, learn more about accessing authentication
+information in [Functions](/auth/functions-auth.mdx) and storing user
+information in the [Database](/auth/database-auth.mdx).
+
+## Convex Auth
+
+For client-side React and React Native mobile apps you can implement auth
+directly in Convex with the [Convex Auth](/auth/convex-auth.mdx) library. This
+[npm package](https://github.com/get-convex/convex-auth) runs on your Convex
+deployment and helps you build a custom sign-up/sign-in flow via social identity
+providers, one-time email or SMS access codes, or via passwords.
+
+Convex Auth is in beta (it isn't complete and may change in
+backward-incompatible ways) and doesn't provide as many features as third party
+auth integrations. Since it doesn't require signing up for another service it's
+the quickest way to get auth up and running.
+
+<BetaAdmonition feature="Convex Auth" verb="is" />
+
+Support for Next.js is under active development. If you'd like to help test this
+experimental support please [give it a try](https://labs.convex.dev/auth)!
+
+## Debugging
+
+If you run into issues consult the [Debugging](/auth/debug.mdx) guide.
+
+## Service Authentication
+
+Servers you control or third party services can call Convex functions but may
+not be able to obtain OpenID JWTs and often do not represent the actions of a
+specific user.
+
+Say you're running some inference on a [Modal](https://modal.com/) server
+written in Python. When that server subscribes to a Convex query it doesn't do
+so with credentials of a particular end-user, rather it's looking for relevant
+tasks for any users that need that inference task, say summarizing and
+translating a conversation, completed.
+
+To provide access to Convex queries, mutations, and actions to an external
+service you can write public functions accessible to the internet that check a
+shared secret, for example from an environment variable, before doing anything
+else.
+
+## Authorization
+
+Convex enables a traditional three tier application structure. You have your
+client/UI for your app, and a backend server that handles user requests, and a
+database that the backend queries. This architecture let's you check every
+public request against any authorization rules you can define in code.
+
+Thus Convex does not need an opinionated authorization framework like RLS, which
+is required in client oriented databases like Firebase or Supabase. This
+flexibility lets you build and use an
+[authorization framework](https://en.wikipedia.org/wiki/Authorization) for your
+needs.
+
+That said, the most common way is to simply write code that checks if the user
+is logged in and if they are allowed to do the requested action at the beginning
+of your public function.
+
+For example, the following function enforces that only the currently
+authenticated user can remove their own user image:
+
+```typescript
+export const removeUserImage = mutation({
+  args: {},
+  handler: async (ctx) => {
+    // highlight-next-line
+    const userId = await getAuthUserId(ctx);
+    // highlight-next-line
+    if (!userId) {
+      // highlight-next-line
+      return;
+      // highlight-next-line
+    }
+    ctx.db.patch(userId, { imageId: undefined, image: undefined });
+  },
+});
+```
+
+<StackPosts query="authentication" />
diff --git a/synced/convex/docs/auth/_under_the_hood.md b/synced/convex/docs/auth/_under_the_hood.md
new file mode 100644
index 0000000..668e448
--- /dev/null
+++ b/synced/convex/docs/auth/_under_the_hood.md
@@ -0,0 +1,20 @@
+The authentication flow looks like this under the hood:
+
+1. The user clicks a login button
+2. The user is redirected to a page where they log in via whatever method you
+   configure in {props.provider}
+3. After a successful login {props.provider} redirects back to your page, or a
+   different page which you configure via {props.configProp}.
+4. The {props.providerProvider} now knows that the user is authenticated.
+5. The {props.integrationProvider} fetches an auth token from {props.provider}.
+6. The `ConvexReactClient` passes this token down to your Convex backend to
+   validate
+7. Your Convex backend retrieves the public key from {props.provider} to check
+   that the token's signature is valid.
+8. The `ConvexReactClient` is notified of successful authentication, and
+   {props.integrationProvider} now knows that the user is authenticated with
+   Convex. `useConvexAuth` returns `isAuthenticated: true` and the
+   `Authenticated` component renders its children.
+
+{props.integrationProvider} takes care of refetching the token when needed to
+make sure the user stays authenticated with your backend.
diff --git a/synced/convex/docs/auth/advanced/_category_.json b/synced/convex/docs/auth/advanced/_category_.json
new file mode 100644
index 0000000..6caf43c
--- /dev/null
+++ b/synced/convex/docs/auth/advanced/_category_.json
@@ -0,0 +1,4 @@
+{
+  "label": "Advanced",
+  "position": 1000
+}
diff --git a/synced/convex/docs/auth/advanced/custom-auth.md b/synced/convex/docs/auth/advanced/custom-auth.md
new file mode 100644
index 0000000..f22a2fd
--- /dev/null
+++ b/synced/convex/docs/auth/advanced/custom-auth.md
@@ -0,0 +1,138 @@
+---
+title: "Custom OIDC Provider"
+sidebar_label: "Custom OIDC Provider"
+sidebar_position: 3
+---
+
+**Note: This is an advanced feature!** We recommend sticking with the
+[supported third-party authentication providers](/auth.mdx).
+
+Convex can be integrated with any identity provider supporting the
+[OpenID Connect](https://openid.net/connect/) protocol. At minimum this means
+that the provider can issue
+[ID tokens](https://openid.net/specs/openid-connect-core-1_0.html#IDToken) and
+exposes the corresponding
+[JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets).
+The ID token is passed from the client to your Convex backend which ensures that
+the token is valid and enables you to query the user information embedded in the
+token, as described in [Auth in Functions](/auth/functions-auth.mdx).
+
+## Server-side integration
+
+Just like with [Clerk](/auth/clerk.mdx) and [Auth0](/auth/auth0.mdx), the
+backend needs to be aware of the domain of the Issuer and your application's
+specific applicationID for a given identity provider.
+
+Add these to your `convex/auth.config.js` file:
+
+```js noDialect title="convex/auth.config.js"
+export default {
+  providers: [
+    {
+      domain: "https://your.issuer.url.com",
+      applicationID: "your-application-id",
+    },
+  ],
+};
+```
+
+The `applicationID` property must exactly match the `aud` field of your JWT and
+the `domain` property must exactly match the `iss` field of the JWT. Use a tool
+like [jwt.io](https://jwt.io/) to view an JWT and confirm these fields match
+exactly.
+
+If multiple providers are provided, the first one fulfilling the above criteria
+will be used.
+
+If you're not able to obtain tokens with an `aud` field, you'll need to instead
+configure a [Custom JWT](/auth/advanced/custom-jwt.mdx). If you're not sure if
+your token is an OIDC ID token, check
+[the spec](https://openid.net/specs/openid-connect-core-1_0-final.html#rfc.section.2)
+for a list of all required fields.
+
+OIDC requires the routes `${domain}/.well-known/jwks.json` and
+`${domain}/.well-known/openid-configuration`. `domain` may include a path like
+`https://your.issuer.url.com/api/auth`. This isn't common for third party auth
+providers but may be useful if you're implementing OIDC on your own server.
+
+## Client-side integration
+
+### Integrating a new identity provider
+
+The [`ConvexProviderWithAuth`](/api/modules/react#convexproviderwithauth)
+component provides a convenient abstraction for building an auth integration
+similar to the ones Convex provides for [Clerk](/auth/clerk.mdx) and
+[Auth0](/auth/auth0.mdx).
+
+In the following example we build an integration with an imaginary "ProviderX",
+whose React integration includes `AuthProviderXReactProvider` and
+`useProviderXAuth` hook.
+
+First we replace `ConvexProvider` with `AuthProviderXReactProvider` wrapping
+`ConvexProviderWithAuth` at the root of our app:
+
+```jsx title="src/index.js"
+import { AuthProviderXReactProvider } from "providerX";
+import { ConvexProviderWithAuth } from "convex/react";
+
+root.render(
+  <StrictMode>
+    <AuthProviderXReactProvider>
+      <ConvexProviderWithAuth client={convex} useAuth={useAuthFromProviderX}>
+        <App />
+      </ConvexProviderWithAuth>
+    </AuthProviderXReactProvider>
+  </StrictMode>,
+);
+```
+
+All we really need is to implement the `useAuthFromProviderX` hook which gets
+passed to the `ConvexProviderWithAuth` component.
+
+This `useAuthFromProviderX` hook provides a translation between the auth
+provider API and the [`ConvexReactClient`](/api/classes/react.ConvexReactClient)
+API, which is ultimately responsible for making sure that the ID token is passed
+down to your Convex backend.
+
+```jsx title="src/ConvexProviderWithProviderX.js"
+function useAuthFromProviderX() {
+  const { isLoading, isAuthenticated, getToken } = useProviderXAuth();
+  const fetchAccessToken = useCallback(
+    async ({ forceRefreshToken }) => {
+      // Here you can do whatever transformation to get the ID Token
+      // or null
+      // Make sure to fetch a new token when `forceRefreshToken` is true
+      return await getToken({ ignoreCache: forceRefreshToken });
+    },
+    // If `getToken` isn't correctly memoized
+    // remove it from this dependency array
+    [getToken],
+  );
+  return useMemo(
+    () => ({
+      // Whether the auth provider is in a loading state
+      isLoading: isLoading,
+      // Whether the auth provider has the user signed in
+      isAuthenticated: isAuthenticated ?? false,
+      // The async function to fetch the ID token
+      fetchAccessToken,
+    }),
+    [isLoading, isAuthenticated, fetchAccessToken],
+  );
+}
+```
+
+### Using the new provider
+
+If you successfully follow the steps above you can now use the standard Convex
+utilities for checking the authentication state: the
+[`useConvexAuth()`](/api/modules/react#useconvexauth) hook and the
+[`Authenticated`](/api/modules/react#authenticated),
+[`Unauthenticated`](/api/modules/react#authenticated) and
+[`AuthLoading`](/api/modules/react#authloading) helper components.
+
+### Debugging
+
+See [Debugging Authentication](/auth/debug.mdx).
+
+<StackPosts query="authentication" />
diff --git a/synced/convex/docs/auth/advanced/custom-jwt.md b/synced/convex/docs/auth/advanced/custom-jwt.md
new file mode 100644
index 0000000..3115a5d
--- /dev/null
+++ b/synced/convex/docs/auth/advanced/custom-jwt.md
@@ -0,0 +1,82 @@
+---
+title: "Custom JWT Provider"
+sidebar_label: "Custom JWT Provider"
+sidebar_position: 4
+---
+
+**Note: This is an advanced feature!** We recommend sticking with the
+[supported third-party authentication providers](/auth.mdx).
+
+If your custom auth provider implements the OIDC protocol it's easiest to
+configure a [Custom OIDC Provider](/auth/advanced/custom-auth). However some
+auth providers only issue JWTs and don't participate in the full OIDC protocol.
+For example, [OpenAuth](https://openauth.js.org/) implements the OAuth 2.0 spec
+but not OIDC, so to use it with Convex you'll need to set it up as a Custom JWT
+provider.
+
+## Server-side integration
+
+Use `type: "customJwt"` to configure a Custom JWT auth provider:
+
+```js noDialect title="convex/auth.config.js"
+export default {
+  providers: [
+    {
+      type: "customJwt",
+      applicationID: "your-application-id",
+      issuer: "https://your.issuer.url.com",
+      jwks: "https://your.issuer.url.com/.well-known/jwks.json",
+      algorithm: "RS256",
+    },
+  ],
+};
+```
+
+- `applicationID` (optional): If provided, Convex will verify that JWTs have
+  this value in the `aud` claim.
+- `issuer`: The issuer URL of the JWT.
+- `jwks`: The URL for fetching the JWKS (JSON Web Key Set) from the auth
+  provider.
+- `algorithm`: The algorithm used to sign the JWT. Only RS256 and ES256 are
+  currently supported. See
+  [RFC 7518](https://datatracker.ietf.org/doc/html/rfc7518#section-3.1) for more
+  details.
+
+The `issuer` property must exactly match the `iss` field of the JWT used and if
+specified the `applicationID` property must exactly match the `aud` field. If
+your JWT doesn't match, use a tool like [jwt.io](https://jwt.io/) to view an JWT
+and confirm these fields match exactly.
+
+When adding a custom JWT provider it is your responsibility to ensure the fields
+uniquely identify a user; for example, if the `iss` field and `issuer` property
+do not uniquely identify your app, it's important to use the `applicationID`
+field as well to require the `aud` field to match.
+
+### Custom claims
+
+In addition to top-level fields like `subject`, `issuer`, and `tokenIdentifier`,
+subfields of the nested fields of the JWT will be accessible in the auth data
+returned from `const authInfo = await ctx.auth.getUserIdentity()` like
+`authInfo["properties.id"]` and `authInfo["properties.favoriteColor"]` for a JWT
+structured like this:
+
+```json
+{
+  "properties": {
+    "id": "123",
+    "favoriteColor": "red"
+  },
+  "iss": "http://localhost:3000",
+  "sub": "user:8fa2be73c2229e85",
+  "exp": 1750968478
+}
+```
+
+## Client-side integration
+
+Your user's browser needs a way to obtain an initial JWT and to request updated
+JWTs, ideally before the previous one expires.
+
+See the instructions for
+[Custom OIDC Providers](/auth/advanced/custom-auth#client-side-integration) for
+how to do this.
diff --git a/synced/convex/docs/auth/auth0.md b/synced/convex/docs/auth/auth0.md
new file mode 100644
index 0000000..0fb3afe
--- /dev/null
+++ b/synced/convex/docs/auth/auth0.md
@@ -0,0 +1,389 @@
+---
+title: "Convex & Auth0"
+sidebar_label: "Auth0"
+sidebar_position: 20
+---
+
+
+
+
+
+
+
+[Auth0](https://auth0.com) is an authentication platform providing login via
+passwords, social identity providers, one-time email or SMS access codes,
+multi-factor authentication, and single sign on and basic user management.
+
+**Example:**
+[Convex Authentication with Auth0](https://github.com/get-convex/convex-demos/tree/main/users-and-auth)
+
+If you're using Next.js see the
+[Next.js setup guide](https://docs.convex.dev/client/react/nextjs).
+
+## Get started
+
+This guide assumes you already have a working React app with Convex. If not
+follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:
+
+<StepByStep>
+  <Step title="Follow the Auth0 React quickstart">
+    Follow the [Auth0 React Quickstart](https://auth0.com/docs/quickstart/spa/react/interactive).
+
+    Sign up for a free Auth0 account.
+
+    Configure your application, using `http://localhost:3000, http://localhost:5173` for Callback
+    and Logout URLs and Allowed Web Origins.
+
+    Come back when you finish the _Install the Auth0 React SDK_ step.
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/auth0-signup.png" alt="Sign up to Auth0" width={300} />
+    </p>
+
+  </Step>
+  <Step title="Create the auth config">
+    In the `convex` folder create a new file <JSDialectFileName name="auth.config.ts" /> with
+    the server-side configuration for validating access tokens.
+
+    Paste in the `domain` and `clientId` values shown in
+    _Install the Auth0 React SDK_ step of the Auth0 quickstart or
+    in your Auth0 application's Settings dashboard.
+
+    ```ts title="convex/auth.config.ts"
+    export default {
+      providers: [
+        {
+          domain: "your-domain.us.auth0.com",
+          applicationID: "yourclientid",
+        },
+      ]
+    };
+    ```
+
+  </Step>
+  <Step title="Deploy your changes">
+    Run `npx convex dev` to automatically sync your configuration to your backend.
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+  <Step title="Configure ConvexProviderWithAuth0">
+    Now replace your `ConvexProvider` with an `Auth0Provider` wrapping `ConvexProviderWithAuth0`.
+    Add the `domain` and `clientId` as props to the `Auth0Provider`.
+
+    Paste in the `domain` and `clientId` values shown in
+    _Install the Auth0 React SDK_ step of the Auth0 quickstart or
+    in your Auth0 application's Settings dashboard as props to `Auth0Provider`.
+
+    <TSAndJSSnippet
+      title="src/main.tsx"
+      sourceTS={ConfigTS}
+      sourceJS={ConfigJS}
+      highlightPatterns={[
+        "Auth0Provider",
+        "ConvexProviderWithAuth0",
+        "domain=",
+        "clientId=",
+        "authorizationParams=",
+          "redirect_uri: ",
+        "}}",
+        "useRefreshTokens=",
+        "cacheLocation=",
+        "  >",
+      ]}
+    />
+
+  </Step>
+</StepByStep>
+
+## Login and logout flows
+
+Now that you have everything set up, you can use the
+[`useAuth0()`](https://auth0.github.io/auth0-react/functions/useAuth0.html) hook
+to create login and logout buttons for your app.
+
+The login button will redirect the user to the Auth0 universal login page. For
+details see
+[Add Login to Your Application](https://auth0.com/docs/quickstart/spa/react/interactive#add-login-to-your-application)
+in the Auth0 React Quickstart.
+
+```tsx title="src/login.ts"
+import { useAuth0 } from "@auth0/auth0-react";
+
+export default function LoginButton() {
+  const { loginWithRedirect } = useAuth0();
+  return <button onClick={loginWithRedirect}>Log in</button>;
+}
+```
+
+The logout button will redirect the user to the Auth0 logout endpoint. For
+details see
+[Add Logout to your Application](https://auth0.com/docs/quickstart/spa/react/interactive#add-logout-to-your-application)
+in the Auth0 React Quickstart.
+
+
+```tsx
+import { useAuth0 } from "@auth0/auth0-react";
+
+export default function LogoutButton() {
+  const { logout } = useAuth0();
+  return (
+    <button
+      onClick={() =>
+        logout({ logoutParams: { returnTo: window.location.origin } })
+      }
+    >
+      Log out
+    </button>
+  );
+}
+```
+
+```tsx
+import { useAuth0 } from "@auth0/auth0-react";
+
+export default function LogoutButton() {
+  const { logout } = useAuth0();
+  return (
+    <button
+      onClick={() =>
+        logout({ logoutParams: { returnTo: window.location.origin } })
+      }
+    >
+      Log out
+    </button>
+  );
+}
+```
+
+
+## Logged-in and logged-out views
+
+Use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
+the `useAuth0` hook when you need to check whether the user is logged in or not.
+The `useConvex` hook makes sure that the browser has fetched the auth token
+needed to make authenticated requests to your Convex backend:
+
+```tsx title="src/App.ts"
+import { useConvexAuth } from "convex/react";
+
+function App() {
+  const { isLoading, isAuthenticated } = useConvexAuth();
+
+  return (
+    <div className="App">
+      {isAuthenticated ? "Logged in" : "Logged out or still loading"}
+    </div>
+  );
+}
+```
+
+You can also use the `Authenticated`, `Unauthenticated` and `AuthLoading` helper
+components which use the `useConvexAuth` hook under the hood:
+
+```tsx title="src/App.ts"
+import { Authenticated, Unauthenticated, AuthLoading } from "convex/react";
+
+function App() {
+  return (
+    <div className="App">
+      <Authenticated>Logged in</Authenticated>
+      <Unauthenticated>Logged out</Unauthenticated>
+      <AuthLoading>Still loading</AuthLoading>
+    </div>
+  );
+}
+```
+
+## User information in React
+
+You can access information about the authenticated user like their name from the
+`useAuth0` hook:
+
+```tsx title="src/badge.ts"
+import { useAuth0 } from "@auth0/auth0-react";
+
+export default function Badge() {
+  const { user } = useAuth0();
+  return <span>Logged in as {user.name}</span>;
+}
+```
+
+## User information in functions
+
+See [Auth in Functions](/auth/functions-auth.mdx) to learn about how to access
+information about the authenticated user in your queries, mutations and actions.
+
+See [Storing Users in the Convex Database](/auth/database-auth.mdx) to learn
+about how to store user information in the Convex database.
+
+## Configuring dev and prod tenants
+
+To configure a different Auth0 tenant (environment) between your Convex
+development and production deployments you can use environment variables
+configured on the Convex dashboard.
+
+### Configuring the backend
+
+First, change your <JSDialectFileName name="auth.config.ts" /> file to use
+environment variables:
+
+```ts title="convex/auth.config.ts"
+export default {
+  providers: [
+    {
+      domain: process.env.AUTH0_DOMAIN,
+      applicationID: process.env.AUTH0_CLIENT_ID,
+    },
+  ],
+};
+```
+
+**Development configuration**
+
+Open the Settings for your dev deployment on the Convex
+[dashboard](https://dashboard.convex.dev) and add the variables there:
+
+<p style={{ textAlign: "center" }}>
+  <img
+    src="/screenshots/auth0-convex-dashboard.png"
+    alt="Convex dashboard dev deployment settings"
+    width={600}
+  />
+</p>
+
+Now switch to the new configuration by running `npx convex dev`.
+
+**Production configuration**
+
+Similarly on the Convex [dashboard](https://dashboard.convex.dev) switch to your
+production deployment in the left side menu and set the values for your
+production Auth0 tenant there.
+
+Now switch to the new configuration by running `npx convex deploy`.
+
+### Configuring a React client
+
+To configure your client you can use environment variables as well. The exact
+name of the environment variables and the way to refer to them depends on each
+client platform (Vite vs Next.js etc.), refer to our corresponding
+[Quickstart](/quickstarts.mdx) or the relevant documentation for the platform
+you're using.
+
+Change the props to `Auth0Provider` to take in environment variables:
+
+
+```tsx
+import React from "react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+import { ConvexReactClient } from "convex/react";
+import { ConvexProviderWithAuth0 } from "convex/react-auth0";
+import { Auth0Provider } from "@auth0/auth0-react";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);
+
+ReactDOM.createRoot(document.getElementById("root")!).render(
+  <React.StrictMode>
+    <Auth0Provider
+      domain={import.meta.env.VITE_AUTH0_DOMAIN}
+      clientId={import.meta.env.VITE_AUTH0_CLIENT_ID}
+      authorizationParams={{
+        redirect_uri: window.location.origin,
+      }}
+      useRefreshTokens={true}
+      cacheLocation="localstorage"
+    >
+      <ConvexProviderWithAuth0 client={convex}>
+        <App />
+      </ConvexProviderWithAuth0>
+    </Auth0Provider>
+  </React.StrictMode>,
+);
+```
+
+```jsx
+import React from "react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+import { ConvexProviderWithAuth0 } from "convex/react-auth0";
+import { Auth0Provider } from "@auth0/auth0-react";
+import { ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
+
+ReactDOM.createRoot(document.getElementById("root")).render(
+  <React.StrictMode>
+    <Auth0Provider
+      domain={import.meta.env.VITE_AUTH0_DOMAIN}
+      clientId={import.meta.env.VITE_AUTH0_CLIENT_ID}
+      authorizationParams={{
+        redirect_uri: window.location.origin,
+      }}
+      useRefreshTokens={true}
+      cacheLocation="localstorage"
+    >
+      <ConvexProviderWithAuth0 client={convex}>
+        <App />
+      </ConvexProviderWithAuth0>
+    </Auth0Provider>
+  </React.StrictMode>,
+);
+```
+
+
+**Development configuration**
+
+Use the `.env.local` or `.env` file to configure your client when running
+locally. The name of the environment variables file depends on each client
+platform (Vite vs Next.js etc.), refer to our corresponding
+[Quickstart](/quickstarts.mdx) or the relevant documentation for the platform
+you're using:
+
+```py title=".env.local"
+VITE_AUTH0_DOMAIN="your-domain.us.auth0.com"
+VITE_AUTH0_CLIENT_ID="yourclientid"
+```
+
+**Production configuration**
+
+Set the environment variables in your production environment depending on your
+hosting platform. See [Hosting](/production/hosting/hosting.mdx).
+
+## Debugging authentication
+
+If a user goes through the Auth0 login flow successfully, and after being
+redirected back to your page `useConvexAuth` gives `isAuthenticated: false`,
+it's possible that your backend isn't correctly configured.
+
+The <JSDialectFileName name="auth.config.ts" /> file in your `convex/` directory
+contains a list of configured authentication providers. You must run
+`npx convex dev` or `npx convex deploy` after adding a new provider to sync the
+configuration to your backend.
+
+For more thorough debugging steps, see
+[Debugging Authentication](/auth/debug.mdx).
+
+## Under the hood
+
+<UnderTheHood
+  provider="Auth0"
+  integrationProvider={<code>ConvexProviderWithAuth0</code>}
+  providerProvider={<code>Auth0Provider</code>}
+  configProp={
+    <>
+      the{" "}
+      <a
+        href="https://auth0.github.io/auth0-react/interfaces/AuthorizationParams.html"
+        target="_blank"
+      >
+        <code>authorizationParams</code>
+      </a>{" "}
+      prop
+    </>
+  }
+/>
diff --git a/synced/convex/docs/auth/clerk.md b/synced/convex/docs/auth/clerk.md
new file mode 100644
index 0000000..757f3ce
--- /dev/null
+++ b/synced/convex/docs/auth/clerk.md
@@ -0,0 +1,695 @@
+---
+title: "Convex & Clerk"
+sidebar_label: "Clerk"
+sidebar_position: 10
+---
+
+
+
+
+
+
+
+
+[Clerk](https://clerk.com) is an authentication platform providing login via
+passwords, social identity providers, one-time email or SMS access codes, and
+multi-factor authentication and basic user management.
+
+## Get started
+
+Convex offers a provider that is specifically for integrating with Clerk called
+`<ConvexProviderWithClerk>`. It works with any of Clerk's React-based SDKs, such
+as the Next.js and Expo SDKs.
+
+See the following sections for the Clerk SDK that you're using:
+
+- [React](#react) - Use this as a starting point if your SDK is not listed
+- [Next.js](#nextjs)
+- [Tanstack Start](#tanstack-start)
+
+### React
+
+**Example:**
+[React with Convex and Clerk](https://github.com/get-convex/template-react-vite-clerk)
+
+This guide assumes you already have a working React app with Convex. If not
+follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:
+
+<StepByStep>
+  <Step title="Sign up for Clerk">
+    Sign up for a free Clerk account at [clerk.com/sign-up](https://dashboard.clerk.com/sign-up).
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/clerk-signup.png" alt="Sign up to Clerk" width={200} />
+    </p>
+
+  </Step>
+  <Step title="Create an application in Clerk">
+    Choose how you want your users to sign in.
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/clerk-createapp.png" alt="Create a Clerk application" width={200} />
+    </p>
+
+  </Step>
+  <Step title="Create a JWT Template">
+    In the Clerk Dashboard, navigate to the [JWT templates](https://dashboard.clerk.com/last-active?path=jwt-templates) page.
+
+    Select _New template_ and then from the list of templates, select _Convex_. You'll be redirected to the template's settings page. **Do NOT rename the JWT token. It must be called `convex`.**
+
+    Copy and save the _Issuer_ URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's _Frontend API URL_. In development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In production, it's format will be `https://clerk.<your-domain>.com`.
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/clerk-createjwt.png" alt="Create a JWT template" width={400} />
+    </p>
+
+  </Step>
+  <Step title="Set the Issuer URL in your env vars">
+    In your `env` file, add your _Issuer_ URL as the `CLERK_FRONTEND_API_URL` environment variable. If you're using Vite, you'll need to prefix it with `VITE_`.
+
+    ```env title=".env"
+    VITE_CLERK_FRONTEND_API_URL=https://verb-noun-00.clerk.accounts.dev
+    ```
+
+  </Step>
+  <Step title="Configure Convex with the Clerk issuer domain">
+    In your app's `convex` folder, create a new file <JSDialectFileName name="auth.config.ts" /> with the following code. This is the server-side configuration for validating access tokens.
+
+    ```ts title="convex/auth.config.ts"
+    export default {
+      providers: [
+        {
+          domain: process.env.VITE_CLERK_FRONTEND_API_URL,
+          applicationID: "convex",
+        },
+      ]
+    };
+    ```
+
+  </Step>
+  <Step title="Deploy your changes">
+    Run `npx convex dev` to automatically sync your configuration to your backend.
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+  <Step title="Install clerk">
+    In a new terminal window, install the Clerk React SDK:
+
+    ```sh
+    npm install @clerk/clerk-react
+    ```
+
+  </Step>
+  <Step title="Set your Clerk API keys">
+    In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page. In the **Quick Copy** section, copy your Clerk Publishable Key and set it as the `CLERK_PUBLISHABLE_KEY` environment variable. If you're using Vite, you will need to prefix it with `VITE_`.
+
+    ```env title=".env"
+    VITE_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
+    ```
+
+  </Step>
+  <Step title="Configure ConvexProviderWithClerk">
+    Both Clerk and Convex have provider components that are required to provide authentication and client context.
+
+    You should already have `<ConvexProvider>` wrapping your app. Replace it with `<ConvexProviderWithClerk>`, and pass Clerk's `useAuth()` hook to it.
+
+    Then, wrap it with `<ClerkProvider>`. `<ClerkProvider>` requires a `publishableKey` prop, which you can set to the `VITE_CLERK_PUBLISHABLE_KEY` environment variable.
+
+    
+```tsx
+import React from "react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+import { ClerkProvider, useAuth } from "@clerk/clerk-react";
+import { ConvexProviderWithClerk } from "convex/react-clerk";
+import { ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);
+
+ReactDOM.createRoot(document.getElementById("root")!).render(
+  <React.StrictMode>
+    <ClerkProvider publishableKey="pk_test_...">
+      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
+        <App />
+      </ConvexProviderWithClerk>
+    </ClerkProvider>
+  </React.StrictMode>,
+);
+```
+
+```jsx
+import React from "react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+import { ClerkProvider, useAuth } from "@clerk/clerk-react";
+import { ConvexProviderWithClerk } from "convex/react-clerk";
+import { ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
+
+ReactDOM.createRoot(document.getElementById("root")).render(
+  <React.StrictMode>
+    <ClerkProvider publishableKey="pk_test_...">
+      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
+        <App />
+      </ConvexProviderWithClerk>
+    </ClerkProvider>
+  </React.StrictMode>,
+);
+```
+
+
+  </Step>
+
+  <Step title="Show UI based on authentication state">
+    You can control which UI is shown when the user is signed in or signed out using Convex's `<Authenticated>`, `<Unauthenticated>` and `<AuthLoading>` helper components. These should be used instead of Clerk's `<SignedIn>`, `<SignedOut>` and `<ClerkLoading>` components, respectively.
+
+    It's important to use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
+    Clerk's `useAuth()` hook when you need to check whether the user is logged in or
+    not. The `useConvexAuth()` hook makes sure that the browser has fetched the auth
+    token needed to make authenticated requests to your Convex backend, and that the
+    Convex backend has validated it.
+
+    In the following example, the `<Content />` component is a child of `<Authenticated>`, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.
+
+    ```tsx title="src/App.tsx"
+    import { SignInButton, UserButton } from "@clerk/clerk-react";
+    import { Authenticated, Unauthenticated, AuthLoading, useQuery } from "convex/react";
+    import { api } from "../convex/_generated/api";
+
+    function App() {
+      return (
+        <main>
+          <Unauthenticated>
+            <SignInButton />
+          </Unauthenticated>
+          <Authenticated>
+            <UserButton />
+            <Content />
+          </Authenticated>
+          <AuthLoading>
+            <p>Still loading</p>
+          </AuthLoading>
+        </main>
+      );
+    }
+
+    function Content() {
+      const messages = useQuery(api.messages.getForCurrentUser);
+      return <div>Authenticated content: {messages?.length}</div>;
+    }
+
+    export default App;
+    ```
+
+  </Step>
+
+  <Step title="Use authentication state in your Convex functions">
+    If the client is authenticated, you can access the information
+    stored in the JWT via `ctx.auth.getUserIdentity`.
+
+    If the client isn't authenticated, `ctx.auth.getUserIdentity` will return `null`.
+
+    **Make sure that the component calling this query is a child of `<Authenticated>` from
+    `convex/react`**. Otherwise, it will throw on page load.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async (ctx) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (identity === null) {
+      throw new Error("Not authenticated");
+    }
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), identity.email))
+      .collect();
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async (ctx) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (identity === null) {
+      throw new Error("Not authenticated");
+    }
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), identity.email))
+      .collect();
+  },
+});
+```
+
+
+  </Step>
+</StepByStep>
+
+### Next.js
+
+**Example:**
+[Next.js with Convex and Clerk](https://github.com/get-convex/template-nextjs-clerk)
+
+This guide assumes you already have a working Next.js app with Convex. If not
+follow the [Convex Next.js Quickstart](/quickstart/nextjs.mdx) first. Then:
+
+<StepByStep>
+  <Step title="Sign up for Clerk">
+    Sign up for a free Clerk account at [clerk.com/sign-up](https://dashboard.clerk.com/sign-up).
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/clerk-signup.png" alt="Sign up to Clerk" width={200} />
+    </p>
+
+  </Step>
+  <Step title="Create an application in Clerk">
+    Choose how you want your users to sign in.
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/clerk-createapp.png" alt="Create a Clerk application" width={200} />
+    </p>
+
+  </Step>
+  <Step title="Create a JWT Template">
+    In the Clerk Dashboard, navigate to the [JWT templates](https://dashboard.clerk.com/last-active?path=jwt-templates) page.
+
+    Select _New template_ and then from the list of templates, select _Convex_. You'll be redirected to the template's settings page. **Do NOT rename the JWT token. It must be called `convex`.**
+
+    Copy and save the _Issuer_ URL somewhere secure. This URL is the issuer domain for Clerk's JWT templates, which is your Clerk app's _Frontend API URL_. In development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In production, it's format will be `https://clerk.<your-domain>.com`.
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/clerk-createjwt.png" alt="Create a JWT template" width={400} />
+    </p>
+
+  </Step>
+  <Step title="Set the Issuer URL in your env vars">
+    In your `env` file, add your _Issuer_ URL as the `NEXT_PUBLIC_CLERK_FRONTEND_API_URL` environment variable.
+
+    ```env title=".env"
+    NEXT_PUBLIC_CLERK_FRONTEND_API_URL=https://verb-noun-00.clerk.accounts.dev
+    ```
+
+  </Step>
+  <Step title="Configure Convex with the Clerk issuer domain">
+    In your app's `convex` folder, create a new file <JSDialectFileName name="auth.config.ts" /> with the following code. This is the server-side configuration for validating access tokens.
+
+    ```ts title="convex/auth.config.ts"
+    export default {
+      providers: [
+        {
+          domain: process.env.NEXT_PUBLIC_CLERK_FRONTEND_API_URL,
+          applicationID: "convex",
+        },
+      ]
+    };
+    ```
+
+  </Step>
+  <Step title="Deploy your changes">
+    Run `npx convex dev` to automatically sync your configuration to your backend.
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+  <Step title="Install clerk">
+    In a new terminal window, install the Clerk Next.js SDK:
+
+    ```sh
+    npm install @clerk/nextjs
+    ```
+
+  </Step>
+  <Step title="Set your Clerk API keys">
+    In the Clerk Dashboard, navigate to the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page. In the **Quick Copy** section, copy your Clerk Publishable and Secret Keys and set them as the `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY` environment variables, respectively.
+
+    ```env title=".env"
+    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
+    CLERK_SECRET_KEY=YOUR_SECRET_KEY
+    ```
+
+  </Step>
+  <Step title="Add Clerk middleware">
+    Clerk's `clerkMiddleware()` helper grants you access to user authentication state throughout your app.
+
+    Create a `middleware.ts` file.
+
+    In your `middleware.ts` file, export the `clerkMiddleware()` helper:
+
+    ```tsx {{ filename: 'middleware.ts' }}
+    import { clerkMiddleware } from '@clerk/nextjs/server'
+
+    export default clerkMiddleware()
+
+    export const config = {
+      matcher: [
+        // Skip Next.js internals and all static files, unless found in search params
+        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
+        // Always run for API routes
+        '/(api|trpc)(.*)',
+      ],
+    }
+    ```
+
+    By default, `clerkMiddleware()` will not protect any routes. All routes are public and you must opt-in to protection for routes.https://clerk.com/docs/references/nextjs/clerk-middleware) to learn how to require authentication for specific routes.
+
+  </Step>
+  <Step title="Configure ConvexProviderWithClerk">
+    Both Clerk and Convex have provider components that are required to provide authentication and client context.
+
+    Typically, you'd replace `<ConvexProvider>` with `<ConvexProviderWithClerk>`, but with Next.js App Router, things are a bit more complex.
+
+    `<ConvexProviderWithClerk>` calls `ConvexReactClient()` to get Convex's client, so it must be used in a Client Component. Your `app/layout.tsx`, where you would use `<ConvexProviderWithClerk>`, is a Server Component, and a Server Component cannot contain Client Component code. To solve this, you must first create a _wrapper_ Client Component around `<ConvexProviderWithClerk>`.
+
+    ```tsx {{ filename: 'components/ConvexClientProvider.tsx' }}
+    'use client'
+
+    import { ReactNode } from 'react'
+    import { ConvexReactClient } from 'convex/react'
+    import { ConvexProviderWithClerk } from 'convex/react-clerk'
+    import { useAuth } from '@clerk/nextjs'
+
+    if (!process.env.NEXT_PUBLIC_CONVEX_URL) {
+      throw new Error('Missing NEXT_PUBLIC_CONVEX_URL in your .env file')
+    }
+
+    const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL)
+
+    export default function ConvexClientProvider({ children }: { children: ReactNode }) {
+      return (
+        <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
+          {children}
+        </ConvexProviderWithClerk>
+      )
+    }
+    ```
+
+  </Step>
+  <Step title="Wrap your app in Clerk and Convex">
+    Now, your Server Component, `app/layout.tsx`, can render `<ConvexClientProvider>` instead of rendering `<ConvexProviderWithClerk>` directly. It's important that `<ClerkProvider>` wraps `<ConvexClientProvider>`, and not the other way around, as Convex needs to be able to access the Clerk context.
+
+    ```tsx {{ filename: 'app/layout.tsx', mark: [5, 31] }}
+    import type { Metadata } from 'next'
+    import { Geist, Geist_Mono } from 'next/font/google'
+    import './globals.css'
+    import { ClerkProvider } from '@clerk/nextjs'
+    import ConvexClientProvider from '@/components/ConvexClientProvider'
+
+    const geistSans = Geist({
+      variable: '--font-geist-sans',
+      subsets: ['latin'],
+    })
+
+    const geistMono = Geist_Mono({
+      variable: '--font-geist-mono',
+      subsets: ['latin'],
+    })
+
+    export const metadata: Metadata = {
+      title: 'Clerk Next.js Quickstart',
+      description: 'Generated by create next app',
+    }
+
+    export default function RootLayout({
+      children,
+    }: Readonly<{
+      children: React.ReactNode
+    }>) {
+      return (
+        <html lang="en">
+          <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
+            <ClerkProvider>
+              <ConvexClientProvider>{children}</ConvexClientProvider>
+            </ClerkProvider>
+          </body>
+        </html>
+      )
+    }
+    ```
+
+  </Step>
+  <Step title="Show UI based on authentication state">
+    You can control which UI is shown when the user is signed in or signed out using Convex's `<Authenticated>`, `<Unauthenticated>` and `<AuthLoading>` helper components. These should be used instead of Clerk's `<SignedIn>`, `<SignedOut>` and `<ClerkLoading>` components, respectively.
+
+    It's important to use the [`useConvexAuth()`](/api/modules/react#useconvexauth) hook instead of
+    Clerk's `useAuth()` hook when you need to check whether the user is logged in or
+    not. The `useConvexAuth()` hook makes sure that the browser has fetched the auth
+    token needed to make authenticated requests to your Convex backend, and that the
+    Convex backend has validated it.
+
+    In the following example, the `<Content />` component is a child of `<Authenticated>`, so its content and any of its child components are guaranteed to have an authenticated user, and Convex queries can require authentication.
+
+    ```tsx title="app/page.tsx"
+    "use client";
+
+    import { Authenticated, Unauthenticated } from "convex/react";
+    import { SignInButton, UserButton } from "@clerk/nextjs";
+    import { useQuery } from "convex/react";
+    import { api } from "../convex/_generated/api";
+
+    export default function Home() {
+      return (
+        <>
+          <Authenticated>
+            <UserButton />
+            <Content />
+          </Authenticated>
+          <Unauthenticated>
+            <SignInButton />
+          </Unauthenticated>
+        </>
+      );
+    }
+
+    function Content() {
+      const messages = useQuery(api.messages.getForCurrentUser);
+      return <div>Authenticated content: {messages?.length}</div>;
+    }
+    ```
+
+  </Step>
+
+  <Step title="Use authentication state in your Convex functions">
+    If the client is authenticated, you can access the information
+    stored in the JWT via `ctx.auth.getUserIdentity`.
+
+    If the client isn't authenticated, `ctx.auth.getUserIdentity` will return `null`.
+
+    **Make sure that the component calling this query is a child of `<Authenticated>` from
+    `convex/react`**. Otherwise, it will throw on page load.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async (ctx) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (identity === null) {
+      throw new Error("Not authenticated");
+    }
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), identity.email))
+      .collect();
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async (ctx) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (identity === null) {
+      throw new Error("Not authenticated");
+    }
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), identity.email))
+      .collect();
+  },
+});
+```
+
+
+  </Step>
+</StepByStep>
+
+### Tanstack Start
+
+**Example:**
+[Tanstack Start with Convex and Clerk](https://github.com/get-convex/templates/tree/main/template-tanstack-start)
+
+See the
+[Tanstack Start with Clerk guide](/client/react/tanstack-start/clerk.mdx) for
+more information.
+
+## Next steps
+
+### Accessing user information in functions
+
+See [Auth in Functions](/auth/functions-auth.mdx) to learn about how to access
+information about the authenticated user in your queries, mutations and actions.
+
+See [Storing Users in the Convex Database](/auth/database-auth.mdx) to learn
+about how to store user information in the Convex database.
+
+### Accessing user information client-side
+
+To access the authenticated user's information, use Clerk's `User` object, which
+can be accessed using Clerk's
+[`useUser()`](https://clerk.com/docs/hooks/use-user) hook. For more information
+on the `User` object, see the
+[Clerk docs](https://clerk.com/docs/references/javascript/user).
+
+```tsx title="components/Badge.tsx"
+export default function Badge() {
+  const { user } = useUser();
+
+  return <span>Logged in as {user.fullName}</span>;
+}
+```
+
+## Configuring dev and prod instances
+
+To configure a different Clerk instance between your Convex development and
+production deployments, you can use environment variables configured on the
+Convex dashboard.
+
+### Configuring the backend
+
+In the Clerk Dashboard, navigate to the
+[**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page. Copy
+your Clerk Frontend API URL. This URL is the issuer domain for Clerk's JWT
+templates, and is necessary for Convex to validate access tokens. In
+development, it's format will be `https://verb-noun-00.clerk.accounts.dev`. In
+production, it's format will be `https://clerk.<your-domain>.com`.
+
+Paste your Clerk Frontend API URL into your `.env` file, set it as the
+`CLERK_FRONTEND_API_URL` environment variable. If you are using Vite, you will
+need to prefix it with `VITE_`. If you are using Next.js, you will need to
+prefix it with `NEXT_PUBLIC_`.
+
+```env title=".env"
+CLERK_FRONTEND_API_URL=https://verb-noun-00.clerk.accounts.dev
+```
+
+Then, update your <JSDialectFileName name="auth.config.ts" /> file to use the
+environment variable. Don't forget to use the necessary prefix for your client
+platform (e.g. `VITE_` or `NEXT_PUBLIC_`).
+
+```ts title="convex/auth.config.ts"
+export default {
+  providers: [
+    {
+      domain: process.env.CLERK_FRONTEND_API_URL,
+      applicationID: "convex",
+    },
+  ],
+};
+```
+
+**Development configuration**
+
+In the left sidenav of the Convex [dashboard](https://dashboard.convex.dev),
+switch to your development deployment and set the values for your development
+Clerk instance.
+
+{/* TODO: Update screenshot to use `CLERK_FRONTEND_API_URL`. It should be in the format `https://verb-noun-00.clerk.accounts.dev` */}
+
+<p style={{ textAlign: "center" }}>
+  <img
+    src="/screenshots/clerk-convex-dashboard.png"
+    alt="Convex dashboard dev deployment settings"
+    width={600}
+  />
+</p>
+
+Then, to switch your deployment to the new configuration, run `npx convex dev`.
+
+**Production configuration**
+
+In the left sidenav of the Convex [dashboard](https://dashboard.convex.dev),
+switch to your production deployment and set the values for your production
+Clerk instance.
+
+{/* TODO: Add screenshot of production configuration in Convex dashboard. The `CLERK_FRONTEND_API_URL` should be in the format `https://clerk.<your-domain>.com` */}
+
+Then, to switch your deployment to the new configuration, run
+`npx convex deploy`.
+
+### Configuring Clerk's API keys
+
+Clerk's API keys differ depending on whether they are for development or
+production. Don't forget to update the environment variables in your `.env` file
+as well as your hosting platform, such as Vercel or Netlify.
+
+**Development configuration**
+
+Clerk's Publishable Key for development follows the format `pk_test_...`.
+
+```py title=".env.local"
+VITE_CLERK_PUBLISHABLE_KEY="pk_test_..."
+```
+
+**Production configuration**
+
+Clerk's Publishable Key for production follows the format `pk_live_...`.
+
+```py title=".env"
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="pk_live_..."
+```
+
+## Debugging authentication
+
+If a user goes through the Clerk login flow successfully, and after being
+redirected back to your page, `useConvexAuth()` returns
+`isAuthenticated: false`, it's possible that your backend isn't correctly
+configured.
+
+The <JSDialectFileName name="auth.config.ts" /> file contains a list of
+configured authentication providers. You must run `npx convex dev` or
+`npx convex deploy` after adding a new provider to sync the configuration to
+your backend.
+
+For more thorough debugging steps, see
+[Debugging Authentication](/auth/debug.mdx).
+
+## Under the hood
+
+<UnderTheHood
+  provider="Clerk"
+  integrationProvider={<code>ConvexProviderWithClerk</code>}
+  providerProvider={<code>ClerkProvider</code>}
+  configProp={
+    <>
+      the{" "}
+      <a
+        href="https://clerk.com/docs/authentication/sign-in#override-ur-ls"
+        target="_blank"
+      >
+        <code>afterSignIn</code>
+      </a>{" "}
+      prop
+    </>
+  }
+/>
diff --git a/synced/convex/docs/auth/convex-auth.md b/synced/convex/docs/auth/convex-auth.md
new file mode 100644
index 0000000..f910277
--- /dev/null
+++ b/synced/convex/docs/auth/convex-auth.md
@@ -0,0 +1,50 @@
+---
+title: "Convex Auth"
+sidebar_label: "Convex Auth"
+sidebar_position: 1
+---
+
+[Convex Auth](https://labs.convex.dev/auth) is a library for implementing
+authentication directly within your Convex backend. This allows you to
+authenticate users without needing an authentication service or even a hosting
+server. Convex Auth currently supports client-side React web apps served from a
+CDN and React Native mobile apps.
+
+**Example:** [Live Demo](https://labs.convex.dev/auth-example)
+([Source](https://github.com/get-convex/convex-auth-example))
+
+<BetaAdmonition feature="Convex Auth" verb="is" />
+
+Support for
+[authentication in Next.js](https://labs.convex.dev/auth/authz/nextjs) server
+components, API routes, middleware, SSR etc. is under active development. If
+you'd like to help test this experimental support please
+[let us know how it goes in Discord](https://convex.dev/community).
+
+## Get Started
+
+To start a new project from scratch with Convex and Convex Auth, run:
+
+```sh
+npm create convex@latest
+```
+
+and choose `React (Vite)` and `Convex Auth`.
+
+---
+
+To add Convex Auth to an existing project, follow the full
+[setup guide](https://labs.convex.dev/auth/setup).
+
+## Overview
+
+Convex Auth enables you to implement the following authentication methods:
+
+1. Magic Links & OTPs - send a link or code via email
+2. OAuth - sign in with GitHub / Google / Apple etc.
+3. Passwords - including password reset flow and optional email verification
+
+The library doesn't come with UI components, but you can copy code from the docs
+and example repo to quickly build a UI in React.
+
+Learn more in the [Convex Auth docs](https://labs.convex.dev/auth).
diff --git a/synced/convex/docs/auth/database-auth.md b/synced/convex/docs/auth/database-auth.md
new file mode 100644
index 0000000..0e4d65b
--- /dev/null
+++ b/synced/convex/docs/auth/database-auth.md
@@ -0,0 +1,1253 @@
+---
+title: "Storing Users in the Convex Database"
+sidebar_label: "Database"
+sidebar_position: 50
+---
+
+
+
+
+
+
+
+
+
+
+
+
+
+_If you're using [Convex Auth](/auth/convex-auth.mdx) the user information is
+already stored in your database. There's nothing else you need to implement._
+
+You might want to store user information directly in your Convex database, for
+the following reasons:
+
+- Your functions need information about other users, not just about the
+  currently logged-in user
+- Your functions need access to information other than the fields available in
+  the [Open ID Connect JWT](/auth/functions-auth.mdx)
+
+There are two ways you can choose from for storing user information in your
+database (but only the second one allows storing information not contained in
+the JWT):
+
+1. Have your app's [client call a mutation](#call-a-mutation-from-the-client)
+   that stores the information from the JWT available on
+   [`ctx.auth`](/api/interfaces/server.Auth)
+2. [Implement a webhook](#set-up-webhooks) and have your identity provider call
+   it whenever user information changes
+
+## Call a mutation from the client
+
+**Example:**
+[Convex Authentication with Clerk](https://github.com/get-convex/convex-demos/tree/main/users-and-clerk)
+
+### (optional) Users table schema
+
+You can define a `"users"` table, optionally with an
+[index](/database/reading-data/indexes/indexes.md) for efficient looking up the
+users in the database.
+
+In the examples below we will use the `tokenIdentifier` from the
+`ctx.auth.getUserIdentity()` to identify the user, but you could use the
+`subject` field (which is usually set to the unique user ID from your auth
+provider) or even `email`, if your authentication provider provides email
+verification and you have it enabled.
+
+Which field you use will determine how multiple providers interact, and how hard
+it will be to migrate to a different provider.
+
+
+```ts
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  messages: defineTable({
+    body: v.string(),
+    user: v.id("users"),
+  }),
+  // @snippet start user
+  users: defineTable({
+    name: v.string(),
+    tokenIdentifier: v.string(),
+  }).index("by_token", ["tokenIdentifier"]),
+  // @snippet end user
+});
+```
+
+
+### Mutation for storing current user
+
+This is an example of a mutation that stores the user's `name` and
+`tokenIdentifier`:
+
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const store = mutation({
+  args: {},
+  handler: async (ctx) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Called storeUser without authentication present");
+    }
+
+    // Check if we've already stored this identity before.
+    // Note: If you don't want to define an index right away, you can use
+    // ctx.db.query("users")
+    //  .filter(q => q.eq(q.field("tokenIdentifier"), identity.tokenIdentifier))
+    //  .unique();
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (user !== null) {
+      // If we've seen this identity before but the name has changed, patch the value.
+      if (user.name !== identity.name) {
+        await ctx.db.patch(user._id, { name: identity.name });
+      }
+      return user._id;
+    }
+    // If it's a new identity, create a new `User`.
+    return await ctx.db.insert("users", {
+      name: identity.name ?? "Anonymous",
+      tokenIdentifier: identity.tokenIdentifier,
+    });
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const store = mutation({
+  args: {},
+  handler: async (ctx) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Called storeUser without authentication present");
+    }
+
+    // Check if we've already stored this identity before.
+    // Note: If you don't want to define an index right away, you can use
+    // ctx.db.query("users")
+    //  .filter(q => q.eq(q.field("tokenIdentifier"), identity.tokenIdentifier))
+    //  .unique();
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (user !== null) {
+      // If we've seen this identity before but the name has changed, patch the value.
+      if (user.name !== identity.name) {
+        await ctx.db.patch(user._id, { name: identity.name });
+      }
+      return user._id;
+    }
+    // If it's a new identity, create a new `User`.
+    return await ctx.db.insert("users", {
+      name: identity.name ?? "Anonymous",
+      tokenIdentifier: identity.tokenIdentifier,
+    });
+  },
+});
+```
+
+
+### Calling the store user mutation from React
+
+You can call this mutation when the user logs in from a `useEffect` hook. After
+the mutation succeeds you can update local state to reflect that the user has
+been stored.
+
+This helper hook that does the job:
+
+
+```ts
+import { useUser } from "@clerk/clerk-react";
+import { useConvexAuth } from "convex/react";
+import { useEffect, useState } from "react";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+import { Id } from "../convex/_generated/dataModel";
+
+export function useStoreUserEffect() {
+  const { isLoading, isAuthenticated } = useConvexAuth();
+  const { user } = useUser();
+  // When this state is set we know the server
+  // has stored the user.
+  const [userId, setUserId] = useState<Id<"users"> | null>(null);
+  const storeUser = useMutation(api.users.store);
+  // Call the `storeUser` mutation function to store
+  // the current user in the `users` table and return the `Id` value.
+  useEffect(() => {
+    // If the user is not logged in don't do anything
+    if (!isAuthenticated) {
+      return;
+    }
+    // Store the user in the database.
+    // Recall that `storeUser` gets the user information via the `auth`
+    // object on the server. You don't need to pass anything manually here.
+    async function createUser() {
+      const id = await storeUser();
+      setUserId(id);
+    }
+    createUser();
+    return () => setUserId(null);
+    // Make sure the effect reruns if the user logs in with
+    // a different identity
+  }, [isAuthenticated, storeUser, user?.id]);
+  // Combine the local state with the state from context
+  return {
+    isLoading: isLoading || (isAuthenticated && userId === null),
+    isAuthenticated: isAuthenticated && userId !== null,
+  };
+}
+```
+
+```js
+import { useAuth0 } from "@auth0/auth0-react";
+import { useConvexAuth } from "convex/react";
+import { useEffect, useState } from "react";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+export default function useStoreUserEffect() {
+  const { isAuthenticated } = useConvexAuth();
+  const { user } = useAuth0();
+  // When this state is set we know the server
+  // has stored the user.
+  const [userId, setUserId] = useState(null);
+  const storeUser = useMutation(api.users.store);
+  // Call the `storeUser` mutation function to store
+  // the current user in the `users` table and return the `Id` value.
+  useEffect(() => {
+    // If the user is not logged in don't do anything
+    if (!isAuthenticated) {
+      return;
+    }
+    // Store the user in the database.
+    // Recall that `storeUser` gets the user information via the `auth`
+    // object on the server. You don't need to pass anything manually here.
+    async function createUser() {
+      const id = await storeUser();
+      setUserId(id);
+    }
+    createUser();
+    return () => setUserId(null);
+    // Make sure the effect reruns if the user logs in with
+    // a different identity
+  }, [isAuthenticated, storeUser, user?.sub]);
+  return userId;
+}
+```
+
+
+You can use this hook in your top-level component. If your queries need the user
+document to be present, make sure that you only render the components that call
+them after the user has been stored:
+
+
+```tsx
+import { SignInButton, UserButton } from "@clerk/clerk-react";
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+import { useStoreUserEffect } from "./useStoreUserEffect.js";
+
+function App() {
+  const { isLoading, isAuthenticated } = useStoreUserEffect();
+  return (
+    <main>
+      {isLoading ? (
+        <>Loading...</>
+      ) : !isAuthenticated ? (
+        <SignInButton />
+      ) : (
+        <>
+          <UserButton />
+          <Content />
+        </>
+      )}
+    </main>
+  );
+}
+
+function Content() {
+  const messages = useQuery(api.messages.getForCurrentUser);
+  return <div>Authenticated content: {messages?.length}</div>;
+}
+
+export default App;
+```
+
+```tsx
+import { SignInButton, UserButton } from "@clerk/clerk-react";
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+import { useStoreUserEffect } from "./useStoreUserEffect.js";
+
+function App() {
+  const { isLoading, isAuthenticated } = useStoreUserEffect();
+  return (
+    <main>
+      {isLoading ? (
+        <>Loading...</>
+      ) : !isAuthenticated ? (
+        <SignInButton />
+      ) : (
+        <>
+          <UserButton />
+          <Content />
+        </>
+      )}
+    </main>
+  );
+}
+
+function Content() {
+  const messages = useQuery(api.messages.getForCurrentUser);
+  return <div>Authenticated content: {messages?.length}</div>;
+}
+
+export default App;
+```
+
+
+In this way the `useStoreUserEffect` hook replaces the `useConvexAuth` hook.
+
+### Using the current user's document ID
+
+Similarly to the store user mutation, you can retrieve the current user's ID, or
+throw an error if the user hasn't been stored.
+
+Now that you have users stored as documents in your Convex database, you can use
+their IDs as foreign keys in other documents:
+
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start load-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (!user) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    await ctx.db.insert("messages", { body: args.body, user: user._id });
+  },
+});
+// @snippet end load-user
+
+// @snippet start use-users
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.user);
+        return {
+          author: user?.name ?? "Anonymous",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+// @snippet end use-users
+```
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start load-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (!user) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    await ctx.db.insert("messages", { body: args.body, user: user._id });
+  },
+});
+// @snippet end load-user
+
+// @snippet start use-users
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.user);
+        return {
+          author: user?.name ?? "Anonymous",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+// @snippet end use-users
+```
+
+
+### Loading users by their ID
+
+The information about other users can be retrieved via their IDs:
+
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start load-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (!user) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    await ctx.db.insert("messages", { body: args.body, user: user._id });
+  },
+});
+// @snippet end load-user
+
+// @snippet start use-users
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.user);
+        return {
+          author: user?.name ?? "Anonymous",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+// @snippet end use-users
+```
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start load-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (!user) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    await ctx.db.insert("messages", { body: args.body, user: user._id });
+  },
+});
+// @snippet end load-user
+
+// @snippet start use-users
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.user);
+        return {
+          author: user?.name ?? "Anonymous",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+// @snippet end use-users
+```
+
+
+## Set up webhooks
+
+This guide will use Clerk, but Auth0 can be set up similarly via
+[Auth0 Actions](https://auth0.com/docs/customize/actions/actions-overview).
+
+With this implementation Clerk will call your Convex backend via an HTTP
+endpoint any time a user signs up, updates or deletes their account.
+
+**Example:**
+[Convex Authentication with Clerk and Webhooks](https://github.com/get-convex/convex-demos/tree/main/users-and-clerk-webhooks)
+
+### Configure the webhook endpoint in Clerk
+
+On your Clerk dashboard, go to _Webhooks_, click on _+ Add Endpoint_.
+
+Set _Endpoint URL_ to
+`https://<your deployment name>.convex.site/clerk-users-webhook` (note the
+domain ends in **`.site`**, not `.cloud`). You can see your deployment name in
+the `.env.local` file in your project directory, or on your Convex dashboard as
+part of the [Deployment URL](/dashboard/deployments/settings.md). For example,
+the endpoint URL could be:
+`https://happy-horse-123.convex.site/clerk-users-webhook`.
+
+In _Message Filtering_, select **user** for all user events (scroll down or use
+the search input).
+
+Click on _Create_.
+
+After the endpoint is saved, copy the _Signing Secret_ (on the right side of the
+UI), it should start with `whsec_`. Set it as the value of the
+`CLERK_WEBHOOK_SECRET` environment variable in your Convex
+[dashboard](https://dashboard.convex.dev).
+
+### (optional) Users table schema
+
+You can define a `"users"` table, optionally with an
+[index](/database/reading-data/indexes/indexes.md) for efficient looking up the
+users in the database.
+
+In the examples below we will use the `subject` from the
+`ctx.auth.getUserIdentity()` to identify the user, which should be set to the
+Clerk user ID.
+
+
+```ts
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  messages: defineTable({
+    body: v.string(),
+    userId: v.id("users"),
+  }).index("byUserId", ["userId"]),
+  // @snippet start table
+  users: defineTable({
+    name: v.string(),
+    // this the Clerk ID, stored in the subject JWT field
+    externalId: v.string(),
+  }).index("byExternalId", ["externalId"]),
+  // @snippet end table
+});
+```
+
+
+### Mutations for upserting and deleting users
+
+This is an example of mutations that handle the updates received via the
+webhook:
+
+
+```ts
+import { internalMutation, query, QueryCtx } from "./_generated/server";
+import { UserJSON } from "@clerk/backend";
+import { v, Validator } from "convex/values";
+
+export const current = query({
+  args: {},
+  handler: async (ctx) => {
+    return await getCurrentUser(ctx);
+  },
+});
+
+export const upsertFromClerk = internalMutation({
+  args: { data: v.any() as Validator<UserJSON> }, // no runtime validation, trust Clerk
+  async handler(ctx, { data }) {
+    const userAttributes = {
+      name: `${data.first_name} ${data.last_name}`,
+      externalId: data.id,
+    };
+
+    const user = await userByExternalId(ctx, data.id);
+    if (user === null) {
+      await ctx.db.insert("users", userAttributes);
+    } else {
+      await ctx.db.patch(user._id, userAttributes);
+    }
+  },
+});
+
+export const deleteFromClerk = internalMutation({
+  args: { clerkUserId: v.string() },
+  async handler(ctx, { clerkUserId }) {
+    const user = await userByExternalId(ctx, clerkUserId);
+
+    if (user !== null) {
+      await ctx.db.delete(user._id);
+    } else {
+      console.warn(
+        `Can't delete user, there is none for Clerk user ID: ${clerkUserId}`,
+      );
+    }
+  },
+});
+
+export async function getCurrentUserOrThrow(ctx: QueryCtx) {
+  const userRecord = await getCurrentUser(ctx);
+  if (!userRecord) throw new Error("Can't get current user");
+  return userRecord;
+}
+
+export async function getCurrentUser(ctx: QueryCtx) {
+  const identity = await ctx.auth.getUserIdentity();
+  if (identity === null) {
+    return null;
+  }
+  return await userByExternalId(ctx, identity.subject);
+}
+
+async function userByExternalId(ctx: QueryCtx, externalId: string) {
+  return await ctx.db
+    .query("users")
+    .withIndex("byExternalId", (q) => q.eq("externalId", externalId))
+    .unique();
+}
+```
+
+```ts
+import { internalMutation, query, QueryCtx } from "./_generated/server";
+import { UserJSON } from "@clerk/backend";
+import { v, Validator } from "convex/values";
+
+export const current = query({
+  args: {},
+  handler: async (ctx) => {
+    return await getCurrentUser(ctx);
+  },
+});
+
+export const upsertFromClerk = internalMutation({
+  args: { data: v.any() as Validator<UserJSON> }, // no runtime validation, trust Clerk
+  async handler(ctx, { data }) {
+    const userAttributes = {
+      name: `${data.first_name} ${data.last_name}`,
+      externalId: data.id,
+    };
+
+    const user = await userByExternalId(ctx, data.id);
+    if (user === null) {
+      await ctx.db.insert("users", userAttributes);
+    } else {
+      await ctx.db.patch(user._id, userAttributes);
+    }
+  },
+});
+
+export const deleteFromClerk = internalMutation({
+  args: { clerkUserId: v.string() },
+  async handler(ctx, { clerkUserId }) {
+    const user = await userByExternalId(ctx, clerkUserId);
+
+    if (user !== null) {
+      await ctx.db.delete(user._id);
+    } else {
+      console.warn(
+        `Can't delete user, there is none for Clerk user ID: ${clerkUserId}`,
+      );
+    }
+  },
+});
+
+export async function getCurrentUserOrThrow(ctx: QueryCtx) {
+  const userRecord = await getCurrentUser(ctx);
+  if (!userRecord) throw new Error("Can't get current user");
+  return userRecord;
+}
+
+export async function getCurrentUser(ctx: QueryCtx) {
+  const identity = await ctx.auth.getUserIdentity();
+  if (identity === null) {
+    return null;
+  }
+  return await userByExternalId(ctx, identity.subject);
+}
+
+async function userByExternalId(ctx: QueryCtx, externalId: string) {
+  return await ctx.db
+    .query("users")
+    .withIndex("byExternalId", (q) => q.eq("externalId", externalId))
+    .unique();
+}
+```
+
+
+There are also a few helpers in this file:
+
+- `current` exposes the user information to the client, which will helps the
+  client determine whether the webhook already succeeded
+- `upsertFromClerk` will be called when a user signs up or when they update
+  their account
+- `deleteFromClerk` will be called when a user deletes their account via Clerk
+  UI from your app
+- `getCurrentUserOrThrow` retrieves the currently logged-in user or throws an
+  error
+- `getCurrentUser` retrieves the currently logged-in user or returns null
+- `userByExternalId` retrieves a user given the Clerk ID, and is used only for
+  retrieving the current user or when updating an existing user via the webhook
+
+### Webhook endpoint implementation
+
+This how the actual HTTP endpoint can be implemented:
+
+
+```ts
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { internal } from "./_generated/api";
+import type { WebhookEvent } from "@clerk/backend";
+import { Webhook } from "svix";
+
+const http = httpRouter();
+
+http.route({
+  path: "/clerk-users-webhook",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    const event = await validateRequest(request);
+    if (!event) {
+      return new Response("Error occured", { status: 400 });
+    }
+    switch (event.type) {
+      case "user.created": // intentional fallthrough
+      case "user.updated":
+        await ctx.runMutation(internal.users.upsertFromClerk, {
+          data: event.data,
+        });
+        break;
+
+      case "user.deleted": {
+        const clerkUserId = event.data.id!;
+        await ctx.runMutation(internal.users.deleteFromClerk, { clerkUserId });
+        break;
+      }
+      default:
+        console.log("Ignored Clerk webhook event", event.type);
+    }
+
+    return new Response(null, { status: 200 });
+  }),
+});
+
+async function validateRequest(req: Request): Promise<WebhookEvent | null> {
+  const payloadString = await req.text();
+  const svixHeaders = {
+    "svix-id": req.headers.get("svix-id")!,
+    "svix-timestamp": req.headers.get("svix-timestamp")!,
+    "svix-signature": req.headers.get("svix-signature")!,
+  };
+  const wh = new Webhook(process.env.CLERK_WEBHOOK_SECRET!);
+  try {
+    return wh.verify(payloadString, svixHeaders) as unknown as WebhookEvent;
+  } catch (error) {
+    console.error("Error verifying webhook event", error);
+    return null;
+  }
+}
+
+export default http;
+```
+
+```ts
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { internal } from "./_generated/api";
+import type { WebhookEvent } from "@clerk/backend";
+import { Webhook } from "svix";
+
+const http = httpRouter();
+
+http.route({
+  path: "/clerk-users-webhook",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    const event = await validateRequest(request);
+    if (!event) {
+      return new Response("Error occured", { status: 400 });
+    }
+    switch (event.type) {
+      case "user.created": // intentional fallthrough
+      case "user.updated":
+        await ctx.runMutation(internal.users.upsertFromClerk, {
+          data: event.data,
+        });
+        break;
+
+      case "user.deleted": {
+        const clerkUserId = event.data.id!;
+        await ctx.runMutation(internal.users.deleteFromClerk, { clerkUserId });
+        break;
+      }
+      default:
+        console.log("Ignored Clerk webhook event", event.type);
+    }
+
+    return new Response(null, { status: 200 });
+  }),
+});
+
+async function validateRequest(req: Request): Promise<WebhookEvent | null> {
+  const payloadString = await req.text();
+  const svixHeaders = {
+    "svix-id": req.headers.get("svix-id")!,
+    "svix-timestamp": req.headers.get("svix-timestamp")!,
+    "svix-signature": req.headers.get("svix-signature")!,
+  };
+  const wh = new Webhook(process.env.CLERK_WEBHOOK_SECRET!);
+  try {
+    return wh.verify(payloadString, svixHeaders) as unknown as WebhookEvent;
+  } catch (error) {
+    console.error("Error verifying webhook event", error);
+    return null;
+  }
+}
+
+export default http;
+```
+
+
+If you deploy your code now and sign in, you should see the user being created
+in your Convex database.
+
+### Using the current user's document
+
+You can use the helpers defined before to retrieve the current user's document.
+
+Now that you have users stored as documents in your Convex database, you can use
+their IDs as foreign keys in other documents:
+
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start current-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+import { getCurrentUserOrThrow } from "./users";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const user = await getCurrentUserOrThrow(ctx);
+    await ctx.db.insert("messages", { body: args.body, userId: user._id });
+  },
+});
+// @snippet end current-user
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.userId);
+        return {
+          author: user?.name ?? "deleted user",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+
+export const sentCount = query({
+  args: {},
+  handler: async (ctx) => {
+    const user = await getCurrentUserOrThrow(ctx);
+    const sent = await ctx.db
+      .query("messages")
+      .withIndex("byUserId", (q) => q.eq("userId", user._id))
+      .collect();
+    return sent.length;
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start current-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+import { getCurrentUserOrThrow } from "./users";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const user = await getCurrentUserOrThrow(ctx);
+    await ctx.db.insert("messages", { body: args.body, userId: user._id });
+  },
+});
+// @snippet end current-user
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.userId);
+        return {
+          author: user?.name ?? "deleted user",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+
+export const sentCount = query({
+  args: {},
+  handler: async (ctx) => {
+    const user = await getCurrentUserOrThrow(ctx);
+    const sent = await ctx.db
+      .query("messages")
+      .withIndex("byUserId", (q) => q.eq("userId", user._id))
+      .collect();
+    return sent.length;
+  },
+});
+```
+
+
+### Loading users by their ID
+
+The information about other users can be retrieved via their IDs:
+
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start load-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (!user) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    await ctx.db.insert("messages", { body: args.body, user: user._id });
+  },
+});
+// @snippet end load-user
+
+// @snippet start use-users
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.user);
+        return {
+          author: user?.name ?? "Anonymous",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+// @snippet end use-users
+```
+
+```ts
+import { query } from "./_generated/server";
+// @snippet start load-user
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const send = mutation({
+  args: { body: v.string() },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (!identity) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    const user = await ctx.db
+      .query("users")
+      .withIndex("by_token", (q) =>
+        q.eq("tokenIdentifier", identity.tokenIdentifier),
+      )
+      .unique();
+    if (!user) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    await ctx.db.insert("messages", { body: args.body, user: user._id });
+  },
+});
+// @snippet end load-user
+
+// @snippet start use-users
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => {
+        // For each message in this channel, fetch the `User` who wrote it and
+        // insert their name into the `author` field.
+        const user = await ctx.db.get(message.user);
+        return {
+          author: user?.name ?? "Anonymous",
+          ...message,
+        };
+      }),
+    );
+  },
+});
+// @snippet end use-users
+```
+
+
+### Waiting for current user to be stored
+
+If you want to use the current user's document in a query, make sure that the
+user has already been stored. You can do this by explicitly checking for this
+condition before rendering the components that call the query, or before
+redirecting to the authenticated portion of your app.
+
+For example you can define a hook that determines the current authentication
+state of the client, taking into account whether the current user has been
+stored:
+
+
+```ts
+import { useConvexAuth, useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function useCurrentUser() {
+  const { isLoading, isAuthenticated } = useConvexAuth();
+  const user = useQuery(api.users.current);
+  // Combine the authentication state with the user existence check
+  return {
+    isLoading: isLoading || (isAuthenticated && user === null),
+    isAuthenticated: isAuthenticated && user !== null,
+  };
+}
+```
+
+```ts
+import { useConvexAuth, useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function useCurrentUser() {
+  const { isLoading, isAuthenticated } = useConvexAuth();
+  const user = useQuery(api.users.current);
+  // Combine the authentication state with the user existence check
+  return {
+    isLoading: isLoading || (isAuthenticated && user === null),
+    isAuthenticated: isAuthenticated && user !== null,
+  };
+}
+```
+
+
+And then you can use it to render the appropriate components:
+
+
+```tsx
+import { SignOutButton } from "@clerk/clerk-react";
+import { useMutation, useQuery } from "convex/react";
+import { FormEvent, useState } from "react";
+import { api } from "../convex/_generated/api";
+import Badge from "./Badge";
+import LoginPage from "./LoginPage";
+// @snippet start client-blocking
+import { useCurrentUser } from "./useCurrentUser";
+
+export default function App() {
+  const { isLoading, isAuthenticated } = useCurrentUser();
+  return (
+    <main>
+      {isLoading ? (
+        <>Loading...</>
+      ) : isAuthenticated ? (
+        <Content />
+      ) : (
+        <LoginPage />
+      )}
+    </main>
+  );
+}
+// @snippet end client-blocking
+
+function Content() {
+  const messages = useQuery(api.messages.list) || [];
+
+  const [newMessageText, setNewMessageText] = useState("");
+  const sendMessage = useMutation(api.messages.send);
+
+  async function handleSendMessage(event: FormEvent) {
+    event.preventDefault();
+    await sendMessage({ body: newMessageText });
+    setNewMessageText("");
+  }
+  return (
+    <main>
+      <h1>Convex Chat</h1>
+      <Badge />
+      <h2>
+        <SignOutButton />
+      </h2>
+      <ul>
+        {messages.map((message) => (
+          <li key={message._id}>
+            <span>{message.author}:</span>
+            <span>{message.body}</span>
+            <span>{new Date(message._creationTime).toLocaleTimeString()}</span>
+          </li>
+        ))}
+      </ul>
+      <form onSubmit={handleSendMessage}>
+        <input
+          value={newMessageText}
+          onChange={(event) => setNewMessageText(event.target.value)}
+          placeholder="Write a message…"
+        />
+        <input type="submit" value="Send" disabled={newMessageText === ""} />
+      </form>
+    </main>
+  );
+}
+```
+
+```tsx
+import { SignOutButton } from "@clerk/clerk-react";
+import { useMutation, useQuery } from "convex/react";
+import { FormEvent, useState } from "react";
+import { api } from "../convex/_generated/api";
+import Badge from "./Badge";
+import LoginPage from "./LoginPage";
+// @snippet start client-blocking
+import { useCurrentUser } from "./useCurrentUser";
+
+export default function App() {
+  const { isLoading, isAuthenticated } = useCurrentUser();
+  return (
+    <main>
+      {isLoading ? (
+        <>Loading...</>
+      ) : isAuthenticated ? (
+        <Content />
+      ) : (
+        <LoginPage />
+      )}
+    </main>
+  );
+}
+// @snippet end client-blocking
+
+function Content() {
+  const messages = useQuery(api.messages.list) || [];
+
+  const [newMessageText, setNewMessageText] = useState("");
+  const sendMessage = useMutation(api.messages.send);
+
+  async function handleSendMessage(event: FormEvent) {
+    event.preventDefault();
+    await sendMessage({ body: newMessageText });
+    setNewMessageText("");
+  }
+  return (
+    <main>
+      <h1>Convex Chat</h1>
+      <Badge />
+      <h2>
+        <SignOutButton />
+      </h2>
+      <ul>
+        {messages.map((message) => (
+          <li key={message._id}>
+            <span>{message.author}:</span>
+            <span>{message.body}</span>
+            <span>{new Date(message._creationTime).toLocaleTimeString()}</span>
+          </li>
+        ))}
+      </ul>
+      <form onSubmit={handleSendMessage}>
+        <input
+          value={newMessageText}
+          onChange={(event) => setNewMessageText(event.target.value)}
+          placeholder="Write a message…"
+        />
+        <input type="submit" value="Send" disabled={newMessageText === ""} />
+      </form>
+    </main>
+  );
+}
+```
+
diff --git a/synced/convex/docs/auth/debug.md b/synced/convex/docs/auth/debug.md
new file mode 100644
index 0000000..3613af0
--- /dev/null
+++ b/synced/convex/docs/auth/debug.md
@@ -0,0 +1,263 @@
+---
+title: "Debugging Authentication"
+sidebar_label: "Debugging"
+sidebar_position: 60
+---
+
+# Debugging Authentication
+
+You have followed one of our authentication guides but something is not working.
+You have double checked that you followed all the steps, and that you used the
+correct secrets, but you are still stuck.
+
+## Frequently encountered issues
+
+### `ctx.auth.getUserIdentity()` returns `null` in a query
+
+This often happens when subscribing to queries via `useQuery` in React, without
+waiting for the client to be authenticated. Even if the user has been logged-in
+previously, it takes some time for the client to authenticate with the Convex
+backend. Therefore on page load, `ctx.auth.getUserIdentity()` called within a
+query returns `null`.
+
+To handle this, you can either:
+
+1. Use the `Authenticated` component from `convex/react` to wrap the component
+   that includes the `useQuery` call (see the last two steps in the
+   [Clerk guide](/auth/clerk.mdx#get-started))
+2. Or return `null` or some other "sentinel" value from the query and handle it
+   on the client
+
+If you are using `fetchQuery` for
+[Next.js Server Rendering](/client/react/nextjs/nextjs-server-rendering.mdx),
+make sure you are explicitly passing in a JWT token as documented
+[here](/client/react/nextjs/nextjs-server-rendering.mdx#server-side-authentication).
+
+If this hasn't helped, follow the steps below to resolve your issue.
+
+## Step 1: Check whether authentication works on the backend
+
+1. Add the following code to the _beginning_ of your function (query, mutation,
+   action or http action):
+
+```ts
+console.log("server identity", await ctx.auth.getUserIdentity());
+```
+
+2. Then call this function from whichever client you're using to talk to Convex.
+
+3. Open the
+   [logs page on your dashboard](https://dashboard.convex.dev/deployment/logs).
+
+4. What do you see on the logs page?
+
+   **Answer: I don't see anything**:
+
+   - Potential cause: You don't have the right dashboard open. Confirm that the
+     Deployment URL on _Settings_ > _URL and Deploy Key_ page matches how your
+     client is configured.
+   - Potential cause: Your client is not connected to Convex. Check your client
+     logs (browser logs) for errors. Reload the page / restart the client.
+   - Potential cause: The code has not been pushed. For dev deployments make
+     sure you have `npx convex dev` running. For prod deployments make sure you
+     successfully pushed via `npx convex deploy`. Go to the _Functions_ page on
+     the dashboard and check that the code shown there includes the
+     `console.log` line you added.
+
+   When you resolved the cause you should see the log appear.
+
+   **Answer: I see a log with `'server identity' null`**:
+
+   - Potential cause: The client is not supplying an auth token.
+   - Potential cause: Your deployment is misconfigured.
+   - Potential cause: Your client is misconfigured.
+
+   Proceed to
+   [step 2](#step-2-check-whether-authentication-works-on-the-frontend).
+
+   **Answer: I see a log with `'server identity' { tokenIdentifier: '... } `**
+
+   Great, you are all set!
+
+## Step 2: Check whether authentication works on the frontend
+
+No matter which client you use, it must pass a JWT token to your backend for
+authentication to work.
+
+The most bullet-proof way of ensuring your client is passing the token to the
+backend, is to inspect the traffic between them.
+
+1. If you're using a client from the web browser, open the _Network_ tab in your
+   browser's developer tools.
+
+2. Check the token
+
+   - For Websocket-based clients (`ConvexReactClient` and `ConvexClient`),
+     filter for the `sync` name and select `WS` as the type of traffic. Check
+     the `sync` items. After the client is initialized (commonly after loading
+     the page), it will send a message (check the _Messages_ tab) with
+     `type: "Authenticate"`, and `value` will be the authentication token.
+
+     <p style={{ textAlign: "center" }}>
+       <img
+         src="/screenshots/auth-ws.png"
+         alt="Network tab inspecting Websocket messages"
+         width={500}
+       />
+     </p>
+
+   - For HTTP based clients (`ConvexHTTPClient` and the
+     [HTTP API](/http-api/index.md)), select `Fetch/XHR` as the type of traffic.
+     You should see an individual network request for each function call, with
+     an `Authorization` header with value `Bearer ` followed by the
+     authentication token.
+
+     <p style={{ textAlign: "center" }}>
+       <img
+         src="/screenshots/auth-http.png"
+         alt="Network tab inspecting HTTP headers"
+         width={480}
+       />
+     </p>
+
+3. Do you see the authentication token in the traffic?
+
+   **Answer: No**:
+
+   - Potential cause: The Convex client is not configured to get/fetch a JWT
+     token. You're not using
+     `ConvexProviderWithClerk`/`ConvexProviderWithAuth0`/`ConvexProviderWithAuth`
+     with the `ConvexReactClient` or you forgot to call `setAuth` on
+     `ConvexHTTPClient` or `ConvexClient`.
+   - Potential cause: You are not signed in, so the token is `null` or
+     `undefined` and the `ConvexReactClient` skipped authentication altogether.
+     Verify that you are signed in via `console.log`ing the token from whichever
+     auth provider you are using:
+
+     - Clerk:
+
+       ```tsx
+       // import { useAuth } from "@clerk/nextjs"; // for Next.js
+       import { useAuth } from "@clerk/clerk-react";
+
+       const { getToken } = useAuth();
+       console.log(getToken({ template: "convex" }));
+       ```
+
+     - Auth0:
+
+       ```tsx
+       import { useAuth0 } from "@auth0/auth0-react";
+
+       const { getAccessTokenSilently } = useAuth0();
+       const response = await getAccessTokenSilently({
+         detailedResponse: true,
+       });
+       const token = response.id_token;
+       console.log(token);
+       ```
+
+     - Custom: However you implemented `useAuthFromProviderX`
+
+     If you don't see a long string that looks like a token, check the browser
+     logs for errors from your auth provider. If there are none, check the
+     Network tab to see whether requests to your provider are failing. Perhaps
+     the auth provider is misconfigured. Double check the auth provider
+     configuration (in the corresponding React provider or however your auth
+     provider is configured for the client). Try clearing your cookies in the
+     browser (in dev tools _Application_ > _Cookies_ > _Clear all cookies_
+     button).
+
+   **Answer: Yes, I see a long string that looks like a JWT**:
+
+   Great, copy the whole token (there can be `.`s in it, so make sure you're not
+   copying just a portion of it).
+
+4. Open https://jwt.io/, scroll down and paste the token in the Encoded textarea
+   on the left of the page. On the right you should see:
+
+   - In _HEADER_, `"typ": "JWT"`
+   - in _PAYLOAD_, a valid JSON with at least `"aud"`, `"iss"` and `"sub"`
+     fields. If you see gibberish in the payload you probably didn't copy the
+     token correctly or it's not a valid JWT token.
+
+   If you see a valid JWT token, repeat
+   [step 1](#step-1-check-whether-authentication-works-on-the-backend). If you
+   still don't see correct identity, proceed to step 3.
+
+## Step 3: Check that backend configuration matches frontend configuration
+
+You have a valid JWT token on the frontend, and you know that it is being passed
+to the backend, but the backend is not validating it.
+
+1. Open the _Settings_ > _Authentication_ on your dashboard. What do you see?
+
+   **Answer: I see
+   `This deployment has no configured authentication providers`**:
+
+   - Cause: You do not have an `auth.config.ts` (or `auth.config.js`) file in
+     your `convex` directory, or you haven't pushed your code. Follow the
+     authentication guide to create a valid auth config file. For dev
+     deployments make sure you have `npx convex dev` running. For prod
+     deployments make sure you successfully pushed via `npx convex deploy`.
+
+   \*\*Answer: I see one or more _Domain_ and _Application ID_ pairs.
+
+Great, let's check they match the JWT token.
+
+2. Look at the `iss` field in the JWT token payload at https://jwt.io/. Does it
+   match a _Domain_ on the _Authentication_ page?
+
+   **Answer: No, I don't see the `iss` URL on the Convex dashboard**:
+
+   - Potential cause: You copied the wrong value into your
+     <JSDialectFileName name="auth.config.ts" />
+     's `domain`, or into the environment variable that is used there. Go back
+     to the authentication guide and make sure you have the right URL from your
+     auth provider.
+   - Potential cause: Your client is misconfigured:
+
+     - Clerk: You have the wrong `publishableKey` configured. The key must
+       belong to the Clerk instance that you used to configure your
+
+       <JSDialectFileName name="auth.config.ts" />.
+
+       - Also make sure that the JWT token in Clerk is called `convex`, as
+         that's the name `ConvexProviderWithClerk` uses to fetch the token!
+
+     - Auth0: You have the wrong `domain` configured (on the client!). The
+       domain must belong to the Auth0 instance that you used to configure your
+       <JSDialectFileName name="auth.config.ts" />.
+     - Custom: Make sure that your client is correctly configured to match your
+       <JSDialectFileName name="auth.config.ts" />.
+
+   **Answer: Yes, I do see the `iss` URL**:
+
+   Great, let's move one.
+
+3. Look at the `aud` field in the JWT token payload at https://jwt.io/. Does it
+   match the _Application ID_ under the correct _Domain_ on the _Authentication_
+   page?
+
+   **Answer: No, I don't see the `aud` value in the _Application ID_ field**:
+
+   - Potential cause: You copied the wrong value into your
+     <JSDialectFileName name="auth.config.ts" />
+     's `applicationID`, or into the environment variable that is used there. Go
+     back to the authentication guide and make sure you have the right value
+     from your auth provider.
+   - Potential cause: Your client is misconfigured:
+     - Clerk: You have the wrong `publishableKey` configured.The key must belong
+       to the Clerk instance that you used to configure your
+       <JSDialectFileName name="auth.config.ts" />.
+     - Auth0: You have the wrong `clientId` configured. Make sure you're using
+       the right `clientId` for the Auth0 instance that you used to configure
+       your <JSDialectFileName name="auth.config.ts" />.
+     - Custom: Make sure that your client is correctly configured to match your
+       <JSDialectFileName name="auth.config.ts" />.
+
+   **Answer: Yes, I do see the `aud` value in the _Application ID_ field**:
+
+   Great, repeat
+   [step 1](#step-1-check-whether-authentication-works-on-the-backend) and you
+   should be all set!
diff --git a/synced/convex/docs/auth/functions-auth.md b/synced/convex/docs/auth/functions-auth.md
new file mode 100644
index 0000000..5748661
--- /dev/null
+++ b/synced/convex/docs/auth/functions-auth.md
@@ -0,0 +1,145 @@
+---
+title: "Auth in Functions"
+sidebar_label: "Functions"
+sidebar_position: 40
+---
+
+
+
+
+
+_If you're using Convex Auth, see the
+[authorization doc](https://labs.convex.dev/auth/authz#use-authentication-state-in-backend-functions)._
+
+Within a Convex [function](/functions.mdx), you can access information about the
+currently logged-in user by using the [`auth`](/api/interfaces/server.Auth)
+property of the [`QueryCtx`](/generated-api/server#queryctx),
+[`MutationCtx`](/generated-api/server#mutationctx), or
+[`ActionCtx`](/generated-api/server#actionctx) object:
+
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const myMutation = mutation({
+  args: {
+    // ...
+  },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (identity === null) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    //...
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const myMutation = mutation({
+  args: {
+    // ...
+  },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    if (identity === null) {
+      throw new Error("Unauthenticated call to mutation");
+    }
+    //...
+  },
+});
+```
+
+
+## User identity fields
+
+The [UserIdentity](/api/interfaces/server.UserIdentity) object returned by
+`getUserIdentity` is guaranteed to have `tokenIdentifier`, `subject` and
+`issuer` fields. Which other fields it will include depends on the identity
+provider used and the configuration of JWT tokens and
+[OpenID scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).
+
+`tokenIdentifier` is a combination of `subject` and `issuer` to ensure
+uniqueness even when multiple providers are used.
+
+If you followed one of our integrations with Clerk or Auth0 at least the
+following fields will be present: `familyName`, `givenName`, `nickname`,
+`pictureUrl`, `updatedAt`, `email`, `emailVerified`. See their corresponding
+standard definition in the
+[OpenID docs](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).
+
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const myMutation = mutation({
+  args: {
+    // ...
+  },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    const { tokenIdentifier, name, email } = identity!;
+    //...
+  },
+});
+```
+
+```js
+import { mutation } from "./_generated/server";
+
+export const myMutation = mutation({
+  args: {
+    // ...
+  },
+  handler: async (ctx, args) => {
+    const identity = await ctx.auth.getUserIdentity();
+    const { tokenIdentifier, name, email } = identity;
+    //...
+  },
+});
+```
+
+
+### Clerk claims configuration
+
+If you're using Clerk, the fields returned by `getUserIdentity` are determined
+by your JWT template's _Claims_ config. If you've set custom claims, they will
+be returned by `getUserIdentity` as well.
+
+### Custom JWT Auth
+
+If you're using [Custom JWT auth](/auth/advanced/custom-jwt.mdx) instead of
+OpenID standard fields you'll find each nested field available at
+dot-containing-string field names like `identity["properties.email"]`.
+
+## HTTP Actions
+
+You can also access the user identity from an HTTP action
+[`ctx.auth.getUserIdentity()`](/api/interfaces/server.Auth#getuseridentity), by
+calling your endpoint with an `Authorization` header including a JWT token:
+
+
+```ts
+const jwtToken = "...";
+
+fetch("https://<deployment name>.convex.site/myAction", {
+  headers: {
+    Authorization: `Bearer ${jwtToken}`,
+  },
+});
+```
+
+```ts
+const jwtToken = "...";
+
+fetch("https://<deployment name>.convex.site/myAction", {
+  headers: {
+    Authorization: `Bearer ${jwtToken}`,
+  },
+});
+```
+
+
+<StackPosts query="authentication functions" />
diff --git a/synced/convex/docs/cli.md b/synced/convex/docs/cli.md
new file mode 100644
index 0000000..3f44f7f
--- /dev/null
+++ b/synced/convex/docs/cli.md
@@ -0,0 +1,280 @@
+---
+title: "CLI"
+sidebar_position: 110
+slug: "cli"
+---
+
+The Convex command-line interface (CLI) is your interface for managing Convex
+projects and Convex functions.
+
+To install the CLI, run:
+
+```sh
+npm install convex
+```
+
+You can view the full list of commands with:
+
+```sh
+npx convex
+```
+
+## Configure
+
+### Create a new project
+
+The first time you run
+
+```sh
+npx convex dev
+```
+
+it will ask you to log in your device and create a new Convex project. It will
+then create:
+
+1. The `convex/` directory: This is the home for your query and mutation
+   functions.
+2. `.env.local` with `CONVEX_DEPLOYMENT` variable: This is the main
+   configuration for your Convex project. It is the name of your development
+   deployment.
+
+### Recreate project configuration
+
+Run
+
+```sh
+npx convex dev
+```
+
+in a project directory without a set `CONVEX_DEPLOYMENT` to configure a new or
+existing project.
+
+### Log out
+
+```sh
+npx convex logout
+```
+
+Remove the existing Convex credentials from your device, so subsequent commands
+like `npx convex dev` can use a different Convex account.
+
+## Develop
+
+### Run the Convex dev server
+
+```sh
+npx convex dev
+```
+
+Watches the local filesystem. When you change a [function](/functions.mdx) or
+the [schema](/database/schemas.mdx), the new versions are pushed to your dev
+deployment and the [generated types](/generated-api/) in `convex/_generated` are
+updated. By default, logs from your dev deployment are displayed in the
+terminal.
+
+It's also possible to
+[run a Convex deployment locally](/cli/local-deployments-for-dev.mdx) for
+development.
+
+### Open the dashboard
+
+```sh
+npx convex dashboard
+```
+
+Open the [Convex dashboard](./dashboard).
+
+### Open the docs
+
+```sh
+npx convex docs
+```
+
+Get back to these docs!
+
+### Run Convex functions
+
+```sh
+npx convex run <functionName> [args]
+```
+
+Run a public or internal Convex query, mutation, or action on your development
+deployment.
+
+Arguments are specified as a JSON object.
+
+```sh
+npx convex run messages:send '{"body": "hello", "author": "me"}'
+```
+
+Add `--watch` to live update the results of a query. Add `--push` to push local
+code to the deployment before running the function.
+
+Use `--prod` to run functions in the production deployment for a project.
+
+### Tail deployment logs
+
+You can choose how to pipe logs from your dev deployment to your console:
+
+```sh
+# Show all logs continuously
+npx convex dev --tail-logs always
+
+# Pause logs during deploys to see sync issues (default)
+npx convex dev
+
+# Don't display logs while developing
+npx convex dev --tail-logs disable
+
+# Tail logs without deploying
+npx convex logs
+```
+
+Use `--prod` with `npx convex logs` to tail the prod deployment logs instead.
+
+### Import data from a file
+
+```sh
+npx convex import --table <tableName> <path>
+npx convex import <path>.zip
+```
+
+See description and use-cases:
+[data import](/database/import-export/import.mdx).
+
+### Export data to a file
+
+```sh
+npx convex export --path <directoryPath>
+npx convex export --path <filePath>.zip
+npx convex export --include-file-storage --path <path>
+```
+
+See description and use-cases:
+[data export](/database/import-export/export.mdx).
+
+### Display data from tables
+
+```sh
+npx convex data  # lists tables
+npx convex data <table>
+```
+
+Display a simple view of the
+[dashboard data page](/dashboard/deployments/data.md) in the command line.
+
+The command supports `--limit` and `--order` flags to change data displayed. For
+more complex filters, use the dashboard data page or write a
+[query](/database/reading-data/reading-data.mdx).
+
+The `npx convex data <table>` command works with
+[system tables](/database/advanced/system-tables.mdx), such as `_storage`, in
+addition to your own tables.
+
+### Read and write environment variables
+
+```sh
+npx convex env list
+npx convex env get <name>
+npx convex env set <name> <value>
+npx convex env remove <name>
+```
+
+See and update the deployment environment variables which you can otherwise
+manage on the dashboard
+[environment variables settings page](/dashboard/deployments/settings.md#environment-variables).
+
+## Deploy
+
+### Deploy Convex functions to production
+
+```sh
+npx convex deploy
+```
+
+The target deployment to push to is determined like this:
+
+1. If the `CONVEX_DEPLOY_KEY` environment variable is set (typical in CI), then
+   it is the deployment associated with that key.
+2. If the `CONVEX_DEPLOYMENT` environment variable is set (typical during local
+   development), then the target deployment is the production deployment of the
+   project that the deployment specified by `CONVEX_DEPLOYMENT` belongs to. This
+   allows you to deploy to your prod deployment while developing against your
+   dev deployment.
+
+This command will:
+
+1. Run a command if specified with `--cmd`. The command will have CONVEX_URL (or
+   similar) environment variable available:
+   ```sh
+   npx convex deploy --cmd "npm run build"
+   ```
+   You can customize the URL environment variable name with
+   `--cmd-url-env-var-name`:
+   ```sh
+   npx convex deploy --cmd 'npm run build' --cmd-url-env-var-name CUSTOM_CONVEX_URL
+   ```
+1. Typecheck your Convex functions.
+1. Regenerate the [generated code](/generated-api/) in the `convex/_generated`
+   directory.
+1. Bundle your Convex functions and their dependencies.
+1. Push your functions, [indexes](/database/reading-data/indexes/indexes.md),
+   and [schema](/database/schemas.mdx) to production.
+
+Once this command succeeds the new functions will be available immediately.
+
+### Deploy Convex functions to a [preview deployment](/production/hosting/preview-deployments.mdx)
+
+```sh
+npx convex deploy
+```
+
+When run with the `CONVEX_DEPLOY_KEY` environment variable containing a Preview
+Deploy Key, this command will:
+
+1. Create a deployment with the specified name. `npx convex deploy` will infer
+   the Git branch name for Vercel, Netlify, GitHub, and GitLab environments, but
+   the `--preview-create` option can be used to customize the name associated
+   with the newly created deployment.
+   ```
+   npx convex deploy --preview-create my-branch-name
+   ```
+1. Run a command if specified with `--cmd`. The command will have CONVEX_URL (or
+   similar) environment variable available:
+
+   ```sh
+   npx convex deploy --cmd "npm run build"
+   ```
+
+   You can customize the URL environment variable name with
+   `--cmd-url-env-var-name`:
+
+   ```sh
+   npx convex deploy --cmd 'npm run build' --cmd-url-env-var-name CUSTOM_CONVEX_URL
+   ```
+
+1. Typecheck your Convex functions.
+1. Regenerate the [generated code](/generated-api/) in the `convex/_generated`
+   directory.
+1. Bundle your Convex functions and their dependencies.
+1. Push your functions, [indexes](/database/reading-data/indexes/indexes.md),
+   and [schema](/database/schemas.mdx) to the deployment.
+1. Run a function specified by `--preview-run` (similar to the `--run` option
+   for `npx convex dev`).
+
+   ```sh
+   npx convex deploy --preview-run myFunction
+   ```
+
+See the [Vercel](/production/hosting/vercel.mdx#preview-deployments) or
+[Netlify](/production/hosting/netlify.mdx#deploy-previews) hosting guide for
+setting up frontend and backend previews together.
+
+### Update generated code
+
+```sh
+npx convex codegen
+```
+
+Update the [generated code](/generated-api/) in `convex/_generated` without
+pushing. This can be useful for orchestrating build steps in CI.
diff --git a/synced/convex/docs/cli/local-deployments-for-dev.md b/synced/convex/docs/cli/local-deployments-for-dev.md
new file mode 100644
index 0000000..f22e73c
--- /dev/null
+++ b/synced/convex/docs/cli/local-deployments-for-dev.md
@@ -0,0 +1,125 @@
+---
+title: "Local Deployments for Development"
+slug: "local-deployments"
+sidebar_label: "Local Deployments"
+---
+
+Instead of syncing code to a Convex dev deployment hosted in the cloud, you can
+develop against a deployment running on your own computer. You can even use the
+Convex dashboard with local deployments!
+
+## Background on deployments in Convex
+
+Each Convex deployment contains its own data, functions, scheduled functions,
+etc. A project has one production deployment, up to one cloud deployment for
+development per team member, and potentially many transient
+[preview deployments](/production/hosting/preview-deployments.mdx).
+
+You can also develop with Convex using a deployment running on your own machine.
+Since the deployment is running locally, code sync is faster and means resources
+like functions calls and database bandwidth don't count against
+[the quotas for your Convex plan](https://www.convex.dev/pricing).
+
+You can use local deployments with an existing Convex project, and view your
+deployment in the Convex dashboard under your project. You can also use local
+deployments without a Convex account and debug and inspect them with a locally
+running version of the Convex dashboard.
+
+## Using local deployments
+
+<BetaAdmonition feature="Local deployments" verb="are" />
+
+While using local deployments, the local Convex backend runs as a subprocess of
+the `npx convex dev` command and exits when that command is stopped. This means
+a `convex dev` command must be running in order to run other commands like
+`npx convex run` against this local deployment or for your frontend to connect
+to this deployment.
+
+State for local backends is stored the `~/.convex/` directory.
+
+### Anonymous development
+
+You can use local deployments to develop with Convex without having to create an
+account. Whenever you want to create an account to deploy your app to production
+or to use more Convex features, you can use `npx convex login` to link your
+local deployments with your account.
+
+### Local deployments for an existing project
+
+To use a local deployment for an existing project, run:
+
+```sh
+npx convex dev --local --once
+```
+
+You'll also always be given the option for a local deployment if you run
+`npx convex dev --configure`. Other flows may assume you want a cloud deployment
+in some situations, for example when connecting to a project for which you
+already have a cloud development deployment.
+
+## Local deployments vs. production
+
+Local deployments are not recommended for production use: they're development
+deployments, i.e. logs for function results and full stack traces for error
+responses are sent to connected clients.
+
+For running a production application, you can use a production deployment hosted
+on the Convex cloud. Learn more about deploying to production
+[here](/production.mdx).
+
+Alternatively, you can self-host a production deployment using the
+[open source convex-backend repo](https://github.com/get-convex/convex-backend).
+
+### Disabling
+
+To stop using local developments for a project, run the following:
+
+```sh
+npx convex disable-local-deployments
+```
+
+Remember your cloud dev deployment and each local dev deployment are completely
+separate, so contain different data. When switching between deployments you may
+wish to [export and re-import](/database/import-export/import-export.mdx) the
+data to keep using it.
+
+## Limitations
+
+- **No Public URL** - Cloud deployments have public URL to receive incoming HTTP
+  requests from services like Twilio, but local deployments listen for HTTP
+  requests on your own computer. Similarly, you can't power websites with Convex
+  WebSocket connections unless your users browsers know how to reach your
+  computer. Set up a proxy like ngrok or use a cloud deployment for these uses
+  cases.
+
+- **Node actions require specific Node.js versions** - Running Node.js actions
+  (actions defined in files with `"use node;"`) requires having Node.js 18
+  installed, since this is the version of Node.js used in production when
+  Node.js actions run in AWS Lambda functions. To resolve this you can install
+  and set up [nvm](https://github.com/nvm-sh/nvm) and then install Node.js
+  version 18. You don't need to use Node.js 18 for the rest of your project.
+
+- **Node.js actions run directly on your computer** - Like a normal Node.js
+  server, code running in Node.js actions has unrestricted filesystem access.
+  Queries, mutations, and Convex runtime actions still run in isolated
+  environments.
+
+- Logs get cleared out every time a `npx convex dev` command is restarted.
+
+- <a id="safari"></a> **Using the dashboard with Safari**: Safari [blocks
+  requests to localhost](https://bugs.webkit.org/show_bug.cgi?id=171934), which
+  prevents the dashboard from working with local deployments. We recommend using
+  another browser if you’re using local deployments.
+
+- <a id="brave"></a> **Using the dashboard with Brave**: Brave [blocks requests
+  to localhost by
+  default](https://brave.com/privacy-updates/27-localhost-permission/), which
+  prevents the dashboard from working with local deployments. You can use the
+  following workaround:
+  - Go to `brave://flags/`
+  - Enable the `#brave-localhost-access-permission` flag
+  - Go back to the Convex dashboard
+  - Click on **View Site Information** 
+    (<img src="/screenshots/brave-site-information.png" alt="View Site Information icon" width={24} style={{ verticalAlign: "middle" }} />)
+    in the URL bar, then on **Site settings**
+  - Change the setting for **Localhost access** to **Allow**
diff --git a/synced/convex/docs/client-server.svg b/synced/convex/docs/client-server.svg
new file mode 100644
index 0000000..a1fe3e5
--- /dev/null
+++ b/synced/convex/docs/client-server.svg
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Do not edit this file with editors other than diagrams.net -->
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="491px" height="192px" viewBox="-0.5 -0.5 491 192" content="&lt;mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2022-03-29T00:15:47.091Z&quot; agent=&quot;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.83 Safari/537.36&quot; etag=&quot;CQjiZ8RtNAPi9QkLsaX3&quot; version=&quot;17.2.4&quot; type=&quot;device&quot;&gt;&lt;diagram id=&quot;tWkWc931Rn5FPuITeH9m&quot; name=&quot;Page-1&quot;&gt;tVjbctowEP0aHtuxLWPgkVuSTm9p6UyTvglbsdUIixEyl359V7ZkW8gQ0obkIezRaqXdsxeRHpqu9rcCr7PPPCGsF3jJvodmvSDwvZEHfxRyqJChH1RAKmiilRpgQf8Qs1OjBU3IxlKUnDNJ1zYY8zwnsbQwLATf2WpPnNmnrnFKHGARY+aiP2kiM+1F32vwO0LTzJzse3plhY2yBjYZTviuBaF5D00F57L6tNpPCVPBM3Gp9t2cWK0vJkguL9mQxT/HYfQl2n74dT9/OCwev3z8/s6wscWs0B5Peb4le8CmjBeJvrs8mICAUYg9CBNwaK3AuNRDk11GJVmscazAHaQDYJlcMZB8pS4FfyZTzrgoLaFkMFpCtNDkiTLWwuejCQpDwLdESApUjBlNc1iTvDTJBf3Dc4lrw3AkzVOQgkb6oXRnoTKfCpxQCFLriNkkjNBYHc0bPCFPuGBSozd4RZlK2jvCtkTdQy8sdCw8I1c560cgu5xompQrZN+CNEe3hK+IFAdQ0atBpPNFF4wfannXpB8ySZa1U8+UGtYpn9a2m6yADzoxXpEkbo58JxhqLfDG67WTIIIXeUISHaEXkqJNfRN/O1VsXlz0DYI+sGMeeKETcx91xPxqIfd9t/ASaExa5EJmPOU5ZvMGnTSRV6FtdD7xshgU+JtIedAZiwvJbTbInsoHRdz7vpYeWyuzvea0FA5GyMHfh7bw2FhQYrOtlMw+hpeETXD8nJbXvpTsjcRCjlVjB3jJePxswBvKaj/y5FgFoJbC72K11lEI1GVgf0rkPREU6CNiUXcUr85G0/1R1fmqVl4uPxMZZ5Zuq9NE5Y/b5J766re6mOkggXGlDZzM7g0vREzO5BDS47L07YzeoNJT+XW2VgRhWNKtPRjfPPPRuYGk2vj/NZyTreXEDBJcgtNcjZ93o3+fJqeGxlmGL+9f/mAABWe1sCAySKuJjTp6WNi/EpMDh8lvBVQYvObgsBxeFt7nogru5u2GSLu0zhQjtwisft6GChQczZLAnd9RBw3RtUbJ0KFhhiV2Il6/5g6MQugFejnuy4qkT8saqNv510KCGWKKTmf7C6ScorHqxhMuJV+pR911CQzDIwJ9l8BhB4HDq70F3EJyHwfuxOuclC327NeCNdJenM3WzOvueq8YqUHHRP7XZ0Up1aeaG766QXS8KGzpSjN7cOHMHl44s9sP2M4vDQa8eLjrM+45VaO47np9u2hq2ZioPNe72t9SjwyFR4aCY0M6r44NlZVVO95VbCA2X7Yr9eZfFmj+Fw==&lt;/diagram&gt;&lt;/mxfile&gt;" style="background-color: rgb(255, 255, 255);"><defs><linearGradient x1="0%" y1="0%" x2="0%" y2="100%" id="mx-gradient-e9b344-1-db463a-1-s-0"><stop offset="0%" style="stop-color: rgb(233, 179, 68); stop-opacity: 1;"/><stop offset="100%" style="stop-color: rgb(219, 70, 58); stop-opacity: 1;"/></linearGradient></defs><g><path d="M 265 47.5 C 205 47.5 190 95 238 104.5 C 190 125.4 244 171 283 152 C 310 190 400 190 430 152 C 490 152 490 114 452.5 95 C 490 57 430 19 377.5 38 C 340 9.5 280 9.5 265 47.5 Z" fill="url(#mx-gradient-e9b344-1-db463a-1-s-0)" stroke="#d79b00" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe flex-start; justify-content: unsafe center; width: 298px; height: 1px; padding-top: 47px; margin-left: 191px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 16px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Convex Cloud</div></div></div></foreignObject><text x="340" y="63" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="16px" text-anchor="middle">Convex Cloud</text></switch></g><rect x="0" y="64" width="130" height="90" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 128px; height: 1px; padding-top: 109px; margin-left: 1px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">React App</div></div></div></foreignObject><text x="65" y="113" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">React App</text></switch></g><path d="M 193.35 109.02 L 202.92 109.03 Q 212.48 109.03 222.07 109.28 L 231.65 109.53" fill="none" stroke="#666666" stroke-width="3" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 178.35 109 L 193.36 101.52 L 193.35 116.52 Z" fill="#666666" stroke="#666666" stroke-width="3" stroke-miterlimit="10" pointer-events="all"/><path d="M 246.65 109.91 L 231.46 117.03 L 231.85 102.03 Z" fill="#666666" stroke="#666666" stroke-width="3" stroke-miterlimit="10" pointer-events="all"/><rect x="107.5" y="86.5" width="90" height="45" fill="url(#mx-gradient-e9b344-1-db463a-1-s-0)" stroke="rgb(0, 0, 0)" transform="rotate(-90,152.5,109)" pointer-events="all"/><g transform="translate(-0.5 -0.5)rotate(-90 152.5 109)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 88px; height: 1px; padding-top: 109px; margin-left: 109px;"><div data-drawio-colors="color: rgb(0, 0, 0); " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Convex Client</div></div></div></foreignObject><text x="153" y="113" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Convex Client</text></switch></g><rect x="250" y="80" width="60" height="60" fill="#f5f5f5" stroke="#666666" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 58px; height: 1px; padding-top: 110px; margin-left: 251px;"><div data-drawio-colors="color: #333333; " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Queries and Mutations</div></div></div></foreignObject><text x="280" y="114" fill="#333333" font-family="Helvetica" font-size="12px" text-anchor="middle">Queries an...</text></switch></g><path d="M 370 85 C 370 76.72 387.91 70 410 70 C 420.61 70 430.78 71.58 438.28 74.39 C 445.79 77.21 450 81.02 450 85 L 450 135 C 450 143.28 432.09 150 410 150 C 387.91 150 370 143.28 370 135 Z" fill="#f5f5f5" stroke="#666666" stroke-miterlimit="10" pointer-events="all"/><path d="M 450 85 C 450 93.28 432.09 100 410 100 C 387.91 100 370 93.28 370 85" fill="none" stroke="#666666" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow: visible; text-align: left;"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 78px; height: 1px; padding-top: 121px; margin-left: 371px;"><div data-drawio-colors="color: #333333; " style="box-sizing: border-box; font-size: 0px; text-align: center;"><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Data</div></div></div></foreignObject><text x="410" y="124" fill="#333333" font-family="Helvetica" font-size="12px" text-anchor="middle">Data</text></switch></g><path d="M 326.24 110 L 353.76 110" fill="none" stroke="#666666" stroke-width="2" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 312.24 110 L 326.24 103 L 326.24 117 Z" fill="#666666" stroke="#666666" stroke-width="2" stroke-miterlimit="10" pointer-events="all"/><path d="M 367.76 110 L 353.76 117 L 353.76 103 Z" fill="#666666" stroke="#666666" stroke-width="2" stroke-miterlimit="10" pointer-events="all"/></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Text is not SVG - cannot display</text></a></switch></svg>
\ No newline at end of file
diff --git a/synced/convex/docs/client/android.md b/synced/convex/docs/client/android.md
new file mode 100644
index 0000000..48c0259
--- /dev/null
+++ b/synced/convex/docs/client/android.md
@@ -0,0 +1,308 @@
+---
+title: "Android Kotlin"
+sidebar_label: "Android Kotlin"
+sidebar_position: 600
+---
+
+Convex Android client library enables your Android application to interact with
+your Convex backend. It allows your frontend code to:
+
+1. Call
+   your [queries](/functions/query-functions.mdx), [mutations](/functions/mutation-functions.mdx) and [actions](/functions/actions.mdx)
+2. Authenticate users using [Auth0](/auth/auth0.mdx)
+
+The library is open source and
+[available on GitHub](https://github.com/get-convex/convex-mobile/tree/main/android).
+
+Follow the [Android Quickstart](/quickstart/android.mdx) to get started.
+
+## Installation
+
+You'll need to make the following changes to your app's `build.gradle[.kts]`
+file.
+
+```kotlin
+plugins {
+    // ... existing plugins
+    kotlin("plugin.serialization") version "1.9.0"
+}
+
+dependencies {
+    // ... existing dependencies
+    implementation("dev.convex:android-convexmobile:0.4.1@aar") {
+        isTransitive = true
+    }
+    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
+}
+```
+
+After that, sync Gradle to pick up those changes. Your app will now have access
+to the Convex for Android library as well as Kotlin's JSON serialization which
+is used to communicate between your code and the Convex backend.
+
+## Connecting to a backend
+
+The `ConvexClient` is used to establish and maintain a connect between your
+application and the Convex backend. First you need to create an instance of the
+client by giving it your backend deployment URL:
+
+```kotlin
+package com.example.convexapp
+
+import dev.convex.android.ConvexClient
+
+val convex = ConvexClient("https://<your domain here>.convex.cloud")
+```
+
+You should create and use one instance of the `ConvexClient` for the lifetime of
+your application process. It can be convenient to create a custom Android
+[`Application`](https://developer.android.com/reference/android/app/Application)
+subclass and initialize it there:
+
+```kotlin
+package com.example.convexapp
+
+import android.app.Application
+import dev.convex.android.ConvexClient
+
+class MyApplication : Application() {
+    lateinit var convex: ConvexClient
+
+    override fun onCreate() {
+        super.onCreate()
+        convex = ConvexClient("https://<your domain here>.convex.cloud")
+    }
+}
+```
+
+Once you've done that, you can access the client from a Jetpack Compose
+`@Composable` function like this:
+
+```kotlin
+val convex = (application as MyApplication).convex
+```
+
+## Fetching data
+
+Convex for Android gives you access to the Convex
+[reactor](https://docs.convex.dev/tutorial/reactor), which enables real-time
+_subscriptions_ to query results. You subscribe to queries with the `subscribe`
+method on `ConvexClient` which returns a `Flow`. The contents of the `Flow` will
+change over time as the underlying data backing the query changes.
+
+All methods on `ConvexClient` suspend, and need to be called from a
+`CoroutineScope` or another `suspend` function. A simple way to consume a query
+that returns a list of strings from a `@Composable` is to use a combination of
+mutable state containing a list and `LaunchedEffect`:
+
+```kotlin
+var workouts: List<String> by remember { mutableStateOf(listOf()) }
+LaunchedEffect("onLaunch") {
+    client.subscribe<List<String>>("workouts:get").collect { result ->
+        result.onSuccess { receivedWorkouts ->
+            workouts = receivedWorkouts
+        }
+    }
+}
+```
+
+Any time the data that powers the backend `"workouts:get"` query changes, a new
+`Result<List<String>>` will be emitted into the `Flow` and the `workouts` list
+will refresh with the new data. Any UI that uses `workouts` will then rebuild,
+giving you a fully reactive UI.
+
+Note: you may prefer to put the subscription logic wrapped a Repository as
+described in the
+[Android architecture patterns](https://developer.android.com/topic/architecture/data-layer).
+
+### Query arguments
+
+You can pass arguments to `subscribe` and they will be supplied to the
+associated backend `query` function. The arguments are typed as
+`Map<String, Any?>`. The values in the map must be primitive values or other
+maps and lists.
+
+```kotlin
+val favoriteColors = mapOf("favoriteColors" to listOf("blue", "red"))
+client.subscribe<List<String>>("users:list", args = favoriteColors)
+```
+
+Assuming a backend query that accepts a `favoriteColors` argument, the value can
+be received and used to perform logic in the query function.
+
+<Admonition type="tip">
+Use serializable [Kotlin Data classes](/client/android/data-types.md#custom-data-types)
+to automatically convert Convex objects to Kotlin model classes.
+</Admonition>
+
+<Admonition type="caution">
+* There are important gotchas when
+  [sending and receiving numbers](/client/android/data-types.md#numerical-types)
+  between Kotlin and Convex.
+* `_` is a used to signify private fields in Kotlin. If you want to use a
+  `_creationTime` and `_id` Convex fields directly without warnings you'll have
+  to
+  [convert the field name in Kotlin](/client/android/data-types.md#field-name-conversion).
+* Depending on your backend functions, you may need to deal with
+  [reserved Kotlin keywords](/client/android/data-types.md#field-name-conversion).
+</Admonition>
+
+### Subscription lifetime
+
+The `Flow` returned from `subscribe` will persist as long as something is
+waiting to consume results from it. When a `@Composable` or `ViewModel` with a
+subscription goes out of scope, the underlying query subscription to Convex will
+be canceled.
+
+## Editing data
+
+You can use the `mutation` method on `ConvexClient` to trigger a backend
+[mutation](https://docs.convex.dev/functions/mutation-functions).
+
+You'll need to use it in another `suspend` function or a `CoroutineScope`.
+Mutations can return a value or not. If you expect a type in the response,
+indicate it in the call signature.
+
+Mutations can also receive arguments, just like queries. Here's an example of
+returning a type from a mutation with arguments:
+
+```kotlin
+val recordsDeleted = convex.mutation<@ConvexNum Int>(
+  "messages:cleanup",
+  args = mapOf("keepLatest" to 100)
+)
+```
+
+If an error occurs during a call to `mutation`, it will throw an exception.
+Typically you may want to catch
+[`ConvexError`](https://docs.convex.dev/functions/error-handling/application-errors)
+and `ServerError` and handle them however is appropriate in your application.
+See documentation on
+[error handling](https://docs.convex.dev/functions/error-handling/) for more
+details.
+
+## Calling third-party APIs
+
+You can use the `action` method on `ConvexClient` to trigger a backend
+[action](https://docs.convex.dev/functions/actions).
+
+Calls to `action` can accept arguments, return values and throw exceptions just
+like calls to `mutation`.
+
+Even though you can call actions from Android, it's not always the right choice.
+See the action docs for tips on
+[calling actions from clients](https://docs.convex.dev/functions/actions#calling-actions-from-clients).
+
+## Authentication with Auth0
+
+You can use `ConvexClientWithAuth` in place of `ConvexClient` to configure
+authentication with [Auth0](https://auth0.com/). You'll need the
+`convex-android-auth0` library to do that, as well as an Auth0 account and
+application configuration.
+
+See the
+[README](https://github.com/get-convex/convex-android-auth0/blob/main/README.md)
+in the `convex-android-auth0` repo for more detailed setup instructions, and the
+[Workout example app](https://github.com/get-convex/android-convex-workout)
+which is configured for Auth0. The overall
+[Convex authentication docs](https://docs.convex.dev/auth) are a good resource
+as well.
+
+It should also be possible to integrate other similar OpenID Connect
+authentication providers. See the
+[`AuthProvider`](https://github.com/get-convex/convex-mobile/blob/5babd583631a7ff6d739e1a2ab542039fd532548/android/convexmobile/src/main/java/dev/convex/android/ConvexClient.kt#L291)
+interface in the `convex-mobile` repo for more info.
+
+## Production and dev deployments
+
+When you're ready to move toward
+[production](https://docs.convex.dev/production) for your app, you can setup
+your Android build system to point different builds or flavors of your
+application to different Convex deployments. One fairly simple way to do it is
+by passing different values (e.g. deployment URL) to different build targets or
+flavors.
+
+Here's a simple example that shows using different deployment URLs for release
+and debug builds:
+
+```kotlin
+// In the android section of build.gradle.kts:
+buildTypes {
+    release {
+        // Snip various other config like ProGuard ...
+        resValue("string", "convex_url", "YOUR_PROD.convex.cloud")
+    }
+
+    debug {
+        resValue("string", "convex_url", "YOUR_DEV.convex.cloud")
+    }
+}
+```
+
+Then you can build your `ConvexClient` using a single resource in code, and it
+will get the right value at compile time.
+
+```kotlin
+val convex = ConvexClient(context.getString(R.string.convex_url))
+```
+
+<Admonition type="tip">
+You may not want these urls checked into your repository. One pattern is to 
+create a custom `my_app.properties` file that is configured to be ignored in
+your `.gitignore` file. You can then read this file in your `build.gradle.kts` 
+file. You can see this pattern in use in the
+[workout sample app](https://github.com/get-convex/android-convex-workout?tab=readme-ov-file#configuration).
+</Admonition>
+
+## Structuring your application
+
+The examples shown in this guide are intended to be brief, and don't provide
+guidance on how to structure a whole application.
+
+The official
+[Android application architecture](https://developer.android.com/topic/architecture/intro)
+docs cover best practices for building applications, and Convex also has a
+[sample open source application](https://github.com/get-convex/android-convex-workout/tree/main)
+that attempts to demonstrate what a small multi-screen application might look
+like.
+
+In general, do the following:
+
+1. Embrace Flows and
+   [unidirectional data flow](https://developer.android.com/develop/ui/compose/architecture#udf)
+2. Have a clear
+   [data layer](https://developer.android.com/topic/architecture/data-layer)
+   (use Repository classes with `ConvexClient` as your data source)
+3. Hold UI state in a
+   [ViewModel](https://developer.android.com/topic/architecture/recommendations#viewmodel)
+
+## Testing
+
+`ConvexClient` is an `open` class so it can be mocked or faked in unit tests. If
+you want to use more of the real client, you can pass a fake
+`MobileConvexClientInterface` in to the `ConvexClient` constructor. Just be
+aware that you'll need to provide JSON in Convex's undocumented
+[JSON format](https://github.com/get-convex/convex-mobile/blob/5babd583631a7ff6d739e1a2ab542039fd532548/android/convexmobile/src/main/java/dev/convex/android/jsonhelpers.kt#L47).
+
+You can also use the full `ConvexClient` in Android instrumentation tests. You
+can setup a special backend instance for testing or run a local Convex server
+and run full integration tests.
+
+## Under the hood
+
+Convex for Android is built on top of the official
+[Convex Rust client](https://docs.convex.dev/client/rust). It handles
+maintaining a WebSocket connection with the Convex backend and implements the
+full Convex protocol.
+
+All method calls on `ConvexClient` are handled via a Tokio async runtime on the
+Rust side and are safe to call from the application's main thread.
+
+`ConvexClient` also makes heavy use of
+[Kotlin's serialization framework](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md),
+and most of the functionality in that framework is available for you to use in
+your applications. Internally, `ConvexClient` enables the JSON
+[`ignoreUnknownKeys`](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#ignoring-unknown-keys)
+and
+[`allowSpecialFloatingPointValues`](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#allowing-special-floating-point-values)
+features.
diff --git a/synced/convex/docs/client/android/data-types.md b/synced/convex/docs/client/android/data-types.md
new file mode 100644
index 0000000..9b1dacb
--- /dev/null
+++ b/synced/convex/docs/client/android/data-types.md
@@ -0,0 +1,134 @@
+---
+title: "Kotlin and Convex type conversion"
+sidebar_label: "Data Types"
+hidden: false
+sidebar_position: 5
+description:
+  "Customizing and converting types between the Kotlin app and Convex"
+---
+
+## Custom data types
+
+When receiving values from Convex, you aren't limited to primitive values. You
+can create custom `@Serializable` classes that will be automatically decoded
+from response data.
+
+Consider a Convex query function that returns results like this JavaScript
+object:
+
+```jsx
+{
+	name: "Guardians",
+	uniformColors: ["blue", "white", "red"],
+	wins: 80n,
+	losses: 60n
+}
+```
+
+That can be represented in Kotlin using:
+
+```kotlin
+@Serializable
+data class BaseballTeam(
+    val name: String,
+    val uniformColors: List<String>,
+    val wins: @ConvexNum Int,
+    val losses: @ConvexNum Int)
+```
+
+Then you can pass it as the type argument in your `subscribe` call:
+
+```kotlin
+convex.subscribe<Team>("mlb:first_place_team", args = mapOf("division" to "AL Central"))
+```
+
+The data from the remote function will be deserialized to your custom class.
+
+## Numerical types
+
+Your Convex backend code is written in JavaScript, which has two relatively
+common types for numerical data: `number` and `BigInt`.
+
+`number` is used whenever a value is assigned a literal numeric value, whether
+`42` or `3.14`. `BigInt` can be used by adding a trailing `n`, like `42n`.
+Despite the two types, is very common to use `number` for holding either integer
+or floating point values in JavaScript.
+
+Because of this, Convex takes extra care to encode values so they won't lose
+precision. Since technically the `number` type is an IEEE 754 floating point
+value, anytime you get a plain `number` from Convex it will be represented as
+floating point in Kotlin. You can choose to use `Double` or `Float`, depending
+on your needs but be aware that `Float` might lose precision from the original.
+
+It also means that Kotlin's `Long` type (64 bit) can't be safely stored in a
+`number` (only 53 bits are available to encode integers) and requires a
+`BigInt`.
+
+That's a long lead up to explain that in order to represent numerical values in
+responses from Convex, you need to hint to Kotlin that they should use custom
+decoding.
+
+You can do this in three ways. Use whichever seems most useful to your project.
+
+1. Annotate the plain Kotlin type (`Int`, `Long`, `Float`, `Double`) with
+   `@ConvexNum`
+2. Use a provided type alias for those types (`Int32`, `Int64`, `Float32`,
+   `Float64`)
+3. Include a special annotation at the top of any file that defines
+   `@Serializable` classes and just use the plain types with no annotation
+
+   ```kotlin
+   @file:UseSerializers(
+       Int64ToIntDecoder::class,
+       Int64ToLongDecoder::class,
+       Float64ToFloatDecoder::class,
+       Float64ToDoubleDecoder::class
+   )
+
+   package com.example.convexapp
+
+   import kotlinx.serialization.UseSerializers
+
+   // @Serializable classes and things.
+   ```
+
+In the example, JavaScript's `BigInt` type is used by adding a trailing `n` to
+the `wins` and `losses` values which lets the Kotlin code use `Int`. If instead
+the code used regular JavaScript `number` types, on the Kotlin side those would
+be received as floating point values and deserialization would fail.
+
+If you have a situation like that where `number` is used but by convention only
+contains integer values, you can handle that in your `@Serializable` class.
+
+```kotlin
+@Serializable
+data class BaseballTeam(
+    val name: String,
+    val uniformColors: List<String>,
+    @SerialName("wins") private val internalWins: Double,
+    @SerialName("losses") private val internalLosses: Double) {
+
+    // Expose the JavaScript number values as Ints.
+    val wins get() = internalWins.toInt()
+    val losses get() = internalLosses.toInt()
+}
+```
+
+The pattern is to store the `Double` values privately and with different names
+that the value from the backend. Then add accessors to provide the `Int` values.
+
+## Field name conversion
+
+This pattern was used above, but it bears describing on its own. Sometimes a
+value will be produced on the backend with a key that matches a Kotlin keyword
+(`{fun: true}`) or doesn't conform to Kotlin naming conventions (e.g. starts
+with an underscore). You can use `@SerialName` to handle those cases.
+
+For example, here's how you can ingest the Convex
+[document ID](https://docs.convex.dev/database/document-ids) from a backend
+response and convert it to a field name that won't trigger Kotlin lint warnings:
+
+```kotlin
+@Serializable
+data class ConvexDocument(@SerialName("_id") val id: String)
+```
diff --git a/synced/convex/docs/client/javascript.md b/synced/convex/docs/client/javascript.md
new file mode 100644
index 0000000..d2b0c5f
--- /dev/null
+++ b/synced/convex/docs/client/javascript.md
@@ -0,0 +1,154 @@
+---
+title: "JavaScript"
+sidebar_label: "JavaScript"
+sidebar_position: 350
+---
+
+
+# Convex JavaScript Clients
+
+Convex applications can be accessed from Node.js or any JavaScript runtime that
+implements [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) or
+[`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket). The
+reactive [Convex Client](/api/classes/browser.ConvexClient) allows web
+applications and long-running Node.js servers to subscribe to updates on Convex
+queries, while the [Convex HTTP client](/api/classes/browser.ConvexHttpClient)
+is typically used for server-side rendering, migrations, administrative scripts,
+and serverless functions to run queries at a single point in time.
+
+If you're using React, see the dedicated
+[`ConvexReactClient`](/api/classes/browser.ConvexClient) described in
+[React](/client/react.mdx).
+
+## Convex Client
+
+The [`ConvexClient`](/api/classes/browser.ConvexClient) provides subscriptions
+to queries in Node.js and any JavaScript environment that supports WebSockets.
+
+
+
+
+```ts
+import { ConvexClient } from "convex/browser";
+import { api } from "../convex/_generated/api";
+
+const client = new ConvexClient(process.env.CONVEX_URL!);
+
+// subscribe to query results
+client.onUpdate(api.messages.listAll, {}, (messages) =>
+  console.log(messages.map((msg) => msg.body)),
+);
+
+// execute a mutation
+function hello() {
+  client.mutation(api.messages.sendAnon, {
+    body: `hello at ${new Date()}`,
+  });
+}
+```
+
+```js
+import { ConvexClient } from "convex/browser";
+import { api } from "../convex/_generated/api";
+
+const client = new ConvexClient(process.env.CONVEX_URL);
+
+// subscribe to query results
+client.onUpdate(api.messages.listAll, {}, (messages) =>
+  console.log(messages.map((msg) => msg.body)),
+);
+
+// execute a mutation
+function hello() {
+  client.mutation(api.messages.sendAnon, {
+    body: `hello at ${new Date()}`,
+  });
+}
+```
+
+
+The Convex client is open source and available on
+[GitHub](https://github.com/get-convex/convex-js).
+
+See the [Script Tag Quickstart](/quickstart/script-tag.mdx) to get started.
+
+## HTTP client
+
+
+The [`ConvexHttpClient`](/api/classes/browser.ConvexHttpClient) works in the
+browser, Node.js, and any JavaScript environment with `fetch`.
+
+See the [Node.js Quickstart](/quickstart/nodejs.mdx).
+
+
+```ts
+import { ConvexHttpClient } from "convex/browser";
+import { api } from "./convex/_generated/api";
+
+const client = new ConvexHttpClient(process.env["CONVEX_URL"]);
+
+// either this
+const count = await client.query(api.counter.get);
+// or this
+client.query(api.counter.get).then((count) => console.log(count));
+```
+
+```ts
+import { ConvexHttpClient } from "convex/browser";
+import { api } from "./convex/_generated/api";
+
+const client = new ConvexHttpClient(process.env["CONVEX_URL"]);
+
+// either this
+const count = await client.query(api.counter.get);
+// or this
+client.query(api.counter.get).then((count) => console.log(count));
+```
+
+
+## Using Convex without generated `convex/_generated/api.js`
+
+If the source code for your Convex function isn't located in the same project or
+in the same monorepos you can use the untyped `api` object called `anyApi`.
+
+
+
+
+```ts
+import { ConvexClient } from "convex/browser";
+import { anyApi } from "convex/server";
+
+const CONVEX_URL = "http://happy-otter-123";
+const client = new ConvexClient(CONVEX_URL);
+client.onUpdate(anyApi.messages.list, {}, (messages) =>
+  console.log(messages.map((msg) => msg.body)),
+);
+setInterval(
+  () =>
+    client.mutation(anyApi.messages.send, {
+      body: `hello at ${new Date()}`,
+      author: "me",
+    }),
+  5000,
+);
+```
+
+```js
+import { ConvexClient } from "convex/browser";
+import { anyApi } from "convex/server";
+
+const CONVEX_URL = "http://happy-otter-123";
+const client = new ConvexClient(CONVEX_URL);
+client.onUpdate(anyApi.messages.list, {}, (messages) =>
+  console.log(messages.map((msg) => msg.body)),
+);
+setInterval(
+  () =>
+    client.mutation(anyApi.messages.send, {
+      body: `hello at ${new Date()}`,
+      author: "me",
+    }),
+  5000,
+);
+```
+
diff --git a/synced/convex/docs/client/javascript/bun.md b/synced/convex/docs/client/javascript/bun.md
new file mode 100644
index 0000000..63c02b3
--- /dev/null
+++ b/synced/convex/docs/client/javascript/bun.md
@@ -0,0 +1,38 @@
+---
+title: "Bun"
+hidden: false
+sidebar_position: 200
+---
+
+[Bun](https://bun.sh/) can be used to run scripts and servers that use Convex
+clients and can even run the Convex CLI.
+
+Convex supports point-in-time queries, mutations and actions (see
+[HTTP client](/api/classes/browser.ConvexHttpClient)) and those plus query
+subscriptions (see [ConvexClient](/api/classes/browser.ConvexClient)) in Bun.
+
+```js
+import { ConvexHttpClient, ConvexClient } from "convex/browser";
+import { api } from "./convex/_generated/api.js";
+
+// HTTP client
+const httpClient = new ConvexHttpClient(process.env.CONVEX_URL);
+httpClient.query(api.messages.list).then((messages) => {
+  console.log(messages);
+});
+
+// Subscription client
+const client = new ConvexClient(process.env.CONVEX_URL);
+const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) =>
+  console.log(messages),
+);
+await Bun.sleep(1000);
+client.mutate(api.messages.send, {}, { body: "hello!", author: "me" });
+await Bun.sleep(1000);
+```
+
+## Using Convex with Bun without codegen
+
+You can always use the `anyApi` object or strings if you don't have the Convex
+functions and api file handy. An api reference like `api.folder.file.exportName`
+becomes `anyApi.folder.file.exportName` or `"folder/file:exportName"`.
diff --git a/synced/convex/docs/client/javascript/node.md b/synced/convex/docs/client/javascript/node.md
new file mode 100644
index 0000000..c38bbe4
--- /dev/null
+++ b/synced/convex/docs/client/javascript/node.md
@@ -0,0 +1,78 @@
+---
+title: "Node.js"
+hidden: false
+sidebar_position: 100
+---
+
+Convex supports point-in-time queries (see
+[HTTP client](/api/classes/browser.ConvexHttpClient)) and query subscriptions
+(see [ConvexClient](/api/classes/browser.ConvexClient)) in Node.js.
+
+If your JavaScript code uses import/export syntax, calling Convex functions
+works just like in a browser.
+
+```js
+import { ConvexHttpClient, ConvexClient } from "convex/browser";
+import { api } from "./convex/_generated/api.js";
+
+// HTTP client
+const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
+httpClient.query(api.messages.list).then(console.log);
+
+// Subscription client
+const client = new ConvexClient(CONVEX_URL_GOES_HERE);
+client.onUpdate(api.messages.list, {}, (messages) => console.log(messages));
+```
+
+## TypeScript
+
+Just like bundling for the browser, bundling TypeScript code for Node.js with
+webpack, esbuild, rollup, vite, and others usually allow you import from code
+that uses import/export syntax with no extra setup.
+
+If you use TypeScript to _compile_ your code (this is rare for web projects but
+more common with Node.js), add `"allowJs": true` to `tsconfig.json` compiler
+options so that TypeScript will compile the `api.js` file as well.
+
+## TypeScript without a compile step
+
+If you want to run your TypeScript script directly without a compile step,
+installing [ts-node-esm](https://www.npmjs.com/package/ts-node) and running your
+script with ts-node-esm should work if you use `"type": "module"` in your
+`package.json`.
+
+## JavaScript with CommonJS (`require()` syntax)
+
+If you don't use `"type": "module"` in the `package.json` of your project you'll
+need to use `require()` syntax and Node.js will not be able to import the
+`convex/_generated/api.js` file directly.
+
+In the same directory as your `package.json`, create or edit
+[`convex.json`](/production/project-configuration.mdx#convexjson):
+
+```json title=convex.json
+{
+  "generateCommonJSApi": true
+}
+```
+
+When the `convex dev` command generates files in `convex/_generated/` a new
+`api_cjs.cjs` file will be created which can be imported from CommonJS code.
+
+```js
+const { ConvexHttpClient, ConvexClient } = require("convex/browser");
+const { api } = require("./convex/_generated/api_cjs.cjs");
+const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
+```
+
+## TypeScript with CommonJS without a compile step
+
+Follow the steps above for CommonJS and use
+[`ts-node`](https://www.npmjs.com/package/ts-node) to run you code. Be sure your
+`tsconfig.json` is configured for CommonJS output.
+
+## Using Convex with Node.js without codegen
+
+You can always use the `anyApi` object or strings if you don't have the Convex
+functions and api file handy. An api reference like `api.folder.file.exportName`
+becomes `anyApi.folder.file.exportName` or `"folder/file:exportName"`.
diff --git a/synced/convex/docs/client/javascript/script-tag.md b/synced/convex/docs/client/javascript/script-tag.md
new file mode 100644
index 0000000..b11fdf6
--- /dev/null
+++ b/synced/convex/docs/client/javascript/script-tag.md
@@ -0,0 +1,79 @@
+---
+title: "Script Tag"
+sidebar_position: 100
+---
+
+Sometimes you just want to get your data on a web page: no installing packages,
+no build steps, no TypeScript. Subscribing to queries deployed to an existing
+Convex deployment from a script tag is simple.
+
+
+
+
+
+```html
+<!doctype html>
+<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
+<script>
+  const CONVEX_URL = "http://localhost:8000";
+  const client = new convex.ConvexClient(CONVEX_URL);
+  client.onUpdate("messages:list", {}, (messages) =>
+    console.log(messages.map((msg) => msg.body)),
+  );
+</script>
+```
+
+
+VS Code doesn't support TypeScript autocompletion in HTML files so for types and
+better autocompletion you can split your code out into a script file:
+
+
+```html
+<!doctype html>
+<form>
+  <input placeholder="type here" />
+</form>
+<div class="messages"></div>
+
+<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
+<!--VS Code TypeScript autocompletion doesn't work in HTML files so use a file-->
+<script src="./script.js"></script>
+```
+
+
+```js
+const CONVEX_URL = "http://localhost:8000";
+
+// These JSDoc type annotations help VS Code find types.
+/** @type {import("convex/browser")["ConvexClient"]} */
+const ConvexClient = convex.ConvexClient;
+const client = new ConvexClient(CONVEX_URL);
+
+/** @type {import("./convex/_generated/api")["api"]} */
+const api = convex.anyApi;
+
+client.onUpdate(api.messages.list, {}, (messages) => {
+  console.log(messages);
+  const container = document.querySelector(".messages");
+  container.innerHTML = "";
+  for (const message of messages.reverse()) {
+    const li = document.createElement("li");
+    li.textContent = `${message.author}: ${message.body}`;
+    container.appendChild(li);
+  }
+});
+
+document.querySelector("form").addEventListener("submit", (e) => {
+  e.preventDefault();
+  const inp = e.target.querySelector("input");
+  client.mutation(api.messages.send, {
+    body: inp.value,
+    author: "me",
+  });
+  inp.value = "";
+});
+```
+
+
+See the [Script Tag Quickstart](/quickstart/script-tag.mdx) for instructions for
+setting up a new Convex project.
diff --git a/synced/convex/docs/client/open-api.md b/synced/convex/docs/client/open-api.md
new file mode 100644
index 0000000..e237088
--- /dev/null
+++ b/synced/convex/docs/client/open-api.md
@@ -0,0 +1,161 @@
+---
+title: "OpenAPI & Other Languages"
+sidebar_label: "OpenAPI"
+sidebar_position: 325
+---
+
+
+
+Convex doesn’t have explicit support for many languages including Go, Java, and
+C++. However, you can generate [OpenAPI](https://swagger.io/specification/)
+specifications from your Convex deployment to create type-safe clients for
+languages that aren't currently supported. Under the hood, this uses our
+[HTTP API](/http-api). This means that your queries will not be
+reactive/real-time.
+
+<BetaAdmonition feature="OAS generation" verb="is" />
+
+## Setup
+
+<StepByStep>
+  <Step title="Install the Convex Helpers npm package">
+    Install the `convex-helpers` package, which contains a CLI command to generate an Open API specification.
+
+    ```sh
+    npm install convex-helpers
+    ```
+
+  </Step>
+  <Step title="Run a command to generate an OpenAPI specification">
+    Running this command will call into your configured Convex deployment and generate an `convex-spec.yaml` file based
+    on it. You can see additional flags by passing `--help` to the command.
+
+    ```sh
+    npx convex-helpers open-api-spec
+    ```
+
+  </Step>
+  <Step title="Generate a type-safe client">
+    You can use a separate tools to generate a client from the `convex-spec.yaml` file. Some popular options are [OpenAPI Tools](https://github.com/OpenAPITools/openapi-generator) and [Swagger](https://swagger.io/tools/swagger-codegen/).
+    ```yaml
+    # convex-spec.yaml
+    openapi: 3.0.3
+    info:
+      title: Convex App - OpenAPI 3.0
+      version: 0.0.0
+      servers:
+        - url: "{hostUrl}"
+      description: Convex App API
+      ...
+    ```
+  </Step>
+</StepByStep>
+
+## Example
+
+Below are code snippets of what this workflow looks like in action. These
+snippets include two different files:
+
+- `convex/load.ts` - contains Convex function definitions
+- `convex.go` - contains `Go` code that uses a generated, type-safe `HTTP`
+  client. This client was generated by installing the
+  [OpenAPI Tools](https://github.com/OpenAPITools/openapi-generator) package and
+  running the command
+  `npx openapi-generator-cli generate -i convex-spec.yaml -g go -o convex_client`
+
+
+```ts
+import { v } from "convex/values";
+import { query } from "./_generated/server";
+import { LinkTable } from "./schema";
+
+export const loadOne = query({
+  args: { normalizedId: v.string(), token: v.string() },
+  returns: v.union(
+    v.object({
+      ...LinkTable.validator.fields,
+      _creationTime: v.number(),
+      _id: v.id("links"),
+    }),
+    v.null(),
+  ),
+  handler: async (ctx, { normalizedId, token }) => {
+    if (token === "" || token !== process.env.CONVEX_AUTH_TOKEN) {
+      throw new Error("Invalid authorization token");
+    }
+    return await ctx.db
+      .query("links")
+      .withIndex("by_normalizedId", (q) => q.eq("normalizedId", normalizedId))
+      .first();
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+import { query } from "./_generated/server";
+import { LinkTable } from "./schema";
+
+export const loadOne = query({
+  args: { normalizedId: v.string(), token: v.string() },
+  returns: v.union(
+    v.object({
+      ...LinkTable.validator.fields,
+      _creationTime: v.number(),
+      _id: v.id("links"),
+    }),
+    v.null(),
+  ),
+  handler: async (ctx, { normalizedId, token }) => {
+    if (token === "" || token !== process.env.CONVEX_AUTH_TOKEN) {
+      throw new Error("Invalid authorization token");
+    }
+    return await ctx.db
+      .query("links")
+      .withIndex("by_normalizedId", (q) => q.eq("normalizedId", normalizedId))
+      .first();
+  },
+});
+```
+
+
+
+```txt
+type Link struct {
+	Short    string // the "foo" part of http://go/foo
+	Long     string // the target URL or text/template pattern to run
+	Created  time.Time
+	LastEdit time.Time // when the link was last edited
+	Owner    string    // user@domain
+}
+
+func (c *ConvexDB) Load(short string) (*Link, error) { 
+  request := *convex.NewRequestLoadLoadOne(*convex.NewRequestLoadLoadOneArgs(short, c.token))
+  resp, httpRes, err := c.client.QueryAPI.ApiRunLoadLoadOnePost(context.Background()).RequestLoadLoadOne(request).Execute()
+  validationErr := validateResponse(httpRes.StatusCode, err, resp.Status) if
+  validationErr != nil { return nil, validationErr }
+
+  linkDoc := resp.Value.Get()
+  if linkDoc == nil {
+    err := fs.ErrNotExist
+    return nil, err
+  }
+  link := Link{
+    Short:    linkDoc.Short,
+    Long:     linkDoc.Long,
+    Created:  time.Unix(int64(linkDoc.Created), 0),
+    LastEdit: time.Unix(int64(linkDoc.LastEdit), 0),
+    Owner:    linkDoc.Owner,
+  }
+
+  return &link, nil
+```
+
+
+## Limits
+
+- Argument and return value validators are not required, but they will enrich
+  the types of your OpenAPI spec. Where validators aren't defined, we default to
+  `v.any()` as the validator.
+- You cannot call internal functions from outside of your Convex deployment.
+- We currently do not support `bigints` or `bytes`.
diff --git a/synced/convex/docs/client/python.md b/synced/convex/docs/client/python.md
new file mode 100644
index 0000000..58e10b6
--- /dev/null
+++ b/synced/convex/docs/client/python.md
@@ -0,0 +1,9 @@
+---
+title: "Python"
+sidebar_position: 400
+---
+
+See the [Python Quickstart](/quickstart/python.mdx) and the
+<a href="https://pypi.org/project/convex/" target="_blank">convex PyPI package
+docs</a>. The Python client is open source and available on
+[GitHub](https://github.com/get-convex/convex-py).
diff --git a/synced/convex/docs/client/react-native.md b/synced/convex/docs/client/react-native.md
new file mode 100644
index 0000000..b55ea8b
--- /dev/null
+++ b/synced/convex/docs/client/react-native.md
@@ -0,0 +1,16 @@
+---
+title: "Convex React Native"
+sidebar_label: "React Native"
+slug: "react-native"
+sidebar_position: 300
+description: "How Convex works in a React Native app"
+---
+
+To use Convex in [React Native](https://reactnative.dev/) use the
+[Convex React client library](/client/react.mdx).
+
+Follow the [React Native Quickstart](/quickstart/react-native.mdx) for the
+different configuration needed specifically for React Native.
+
+You can also clone a working
+[Convex React Native demo](https://github.com/get-convex/convex-demos/tree/main/react-native).
diff --git a/synced/convex/docs/client/react.md b/synced/convex/docs/client/react.md
new file mode 100644
index 0000000..1034fa1
--- /dev/null
+++ b/synced/convex/docs/client/react.md
@@ -0,0 +1,392 @@
+---
+title: "Convex React"
+sidebar_label: "React"
+sidebar_position: 4
+---
+
+
+
+Convex React is the client library enabling your React application to interact
+with your Convex backend. It allows your frontend code to:
+
+1. Call your [queries](/functions/query-functions.mdx),
+   [mutations](/functions/mutation-functions.mdx) and
+   [actions](/functions/actions.mdx)
+2. Upload and display files from [File Storage](/file-storage.mdx)
+3. Authenticate users using [Authentication](/auth.mdx)
+4. Implement full text [Search](/search.mdx) over your data
+
+The Convex React client is open source and available on
+[GitHub](https://github.com/get-convex/convex-js).
+
+Follow the [React Quickstart](/quickstart/react.mdx) to get started with React
+using [Vite](https://vitejs.dev/).
+
+## Installation
+
+Convex React is part of the `convex` npm package:
+
+```
+npm install convex
+```
+
+## Connecting to a backend
+
+The [`ConvexReactClient`](/api/classes/react.ConvexReactClient) maintains a
+connection to your Convex backend, and is used by the React hooks described
+below to call your functions.
+
+First you need to create an instance of the client by giving it your backend
+deployment URL. See [Configuring Deployment URL](/client/react/project-setup.md)
+on how to pass in the right value:
+
+```jsx
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient("https://<your domain here>.convex.cloud");
+```
+
+And then you make the client available to your app by passing it in to a
+[`ConvexProvider`](/api/modules/react#convexprovider) wrapping your component
+tree:
+
+```jsx
+reactDOMRoot.render(
+  <React.StrictMode>
+    <ConvexProvider client={convex}>
+      <App />
+    </ConvexProvider>
+  </React.StrictMode>,
+);
+```
+
+## Fetching data
+
+Your React app fetches data using the [`useQuery`](/api/modules/react#usequery)
+React hook by calling your [queries](/functions/query-functions.mdx) via an
+[`api`](/generated-api/api.md#api) object.
+
+The `npx convex dev` command generates this api object for you in the
+`convex/_generated/api.js` module to provide better autocompletion in JavaScript
+and end-to-end type safety in
+[TypeScript](/understanding/best-practices/typescript.mdx):
+
+```tsx title="src/App.tsx"
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const data = useQuery(api.functions.myQuery);
+  return data ?? "Loading...";
+}
+```
+
+The `useQuery` hook returns `undefined` while the data is first loading and
+afterwards the return value of your query.
+
+### Query arguments
+
+Arguments to your query follow the query name:
+
+```tsx title="src/App.tsx"
+export function App() {
+  const a = "Hello world";
+  const b = 4;
+  const data = useQuery(api.functions.myQuery, { a, b });
+  //...
+}
+```
+
+### Reactivity
+
+The `useQuery` hook makes your app automatically reactive: when the underlying
+data changes in your database, your component rerenders with the new query
+result.
+
+The first time the hook is used it creates a subscription to your backend for a
+given query and any arguments you pass in. When your component unmounts, the
+subscription is canceled.
+
+### Consistency
+
+Convex React ensures that your application always renders a consistent view of
+the query results based on a single state of the underlying database.
+
+Imagine a mutation changes some data in the database, and that 2 different
+`useQuery` call sites rely on this data. Your app will never render in an
+inconsistent state where only one of the `useQuery` call sites reflects the new
+data.
+
+### Paginating queries
+
+See
+[Paginating within React Components](/database/pagination.mdx#paginating-within-react-components).
+
+### Skipping queries
+
+<Details summary="Advanced: Loading a query conditionally">
+
+With React it can be tricky to dynamically invoke a hook, because hooks cannot
+be placed inside conditionals or after early returns:
+
+
+```tsx
+/* eslint-disable react-hooks/rules-of-hooks */
+
+// @snippet start example
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  // the URL `param` might be null
+  const param = new URLSearchParams(window.location.search).get("param");
+  // ERROR! React Hook "useQuery" is called conditionally. React Hooks must
+  // be called in the exact same order in every component render.
+  const data = param !== null ? useQuery(api.functions.read, { param }) : null;
+  //...
+}
+// @snippet end example
+```
+
+```tsx
+/* eslint-disable react-hooks/rules-of-hooks */
+
+// @snippet start example
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  // the URL `param` might be null
+  const param = new URLSearchParams(window.location.search).get("param");
+  // ERROR! React Hook "useQuery" is called conditionally. React Hooks must
+  // be called in the exact same order in every component render.
+  const data = param !== null ? useQuery(api.functions.read, { param }) : null;
+  //...
+}
+// @snippet end example
+```
+
+
+For this reason `useQuery` can be "disabled" by passing in `"skip"` instead of
+its arguments:
+
+
+```tsx
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const param = new URLSearchParams(window.location.search).get("param");
+  const data = useQuery(
+    api.functions.read,
+    param !== null ? { param } : "skip",
+  );
+  //...
+}
+```
+
+```tsx
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const param = new URLSearchParams(window.location.search).get("param");
+  const data = useQuery(
+    api.functions.read,
+    param !== null ? { param } : "skip",
+  );
+  //...
+}
+```
+
+
+When `"skip"` is used the `useQuery` doesn't talk to your backend at all and
+returns `undefined`.
+
+</Details>
+
+### One-off queries
+
+<Details summary="Advanced: Fetching a query from a callback">
+
+Sometimes you might want to read state from the database in response to a user
+action, for example to validate given input, without making any changes to the
+database. In this case you can use a one-off
+[`query`](/api/classes/react.ConvexReactClient#query) call, similarly to calling
+mutations and actions.
+
+The async method `query` is exposed on the `ConvexReactClient`, which you can
+reference in your components via the
+[`useConvex()`](/api/modules/react#useconvex) hook.
+
+```tsx title="src/App.tsx"
+import { useConvex } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const convex = useConvex();
+  return (
+    <button
+      onClick={async () => {
+        console.log(await convex.query(api.functions.myQuery));
+      }}
+    >
+      Check
+    </button>
+  );
+}
+```
+
+</Details>
+
+## Editing data
+
+Your React app edits data using the
+[`useMutation`](/api/modules/react#usemutation) React hook by calling your
+[mutations](/functions/mutation-functions.mdx).
+
+The `convex dev` command generates this api object for you in the
+`convex/_generated/api.js` module to provide better autocompletion in JavaScript
+and end-to-end type safety in
+[TypeScript](/understanding/best-practices/typescript.mdx):
+
+```tsx title="src/App.tsx"
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const doSomething = useMutation(api.functions.doSomething);
+  return <button onClick={() => doSomething()}>Click me</button>;
+}
+```
+
+The hook returns an `async` function which performs the call to the mutation.
+
+### Mutation arguments
+
+Arguments to your mutation are passed to the `async` function returned from
+`useMutation`:
+
+```tsx title="src/App.tsx"
+export function App() {
+  const a = "Hello world";
+  const b = 4;
+  const doSomething = useMutation(api.functions.doSomething);
+  return <button onClick={() => doSomething({ a, b })}>Click me</button>;
+}
+```
+
+### Mutation response and error handling
+
+The mutation can optionally return a value or throw errors, which you can
+[`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await):
+
+```tsx title="src/App.tsx"
+export function App() {
+  const doSomething = useMutation(api.functions.doSomething);
+  const onClick = () => {
+    async function callBackend() {
+      try {
+        const result = await doSomething();
+      } catch (error) {
+        console.error(error);
+      }
+      console.log(result);
+    }
+    void callBackend();
+  };
+  return <button onClick={onClick}>Click me</button>;
+}
+```
+
+Or handle as a
+[`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise):
+
+```tsx title="src/App.tsx"
+export function App() {
+  const doSomething = useMutation(api.functions.doSomething);
+  const onClick = () => {
+    doSomething()
+      .catch((error) => {
+        console.error(error);
+      })
+      .then((result) => {
+        console.log(result);
+      });
+  };
+  return <button onClick={onClick}>Click me</button>;
+}
+```
+
+Learn more about [Error Handling](/functions/error-handling/error-handling.mdx)
+in functions.
+
+### Retries
+
+Convex React automatically retries mutations until they are confirmed to have
+been written to the database. The Convex backend ensures that despite multiple
+retries, every mutation call only executes once.
+
+Additionally, Convex React will warn users if they try to close their browser
+tab while there are outstanding mutations. This means that when you call a
+Convex mutation, you can be sure that the user's edits won't be lost.
+
+### Optimistic updates
+
+Convex queries are fully reactive, so all query results will be automatically
+updated after a mutation. Sometimes you may want to update the UI before the
+mutation changes propagate back to the client. To accomplish this, you can
+configure an _optimistic update_ to execute as part of your mutation.
+
+Optimistic updates are temporary, local changes to your query results which are
+used to make your app more responsive.
+
+See [Optimistic Updates](/client/react/optimistic-updates.mdx) on how to
+configure them.
+
+## Calling third-party APIs
+
+Your React app can read data, call third-party services, and write data with a
+single backend call using the [`useAction`](/api/modules/react#useaction) React
+hook by calling your [actions](/functions/actions.mdx).
+
+Like `useQuery` and `useMutation`, this hook is used with the `api` object
+generated for you in the `convex/_generated/api.js` module to provide better
+autocompletion in JavaScript and end-to-end type safety in
+[TypeScript](/understanding/best-practices/typescript.mdx):
+
+```tsx title="src/App.tsx"
+import { useAction } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const doSomeAction = useAction(api.functions.doSomeAction);
+  return <button onClick={() => doSomeAction()}>Click me</button>;
+}
+```
+
+The hook returns an `async` function which performs the call to the action.
+
+### Action arguments
+
+Action arguments work exactly the same as
+[mutation arguments](#mutation-arguments).
+
+### Action response and error handling
+
+Action response and error handling work exactly the same as
+[mutation response and error handling](#mutation-response-and-error-handling).
+
+Actions do not support automatic retries or optimistic updates.
+
+## Under the hood
+
+The [`ConvexReactClient`](/api/classes/react.ConvexReactClient) connects to your
+Convex deployment by creating a
+[`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket). The
+WebSocket provides a 2-way communication channel over TCP. This allows Convex to
+push new query results reactively to the client without the client needing to
+poll for updates.
+
+If the internet connection drops, the client will handle reconnecting and
+re-establishing the Convex session automatically.
diff --git a/synced/convex/docs/client/react/nextjs-pages-router/nextjs-pages-router.md b/synced/convex/docs/client/react/nextjs-pages-router/nextjs-pages-router.md
new file mode 100644
index 0000000..f61fe70
--- /dev/null
+++ b/synced/convex/docs/client/react/nextjs-pages-router/nextjs-pages-router.md
@@ -0,0 +1,141 @@
+---
+title: "Next.js Pages Router"
+slug: "nextjs-pages-router"
+sidebar_position: 250
+sidebar_label: "Next.js Pages Router"
+---
+
+
+
+This pages covers the Pages Router variant of Next.js. Alternatively see the
+[App Router](/client/react/nextjs/nextjs.mdx) version of this page.
+
+## Getting started
+
+Follow the
+[Next.js Pages Router Quickstart](/client/react/nextjs-pages-router/quickstart-nextjs-pages-router.mdx)
+to add Convex to a new or existing Next.js project.
+
+## Adding client-side authentication
+
+The simplest approach to authentication in Next.js is to keep it client-side.
+
+For example Auth0 describes this approach in
+[Next.js Authentication with Auth0 guide](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0),
+describing it in
+"[Next.js Static Site Approach](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0/#Next-js-Static-Site-Approach)"
+and "Serverless with the user on the frontend".
+
+To require login on every page of your application you can add logic to
+`_app.jsx` to conditionally render page content, blocking it until the user is
+logged in.
+
+If you're using Auth0, the helper component `ConvexProviderWithAuth0` can be
+imported from `convex/react-auth0`.
+
+
+```tsx
+// This file is not used in the demo app.
+// Replace the contents of _auth.tsx with the contents of this file
+// to use the default loading and logged out views instead of the custom
+// components.
+
+// @snippet start simpleAuthedApp
+import { ConvexReactClient } from "convex/react";
+import { ConvexProviderWithAuth0 } from "convex/react-auth0";
+import { Auth0Provider } from "@auth0/auth0-react";
+import { AppProps } from "next/app";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
+
+export default function MyApp({ Component, pageProps }: AppProps) {
+  return (
+    <Auth0Provider
+      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
+      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
+      authorizationParams={{
+        redirect_uri:
+          typeof window === "undefined" ? undefined : window.location.origin,
+      }}
+      useRefreshTokens={true}
+      cacheLocation="localstorage"
+    >
+      <ConvexProviderWithAuth0 client={convex}>
+        <Component {...pageProps} />
+      </ConvexProviderWithAuth0>
+    </Auth0Provider>
+  );
+}
+// @snippet end simpleAuthedApp
+```
+
+
+Custom loading and logged out views can be built with the helper
+`Authenticated`, `Unauthenticated` and `AuthLoading` components from
+`convex/react`, see the
+[Convex Next.js demo](https://github.com/get-convex/convex-demos/tree/main/nextjs-pages-router/pages/_app.jsx)
+for an example.
+
+If only some routes of your app require login, the same helpers can be used
+directly in page components that do require login instead of being shared
+between all pages from `pages/_app.jsx`. Share a single
+[ConvexReactClient](/api/classes/react.ConvexReactClient) instance between pages
+to avoid needing to reconnect to Convex on client-side page navigation.
+
+Read more about authenticating users with Convex in [Authentication](/auth.mdx).
+
+## API routes
+
+Next.js supports building HTTP request handling routes, similar to Convex
+[HTTP Actions](/functions/http-actions.mdx). Using Next.js routes might be
+helpful if you need to use a dependency not supported by the Convex default
+runtime.
+
+To build an [API route](https://nextjs.org/docs/api-routes/introduction) add a
+file to the `pages/api` directory.
+
+To load and edit Convex data in your endpoints, use the
+[`fetchQuery`](/api/modules/nextjs#fetchquery) function from `convex/nextjs`:
+
+
+```ts
+import type { NextApiRequest, NextApiResponse } from "next";
+import { fetchQuery } from "convex/nextjs";
+import { api } from "../../convex/_generated/api";
+
+export const count = async function handler(
+  _req: NextApiRequest,
+  res: NextApiResponse,
+) {
+  const clicks = await fetchQuery(api.counter.get, { counterName: "clicks" });
+  res.status(200).json({ clicks });
+};
+```
+
+
+## Server-side rendering
+
+**Consider client-side rendering Convex data when using Next.js.** Data from
+Convex is
+[fully reactive](/functions/query-functions.mdx#caching--reactivity--consistency)
+so Convex needs a connection from your deployment to the browser in order to
+push updates as data changes.
+
+You can of course load data from Convex in
+[`getStaticProps`](https://nextjs.org/docs/basic-features/data-fetching/get-static-props)
+or
+[`getServerSideProps`](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props),
+but it will be non-reactive. To do this, use the
+[`fetchQuery`](/api/modules/nextjs#fetchquery) function to call query functions
+just like you would in [API routes](#api-routes).
+
+To make authenticated requests to Convex during server-side rendering, you need
+authentication info present server-side. Auth0 describes this approach in
+[Serverless with the user on the backend](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0/#Serverless-with-the-user-on-the-backend).
+When server-side rendering, pass the authentication token as `token` to the
+third argument of `fetchQuery`.
+
+To preload data on server side before rendering a reactive query on the client
+side use [`preloadQuery`](/api/modules/nextjs#preloadquery). Check out the
+[App Router version of these docs](/client/react/nextjs/nextjs-server-rendering.mdx)
+for more details.
diff --git a/synced/convex/docs/client/react/nextjs-pages-router/quickstart-nextjs-pages-router.md b/synced/convex/docs/client/react/nextjs-pages-router/quickstart-nextjs-pages-router.md
new file mode 100644
index 0000000..2b9a78f
--- /dev/null
+++ b/synced/convex/docs/client/react/nextjs-pages-router/quickstart-nextjs-pages-router.md
@@ -0,0 +1,164 @@
+---
+title: Next.js Pages Quickstart
+sidebar_label: Quickstart
+hide_table_of_contents: true
+slug: "quickstart"
+---
+
+
+
+
+
+Learn how to query data from Convex in a Next.js app using the Pages Router.
+
+Alternatively see the [App Router](/quickstart/nextjs.mdx) version of this
+quickstart.
+
+<StepByStep>
+  <Step title="Create a React app">
+    Create a Next.js app using the `npx create-next-app` command.
+
+    Choose the default option for every prompt (hit Enter).
+
+
+    ```sh
+    npx create-next-app@latest my-app --no-app --js
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    To get started, install the `convex`
+    package which provides a convenient interface for working
+    with Convex from a React app.
+
+    Navigate to your app and install `convex`.
+
+
+    ```sh
+    cd my-app && npm install convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+    In `pages/_app.js`, create a `ConvexReactClient` and pass it to a `ConvexProvider`
+    wrapping your app.
+
+    
+```js
+import "@/styles/globals.css";
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);
+
+export default function App({ Component, pageProps }) {
+  return (
+    <ConvexProvider client={convex}>
+      <Component {...pageProps} />
+    </ConvexProvider>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In `pages/index.js`, use the `useQuery` hook to fetch from your `api.tasks.get`
+    API function.
+
+    
+```js
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function Home() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <main className="flex min-h-screen flex-col items-center p-24">
+      {tasks?.map(({ _id, text }) => (
+        <div key={_id}>{text}</div>
+      ))}
+    </main>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, open [http://localhost:3000](http://localhost:3000) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
diff --git a/synced/convex/docs/client/react/nextjs/nextjs-server-rendering.md b/synced/convex/docs/client/react/nextjs/nextjs-server-rendering.md
new file mode 100644
index 0000000..c1d2604
--- /dev/null
+++ b/synced/convex/docs/client/react/nextjs/nextjs-server-rendering.md
@@ -0,0 +1,348 @@
+---
+title: "Next.js Server Rendering"
+slug: "server-rendering"
+sidebar_label: "Server Rendering"
+sidebar_position: 10
+---
+
+
+
+
+
+
+
+
+
+
+
+
+Next.js automatically renders both Client and Server Components on the server
+during the initial page load.
+
+By default Client Components will not wait for Convex data to be loaded, and
+your UI will render in a "loading" state. Read on to learn how to preload data
+during server rendering and how to interact with the Convex deployment from
+Next.js server-side.
+
+**Example:**
+[Next.js App Router](https://github.com/get-convex/convex-demos/tree/main/nextjs-app-router)
+
+This pages covers the App Router variant of Next.js.
+
+<BetaAdmonition feature="Next.js Server Rendering support" verb="is" />
+
+## Preloading data for Client Components
+
+If you want to preload data from Convex and leverage Next.js
+[server rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies),
+but still retain reactivity after the initial page load, use
+[`preloadQuery`](/api/modules/nextjs#preloadquery) from
+[`convex/nextjs`](/api/modules/nextjs).
+
+In a
+[Server Component](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
+call `preloadQuery`:
+
+
+```tsx
+import { preloadQuery } from "convex/nextjs";
+import { api } from "@/convex/_generated/api";
+import { Tasks } from "./Tasks";
+
+export async function TasksWrapper() {
+  const preloadedTasks = await preloadQuery(api.tasks.list, {
+    list: "default",
+  });
+  return <Tasks preloadedTasks={preloadedTasks} />;
+}
+```
+
+```tsx
+import { preloadQuery } from "convex/nextjs";
+import { api } from "@/convex/_generated/api";
+import { Tasks } from "./Tasks";
+
+export async function TasksWrapper() {
+  const preloadedTasks = await preloadQuery(api.tasks.list, {
+    list: "default",
+  });
+  return <Tasks preloadedTasks={preloadedTasks} />;
+}
+```
+
+
+In a
+[Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components)
+call [`usePreloadedQuery`](/api/modules/react#usepreloadedquery):
+
+
+```tsx
+"use client";
+
+import { Preloaded, usePreloadedQuery } from "convex/react";
+import { api } from "@/convex/_generated/api";
+
+export function Tasks(props: {
+  preloadedTasks: Preloaded<typeof api.tasks.list>;
+}) {
+  const tasks = usePreloadedQuery(props.preloadedTasks);
+  // render `tasks`...
+  return <div>...</div>;
+}
+```
+
+```jsx
+"use client";
+
+import { usePreloadedQuery } from "convex/react";
+
+export function Tasks(props) {
+  const tasks = usePreloadedQuery(props.preloadedTasks);
+  // render `tasks`...
+  return tasks.map((task) => <div key={task._id}>{task.text}</div>);
+}
+```
+
+
+[`preloadQuery`](/api/modules/nextjs#preloadquery) takes three arguments:
+
+1. The query reference
+2. Optionally the arguments object passed to the query
+3. Optionally a [NextjsOptions](/api/modules/nextjs#nextjsoptions) object
+
+`preloadQuery` uses the
+[`cache: 'no-store'` policy](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching)
+so any Server Components using it will not be eligible for
+[static rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies).
+
+### Using the query result
+
+[`preloadQuery`](/api/modules/nextjs#preloadquery) returns an opaque `Preloaded`
+payload that should be passed through to `usePreloadedQuery`. If you want to use
+the return value of the query, perhaps to decide whether to even render the
+Client Component, you can pass the `Preloaded` payload to the
+[`preloadedQueryResult`](/api/modules/nextjs#preloadedqueryresult) function.
+
+## Using Convex to render Server Components
+
+If you need Convex data on the server, you can load data from Convex in your
+[Server Components](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching),
+but it will be non-reactive. To do this, use the
+[`fetchQuery`](/api/modules/nextjs#fetchquery) function from `convex/nextjs`:
+
+
+```tsx
+import { fetchQuery } from "convex/nextjs";
+import { api } from "@/convex/_generated/api";
+
+export async function StaticTasks() {
+  const tasks = await fetchQuery(api.tasks.list, { list: "default" });
+  // render `tasks`...
+  return <div>...</div>;
+}
+```
+
+```tsx
+import { fetchQuery } from "convex/nextjs";
+import { api } from "@/convex/_generated/api";
+
+export async function StaticTasks() {
+  const tasks = await fetchQuery(api.tasks.list, { list: "default" });
+  // render `tasks`...
+  return <div>...</div>;
+}
+```
+
+
+## Server Actions and Route Handlers
+
+Next.js supports building HTTP request handling routes, similar to Convex
+[HTTP Actions](/functions/http-actions.mdx). You can use Convex from a
+[Server Action](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
+or a
+[Route Handler](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
+as you would any other database service.
+
+To load and edit Convex data in your Server Action or Route Handler, you can use
+the `fetchQuery`, `fetchMutation` and `fetchAction` functions.
+
+Here's an example inline Server Action calling a Convex mutation:
+
+
+```tsx
+import { api } from "@/convex/_generated/api";
+import { fetchMutation, fetchQuery } from "convex/nextjs";
+import { revalidatePath } from "next/cache";
+
+export default async function PureServerPage() {
+  const tasks = await fetchQuery(api.tasks.list, { list: "default" });
+  async function createTask(formData: FormData) {
+    "use server";
+
+    await fetchMutation(api.tasks.create, {
+      text: formData.get("text") as string,
+    });
+    revalidatePath("/example");
+  }
+  // render tasks and task creation form
+  return <form action={createTask}>...</form>;
+}
+```
+
+```jsx
+import { api } from "@/convex/_generated/api";
+import { fetchMutation, fetchQuery } from "convex/nextjs";
+import { revalidatePath } from "next/cache";
+
+export default async function PureServerPage() {
+  const tasks = await fetchQuery(api.tasks.list, { list: "default" });
+  async function createTask(formData) {
+    "use server";
+
+    await fetchMutation(api.tasks.create, {
+      text: formData.get("text"),
+    });
+    revalidatePath("/example");
+  }
+  // render tasks and task creation form
+  return <form action={createTask}>...</form>;
+}
+```
+
+
+Here's an example Route Handler calling a Convex mutation:
+
+
+```ts
+import { NextResponse } from "next/server";
+// Hack for TypeScript before 5.2
+const Response = NextResponse;
+
+// @snippet start example
+import { api } from "@/convex/_generated/api";
+import { fetchMutation } from "convex/nextjs";
+
+export async function POST(request: Request) {
+  const args = await request.json();
+  await fetchMutation(api.tasks.create, { text: args.text });
+  return Response.json({ success: true });
+}
+// @snippet end example
+```
+
+```js
+import { api } from "@/convex/_generated/api";
+import { fetchMutation } from "convex/nextjs";
+
+export async function POST(request) {
+  const args = await request.json();
+  await fetchMutation(api.tasks.create, { text: args.text });
+  return Response.json({ success: true });
+}
+```
+
+
+## Server-side authentication
+
+To make authenticated requests to Convex during server rendering, pass a JWT
+token to [`preloadQuery`](/api/modules/nextjs#preloadquery) or
+[`fetchQuery`](/api/modules/nextjs#fetchquery) in the third options argument:
+
+
+```tsx
+// @snippet start example
+import { preloadQuery } from "convex/nextjs";
+import { api } from "@/convex/_generated/api";
+import { Tasks } from "./Tasks";
+
+export async function TasksWrapper() {
+  const token = await getAuthToken();
+  const preloadedTasks = await preloadQuery(
+    api.tasks.list,
+    { list: "default" },
+    { token },
+  );
+  return <Tasks preloadedTasks={preloadedTasks} />;
+}
+// @snippet end example
+
+function getAuthToken() {
+  return "foo";
+}
+```
+
+```tsx
+// @snippet start example
+import { preloadQuery } from "convex/nextjs";
+import { api } from "@/convex/_generated/api";
+import { Tasks } from "./Tasks";
+
+export async function TasksWrapper() {
+  const token = await getAuthToken();
+  const preloadedTasks = await preloadQuery(
+    api.tasks.list,
+    { list: "default" },
+    { token },
+  );
+  return <Tasks preloadedTasks={preloadedTasks} />;
+}
+// @snippet end example
+
+function getAuthToken() {
+  return "foo";
+}
+```
+
+
+The implementation of `getAuthToken` depends on your authentication provider.
+
+<Tabs>
+<TabItem value="clerk" label="Clerk">
+```ts title="app/auth.ts"
+import { auth } from "@clerk/nextjs/server";
+
+export async function getAuthToken() {
+  return (await (await auth()).getToken({ template: "convex" })) ?? undefined;
+}
+```
+</TabItem>
+<TabItem value="auth0" label="Auth0">
+```ts title="app/auth.ts"
+// You'll need v4.3 or later of @auth0/nextjs-auth0
+import { getSession } from '@auth0/nextjs-auth0';
+
+export async function getAuthToken() {
+  const session = await getSession();
+  const idToken = session.tokenSet.idToken;
+  return idToken;
+}
+```
+</TabItem>
+</Tabs>
+
+## Configuring Convex deployment URL
+
+Convex hooks used by Client Components are configured via the
+`ConvexReactClient` constructor, as shown in the
+[Next.js Quickstart](/quickstart/nextjs.mdx).
+
+To use `preloadQuery`, `fetchQuery`, `fetchMutation` and `fetchAction` in Server
+Components, Server Actions and Route Handlers you must either:
+
+1. have `NEXT_PUBLIC_CONVEX_URL` environment variable set to the Convex
+   deployment URL
+2. or pass the [`url` option](/api/modules/nextjs#nextjsoptions) in the third
+   argument to `preloadQuery`, `fetchQuery`, `fetchMutation` or `fetchAction`
+
+## Consistency
+
+[`preloadQuery`](/api/modules/nextjs#preloadquery) and
+[`fetchQuery`](/api/modules/nextjs#fetchquery) use the `ConvexHTTPClient` under
+the hood. This client is stateless. This means that two calls to `preloadQuery`
+are not guaranteed to return consistent data based on the same database state.
+This is similar to more traditional databases, but is different from the
+[guaranteed consistency](/client/react.mdx#consistency) provided by the
+`ConvexReactClient`.
+
+To prevent rendering an inconsistent UI avoid using multiple `preloadQuery`
+calls on the same page.
diff --git a/synced/convex/docs/client/react/nextjs/nextjs.md b/synced/convex/docs/client/react/nextjs/nextjs.md
new file mode 100644
index 0000000..4dc3e23
--- /dev/null
+++ b/synced/convex/docs/client/react/nextjs/nextjs.md
@@ -0,0 +1,165 @@
+---
+title: "Next.js"
+sidebar_label: "Next.js App Router"
+sidebar_position: 200
+description: "How Convex works in a Next.js app"
+---
+
+
+[Next.js](https://nextjs.org/) is a React web development framework. When used
+with Convex, Next.js provides:
+
+- File-system based routing
+- Fast refresh in development
+- Font and image optimization
+
+and more!
+
+This page covers the App Router variant of Next.js. Alternatively see the
+[Pages Router](/client/react/nextjs-pages-router/nextjs-pages-router.mdx)
+version of this page.
+
+## Getting started
+
+Follow the [Next.js Quickstart](/quickstart/nextjs.mdx) to add Convex to a new
+or existing Next.js project.
+
+## Adding authentication
+
+### Client-side only
+
+The simplest way to add user authentication to your Next.js app is to follow our
+React-based authentication guides for [Clerk](/auth/clerk.mdx) or
+[Auth0](/auth/auth0.mdx), inside your `app/ConvexClientProvider.tsx` file. For
+example this is what the file would look like for Auth0:
+
+
+```tsx
+"use client";
+
+import { Auth0Provider } from "@auth0/auth0-react";
+import { ConvexReactClient } from "convex/react";
+import { ConvexProviderWithAuth0 } from "convex/react-auth0";
+import { ReactNode } from "react";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
+
+export function ConvexClientProvider({ children }: { children: ReactNode }) {
+  return (
+    <Auth0Provider
+      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
+      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
+      authorizationParams={{
+        redirect_uri:
+          typeof window === "undefined" ? undefined : window.location.origin,
+      }}
+      useRefreshTokens={true}
+      cacheLocation="localstorage"
+    >
+      <ConvexProviderWithAuth0 client={convex}>
+        {children}
+      </ConvexProviderWithAuth0>
+    </Auth0Provider>
+  );
+}
+```
+
+```tsx
+"use client";
+
+import { Auth0Provider } from "@auth0/auth0-react";
+import { ConvexReactClient } from "convex/react";
+import { ConvexProviderWithAuth0 } from "convex/react-auth0";
+import { ReactNode } from "react";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
+
+export function ConvexClientProvider({ children }: { children: ReactNode }) {
+  return (
+    <Auth0Provider
+      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
+      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
+      authorizationParams={{
+        redirect_uri:
+          typeof window === "undefined" ? undefined : window.location.origin,
+      }}
+      useRefreshTokens={true}
+      cacheLocation="localstorage"
+    >
+      <ConvexProviderWithAuth0 client={convex}>
+        {children}
+      </ConvexProviderWithAuth0>
+    </Auth0Provider>
+  );
+}
+```
+
+
+Custom loading and logged out views can be built with the helper
+`Authenticated`, `Unauthenticated` and `AuthLoading` components from
+`convex/react`, see the
+[Convex Next.js demo](https://github.com/get-convex/convex-demos/tree/main/nextjs-pages-router/pages/_app.tsx)
+for an example.
+
+If only some routes of your app require login, the same helpers can be used
+directly in page components that do require login instead of being shared
+between all pages from `app/ConvexClientProvider.tsx`. Share a single
+[ConvexReactClient](/api/classes/react.ConvexReactClient) instance between pages
+to avoid needing to reconnect to Convex on client-side page navigation.
+
+### Server and client side
+
+To access user information or load Convex data requiring `ctx.auth` from Server
+Components, Server Actions, or Route Handlers you need to use the Next.js
+specific SDKs provided by Clerk and Auth0.
+
+Additional `.env.local` configuration is needed for these hybrid SDKs.
+
+#### Clerk
+
+For an example of using Convex and with Next.js 15, run
+
+<p>
+  <b>
+    <CodeWithCopyButton text="npm create convex@latest -- -t nextjs-clerk" />
+  </b>
+</p>
+
+Otherwise, follow the
+[Clerk Next.js quickstart](https://clerk.com/docs/quickstarts/nextjs), a guide
+from Clerk that includes steps for adding `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`
+and `CLERK_SECRET_KEY` to the .env.local file. In Next.js 15, the
+`<ClerkProvider>` component imported from the `@clerk/nextjs` v6 package
+functions as both a client and a server context provider so you probably won't
+need the `ClerkProvider` from `@clerk/clerk-react`.
+
+#### Auth0
+
+See the
+[Auth0 Next.js](https://auth0.com/docs/quickstart/webapp/nextjs/01-login) guide.
+
+#### Other providers
+
+Convex uses JWT identity tokens on the client for live query subscriptions and
+running mutations and actions, and on the Next.js backend for running queries,
+mutations, and actions in server components and API routes.
+
+Obtain the appropriate OpenID Identity JWT in both locations and you should be
+able to use any auth provider. See
+[Custom Auth](https://docs.convex.dev/auth/advanced/custom-auth) for more.
+
+## Server rendering (SSR)
+
+Next.js automatically renders both Client and Server Components on the server
+during the initial page load.
+
+To keep your UI
+[automatically reactive](/functions/query-functions.mdx#caching--reactivity--consistency)
+to changes in your Convex database it needs to use Client Components. The
+`ConvexReactClient` will maintain a connection to your deployment and will get
+updates as data changes and that must happen on the client.
+
+See the dedicated
+[Server Rendering](/client/react/nextjs/nextjs-server-rendering.mdx) page for
+more details about preloading data for Client Components, fetching data and
+authentication in Server Components, and implementing Route Handlers.
diff --git a/synced/convex/docs/client/react/optimistic-updates.md b/synced/convex/docs/client/react/optimistic-updates.md
new file mode 100644
index 0000000..4c0d6a7
--- /dev/null
+++ b/synced/convex/docs/client/react/optimistic-updates.md
@@ -0,0 +1,212 @@
+---
+title: "Optimistic Updates"
+slug: "optimistic-updates"
+hidden: false
+sidebar_position: 90
+---
+
+
+
+
+Even though Convex queries are completely reactive, sometimes you'll want to
+update your UI before the mutation changes propagate back to the client. To
+accomplish this, you can configure an _optimistic update_ to execute as part of
+your mutation.
+
+Optimistic updates are temporary, local changes to your query results which are
+used to make your app more responsive. These updates are made by functions
+registered on a mutation invocation with the
+[`.withOptimisticUpdate`](/api/interfaces/react.ReactMutation#withoptimisticupdate)
+configuration option.
+
+Optimistic updates are run when a mutation is initiated, rerun if the local
+query results change, and rolled back when a mutation completes.
+
+## Simple example
+
+Here is how an optimistic update could be added to an `increment` mutation in a
+simple counter app:
+
+
+```tsx
+import { api } from "../convex/_generated/api";
+import { useMutation } from "convex/react";
+
+export function IncrementCounter() {
+  const increment = useMutation(api.counter.increment).withOptimisticUpdate(
+    (localStore, args) => {
+      const { increment } = args;
+      const currentValue = localStore.getQuery(api.counter.get);
+      if (currentValue !== undefined) {
+        localStore.setQuery(api.counter.get, {}, currentValue + increment);
+      }
+    },
+  );
+
+  const incrementCounter = () => {
+    increment({ increment: 1 });
+  };
+
+  return <button onClick={incrementCounter}>+1</button>;
+}
+```
+
+```tsx
+import { api } from "../convex/_generated/api";
+import { useMutation } from "convex/react";
+
+export function IncrementCounter() {
+  const increment = useMutation(api.counter.increment).withOptimisticUpdate(
+    (localStore, args) => {
+      const { increment } = args;
+      const currentValue = localStore.getQuery(api.counter.get);
+      if (currentValue !== undefined) {
+        localStore.setQuery(api.counter.get, {}, currentValue + increment);
+      }
+    },
+  );
+
+  const incrementCounter = () => {
+    increment({ increment: 1 });
+  };
+
+  return <button onClick={incrementCounter}>+1</button>;
+}
+```
+
+
+Optimistic updates receive a
+[`localStore`](/api/interfaces/browser.OptimisticLocalStore), a view of the
+Convex client's internal state, followed by the arguments to the mutation.
+
+This optimistic update updates the `api.counter.get` query to be `increment`
+higher if it's loaded.
+
+## Complex example
+
+If we want to add an optimistic update to a multi-channel chat app, that might
+look like:
+
+
+```tsx
+import { api } from "../convex/_generated/api";
+import { useMutation } from "convex/react";
+import { Id } from "../convex/_generated/dataModel";
+
+export function MessageSender(props: { channel: Id<"channels"> }) {
+  const sendMessage = useMutation(api.messages.send).withOptimisticUpdate(
+    (localStore, args) => {
+      const { channel, body } = args;
+      const existingMessages = localStore.getQuery(api.messages.list, {
+        channel,
+      });
+      // If we've loaded the api.messages.list query, push an optimistic message
+      // onto the list.
+      if (existingMessages !== undefined) {
+        const now = Date.now();
+        const newMessage = {
+          _id: crypto.randomUUID() as Id<"messages">,
+          _creationTime: now,
+          channel,
+          body,
+        };
+        localStore.setQuery(api.messages.list, { channel }, [
+          ...existingMessages,
+          newMessage,
+        ]);
+      }
+    },
+  );
+
+  async function handleSendMessage(
+    channelId: Id<"channels">,
+    newMessageText: string,
+  ) {
+    await sendMessage({ channel: channelId, body: newMessageText });
+  }
+
+  return (
+    <button onClick={() => handleSendMessage(props.channel, "Hello world!")}>
+      Send message
+    </button>
+  );
+}
+```
+
+```jsx
+import { api } from "../convex/_generated/api";
+import { useMutation } from "convex/react";
+
+export function MessageSender(props) {
+  const sendMessage = useMutation(api.messages.send).withOptimisticUpdate(
+    (localStore, args) => {
+      const { channel, body } = args;
+      const existingMessages = localStore.getQuery(api.messages.list, {
+        channel,
+      });
+      // If we've loaded the api.messages.list query, push an optimistic message
+      // onto the list.
+      if (existingMessages !== undefined) {
+        const now = Date.now();
+        const newMessage = {
+          _id: crypto.randomUUID(),
+          _creationTime: now,
+          channel,
+          body,
+        };
+        localStore.setQuery(api.messages.list, { channel }, [
+          ...existingMessages,
+          newMessage,
+        ]);
+      }
+    },
+  );
+
+  async function handleSendMessage(channelId, newMessageText) {
+    await sendMessage({ channel: channelId, body: newMessageText });
+  }
+
+  return (
+    <button onClick={() => handleSendMessage(props.channel, "Hello world!")}>
+      Send message
+    </button>
+  );
+}
+```
+
+
+This optimistic update changes the `api.messages.list` query for the current
+channel to include a new message. The newly created message object should match
+the structure of the real messages generated by the `api.messages.list` query on
+the server.
+
+Because this message includes the client's current time (not the server's), it
+will inevitably not match the `api.messages.list` query after the mutation runs.
+That's okay! The Convex client will handle rolling back this update after the
+mutation completes and the queries are updated. If there are small mistakes in
+optimistic updates, the UI will always eventually render the correct values.
+
+Similarly, the update creates a temporary `Id` with
+`new Id("messages", crypto.randomUUID())`. This will also be rolled back and
+replaced with the true ID once the server assigns it.
+
+Lastly, note that this update creates a new array of messages instead of using
+`existingMessages.push(newMessage)`. This is important! Mutating objects inside
+of optimistic updates will corrupt the client's internal state and lead to
+surprising results. Always create new objects inside of optimistic updates.
+
+## Learning more
+
+To learn more, check out our API documentation:
+
+- [`.withOptimisticUpdate`](/api/interfaces/react.ReactMutation#withoptimisticupdate)
+- [`OptimisticUpdate`](/api/modules/browser#optimisticupdate)
+- [`OptimisticLocalStore`](/api/interfaces/browser.OptimisticLocalStore)
+
+If you'd like some hands on experience, try adding optimistic updates to the
+[tutorial app](https://github.com/get-convex/convex-tutorial)! If you do, you
+should notice the app feels snappier — just a little, Convex is pretty fast
+already! — but otherwise works the same.
+
+To explore even further, try inserting a mistake into this update! You should
+see a flicker as the optimistic update is applied and then rolled back.
diff --git a/synced/convex/docs/client/react/project-setup.md b/synced/convex/docs/client/react/project-setup.md
new file mode 100644
index 0000000..8138849
--- /dev/null
+++ b/synced/convex/docs/client/react/project-setup.md
@@ -0,0 +1,94 @@
+---
+title: "Configuring Deployment URL"
+slug: "deployment-urls"
+sidebar_label: "Deployment URLs"
+hidden: false
+sidebar_position: 5
+description: "Configuring your project to run with Convex"
+---
+
+When [connecting to your backend](/client/react.mdx#connecting-to-a-backend)
+it's important to correctly configure the deployment URL.
+
+### Create a Convex project
+
+The first time you run
+
+```sh
+npx convex dev
+```
+
+in your project directory you will create a new Convex project.
+
+Your new project includes two deployments: _production_ and _development_. The
+_development_ deployment's URL will be saved in `.env.local` or `.env` file,
+depending on the frontend framework or bundler you're using.
+
+You can find the URLs of all deployments in a project by visiting the
+[deployment settings](/dashboard/deployments/settings.md) on your Convex
+[dashboard](https://dashboard.convex.dev).
+
+### Configure the client
+
+Construct a Convex React client by passing in the URL of the Convex deployment.
+There should generally be a single Convex client in a frontend application.
+
+```jsx title="src/index.js"
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const deploymentURL = import.meta.env.VITE_CONVEX_URL;
+
+const convex = new ConvexReactClient(deploymentURL);
+```
+
+While this URL can be hardcoded, it's convenient to use an environment variable
+to determine which deployment the client should connect to.
+
+Use an environment variable name accessible from your client code according to
+the frontend framework or bundler you're using.
+
+### Choosing environment variable names
+
+To avoid unintentionally exposing secret environment variables in frontend code,
+many bundlers require environment variables referenced in frontend code to use a
+specific prefix.
+
+[Vite](https://vitejs.dev/guide/env-and-mode.html) requires environment
+variables used in frontend code start with `VITE_`, so `VITE_CONVEX_URL` is a
+good name.
+
+[Create React App](https://create-react-app.dev/docs/adding-custom-environment-variables/)
+requires environment variables used in frontend code to begin with `REACT_APP_`,
+so the code above uses `REACT_APP_CONVEX_URL`.
+
+[Next.js](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser)
+requires them to begin with `NEXT_PUBLIC_`, so `NEXT_PUBLIC_CONVEX_URL` is a
+good name.
+
+Bundlers provide different ways to access these variables too: while
+[Vite uses `import.meta.env.VARIABLE_NAME`](https://vitejs.dev/guide/env-and-mode.html),
+many other tools like Next.js use the Node.js-like
+[`process.env.VARIABLE_NAME`](https://nextjs.org/docs/basic-features/environment-variables)
+
+```jsx
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);
+```
+
+[`.env` files](https://www.npmjs.com/package/dotenv) are a common way to wire up
+different environment variable values in development and production
+environments. `npx convex dev` will save the deployment URL to the corresponding
+`.env` file, while trying to infer which bundler your project uses.
+
+```shell title=".env.local"
+NEXT_PUBLIC_CONVEX_URL=https://guiltless-dog-960.convex.cloud
+
+# examples of other environment variables that might be passed to the frontend
+NEXT_PUBLIC_SENTRY_DSN=https://123abc@o123.ingest.sentry.io/1234
+NEXT_PUBLIC_LAUNCHDARKLY_SDK_CLIENT_SIDE_ID=01234567890abcdef
+```
+
+Your backend functions can use
+[environment variables](/production/environment-variables.mdx) configured on
+your dashboard. They do not source values from `.env` files.
diff --git a/synced/convex/docs/client/react/quickstart-react-cra.md b/synced/convex/docs/client/react/quickstart-react-cra.md
new file mode 100644
index 0000000..3f091f1
--- /dev/null
+++ b/synced/convex/docs/client/react/quickstart-react-cra.md
@@ -0,0 +1,147 @@
+---
+title: Create-React-App Quickstart
+sidebar_label: Create React App
+description: "Add Convex to a Create React App project"
+slug: "quickstart-create-react-app"
+hide_table_of_contents: true
+sidebar_position: 1000
+---
+
+Learn how to query data from Convex in a React app using Create React App.
+
+Alternatively check out the [React Quickstart](/quickstart/react.mdx) using
+Vite.
+
+<StepByStep>
+  <Step title="Create a React app">
+    Create a React app using the `create-react-app` command.
+
+    ```sh
+    npx create-react-app my-app
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    To get started, install the `convex`
+    package which provides a convenient interface for working
+    with Convex from a React app.
+
+    Navigate to your app directory and install `convex`.
+
+
+    ```sh
+    cd my-app && npm install convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `src/convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    ```csv title="sampleData.jsonl"
+    {"text": "Buy groceries", "isCompleted": true}
+    {"text": "Go for a swim", "isCompleted": true}
+    {"text": "Integrate Convex", "isCompleted": false}
+    ```
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `src/convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    ```js title="src/convex/tasks.js"
+    import { query } from "./_generated/server";
+
+    export const get = query({
+      args: {},
+      handler: async (ctx) => {
+        return await ctx.db.query("tasks").collect();
+      },
+    });
+    ```
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+    In `index.js`, create a `ConvexReactClient` and pass it to a `ConvexProvider`
+    wrapping your app.
+
+    ```js title="src/index.js"
+    import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+    const convex = new ConvexReactClient(process.env.REACT_APP_CONVEX_URL);
+    root.render(
+      <React.StrictMode>
+        <ConvexProvider client={convex}>
+          <App />
+        </ConvexProvider>
+      </React.StrictMode>
+    );
+    ```
+
+  </Step>
+
+  <Step title="Display the data in your app">
+      In `App.js`, use the `useQuery` hook to fetch from your `api.tasks.get`
+      API function.
+
+      ```js title="src/App.js"
+      import { useQuery } from "convex/react";
+      import { api } from "./convex/_generated/api";
+
+      function App() {
+        const tasks = useQuery(api.tasks.get);
+        return (
+          <div className="App">
+            {JSON.stringify(tasks, null, 2)}
+          </div>
+        );
+      }
+      ```
+
+  </Step>
+
+  <Step title="Start the app">
+      Start the app, go to [http://localhost:3000](http://localhost:3000) in a browser,
+      and see the serialized list of tasks at the top of the page.
+
+      ```sh
+      npm start
+      ```
+
+  </Step>
+
+</StepByStep>
diff --git a/synced/convex/docs/client/react/tanstack-start/clerk.md b/synced/convex/docs/client/react/tanstack-start/clerk.md
new file mode 100644
index 0000000..c591d82
--- /dev/null
+++ b/synced/convex/docs/client/react/tanstack-start/clerk.md
@@ -0,0 +1,255 @@
+---
+title: "TanStack Start with Clerk"
+slug: "tanstack-start-with-clerk"
+sidebar_label: With Clerk
+sidebar_position: 10
+---
+
+
+
+Using Clerk with Convex looks like following the
+[Clerk TanStack Quickstart](https://clerk.com/docs/quickstarts/tanstack-start)
+and adding Convex like the
+[Convex TanStack Quickstart](/quickstart/tanstack-start.mdx) shows. Then to make
+Clerk identity tokens available everywhere you might make authenticated calls to
+Convex in TanStack Start, you'll want to
+
+1. Get an ID token from Clerk in addition to the `getAuth()` call with
+   `const token = await auth.getToken({ template: "convex" })`.
+2. Set the token in beforeLoad with
+   `ctx.context.convexQueryClient.serverHttpClient?.setAuth(token)` so the token
+   will be available in loaders.
+3. Add `<ConvexProviderWithClerk>` to the root component to keep refreshing
+   Clerk tokens while the app is in use.
+
+Making these changes looks like modifying `app/router.tsx` like this:
+
+
+```tsx
+import { createRouter as createTanStackRouter } from '@tanstack/react-router'
+import { routeTree } from './routeTree.gen'
+import { DefaultCatchBoundary } from './components/DefaultCatchBoundary'
+import { NotFound } from './components/NotFound'
+import { routerWithQueryClient } from '@tanstack/react-router-with-query'
+import { ConvexProvider, ConvexReactClient } from 'convex/react'
+import { ConvexQueryClient } from '@convex-dev/react-query'
+import { QueryClient } from '@tanstack/react-query'
+
+export function createRouter() {
+  const CONVEX_URL = (import.meta as any).env.VITE_CONVEX_URL!
+  if (!CONVEX_URL) {
+    throw new Error('missing VITE_CONVEX_URL envar')
+  }
+  const convex = new ConvexReactClient(CONVEX_URL, {
+    unsavedChangesWarning: false,
+  })
+  const convexQueryClient = new ConvexQueryClient(convex)
+
+  const queryClient: QueryClient = new QueryClient({
+    defaultOptions: {
+      queries: {
+        queryKeyHashFn: convexQueryClient.hashFn(),
+        queryFn: convexQueryClient.queryFn(),
+      },
+    },
+  })
+  convexQueryClient.connect(queryClient)
+
+  // @snippet start example
+  const router = routerWithQueryClient(
+    createTanStackRouter({
+      routeTree,
+      defaultPreload: 'intent',
+      defaultErrorComponent: DefaultCatchBoundary,
+      defaultNotFoundComponent: () => <NotFound />,
+      context: { queryClient, convexClient: convex, convexQueryClient },
+      Wrap: ({ children }) => (
+        <ConvexProvider client={convexQueryClient.convexClient}>
+          {children}
+        </ConvexProvider>
+      ),
+    }),
+    queryClient,
+  )
+  // @snippet end example
+
+  return router
+}
+
+declare module '@tanstack/react-router' {
+  interface Register {
+    router: ReturnType<typeof createRouter>
+  }
+}
+```
+
+
+and modifying `app/routes/__root.tsx` like this:
+
+
+```tsx
+import {
+  Link,
+  Outlet,
+  ScrollRestoration,
+  createRootRouteWithContext,
+  useRouteContext,
+} from '@tanstack/react-router'
+import {
+  ClerkProvider,
+  SignInButton,
+  SignedIn,
+  SignedOut,
+  UserButton,
+  useAuth,
+} from '@clerk/tanstack-start'
+import { TanStackRouterDevtools } from '@tanstack/router-devtools'
+import { Meta, Scripts, createServerFn } from '@tanstack/start'
+import { QueryClient } from '@tanstack/react-query'
+import * as React from 'react'
+import { getAuth } from '@clerk/tanstack-start/server'
+import { getWebRequest } from 'vinxi/http'
+import { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary.js'
+import { NotFound } from '~/components/NotFound.js'
+import appCss from '~/styles/app.css?url'
+import { ConvexQueryClient } from '@convex-dev/react-query'
+
+import { ConvexReactClient } from 'convex/react'
+import { ConvexProviderWithClerk } from 'convex/react-clerk'
+
+const fetchClerkAuth = createServerFn({ method: 'GET' }).handler(async () => {
+  const auth = await getAuth(getWebRequest())
+  const token = await auth.getToken({ template: 'convex' })
+
+  return {
+    userId: auth.userId,
+    token,
+  }
+})
+
+export const Route = createRootRouteWithContext<{
+  queryClient: QueryClient
+  convexClient: ConvexReactClient
+  convexQueryClient: ConvexQueryClient
+}>()({
+  head: () => ({
+    meta: [
+      {
+        charSet: 'utf-8',
+      },
+      {
+        name: 'viewport',
+        content: 'width=device-width, initial-scale=1',
+      },
+    ],
+    links: [
+      { rel: 'stylesheet', href: appCss },
+      {
+        rel: 'apple-touch-icon',
+        sizes: '180x180',
+        href: '/apple-touch-icon.png',
+      },
+      {
+        rel: 'icon',
+        type: 'image/png',
+        sizes: '32x32',
+        href: '/favicon-32x32.png',
+      },
+      {
+        rel: 'icon',
+        type: 'image/png',
+        sizes: '16x16',
+        href: '/favicon-16x16.png',
+      },
+      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },
+      { rel: 'icon', href: '/favicon.ico' },
+    ],
+  }),
+  beforeLoad: async (ctx) => {
+    const auth = await fetchClerkAuth()
+    const { userId, token } = auth
+
+    // During SSR only (the only time serverHttpClient exists),
+    // set the Clerk auth token to make HTTP queries with.
+    if (token) {
+      ctx.context.convexQueryClient.serverHttpClient?.setAuth(token)
+    }
+
+    return {
+      userId,
+      token,
+    }
+  },
+  errorComponent: (props) => {
+    return (
+      <RootDocument>
+        <DefaultCatchBoundary {...props} />
+      </RootDocument>
+    )
+  },
+  notFoundComponent: () => <NotFound />,
+  component: RootComponent,
+})
+
+function RootComponent() {
+  const context = useRouteContext({ from: Route.id })
+  return (
+    <ClerkProvider>
+      <ConvexProviderWithClerk client={context.convexClient} useAuth={useAuth}>
+        <RootDocument>
+          <Outlet />
+        </RootDocument>
+      </ConvexProviderWithClerk>
+    </ClerkProvider>
+  )
+}
+
+function RootDocument({ children }: { children: React.ReactNode }) {
+  return (
+    <html>
+      <head>
+        <Meta />
+      </head>
+      <body>
+        <div className="p-2 flex gap-2 text-lg">
+          <Link
+            to="/"
+            activeProps={{
+              className: 'font-bold',
+            }}
+            activeOptions={{ exact: true }}
+          >
+            Home
+          </Link>{' '}
+          <Link
+            to="/posts"
+            activeProps={{
+              className: 'font-bold',
+            }}
+          >
+            Posts
+          </Link>
+          <div className="ml-auto">
+            <SignedIn>
+              <UserButton />
+            </SignedIn>
+            <SignedOut>
+              <SignInButton mode="modal" />
+            </SignedOut>
+          </div>
+        </div>
+        <hr />
+        {children}
+        <ScrollRestoration />
+        <TanStackRouterDevtools position="bottom-right" />
+        <Scripts />
+      </body>
+    </html>
+  )
+}
+```
+
+
+Now all queries, mutations and action made with
+[TanStack Query](/client/tanstack-query.mdx) will be authenticated by a Clerk
+identity token.
diff --git a/synced/convex/docs/client/react/tanstack-start/tanstack-start.md b/synced/convex/docs/client/react/tanstack-start/tanstack-start.md
new file mode 100644
index 0000000..2695df7
--- /dev/null
+++ b/synced/convex/docs/client/react/tanstack-start/tanstack-start.md
@@ -0,0 +1,122 @@
+---
+title: "TanStack Start"
+sidebar_label: "TanStack Start"
+sidebar_position: 180
+description: "How Convex works with TanStack Start"
+---
+
+[TanStack Start](https://tanstack.com/start/latest) is a new React web framework
+with best-in-class typesafe routing.
+
+When used with Convex, TanStack Start provides
+
+- Live-updating queries with React Query (the React client for TanStack Query)
+- Subscription session resumption, from SSR to live on the client
+- Loader-based preloading and prefetching
+- Consistent logical query timestamp during SSR
+- Opt-in component-local SSR
+
+and more!
+
+This page describes the recommended way to use Convex with TanStack Start, via
+React Query. The standard Convex React hooks work also with TanStack Start
+without React Query, as do the [React Query hooks](/client/tanstack-query.mdx)
+without TanStack Start! But using all three is a sweet spot.
+
+<Admonition type="caution" title="TanStack Start is in Beta">
+  TanStack Start is a new React framework currently in beta. You can use it
+  today but there may be breaking changes made to it before a stable release.
+</Admonition>
+
+## Getting started
+
+Follow the [TanStack Start Quickstart](/quickstart/tanstack-start.mdx) to add
+Convex to a new TanStack Start project.
+
+## Using Convex with React Query
+
+You can read more about [React Query hooks](/client/tanstack-query.mdx), but a
+few highlights relevant to TanStack Start.
+
+### Staying subscribed to queries
+
+Convex queries in React Query continue to receive updates after the last
+component subscribed to the query unmounts. The default for this behavior is 5
+minutes and this value is configured with
+[`gcTime`](https://tanstack.com/query/latest/docs/framework/react/guides/caching).
+
+This is useful to know when debugging why a query result is already loaded: for
+client side navigations, whether a subscription is already active can depend on
+what pages were previously visited in a session.
+
+### Using Convex React hooks
+
+[Convex React](/client/react.mdx) hooks like
+[`usePaginatedQuery`](/api/modules/react#usepaginatedquery) can be used
+alongside TanStack hooks. These hooks reference the same Convex Client so
+there's still just one set of consistent query results in your app when these
+are combined.
+
+## Server-side Rendering
+
+Using TanStack Start and Query with Convex makes it particularly easy to
+live-update Convex queries on the client while also
+[server-rendering](https://tanstack.com/query/v5/docs/framework/react/guides/ssr)
+them.
+[`useSuspenseQuery()`](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
+is the simplest way to do this:
+
+```ts
+const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
+```
+
+### Consistent client views
+
+In the browser all Convex query subscriptions present a consistent,
+at-the-same-logical-timestamp view of the database: if one query result reflects
+a given mutation transaction, every other query result will too.
+
+Server-side rendering is usually a special case: instead of a stateful WebSocket
+session, on the server it's simpler to fetch query results ad-hoc. This can lead
+to inconsistencies analogous to one REST endpoint returning results before a
+mutation ran and another endpoint returning results after that change.
+
+In TanStack Start, this issue is avoided by sending in a timestamp along with
+each query: Convex uses the same timestamp for all queries.
+
+### Loaders
+
+To make client-side navigations faster you can add a
+[loader](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#using-loaders-to-ensure-data-is-loaded)
+to a route. By default, loaders will run when mousing over a link to that page.
+
+```ts
+export const Route = createFileRoute('/posts')({
+  loader: async (opts) => {
+    await opts.context.queryClient.ensureQueryData(
+      convexQuery(api.messages.list, {}),
+    );
+  };
+  component: () => {
+    const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
+    return (
+      <div>
+	{data.map((message) => (
+	  <Message key={message.id} post={message} />
+	))}
+      </div>
+    );
+  },
+})
+```
+
+## Authentication
+
+Client-side authentication in Start works the way
+[client-side authentication with Convex](https://docs.convex.dev/auth) generally
+works in React because TanStack Start works well as a client-side framework.
+
+To use Clerk auth to make authenticated Convex calls on the server as well see
+the [TanStack Start + Clerk guide](/client/react/tanstack-start/clerk.mdx).
+
+Clerk is an official partner of TanStack, see our setup guide.
diff --git a/synced/convex/docs/client/rust.md b/synced/convex/docs/client/rust.md
new file mode 100644
index 0000000..978e2e0
--- /dev/null
+++ b/synced/convex/docs/client/rust.md
@@ -0,0 +1,9 @@
+---
+title: "Rust"
+sidebar_position: 500
+---
+
+See the [Rust Quickstart](/quickstart/rust.mdx) and
+<a href="https://docs.rs/convex/latest/convex/" target="_blank">`convex` on
+docs.rs docs</a>. The Rust client is open source and available on
+[GitHub](https://github.com/get-convex/convex-rs).
diff --git a/synced/convex/docs/client/svelte.md b/synced/convex/docs/client/svelte.md
new file mode 100644
index 0000000..a994f06
--- /dev/null
+++ b/synced/convex/docs/client/svelte.md
@@ -0,0 +1,13 @@
+---
+title: "Svelte"
+sidebar_position: 250
+---
+
+Convex is a great fit for reactive UI frameworks like Svelte. The
+[convex-svelte npm package](https://www.npmjs.com/package/convex-svelte)
+enhances the [ConvexClient](/api/classes/browser.ConvexClient) with declarative
+subscriptions in Svelte 5.
+
+See the [Svelte Quickstart](/quickstart/svelte.mdx) to get started. The Svelte
+client is open source and available on
+[GitHub](https://github.com/get-convex/convex-svelte).
diff --git a/synced/convex/docs/client/swift.md b/synced/convex/docs/client/swift.md
new file mode 100644
index 0000000..96c0863
--- /dev/null
+++ b/synced/convex/docs/client/swift.md
@@ -0,0 +1,289 @@
+---
+title: "iOS & macOS Swift"
+sidebar_label: "Swift"
+sidebar_position: 700
+---
+
+The Convex Swift client library enables your iOS or macOS application to
+interact with your Convex backend. It allows your frontend code to:
+
+1. Call
+   your [queries](/functions/query-functions.mdx), [mutations](/functions/mutation-functions.mdx) and [actions](/functions/actions.mdx)
+2. Authenticate users using [Auth0](/auth/auth0.mdx)
+
+The library is open source
+and [available on GitHub](https://github.com/get-convex/convex-swift).
+
+Follow the [Swift Quickstart](/quickstart/swift.mdx) to get started.
+
+## Installation
+
+For an iOS or macOS project in Xcode, you’ll need to perform the following steps
+to add a dependency on the `ConvexMobile` library.
+
+1. Click on the top-level app container in the project navigator on the left
+2. Click on the app name under the PROJECT heading
+3. Click the _Package Dependencies_ tab
+4. Click the + button
+
+   ![Screenshot 2024-10-02 at 2.33.43 PM.png](/screenshots/swift_qs_step_2.png)
+
+5. Paste
+   [`https://github.com/get-convex/convex-swift`](https://github.com/get-convex/convex-swift)
+   into the search box and press Enter
+6. When the `convex-swift` package loads, click the Add Package button
+7. In the _Package Products_ dialog, select your product name in the _Add to
+   Target_ dropdown
+8. Click _Add Package_
+
+## Connecting to a backend
+
+The `ConvexClient` is used to establish and maintain a connection between your
+application and the Convex backend. First you need to create an instance of the
+client by giving it your backend deployment URL:
+
+```swift
+import ConvexMobile
+
+let convex = ConvexClient(deploymentUrl: "https://<your domain here>.convex.cloud")
+```
+
+You should create and use one instance of the `ConvexClient` for the lifetime of
+your application process. You can store the client in a global constant like
+shown above. An actual connection to the Convex backend won’t be initiated until
+you call a method on the `ConvexClient`. After that it will maintain the
+connection and re-establish it if it gets dropped.
+
+## Fetching data
+
+The Swift Convex library gives you access to the Convex sync engine, which
+enables real-time *subscriptions* to query results. You subscribe to queries
+with the `subscribe` method on `ConvexClient` which returns
+a [`Publisher`](https://developer.apple.com/documentation/combine). The data
+available via the `Publisher` will change over time as the underlying data
+backing the query changes.
+
+You can call methods on the `Publisher` to transform and consume the data it
+provides.
+
+A simple way to consume a query that returns a list of strings in a `View` is to
+use a combination of a `@State` containing a list and the `.task` modifier with
+code that loops over the query results as an `AsyncSequence`:
+
+```swift
+struct ColorList: View {
+  @State private var colors: [String] = []
+
+  var body: some View {
+    List {
+      ForEach(colors, id: \.self) { color in
+        Text(color)
+      }
+    }.task {
+      let latestColors = convex.subscribe(to: "colors:get", yielding: [String].self)
+        .replaceError(with: [])
+        .values
+      for await colors in latestColors {
+        self.colors = colors
+      }
+    }
+  }
+}
+```
+
+Any time the data that powers the backend `"colors:get"` query changes, a
+new array of `String` values will appear in the `AsyncSequence` and the
+`View`'s `colors` list gets assigned the new data. The UI will then rebuild
+reactively to reflect the changed data.
+
+### Query arguments
+
+You can pass arguments to `subscribe` and they will be supplied to the
+associated backend `query` function. The arguments must be a Dictionary keyed
+with strings and the values should generally be primitive types, Arrays and
+other Dictionaries.
+
+```swift
+let publisher = convex.subscribe(to: "colors:get",
+                               with:["onlyFavorites": true],
+                           yielding:[String].self)
+```
+
+Assuming the `colors:get` query accepts an `onlyFavorites` argument, the value
+can be received and used to perform logic in the query function.
+
+<Admonition type="tip">
+Use [Decodable structs](/client/swift/data-types.md#custom-data-types)
+to automatically convert Convex objects to Swift structs.
+</Admonition>
+
+<Admonition type="caution">
+* There are important gotchas when
+  [sending and receiving numbers](/client/swift/data-types.md#numerical-types)
+  between Swift and Convex.
+* Depending on your backend functions, you may need to deal with
+  [reserved Swift keywords](/client/swift/data-types.md#field-name-conversion).
+</Admonition>
+
+### Subscription lifetime
+
+The `Publisher` returned from `subscribe` will persist as long as the associated
+`View` or `ObservableObject`. When either is no longer part of the UI, the
+underlying query subscription to Convex will be canceled.
+
+## Editing Data
+
+You can use the `mutation` method on `ConvexClient` to trigger a
+backend [mutation](/functions/mutation-functions.mdx).
+
+`mutation` is an `async` method so you'll need to call it within a `Task`.
+Mutations can return a value or not.
+
+Mutations can also receive arguments, just like queries. Here's an example of
+calling a mutation with arguments that returns a value:
+
+```swift
+let isColorAdded: Bool = try await convex.mutation("colors:put", with: ["color": newColor])
+```
+
+### Handling errors
+
+If an error occurs during a call to `mutation`, it will throw. Typically you may
+want to
+catch [`ConvexError`](/functions/error-handling/application-errors.mdx) and `ServerError` and
+handle them however is appropriate in your application.
+
+Here’s a small example of how you might handle an error from `colors:put` if it
+threw a `ConvexError` with an error message if a color already existed.
+
+```swift
+do {
+  try await convex.mutation("colors:put", with: ["color": newColor])
+} catch ClientError.ConvexError(let data) {
+  errorMessage = try! JSONDecoder().decode(String.self, from: Data(data.utf8))
+  colorNotAdded = true
+}
+```
+
+See documentation on [error handling](/functions/error-handling/) for more
+details.
+
+## Calling third-party APIs
+
+You can use the `action` method on `ConvexClient` to trigger a
+backend [action](/functions/actions.mdx).
+
+Calls to `action` can accept arguments, return values and throw exceptions just
+like calls to `mutation`.
+
+Even though you can call actions from your client code, it's not always the
+right choice. See the action docs for tips
+on [calling actions from clients](/functions/actions.mdx#calling-actions-from-clients).
+
+## Authentication with Auth0
+
+You can use `ConvexClientWithAuth` in place of `ConvexClient` to configure
+authentication with [Auth0](https://auth0.com/). You'll need
+the `convex-swift-auth0` library to do that, as well as an Auth0 account and
+application configuration.
+
+See
+the [README](https://github.com/get-convex/convex-swift-auth0/blob/main/README.md) in
+the `convex-swift-auth0` repo for more detailed setup instructions, and
+the [Workout example app](https://github.com/get-convex/ios-convex-workout) which
+is configured for Auth0. The overall [Convex authentication docs](/auth.mdx) are
+a good resource as well.
+
+It should also be possible to integrate other similar OpenID Connect
+authentication providers. See
+the [`AuthProvider`](https://github.com/get-convex/convex-swift/blob/c47aea414c92db2ccf3a0fa4f9db8caf2029b032/Sources/ConvexMobile/ConvexMobile.swift#L188) protocol
+in the `convex-swift` repo for more info.
+
+## Production and dev deployments
+
+When you're ready to move toward [production](/production.mdx) for your app, you
+can setup your Xcode build system to point different build targets to different
+Convex deployments. Build environment configuration is highly specialized, and
+it’s possible that you or your team have different conventions, but this is one
+way to approach the problem.
+
+1. Create “Dev” and “Prod” folders in your project sources.
+2. Add an `Env.swift` file in each one with contents like:
+
+```swift
+let deploymentUrl = "https://$DEV_OR_PROD.convex.cloud"
+```
+
+3. Put your dev URL in `Dev/Env.swift` and your prod URL in `Prod/Env.swift`.
+   Don’t worry if Xcode complains that `deploymentUrl` is defined multiple
+   times.
+4. Click on your top-level project in the explorer view on the left.
+5. Select your build target from the **TARGETS** list.
+6. Change the target’s name so it ends in “dev”.
+7. Right/Ctrl-click it and duplicate it, giving it a name that ends in “prod”.
+8. With the “dev” target selected, click the **Build Phases** tab.
+9. Expand the **Compile Sources** section.
+10. Select `Prod/Env.swift` and remove it with the - button.
+11. Likewise, open the “prod” target and remove `Dev/Env.swift` from its
+    sources.
+
+![Screenshot 2024-10-03 at 1.34.34 PM.png](/screenshots/swift_env_setup.png)
+
+Now you can refer to `deploymentUrl` wherever you create your `ConvexClient` and
+depending on the target that you build, it will use your dev or prod URL.
+
+## Structuring your application
+
+The examples shown in this guide are intended to be brief, and don't provide
+guidance on how to structure a whole application.
+
+If you want a more robust and layered approach, put your code that interacts
+with `ConvexClient`in a class that conforms to `ObservableObject`. Then your
+`View` can observe that object as a `@StateObject` and will rebuild whenever it
+changes.
+
+For example, if we adapt the `colors:get` example from above to a
+`ViewModel: ObservableObject` class, the `View` no longer plays a direct part in
+fetching the data - it only knows that the list of `colors` is provided by the
+`ViewModel`.
+
+```swift
+import SwiftUI
+
+class ViewModel: ObservableObject {
+  @Published var colors: [String] = []
+
+  init() {
+    convex.subscribe(to: "colors:get")
+      .replaceError(with: [])
+      .receive(on: DispatchQueue.main)
+      .assign(to: &$colors)
+  }
+}
+
+struct ContentView: View {
+  @StateObject var viewModel = ViewModel()
+
+  var body: some View {
+    List {
+      ForEach(viewModel.colors, id: \.self) { color in
+        Text(color)
+      }
+    }
+  }
+}
+```
+
+Depending on your needs and the scale of your app, it might make sense to give
+it even more formal structure as demonstrated in something like
+https://github.com/nalexn/clean-architecture-swiftui.
+
+## Under the hood
+
+The Swift Convex library is built on top of the
+official [Convex Rust client](/client/rust.md). It handles maintaining a
+WebSocket connection with the Convex backend and implements the full Convex
+protocol.
+
+All method calls on `ConvexClient` are handled via a Tokio async runtime on the
+Rust side and are safe to call from the application's main actor.
diff --git a/synced/convex/docs/client/swift/data-types.md b/synced/convex/docs/client/swift/data-types.md
new file mode 100644
index 0000000..7c6dae9
--- /dev/null
+++ b/synced/convex/docs/client/swift/data-types.md
@@ -0,0 +1,136 @@
+---
+title: "Swift and Convex type conversion"
+sidebar_label: "Data Types"
+hidden: false
+sidebar_position: 5
+description: "Customizing and converting types between the Swift app and Convex"
+---
+
+## Custom data types
+
+Convex lets you easily express your data in the backend as TypeScript objects,
+and can return those objects from queries, mutations and actions. To handle
+objects on the Swift side, create `struct` definitions that conform to the
+`Decodable` protocol. Usually that’s fairly trivial to do, as any `struct` with
+all `Decodable` members can automatically conform.
+
+Consider a Convex query function that returns results like this JavaScript
+object:
+
+```tsx
+{
+  name: "Guardians",
+  uniformColors: ["blue", "white", "red"],
+  wins: 80n,
+  losses: 60n
+}
+```
+
+That can be represented in Swift using:
+
+```swift
+struct BaseballTeam: Decodable {
+  let name: String
+  let uniformColors: [String]
+  @ConvexInt
+  var wins: Int
+  @ConvexInt
+  var losses: Int
+}
+```
+
+Then you can pass that type as the yielding argument in your subscribe call:
+
+```swift
+convex.subscribe(to: "mlb:first_place_team",
+               with: ["division": "AL Central"],
+           yielding: BaseballTeam.self)
+```
+
+The data from the remote function will be deserialized to your custom struct.
+Often your use of the type can be inferred from the calling context, and you can
+skip the yielding argument.
+
+## Numerical types
+
+Numeric types like `Int` and `Double` are encoded in a special format to ensure
+proper interoperation with your TypeScript backend functions. To safely use them
+on the Swift side, ensure that you use one of the following property wrappers.
+
+| Type                           | Wrapper                |
+| ------------------------------ | ---------------------- |
+| `Float` or `Double`            | `@ConvexFloat`         |
+| `Float?` or `Double?`          | `@OptionalConvexFloat` |
+| `Int` or `Int32` or `Int64`    | `@ConvexInt`           |
+| `Int?` or `Int32?` or `Int64?` | `@OptionalConvexInt`   |
+
+Note that `struct` properties with wrappers must be declared as `var`.
+
+## Field name conversion
+
+If your code receives objects with names that you need to or want to translate
+to different names, you can use a `CodingKeys` `enum` to specify a mapping of
+remote names to names on your struct. For example, imagine a backend function or
+API that returns log entries like the following representing when someone came
+in and went out:
+
+```tsx
+{name: "Bob", in: "2024-10-03 08:00:00", out: "2024-10-03 11:00:00"}
+```
+
+That data can’t decode directly into a `struct` because `in` is a keyword in
+Swift. We can use `CodingKeys` to give it an alternate name while still
+ingesting the data from the original name.
+
+```swift
+struct Log: Decodable {
+  let name: String
+  let inTime: String
+  let outTime: String
+
+  enum CodingKeys: String, CodingKey {
+    case name
+    case inTime = "in"
+    case outTime = "out"
+  }
+}
+```
+
+## Putting it all together
+
+In the custom data type example above, JavaScript's `BigInt` type is used in the
+backend data by adding a trailing `n` to the `wins` and `losses` values which
+lets the Swift code use `Int`. If instead the code used regular
+JavaScript `number` types, on the Swift side those would be received as floating
+point values and deserialization to `Int` would fail.
+
+If you have a situation like that where `number` is used but by convention it
+only contains integer values, you can handle that in your `struct` by using
+field name conversion and custom properties to hide the floating point
+representation.
+
+```swift
+struct BaseballTeam: Decodable {
+  let name: String
+  let uniformColors: [String]
+  @ConvexFloat
+  private var internalWins: Double
+  @ConvexFloat
+  private var internalLosses: Double
+
+  enum CodingKeys: String, CodingKey {
+    case name
+    case uniformColors
+    case internalWins = "wins"
+    case internalLosses = "losses"
+  }
+
+  // Expose the Double values as Ints
+  var wins: Int { Int(internalWins) }
+  var losses: Int { Int(internalLosses) }
+}
+```
+
+The pattern is to store the `Double` values privately and with different names
+than the value from the backend. Then add custom properties to provide
+the `Int` values.
diff --git a/synced/convex/docs/client/tanstack-query.md b/synced/convex/docs/client/tanstack-query.md
new file mode 100644
index 0000000..75ebc3d
--- /dev/null
+++ b/synced/convex/docs/client/tanstack-query.md
@@ -0,0 +1,172 @@
+---
+title: "Convex with TanStack Query"
+sidebar_label: "TanStack Query"
+sidebar_position: 325
+---
+
+
+
+[TanStack Query](https://tanstack.com/query/latest) is an excellent, popular
+library for managing requests to a server.
+
+The
+[`@convex-dev/react-query`](https://www.npmjs.com/package/@convex-dev/react-query)
+library provides
+[Query Option](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
+functions for use with TanStack Query.
+
+Not all features of the standard [Convex React client](/client/react) are
+available through the TanStack Query APIs but you can use the two alongside each
+other, dropping into the standard Convex React hooks as necessary.
+
+<BetaAdmonition feature="The TanStack Query adapter" verb="is" />
+
+This makes subscribing to a Convex query function using the TanStack Query
+`useQuery` hook look like this:
+
+```ts
+const { data, isPending, error } = useQuery(convexQuery(api.messages.list, {}));
+```
+
+Instead of the typical polling pattern for API endpoints used with TanStack
+Query, the code above receives updates for this `api.messages.list` query from
+the Convex server reactively. New results for all relevant subscriptions are
+pushed to the client where they update at the same time so data is never stale
+and there's no need to manually invalidate queries.
+
+<Admonition type="note" title="Support for other frameworks">
+  Currently only [React
+  Query](https://tanstack.com/query/latest/docs/framework/react/overview) is
+  supported via
+  [`@convex-dev/react-query`](https://www.npmjs.com/package/@convex-dev/react-query).
+  [Let us know](https://convex.dev/community) if you would find support for
+  vue-query, svelte-query, solid-query, or angular-query helpful.
+</Admonition>
+
+## Setup
+
+To get live updates in TanStack Query create a `ConvexQueryClient` and connect
+it to the TanStack Query
+[QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient).
+After installing the adapter library with
+
+```
+npm i @convex-dev/react-query
+```
+
+wire up Convex to TanStack Query like this:
+
+
+```tsx
+import { ConvexQueryClient } from "@convex-dev/react-query";
+import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
+const convexQueryClient = new ConvexQueryClient(convex);
+const queryClient = new QueryClient({
+  defaultOptions: {
+    queries: {
+      queryKeyHashFn: convexQueryClient.hashFn(),
+      queryFn: convexQueryClient.queryFn(),
+    },
+  },
+});
+convexQueryClient.connect(queryClient);
+
+ReactDOM.createRoot(document.getElementById("root")!).render(
+  <ConvexProvider client={convex}>
+    <QueryClientProvider client={queryClient}>
+      <App />
+    </QueryClientProvider>
+  </ConvexProvider>,
+);
+```
+
+
+Note that when your create your React tree you should both:
+
+- wrap your app in the TanStack Query
+  [`QueryClientProvider`](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
+  so you can use
+  [TanStack Query hooks](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
+  and
+- wrap your app in the [`ConvexProvider`](/api/modules/react#convexprovider) so
+  you can also use normal [Convex React](/client/react) hooks
+
+## Queries
+
+A live-updating subscription to a Convex [query](/functions/query-functions.mdx)
+is as simple as calling TanStack
+[`useQuery`](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
+with `convexQuery`:
+
+```ts
+import { useQuery } from "@tanstack/react-query";
+import { convexQuery } from "@convex-dev/react-query";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const { data, isPending, error } = useQuery(
+    convexQuery(api.functions.myQuery, { id: 123 }),
+  );
+  return isPending ? "Loading..." : data;
+}
+```
+
+You can spread the object returned by `convexQuery` into an object specifying
+additional
+[arguments of `useQuery`](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery).
+
+```ts
+const { data, isPending, error } = useQuery({
+  ...convexQuery(api.functions.myQuery, { id: 123 }),
+  initialData: [], // use an empty list if no data is available yet
+  gcTime: 10000, // stay subscribed for 10 seconds after this component unmounts
+});
+```
+
+## Mutations
+
+Your app can call Convex [mutations](/functions/mutation-functions.mdx) by using
+the TanStack
+[`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
+hook, and setting the `mutationFn` property to the result of calling
+`useConvexMutation`:
+
+```ts
+import { useMutation } from "@tanstack/react-query";
+import { useConvexMutation } from "@convex-dev/react-query";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const { mutate, isPending } = useMutation({
+    mutationFn: useConvexMutation(api.functions.doSomething),
+  });
+  return <button onClick={() => mutate({a: "Hello"})}>Click me</button>;
+}
+```
+
+`useConvexMutation` is just a re-export of the
+[`useMutation`](/client/react#editing-data) hook from
+[Convex React](/client/react).
+
+## Differences from using `fetch` with TanStack Query
+
+Convex provides stronger guarantees than other methods of fetching data with
+React Query, so some options and return value properties are no longer
+necessary.
+
+Subscriptions to Convex queries will remain active after the last component
+using `useQuery` for a given function unmounts for `gcTime` milliseconds. This
+value is 5 minutes by default; if this results in unwanted function activity use
+a smaller value.
+
+Data provided by Convex is never stale, so the `isStale` property of the return
+value of `useQuery` will always be false. `retry`-related options are ignored,
+since Convex provides its own retry mechanism over its WebSocket protocol.
+`refetch`-related options are similarly ignored since Convex queries are always
+up to date.
diff --git a/synced/convex/docs/client/vue.md b/synced/convex/docs/client/vue.md
new file mode 100644
index 0000000..96b205e
--- /dev/null
+++ b/synced/convex/docs/client/vue.md
@@ -0,0 +1,25 @@
+---
+title: "Vue"
+sidebar_position: 250
+---
+
+The community-maintained
+[`@convex-vue/core` npm package](https://www.npmjs.com/package/@convex-vue/core)
+provides deep integration of Convex with the Vue ecosystem.
+
+See the [Vue Quickstart](/quickstart/vue.mdx) to get started or the
+[convex-vue GitHub page](https://github.com/Darialyphia/convex-vue/tree/master/packages/convex-vue)
+for more documentation.
+
+<Admonition type="info">
+
+The [`@convex-vue/core` library](https://www.npmjs.com/package/@convex-vue/core)
+is community-maintained. Thank you to the maintainer
+[Daria](https://github.com/Darialyphia) for his work on this project!
+
+You're welcome to ask questions about the library on the
+[Convex Discord](https://convex.dev/community) but opening a
+[convex-vue GitHub](https://github.com/Darialyphia/convex-vue/tree/master/packages/convex-vue)
+issue is a better way to request a new feature or report a bug.
+
+</Admonition>
diff --git a/synced/convex/docs/components.md b/synced/convex/docs/components.md
new file mode 100644
index 0000000..e293853
--- /dev/null
+++ b/synced/convex/docs/components.md
@@ -0,0 +1,246 @@
+---
+title: "Components"
+description: "Self contained building blocks of your app"
+pagination_prev: search
+---
+
+import { ComponentCardList } from "@site/src/ComponentCardList.tsx";
+
+<span className="convex-hero">
+  Convex Components package up code and data in a sandbox that allows you to
+  confidently and quickly add new features to your backend.
+</span>
+
+Convex Components are like mini self-contained Convex backends, and installing
+them is always safe. They can't read your app's tables or call your app's
+functions unless you pass them in explicitly.
+
+You can read about the full vision in
+[Convex: The Software-Defined Database](https://stack.convex.dev/the-software-defined-database#introducing-convex-components)
+
+The Convex team has built a few components that add new features to your
+backend. You'll eventually be able to author your own components to use within
+your project and to share with the community, but we haven't stabilized and
+documented the authoring APIs yet.
+
+Each component is installed as its own independent library from NPM. Check out
+the component's README for installation and usage instructions. You can see the
+full directory on the [Convex website](https://convex.dev/components).
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "https://convex.dev/components",
+    label: "Full Components Directory",
+  }}
+/>
+
+## Durable Functions
+
+<ComponentCardList
+  items={[
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/workflow",
+      label: "Workflow",
+      description: "Async code flow as durable functions.",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/workpool",
+      label: "Workpool",
+      description: "Async durable function queue.",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/crons",
+      label: "Crons",
+      description: "Dynamic runtime cron management",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/retrier",
+      label: "Action Retrier",
+      description: "Retry failed external calls automatically",
+    },
+  ]}
+/>
+
+## Database
+
+<ComponentCardList
+  items={[
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/sharded-counter",
+      label: "Sharded Counter",
+      description: "High-throughput counter operations",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/migrations",
+      label: "Migrations",
+      description: "Define and run migrations",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/aggregate",
+      label: "Aggregate",
+      description: "Efficient sums and counts",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/geospatial",
+      label: "Geospatial (Beta)",
+      description: "Store and search locations",
+    },
+  ]}
+/>
+
+## Integrations
+
+<ComponentCardList
+  items={[
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/cloudflare-r2",
+      label: "Cloudflare R2",
+      description: "Store and serve files",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/prosemirror-sync",
+      label: "Collaborative Text Editor Sync",
+      description: "Real-time collaborative text editing",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/push-notifications",
+      label: "Expo Push Notifications",
+      description: "Send mobile push notifications",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/twilio",
+      label: "Twilio SMS",
+      description: "Send and receive SMS messages",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/launchdarkly",
+      label: "LaunchDarkly Feature Flags",
+      description: "Sync feature flags with backend",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/polar",
+      label: "Polar",
+      description: "Add subscriptions and billing",
+    },
+  ]}
+/>
+
+## Backend
+
+<ComponentCardList
+  items={[
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/agent",
+      label: "AI Agent",
+      description: "Define agents with tools and memory",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/persistent-text-streaming",
+      label: "Persistent Text Streaming",
+      description: "Stream and store text data",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/rate-limiter",
+      label: "Rate Limiter",
+      description: "Control resource usage rates",
+    },
+    {
+      type: "link",
+      href: "https://www.convex.dev/components/action-cache",
+      label: "Action Cache",
+      description: "Cache expensive external calls",
+    },
+  ]}
+/>
+
+<Admonition type="caution" title="The component authoring APIs are in Beta">
+  The underlying authoring APIs for components are still in flux. The Convex
+  team authored components listed below will be kept up to date as the APIs
+  change.
+</Admonition>
+
+## Understanding Components
+
+Components can be thought of as a combination of concepts from frontend
+components, third party APIs, and both monolith and service-oriented
+architectures.
+
+### Data
+
+Similar to frontend components, Convex Components encapsulate state and behavior
+and allow exposing a clean interface. However, instead of just storing state in
+memory, these can have internal state machines that can persist between user
+sessions, span users, and change in response to external inputs, such as
+webhooks. Components can store data in a few ways:
+
+- Database tables with their own schema validation definitions. Since Convex is
+  realtime by default, data reads are automatically reactive, and writes commit
+  transactionally.
+- File storage, independent of the main app's file storage.
+- Durable functions via the built-in function scheduler. Components can reliably
+  schedule functions to run in the future and pass along state.
+
+Typically, libraries require configuring a third party service to add stateful
+off-the-shelf functionality, which lack the transactional guarantees that come
+from storing state in the same database.
+
+### Isolation
+
+Similar to regular npm libraries, Convex Components include functions, type
+safety, and are called from your code. However, they also provide extra
+guarantees.
+
+- Similar to a third-party API, components can't read data for which you don't
+  provide access. This includes database tables, file storage, environment
+  variables, scheduled functions, etc.
+- Similar to service-oriented architecture, functions in components are run in
+  an isolated environment, so they can't read or write global variables or patch
+  system behavior.
+- Similar to a monolith architecture, data changes commit transactionally across
+  calls to components, without having to reason about complicated distributed
+  commit protocols or data inconsistencies. You'll never have a component commit
+  data but have the calling code roll back.
+- In addition, each mutation call to a component is a sub-mutation isolated from
+  other calls, allowing you to safely catch errors thrown by components. It also
+  allows component authors to easily reason about state changes without races,
+  and trust that a thrown exception will always roll back the Component's
+  sub-mutation. [Read more](/components/using.mdx#transactions).
+
+### Encapsulation
+
+Being able to reason about your code is essential to scaling a codebase.
+Components allow you to reason about API boundaries and abstractions.
+
+- The transactional guarantees discussed above allows authors and users of
+  components to reason locally about data changes.
+- Components expose an explicit API, not direct database table access. Data
+  invariants can be enforced in code, within the abstraction boundary. For
+  example, the [aggregate component](https://convex.dev/components/aggregate)
+  can internally denormalize data, the
+  [rate limiter](https://convex.dev/components/rate-limiter) component can shard
+  its data, and the
+  [push notification](https://convex.dev/components/push-notifications)
+  component can internally batch API requests, while maintaining simple
+  interfaces.
+- Runtime validation ensures all data that cross a component boundary are
+  validated: both arguments and return values. As with normal Convex functions,
+  the validators also specify the TypeScript types, providing end-to-end typing
+  with runtime guarantees.
diff --git a/synced/convex/docs/components/using.md b/synced/convex/docs/components/using.md
new file mode 100644
index 0000000..c5e0bd9
--- /dev/null
+++ b/synced/convex/docs/components/using.md
@@ -0,0 +1,122 @@
+---
+title: "Using Components"
+slug: "using-components"
+sidebar_position: 10
+description: "Using existing components"
+---
+
+Convex components add new features to your backend in their own sandbox with
+their own functions, schema and data, scheduled functions and all other
+fundamental Convex features.
+
+You can see the full list of components in the
+[directory](https://convex.dev/components). Each component README provides full
+instructions on how to install and use them.
+
+This doc will go through common patterns on how to install and use Components.
+
+## Installing Components
+
+We'll use the
+[Sharded Counter](https://www.npmjs.com/package/@convex-dev/sharded-counter)
+component as an example.
+
+<StepByStep>
+  <Step title="Install from `npm`">
+  Install the relevant package from npm
+
+```bash
+npm i @convex-dev/sharded-counter
+```
+
+  </Step>
+  <Step title="Add the component to your app">
+  Create or update the `convex.config.ts` file in your app's `convex/` folder and install the component by calling `use`:
+
+```ts
+// convex/convex.config.ts
+import { defineApp } from "convex/server";
+
+const app = defineApp();
+
+// highlight-next-line
+app.use(shardedCounter);
+//... Add other components here
+
+export default app;
+```
+
+  </Step>
+  <Step title="Run convex dev">
+  Make sure the convex dev cli is running to ensure the component is registered with your backend and the necessary code is generated.
+
+```bash
+npx convex dev
+```
+
+  </Step>
+  <Step title="Use the provided component API">
+    Each component has its own API. Check out each component's README file for more details on its usage.
+  </Step>
+
+</StepByStep>
+
+## Component functions
+
+Though components may expose higher level TypeScript APIs, under the hood they
+are called via normal Convex functions over the component sandbox boundary.
+
+Queries, mutations, and action rules still apply - queries can only call
+component queries, mutations can also call component mutations, and actions can
+also call component actions. As a result, queries into components are reactive
+by default, and mutations have the same transaction guarantees.
+
+## Transactions
+
+Remember that mutation functions in Convex are
+[transactions](/functions/mutation-functions.mdx#transactions). Either all the
+changes in the mutation get written at once or none are written at all.
+
+All writes for a top-level mutation call, including writes performed by calls
+into other components' mutations, are committed at the same time. If the
+top-level mutation throws an error, all of the writes are rolled back, and the
+mutation doesn't change the database at all.
+
+However, if a component mutation call throws an exception, only its writes are
+rolled back. Then, if the caller catches the exception, it can continue, perform
+more writes, and return successfully. If the caller doesn't catch the exception,
+then it's treated as failed and all the writes associated with the caller
+mutation are rolled back. This means your code can choose a different code path
+depending on the semantics of your component.
+
+As an example, take the
+[Rate Limiter](https://www.npmjs.com/package/@convex-dev/ratelimiter) component.
+One API of the Rate Limiter throws an error if a rate limit is hit:
+
+```ts
+// Automatically throw an error if the rate limit is hit.
+await rateLimiter.limit(ctx, "failedLogins", { key: userId, throws: true });
+```
+
+If the call to `rateLimiter.limit` throws an exception, we're over the rate
+limit. Then, if the calling mutation doesn't catch this exception, the whole
+transaction is rolled back.
+
+The calling mutation, on the other hand, could also decide to ignore the rate
+limit by catching the exception and proceeding. For example, an app may want to
+ignore rate limits if there is a development environment override. In this case,
+only the component mutation will be rolled back, and the rest of the mutation
+will continue.
+
+## Dashboard
+
+You can see your component’s data, functions, files, and other info using the
+dropdown in the Dashboard.
+
+<p style={{ textAlign: "center" }}>
+  <img
+    src="/screenshots/component_dropdown.png"
+    alt="Screenshot of the component dropdown"
+    width={414}
+  />
+</p>
diff --git a/synced/convex/docs/cspell.json b/synced/convex/docs/cspell.json
new file mode 100644
index 0000000..b5abcc8
--- /dev/null
+++ b/synced/convex/docs/cspell.json
@@ -0,0 +1,128 @@
+{
+  "words": [
+    "agentic",
+    "airbyte",
+    "Airbyte",
+    "AITODO",
+    "Alexes",
+    "androidx",
+    "asynciterable",
+    "Authed",
+    "bendrucker",
+    "birthdate",
+    "bundleable",
+    "bunx",
+    "bursty",
+    "bytestrings",
+    "Bytestrings",
+    "cacheable",
+    "canonicalized",
+    "chatbots",
+    "codegen",
+    "convexapp",
+    "convexmobile",
+    "cronspec",
+    "dall",
+    "Dall",
+    "Daria",
+    "Darialyphia",
+    "Databricks",
+    "ddtags",
+    "Deduped",
+    "denormalize",
+    "dotenvy",
+    "evals",
+    "Finalizer",
+    "Fivetran",
+    "gapless",
+    "Geospatial",
+    "getenv",
+    "giphy",
+    "GIPHY",
+    "hillo",
+    "interoperation",
+    "Ints",
+    "jetbrains",
+    "Jetpack",
+    "JWKS",
+    "kapa",
+    "keyof",
+    "kotlinx",
+    "LangChain",
+    "lateinit",
+    "leaderboard",
+    "leaderboards",
+    "libvips",
+    "Linsley",
+    "llms",
+    "localstorage",
+    "Luxon",
+    "Macartney",
+    "Michal",
+    "myapp",
+    "navigations",
+    "nextjs",
+    "OIDC",
+    "OLAP",
+    "OLTP",
+    "Oneoff",
+    "OpenAI",
+    "OWASP",
+    "pseudocode",
+    "quickstart",
+    "Quickstart",
+    "Quickstarts",
+    "Rakeeb",
+    "refetched",
+    "Retrier",
+    "Routable",
+    "ROUTABLE",
+    "runtimes",
+    "sandboxed",
+    "sarahs",
+    "Schedulable",
+    "SENDGRID",
+    "serializability",
+    "Serializability",
+    "Sharded",
+    "shouty",
+    "Snippeting",
+    "somethan",
+    "Steph",
+    "struct",
+    "structs",
+    "Sujay",
+    "Supabase",
+    "Superstruct",
+    "Swaghaus",
+    "tamagui",
+    "tiktoken",
+    "transactionally",
+    "transpile",
+    "transpiles",
+    "typeahead",
+    "typecheck",
+    "Typecheck",
+    "typechecked",
+    "typeof",
+    "typesafe",
+    "unauthed",
+    "unparameterized",
+    "unstub",
+    "Unvalidated",
+    "upsell",
+    "upsert",
+    "upserting",
+    "venv",
+    "vueuse",
+    "webapps",
+    "webm",
+    "websockets",
+    "whsec",
+    "Workpool",
+    "yourclientid",
+    "zoneinfo"
+  ],
+  "ignoreRegExpList": ["/#[\\w-]+/", "/\\w+.png/"],
+  "enableFiletypes": ["mdx"]
+}
diff --git a/synced/convex/docs/dashboard.md b/synced/convex/docs/dashboard.md
new file mode 100644
index 0000000..3d0aa18
--- /dev/null
+++ b/synced/convex/docs/dashboard.md
@@ -0,0 +1,10 @@
+---
+title: "Dashboard"
+id: "dashboard"
+---
+
+![Dashboard Projects View](/screenshots/projects.png)
+
+[The dashboard](https://dashboard.convex.dev/) is the central hub for managing
+your Convex projects. Here you can create and manage your Convex teams,
+projects, and deployments.
diff --git a/synced/convex/docs/dashboard/deployments/data.md b/synced/convex/docs/dashboard/deployments/data.md
new file mode 100644
index 0000000..7dbb910
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/data.md
@@ -0,0 +1,204 @@
+---
+title: "Data"
+slug: "data"
+sidebar_position: 5
+---
+
+![Data Dashboard Page](/screenshots/data.png)
+
+The [data page](https://dashboard.convex.dev/deployment/data) allows you to view
+and manage all of your tables and documents.
+
+On the left side of the page is a list of your tables. Clicking on a table will
+allows you to create, view, update, and delete documents in that table.
+
+You may drag-and-drop the column headers in each table to visually re-order the
+data.
+
+A readonly view of the data page is available in the
+[command line](/cli.md#display-data-from-tables).
+
+```sh
+npx convex data [table]
+```
+
+## Filtering documents
+
+You may filters documents on the data page by clicking the "Filter" button on
+the top of the page.
+
+![Data filters](/screenshots/data_filters.png)
+
+All fields in a document are filterable by the operations supported in Convex
+query syntax. [Equality](/database/reading-data/filters.mdx#equality-conditions)
+and [comparisons](/database/reading-data/filters.mdx#comparisons) share the same
+rules when filtering in the dashboard as a query using the Convex client. You
+may also filter based on the type of the field.
+
+To add a filter, click the `+` next to an existing filter. If you add more than
+one condition, they will be evaluated using the `and` operation.
+
+For each filter, you must select a field to filter by, operation, and comparison
+value. In the third input box (selecting a value), you may enter a valid Convex
+value, such as `"a string"`, `123`, or even a complex object, such as
+`{ a: { b: 2 } }`
+
+<Admonition type="note">
+
+When filtering by `_creationTime`, a date picker will be displayed instead of
+the normal JavaScript syntax input box. Comparisons for `_creationTime` are made
+at the nanosecond granularity, so if you'd like to filter to an exact time, try
+adding two filter conditions for `creationTime >= $time` and
+`creationTime <= $time + 1 minute`.
+
+</Admonition>
+
+## Writing custom queries
+
+You can write a [query](/database/reading-data/reading-data.mdx) directly in the
+dashboard. This allows you to perform arbitrary filtering and transformation of
+the data, including sorting, joins, grouping and aggregations.
+
+In the `⋮` overflow menu at the top of the data page click on the “Custom query”
+option.
+
+<img
+    src="/screenshots/data_custom_query.png"
+    alt="Custom query button"
+    width={250}
+/>
+
+This opens the same UI used for
+[running your deployed functions](/dashboard/deployments/functions.md#running-functions),
+but with the “Custom test query” option selected, which lets you edit the source
+code for the query. This source code will be sent to your deployment and
+executed when you click on the “Run Custom Query“ button.
+
+![Running a custom test query](/screenshots/data_custom_query_runner.png)
+
+If you're not on the data page, you can still open this UI via the persistent
+_fn_ button shown on the bottom right of all deployment pages. The keyboard
+shortcut to open the function runner is Ctrl + ` (backtick).
+
+## Creating tables
+
+You may create a table from the dashboard by clicking the "Create Table" button
+and entering a new name for the table.
+
+## Creating documents
+
+You may add individual documents to the table using the “Add Documents” button
+located in the data table's toolbar.
+
+Once you click “Add Documents” a side panel will open, allowing you to add new
+documents to your table using JavaScript syntax. To add more than one document
+add a time, add new objects to the array in the editor.
+
+![Add document](/screenshots/data_add_document.png)
+
+## Quick actions (context menu)
+
+You can right-click on a document or value to open a context menu with quick
+actions, like copying values, quickly filtering by the selected value, and
+deleting documents.
+
+![Quick actions context menu](/screenshots/data_context_menu.png)
+
+## Editing a cell
+
+To edit a cell's value, double-click on the cell in the data table, or press the
+Enter key while it’s selected. You can change the selected cell by using the
+arrow keys.
+
+You can change the value by editing inline, and pressing enter to save.
+
+<Admonition type="note">
+
+You can even edit the type of your value here, as long as it satisfies your
+[schema](/database/schemas.mdx) — try replacing a string with an object!
+
+</Admonition>
+
+![Inline value editor](/screenshots/data_edit_inline.png)
+
+## Editing a document
+
+To edit multiple fields in a document at the same time, hover over the document
+and right-click to open the context menu. From there you can click on "Edit
+Document".
+
+![Edit entire document](/screenshots/data_edit_document.png)
+
+## Adding references to other documents
+
+To reference another document, use the string ID of the document you want to
+reference.
+
+You can copy the ID by clicking on its cell and pressing CTRL/CMD+C.
+
+## Bulk editing documents
+
+You can edit multiple or all documents at once. To select all documents click on
+the checkbox in the table header row. To select individual documents hover over
+the left-most cell and click the checkbox that appears. To select multiple
+adjacent documents at once, press the Shift key when clicking on the checkbox.
+
+When at least one document is selected, the “(Bulk) Edit Document(s)” button
+will be visible in the table toolbar. Click the button and an editor will appear
+on the right hand side.
+
+![Bulk edit documents](/screenshots/data_bulk_edit.png)
+
+## Deleting documents
+
+When at least one document is selected (see above), the “Delete Document(s)”
+button will be visible in the table toolbar. Click the button to delete
+documents. If you're editing data in a production deployment a confirmation
+dialog will appear before the documents are deleted.
+
+## Clear a table
+
+You can also delete all documents by clicking on the `⋮` overflow menu at the
+top of the data page and clicking "Clear Table". This action will delete all
+documents in the table, without deleting the table itself.
+
+In production environments, the Convex dashboard will have you type in the name
+of the table before deletion.
+
+## Delete a table
+
+<Admonition type="caution" title="This is a permanent action">
+
+Deleting a table is irreversible. In production environments, the Convex
+dashboard will have you type in the name of the table before deletion.
+
+</Admonition>
+
+The "Delete table" button can be found by clicking on the `⋮` overflow menu at
+the top of the data page. This action will delete all documents this table, and
+remove the table from your list of tables. If this table had indexes, you will
+need to redeploy your convex functions (by running `npx convex deploy` or
+`npx convex dev` for production or development, respectively) to recreate the
+indexes.
+
+## Generating a schema
+
+At the bottom-left of the page is a "Generate Schema" button which you can click
+to have Convex generate a [schema](/database/schemas.mdx) of all your documents
+within this table.
+
+![Generate Schema button](/screenshots/data_generate_schema.png)
+
+## Table Schema and Indexes
+
+The "Schema and Indexes" button can be found by clicking on the `⋮` overflow
+menu at the top of the data page.
+
+This button will open a panel showing the saved [schema](/database/schemas.mdx)
+and [indexes](/database/reading-data/indexes/indexes.md) associated with the
+selected table.
+
+Indexes that have not completed backfilling will be accompanied by a loading
+spinner next to their name.
+
+![Table indexes](/screenshots/data_indexes.png)
diff --git a/synced/convex/docs/dashboard/deployments/deployments.md b/synced/convex/docs/dashboard/deployments/deployments.md
new file mode 100644
index 0000000..5956fb9
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/deployments.md
@@ -0,0 +1,17 @@
+---
+title: "Deployments"
+id: "deployments"
+sidebar_position: 20
+---
+
+Each project in Convex has a main production deployment, and each developer on
+your team can also set up their own personal development deployment.
+Additionally, there are
+[preview deployments](/production/hosting/preview-deployments.mdx) used to test
+backend changes before they're deployed to production.
+
+While on a [deployment page](https://dashboard.convex.dev/deployment), you may
+switch between production, your development deployment, and any preview
+deployments by using the dropdown menu on the top-left of the page.
+
+![Deployment switcher](/screenshots/deployment_menu.png)
diff --git a/synced/convex/docs/dashboard/deployments/files.md b/synced/convex/docs/dashboard/deployments/files.md
new file mode 100644
index 0000000..34760c5
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/files.md
@@ -0,0 +1,23 @@
+---
+title: "File Storage"
+sidebar_label: "Files"
+slug: "file-storage"
+sidebar_position: 20
+---
+
+The [file storage page](https://dashboard.convex.dev/deployment/files) displays
+[files stored in your deployment](/file-storage.mdx). The page also shows the
+files' storage IDs, size, and content type. You can upload new files and
+download or delete existing files.
+
+Storage IDs might be referenced by documents in your database.
+
+<Admonition type="tip">
+
+When new files are uploaded, the UI will reference the name of the recently
+uploaded file. However, these names are not persisted and will no longer appear
+when the page is reloaded.
+
+</Admonition>
+
+![File Storage button](/screenshots/file_storage.png)
diff --git a/synced/convex/docs/dashboard/deployments/functions.md b/synced/convex/docs/dashboard/deployments/functions.md
new file mode 100644
index 0000000..9e8acd3
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/functions.md
@@ -0,0 +1,146 @@
+---
+title: "Functions"
+slug: "functions"
+sidebar_position: 10
+---
+
+![Functions Dashboard View](/screenshots/functions.png)
+
+The [functions page](https://dashboard.convex.dev/deployment/functions) shows
+all currently deployed Convex functions.
+
+For dev deployments, these are updated continuously by
+[`npx convex dev`](/cli.md#run-the-convex-dev-server). The functions for
+production deployments are registered with
+[`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).
+
+## Running functions
+
+To run a Convex function in the dashboard, select a function from the list on
+the left-hand side of the page, and click the "Run Function" button that appears
+next to the function's name.
+
+If you're not on the functions page, you can still open this UI via the
+persistent _fn_ button shown on the bottom right of all deployment pages. The
+keyboard shortcut to open the function runner is Ctrl + ` (backtick).
+
+This view allows you to fill out the arguments for your function and run it.
+
+Query results will update automatically as you modify function arguments and
+data changes.
+
+Mutation and action results will be visible once you click the "Run" button.
+
+Note that these results will show the logs and value returned from the function.
+To see what changed when you ran your function, see the
+[data page](/dashboard/deployments/data.md).
+
+![Running a function](/screenshots/run_function.png)
+
+You can also
+[write a custom query function](/dashboard/deployments/data.md#writing-custom-queries)
+by choosing the “Custom test query“ option instead of one of your deployed
+functions.
+
+### Querying a paginated function
+
+When querying a paginated function in the dashboard, the UI will expect the
+arguments to include
+[`PaginationOptions`](/api/interfaces/server.PaginationOptions) -- i.e. an
+object containing the `numItems` field, and optionally the `cursor` field. The
+name of this argument should be the same as the name defined in your query
+function.
+
+- `numItems` should be the number of items to include in a page
+- `cursor` can be left blank to begin pagination. Once you receive results, you
+  may set `cursor` to the result's `continueCursor` field to proceed to the next
+  page.
+
+### Assuming a user identity
+
+<Admonition type="tip">
+
+Assuming a user identity in the Convex dashboard does not give you access to a
+real user identity. Instead, this concept can be thought of as "mocking" a user
+identity into your function.
+
+</Admonition>
+
+If you're building an authenticated application, you may want to run a Convex
+function while acting as an authenticated user identity.
+
+To do so, check the "Act as a user" box.
+
+From there, you can type in the box that appears to fill out the user identity
+object.
+
+![Acting as a user](/screenshots/acting_as_a_user.png)
+
+The valid user attributes are:
+
+| Attribute           | Type                                     |
+| ------------------- | ---------------------------------------- |
+| subject\*           | string                                   |
+| issuer\*            | string                                   |
+| name                | string                                   |
+| givenName           | string                                   |
+| familyName          | string                                   |
+| nickname            | string                                   |
+| preferredUsername   | string                                   |
+| profileUrl          | string                                   |
+| email               | string                                   |
+| emailVerified       | boolean                                  |
+| gender              | string                                   |
+| birthday            | string                                   |
+| timezone            | string                                   |
+| language            | string                                   |
+| phoneNumber         | string                                   |
+| phoneNumberVerified | boolean                                  |
+| address             | string                                   |
+| updatedAt           | string (in the form of an RFC 3339 date) |
+| customClaims        | object                                   |
+
+\*These attributes are required.
+
+## Metrics
+
+There are four basic charts for each function. For overall team usage metrics,
+see [team settings](/dashboard/teams.md#usage).
+
+### Invocations
+
+This chart plots the number of times your function was called per minute. As
+your app's usage increases, you should see this chart trend upward as well.
+
+### Errors
+
+A plot of any exceptions that occur while running your function. Want to know
+what's going wrong? Check out the logs page, detailed below.
+
+### Cache Hit Rate
+
+<Admonition type="tip">
+Cache hit rate only applies to query functions
+</Admonition>
+
+A percentage rate of how often this function is simply reusing a cached value
+vs. being rerun. Your application will run best and your response times will be
+fastest with high cache hit rates.
+
+### Execution Time
+
+How long, in milliseconds, this function is taking to run.
+
+There are four individual lines plotted on this chart, p50, p90, p95, and p99.
+Each of these lines represents the response time for that percentile in the
+distribution of hits over time. So, only 1% of requests took longer to run than
+the time shown by the p99 line. Typically, keeping an eye on these _tail
+latencies_ is a good way to make sure your application is getting data services
+quickly.
+
+Consider the relationship of the execution time to the cache hit rate. As a
+rule, a cache hit takes well under 1 ms, so the higher your cache hit rate, the
+better your response times will be.
+
+Clicking on any of the charts will give you a larger, detailed view where you
+can customize the time ranges you're inspecting.
diff --git a/synced/convex/docs/dashboard/deployments/health.md b/synced/convex/docs/dashboard/deployments/health.md
new file mode 100644
index 0000000..2a986ca
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/health.md
@@ -0,0 +1,89 @@
+---
+title: "Health"
+slug: "health"
+sidebar_position: 0
+---
+
+The [health page](https://dashboard.convex.dev/deployment/) is the landing page
+for your deployment. On this page, you can see some important information about
+the health of your deployment.
+
+## Failure Rate
+
+![Failure Rate Card](/screenshots/health_failure_rate.png)
+
+The failure rate card shows the percentage of failed request by minute ove the
+last hour. The failure rate is calculated as the number of failed requests
+divided by the total number of requests.
+
+## Cache Hit Rate
+
+![Cache Hit Rate Card](/screenshots/health_cache_hit_rate.png)
+
+The cache hit rate card shows the percentage of cache hits by minute over the
+last hour. The cache hit rate is calculated as the number of cache hits divided
+by the total number of requests.
+
+Cache hit rate only applies to query functions.
+
+## Scheduler Status
+
+![Scheduler Status Card](/screenshots/scheduler_overdue.png)
+
+The scheduler status card shows the status of the
+[scheduler](/scheduling/scheduled-functions). If the scheduler falls behind due
+to too many scheduled tasks, the status will show as "Overdue", displaying the
+lag time in minutes.
+
+You may click the button in the top right corner of the card to view a chart
+showing the scheduler status over the last hour.
+
+![Scheduler Status Chart](/screenshots/scheduler_status.png)
+
+## Last Deployed
+
+![Last Deployed Card](/screenshots/health_last_deployed.png)
+
+The last deployed card shows the time of the last time your functions were
+deployed.
+
+## Integrations
+
+<Admonition type="info">
+
+Integrations are only available on Convex Professional.
+
+</Admonition>
+
+![Last Deployed Card](/screenshots/health_integrations.png)
+
+The integrations card shows the status of your
+[Exception Reporting](/production/integrations/exception-reporting) and
+[Log Streams](/production/integrations/log-streams) integrations, with quick
+links to view and configure your integrations.
+
+## Insights
+
+![Insights Card](/screenshots/insights.png)
+
+The Health page also surfaces insights about your deployment, with suggestions
+on how to improve performance and reliability.
+
+Each Insight contains a description of the issue, the impact on your deployment
+(via a chart and event log), and a link to learn more about the issue and how to
+resolve it.
+
+Clicking on an Insight will open a breakdown of the issue, including a larger
+chart and a list of events that triggered the Insight.
+
+![Insight Breakdown](/screenshots/insights_breakdown.png)
+
+Available insights include:
+
+- Functions that are
+  [reading too many bytes](/production/state/limits#transactions) in a single
+  transaction.
+- Functions that are
+  [reading too many documents](/production/state/limits#transactions) in a
+  single transaction.
+- Functions that are experiencing [write conflicts](/error#1).
diff --git a/synced/convex/docs/dashboard/deployments/history.md b/synced/convex/docs/dashboard/deployments/history.md
new file mode 100644
index 0000000..1542ef6
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/history.md
@@ -0,0 +1,21 @@
+---
+title: "History"
+slug: "history"
+sidebar_position: 50
+---
+
+![History Dashboard Page](/screenshots/history.png)
+
+<Admonition type="info">
+
+The history page is only available on Convex Professional.
+
+</Admonition>
+
+This [history page](https://dashboard.convex.dev/deployment/history) is an audit
+log of configuration-related events that have occurred in the selected
+deployment, such as function deployments, changes to indexes, and changes to
+environment variables.
+
+You may also view an audit log of team-related events in the
+[team audit log](/dashboard/teams.md#audit-log).
diff --git a/synced/convex/docs/dashboard/deployments/logs.md b/synced/convex/docs/dashboard/deployments/logs.md
new file mode 100644
index 0000000..7c84f20
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/logs.md
@@ -0,0 +1,68 @@
+---
+title: "Logs"
+slug: "logs"
+sidebar_position: 40
+---
+
+![Logs Dashboard Page](/screenshots/logs.png)
+
+The [logs page](https://dashboard.convex.dev/deployment/logs) is a realtime view
+of all activity that occurs within your deployment.
+
+The logs page provides a short history of recent function logs, and will display
+new logs as they are generated. To store a longer history of logs, you may
+configure a [log stream](/production/integrations/log-streams/log-streams.mdx).
+
+Function activity includes:
+
+- The time of function execution.
+- The request ID of the function execution.
+- The outcome of the function execution (success or failure).
+- The name of the invoked function.
+- The output of the function, including any log lines logged by the function (ex
+  `console.log`) and exceptions.
+- The duration of function execution, in milliseconds (does not include network
+  latency).
+
+In addition to function activity,
+[deployment events](/dashboard/deployments/history.md) describing configuration
+changes will be present here.
+
+Clicking on log will open a view for all logs associated with the same Request
+ID as the selected log. This can be useful for debugging errors and
+understanding the context of a function execution.
+
+![Request ID Logs](/screenshots/request_logs.png)
+
+You can use controls on the top of this page to filter logs by text, function
+name, execution status, and log severity.
+
+### Filter logs
+
+Use the "Filter logs..." text box on the top of the page to filter log text.
+
+You can use the “Functions” drop-down list to include or exclude functions from
+the results.
+
+You can also find logs for a particular error using "Filter logs" and the
+[Convex request id](/functions/error-handling/error-handling.mdx#debugging-errors).
+For example if you see this `Error` in your browser console:
+
+![Browser Error](/screenshots/console_error_requestid.png)
+
+You can view the logs for that function in your dashboard by pasting that
+Request ID into the 'Search logs...' search bar on the
+[Logs](/dashboard/deployments/logs.md) page of your Convex dashboard. Note that
+because this page is not a complete historical view of logs, you may not find
+logs for older requests.
+
+Most error reporting services and log sinks should also be searchable by Request
+ID.
+
+### Log Types
+
+Logs can also be filtered by type. Types include function outcomes (success or
+failure) and severity levels (info, warn, debug, error).
+
+All failed executions will include a reason, which will usually be a JavaScript
+exception.
diff --git a/synced/convex/docs/dashboard/deployments/schedules.md b/synced/convex/docs/dashboard/deployments/schedules.md
new file mode 100644
index 0000000..7d12e22
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/schedules.md
@@ -0,0 +1,30 @@
+---
+title: "Schedules"
+slug: "schedules"
+sidebar_position: 30
+---
+
+The [schedules page](https://dashboard.convex.dev/deployment/schedules) displays
+all [scheduled functions](docs/scheduling/scheduled-functions.mdx) and
+[cron jobs](/scheduling/cron-jobs.mdx) in your deployment. Use the tabs at the
+top of this page to switch between scheduled functions and cron jobs.
+
+## Scheduled functions UI
+
+The scheduled functions UI shows a list of all upcoming function invocation.
+From here, you can filter to scheduled runs for a specific function, and cancel
+scheduled functions runs.
+
+![Scheduled functions](/screenshots/scheduled_functions.png)
+
+## Cron jobs UI
+
+The cron jobs UI lists all of your cron jobs, including their run frequency and
+scheduled run time.
+
+![Cron jobs](/screenshots/cron_jobs.png)
+
+Expanding a specific cron job will open the execution history for the selected
+job.
+
+![Cron job history](/screenshots/cron_job_history.png)
diff --git a/synced/convex/docs/dashboard/deployments/settings.md b/synced/convex/docs/dashboard/deployments/settings.md
new file mode 100644
index 0000000..270fb0a
--- /dev/null
+++ b/synced/convex/docs/dashboard/deployments/settings.md
@@ -0,0 +1,68 @@
+---
+title: "Settings"
+slug: "deployment-settings"
+sidebar_position: 60
+---
+
+The [deployment settings page](https://dashboard.convex.dev/deployment/settings)
+gives you access to information and configuration options related to a specific
+deployment (**production**, your personal **development** deployment, or a
+**preview** deployment).
+
+## URL and Deploy Key
+
+The [URL and deploy key page](https://dashboard.convex.dev/deployment/settings)
+shows:
+
+- The URL this deployment is hosted at. Some Convex integrations may require the
+  deployment URL for configuration.
+- The URL that HTTP Actions for this deployment should be sent to.
+- The deployment's deploy key, used to
+  [integrate with build tools such as Netlify and Vercel](/production/hosting/hosting.mdx)
+  and
+  [syncing data with Fivetran and Airbyte](/production/integrations/streaming-import-export.md).
+
+![Deployment Settings Dashboard Page](/screenshots/deployment_settings.png)
+
+## Environment Variables
+
+The
+[environment variables page](https://dashboard.convex.dev/deployment/settings/environment-variables)
+lets you add, change, remove and copy the deployment's
+[environment variables](/production/environment-variables.mdx).
+
+![deployment settings environment variables page](/screenshots/deployment_settings_env_vars.png)
+
+## Authentication
+
+The
+[authentication page](https://dashboard.convex.dev/deployment/settings/authentication)
+shows the values configured in your `auth.config.js` for user
+[authentication](/auth.mdx) implementation.
+
+## Backup & Restore
+
+The
+[backup & restore page](https://dashboard.convex.dev/deployment/settings/backups)
+lets you [backup](/database/backup-restore.mdx) the data stored in your
+deployment's database and file storage. On this page, you can schedule periodic
+backups.
+
+![deployment settings export page](/screenshots/backups.png)
+
+## Integrations
+
+The integrations page allows you to configure
+[log streaming](/production/integrations/integrations.mdx),
+[exception reporting](/production/integrations/integrations.mdx), and
+[streaming export](/production/integrations/streaming-import-export.md)
+integrations.
+
+## Pause Deployment
+
+On the
+[pause deployment page](https://dashboard.convex.dev/deployment/settings/pause-deployment)
+you can [pause your deployment](/production/pause-deployment.mdx) with the pause
+button.
+
+![deployment settings pause deployment page](/screenshots/deployment_settings_pause.png)
diff --git a/synced/convex/docs/dashboard/projects.md b/synced/convex/docs/dashboard/projects.md
new file mode 100644
index 0000000..f43fbc0
--- /dev/null
+++ b/synced/convex/docs/dashboard/projects.md
@@ -0,0 +1,60 @@
+---
+title: "Projects"
+slug: "projects"
+sidebar_position: 10
+---
+
+![Project settings](/screenshots/projects.png)
+
+A project corresponds to a codebase that uses Convex, which contains a
+production deployment and one personal deployment for each team member.
+
+Clicking on a project in the [landing page](https://dashboard.convex.dev) will
+redirect you to project details.
+
+## Creating a project
+
+Projects can be created from the dashboard or from the
+[CLI](/cli.md#create-a-new-project). To create a project from the dashboard
+click on the Create Project button.
+
+## Project Settings
+
+You can access project-level settings by clicking on the triple-dot `⋮` button
+on each Project card on the Projects page.
+
+![Project card menu](/screenshots/project_menu.png)
+
+On the [Project Settings page](https://dashboard.convex.dev/project/settings),
+you can:
+
+- Update your project's name and slug.
+- Manage the project's Admins. See
+  [Roles and Permissions](/dashboard/teams.md#roles-and-permissions) for more
+  details.
+- View the amount of [usage metrics](/dashboard/teams.md#usage) your project has
+  consumed.
+- Add [custom domains](/production/hosting/custom.mdx#custom-domains) for your
+  production deployment
+- Generate deploy keys for your production and preview deployments.
+- Create and edit
+  [default environment variables](/production/environment-variables.mdx#project-environment-variable-defaults).
+- View instructions to regain access to your project, should you lose track of
+  your `CONVEX_DEPLOYMENT` config.
+- Permanently delete the project.
+
+![Project settings](/screenshots/project_settings.png)
+
+## Deleting projects
+
+To delete a project, click on the triple-dot `⋮` button on the Project card and
+select "Delete". You may also delete your project from the Project Settings
+page.
+
+Once a project is deleted, it cannot be recovered. All deployments and data
+associated with the project will be permanently removed. When deleting a project
+from the dashboard, you will be asked to confirm the deletion. Projects with
+activity in the production deployment will have additional confirmation steps to
+prevent accidental deletion.
+
+![Delete project](/screenshots/project_delete.png)
diff --git a/synced/convex/docs/dashboard/teams.md b/synced/convex/docs/dashboard/teams.md
new file mode 100644
index 0000000..890f855
--- /dev/null
+++ b/synced/convex/docs/dashboard/teams.md
@@ -0,0 +1,156 @@
+---
+title: "Teams"
+slug: "teams"
+sidebar_position: 0
+---
+
+In Convex, your projects are organized by team. Teams are used to share access
+to your projects with other people. You may switch between teams or create a new
+team by clicking on the name of your team located on the top of the Convex
+dashboard. This will open the project selector, where you can switch teams by
+clicking on the team name once again.
+
+![Team switcher](/screenshots/team_selector.png)
+
+You may change the name of a team or invite new members to a team by clicking on
+the "Team Settings" button located on the top of the project list page.
+
+## General
+
+The [general page](https://dashboard.convex.dev/team/settings) allows changing
+the team name and slug.
+
+You may also delete the team from this page. You can only delete a team after
+deleting all of it's projects, and removing all other team members from your
+team. Deleting your team will automatically cancel your Convex subscription.
+
+![General team settings page](/screenshots/teams_general.png)
+
+## Team Members
+
+Use the
+[members settings page](https://dashboard.convex.dev/team/settings/members) to
+invite or remove members from your team.
+
+![Team members page](/screenshots/teams_members.png)
+
+### Roles and permissions
+
+Convex has two levels of control for managing access to your team, projects, and
+deployments. Team-level roles control what a user can do within the team, while
+project-level permissions control what a user can do within a specific project.
+
+#### Team roles
+
+Your team members can have one of the following roles:
+
+- Admin
+- Developer
+
+The creator of the team is automatically assigned the Admin role. When inviting
+new team members, you may select a role for them. You may also change the role
+of a team member at any time.
+
+Developers can:
+
+- Create new projects and deployments. When a new project is created, the
+  creator of the project is automatically granted the
+  [Project Admin](#project-admins) role for that project.
+- View existing projects, and create development and preview deployments for
+  these projects. Developers may read data from production deployments, but
+  cannot write to them.
+- View the team's usage and billing status (such as previous and upcoming
+  invoices)
+
+Admins can do everything developers can, as well as:
+
+- Invite new team members
+- Remove members from the team
+- Change the role of other team members
+- Manage the team's Convex subscription and billing details.
+- Change the team name and slug
+- Team Admins are also implicitly granted project admin access to all projects
+  within the team. See [Project Admins](#project-admins) for more information.
+
+#### Project Admins
+
+In addition to team roles, you may also grant admin access to individual
+projects by granting team members the "Project Admin" role.
+
+If you are a Project Admin for a given project, you may:
+
+- Update the project name and slug
+- Update the project's default environment variables
+- Delete the project
+- Write to production deployments
+
+You may assign and remove the Project Admin role for multiple projects at the
+same time on the member settings page. To assign or remove the Project Admin
+role for multiple members at the same time, visit the
+[Project Settings](/dashboard/projects.md#project-settings) page instead.
+
+## Billing
+
+Use the [billing page](https://dashboard.convex.dev/team/settings/billing) to
+upgrade your Convex subscription to a higher tier, or manage your existing
+subscription.
+
+On paid plans, you can also update your billing contact details, payment method,
+and view your invoices.
+
+[Learn more about Convex pricing](https://www.convex.dev/pricing).
+
+![Team billing page](/screenshots/teams_billing.png)
+
+### Spending limits
+
+When you have an active Convex subscription, you can set the spending limits for
+your team on the
+[billing page](https://dashboard.convex.dev/team/settings/billing):
+
+- The **warning threshold** is only a soft limit: if it is exceeded, the team
+  will be notified by email, but no other action will be taken.
+- The **disable threshold** is a hard limit: if it is exceeded, all projects in
+  the team will be disabled. This will cause errors to be thrown when attempting
+  to run functions in your projects. You can re-enable projects by increasing or
+  removing the limit.
+
+Spending limits only apply to the resources used by your team’s projects beyond
+the amounts included in your plan. The seat fees (the amount paid for each
+developer in your team) are not counted towards the limits. For instance, if you
+send the spending limit to $0/month, you will be billed for the seat fees only
+and the projects will be disabled if you exceed the built-in resources included
+in your plan.
+
+![The team billing page with some spending limits set.](/screenshots/teams_billing_spending_limits.png)
+
+## Usage
+
+On the [usage page](https://dashboard.convex.dev/team/settings/usage) you can
+see all the resources consumed by your team, and how you're tracking against
+your plan's limits.
+
+[Learn more about Convex pricing](https://www.convex.dev/pricing).
+
+![Team usage page](/screenshots/teams_usage.png)
+
+All metrics are available in daily breakdowns:
+
+![Team usage page graphs](/screenshots/teams_usage_2.png)
+
+## Audit Log
+
+<Admonition type="info">
+
+The Audit Log is only available on Convex Professional.
+
+</Admonition>
+
+The [audit log page](https://dashboard.convex.dev/team/settings/audit-log) shows
+all the actions taken by members within the team. This includes creating and
+managing projects and deployments, inviting and removing team members, and more.
+
+![Team audit log page](/screenshots/teams_audit_log.png)
+
+You may also view a history of deployment-related events on the
+[deployment history page](/dashboard/deployments/history.md).
diff --git a/synced/convex/docs/database.md b/synced/convex/docs/database.md
new file mode 100644
index 0000000..080e8d9
--- /dev/null
+++ b/synced/convex/docs/database.md
@@ -0,0 +1,96 @@
+---
+title: "Database"
+description: "Store JSON-like documents with a relational data model."
+hide_table_of_contents: true
+pagination_prev: functions
+---
+
+The Convex database provides a relational data model, stores JSON-like
+documents, and can be used with or without a schema. It "just works," giving you
+predictable query performance in an easy-to-use interface.
+
+Query and mutation [functions](/functions.mdx) read and write data through a
+lightweight JavaScript API. There is nothing to set up and no need to write any
+SQL. Just use JavaScript to express your app's needs.
+
+Start by learning about the basics of [tables](#tables), [documents](#documents)
+and [schemas](#schemas) below, then move on to
+[Reading Data](/database/reading-data/reading-data.mdx) and
+[Writing Data](/database/writing-data.mdx).
+
+As your app grows more complex you'll need more from your database:
+
+- Relational data modeling with [Document IDs](/database/document-ids.mdx)
+- Fast querying with [Indexes](/database/reading-data/indexes/indexes.md)
+- Exposing large datasets with [Paginated Queries](/database/pagination.mdx)
+- Type safety by [Defining a Schema](/database/schemas.mdx)
+- Interoperability with data
+  [Import & Export](docs/database/import-export/import-export.mdx)
+
+## Tables
+
+Your Convex deployment contains tables that hold your app's data. Initially,
+your deployment contains no tables or documents.
+
+Each table springs into existence as soon as you add the first document to it.
+
+```javascript
+// `friends` table doesn't exist.
+await ctx.db.insert("friends", { name: "Jamie" });
+// Now it does, and it has one document.
+```
+
+You do not have to specify a schema upfront or create tables explicitly.
+
+## Documents
+
+Tables contain documents. Documents are very similar to JavaScript objects. They
+have fields and values, and you can nest arrays or objects within them.
+
+These are all valid Convex documents:
+
+```json
+{}
+{"name": "Jamie"}
+{"name": {"first": "Ari", "second": "Cole"}, "age": 60}
+```
+
+They can also contain references to other documents in other tables. See
+[Data Types](/database/types.md) to learn more about the types supported in
+Convex and [Document IDs](/database/document-ids.mdx) to learn about how to use
+those types to model your data.
+
+## Schemas
+
+Though optional, schemas ensure that your data looks exactly how you want. For a
+simple chat app, the schema will look like this:
+
+```typescript
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+// @snippet start schema
+export default defineSchema({
+  messages: defineTable({
+    author: v.id("users"),
+    body: v.string(),
+  }),
+});
+```
+
+You can choose to be as flexible as you want by using types such as `v.any()` or
+as specific as you want by precisely describing a `v.object()`.
+
+See [the schema documentation](/database/schemas.mdx) to learn more about
+schemas.
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "/database/reading-data",
+    docId: "database/reading-data/reading-data",
+    label: "Next: Reading Data",
+  }}
+/>
+
+<StackPosts query="database" />
diff --git a/synced/convex/docs/database/advanced/_category_.json b/synced/convex/docs/database/advanced/_category_.json
new file mode 100644
index 0000000..97b012a
--- /dev/null
+++ b/synced/convex/docs/database/advanced/_category_.json
@@ -0,0 +1,4 @@
+{
+  "label": "Advanced",
+  "position": 100
+}
diff --git a/synced/convex/docs/database/advanced/occ.md b/synced/convex/docs/database/advanced/occ.md
new file mode 100644
index 0000000..bde9b22
--- /dev/null
+++ b/synced/convex/docs/database/advanced/occ.md
@@ -0,0 +1,159 @@
+---
+title: "OCC and Atomicity"
+slug: "occ"
+hidden: false
+sidebar_position: 500
+todo: Push under mutations, or inline, or kill (move to Stack)
+---
+
+In [Queries](/functions/query-functions.mdx), we mentioned that determinism as
+important in the way optimistic concurrency control (OCC) was used within
+Convex. In this section, we'll dive much deeper into _why_.
+
+## Convex Financial, Inc.
+
+Imagine that you're building a banking app, and therefore your databases stores
+accounts with balances. You want your users to be able to give each other money,
+so you write a mutation function that transfers funds from one user's account to
+another.
+
+One run of that transaction might read Alice's account balance, and then Bob's.
+You then propose to deduct $5 from Alice's account and increase Bob's balance by
+the same $5.
+
+Here's our pseudocode:
+
+```
+$14 <- READ Alice
+$11 <- READ Bob
+WRITE Alice $9
+WRITE Bob $16
+```
+
+This ledger balance transfer is a classic database scenario that requires a
+guarantee that these write operations will only apply together. It is a really
+bad thing if only one operation succeeds!
+
+```
+$14 <- READ Alice
+$11 <- READ Bob
+WRITE Alice $9
+*crash* // $5 lost from your bank
+```
+
+You need a guarantee that this can never happen. You require transaction
+atomicity, and Convex provides it.
+
+The problem of data correctness is much deeper. Concurrent transactions that
+read and edit the same records can create _data races_.
+
+In the case of our app it's entirely possible that someone deducts Alice's
+balance right after we read it. Maybe she bought a Coke Zero at the airport with
+her debit card for $3.
+
+```
+$5 Transfer                           $3 Debit Card Charge
+----------------------------------------------------------
+$14 <- READ Alice
+$11 <- READ Bob
+                                        $14 <- READ Alice
+                                        WRITE Alice $11
+WRITE Alice $9 // Free coke!
+WRITE Bob $16
+```
+
+Clearly, we need to prevent these types of data races from happening. We need a
+way to handle these concurrent conflicts. Generally, there are two common
+approaches.
+
+Most traditional databases choose a _pessimistic locking_ strategy. (Pessimism
+in this case means the strategy assumes conflict will happen ahead of time so
+seeks to prevent it.) With pessimistic locking, you first need to acquire a lock
+on Alice's record, and then acquire a lock on Bob's record. Then you can proceed
+to conduct your transaction, knowing that any other transaction that needed to
+touch those records will wait until you are done and all your writes are
+committed.
+
+After decades of experience, the drawbacks of pessimistic locking are well
+understood and undeniable. The biggest limitation arises from real-life networks
+and computers being inherently unreliable. If the lock holder goes missing for
+whatever reason half way through its transaction, everyone else that wants to
+modify any of those records is waiting indefinitely. Not good!
+
+Optimistic concurrency control is, as the name states, optimistic. It assumes
+the transaction will succeed and doesn't worry about locking anything ahead of
+time. Very brash! How can it be so sure?
+
+It does this by treating the transaction as a _declarative proposal_ to write
+records on the basis of any read record versions (the "read set"). At the end of
+the transaction, the writes all commit if every version in the read set is still
+the latest version of that record. This means no concurrent conflict occurred.
+
+Now using our version read set, let's see how OCC would have prevented the
+soda-catastrophe above:
+
+```
+$5 Transfer                           $3 Debit Card Charge
+----------------------------------------------------------
+(v1, $14) <- READ Alice
+(v7, $11) <- READ Bob
+                                        (v1, $14) <- READ Alice
+                                        WRITE Alice $11
+                                        IF Alice.v = v1
+
+WRITE Alice = $9, Bob = $16
+    IF Alice.v = v1, Bob.v = v7 // Fails! Alice is = v2
+```
+
+This is akin to being unable to push your Git repository because you're not at
+HEAD. We all know in that circumstance, we need to pull, and rebase or merge,
+etc.
+
+## When OCC loses, determinism wins
+
+A naive optimistic concurrency control solution would be to solve this the same
+way that Git does: require the user/application to resolve the conflict and
+determine if it is safe to retry.
+
+In Convex, however, we don't need to do that. We know the transaction is
+deterministic. It didn't charge money to Stripe, it didn't write a permanent
+value out to the filesystem. It had no effect at all other than proposing some
+atomic changes to Convex tables that were not applied.
+
+The determinism means that we can simply re-run the transaction; you never need
+to worry about temporary data races. We can run several retries if necessary
+until we succeed to execute the transaction without any conflicts.
+
+<Admonition type="tip">
+
+In fact, the Git analogy stays very apt. An OCC conflict means we cannot push
+because our HEAD is out of date, so we need to rebase our changes and try again.
+And determinism is what guarantees there is never a "merge conflict", so (unlike
+with Git) this rebase operation will always eventually succeed without developer
+intervention.
+
+</Admonition>
+
+## Snapshot Isolation vs Serializability
+
+It is common for optimistic multi-version concurrency control databases to
+provide a guarantee of
+[snapshot isolation](https://en.wikipedia.org/wiki/Snapshot_isolation). This
+[isolation level](<https://en.wikipedia.org/wiki/Isolation_(database_systems)>)
+provides the illusion that all transactions execute on an atomic snapshot of the
+data but it is vulnerable to
+[anomalies](https://en.wikipedia.org/wiki/Snapshot_isolation#Definition) where
+certain combinations of concurrent transactions can yield incorrect results. The
+implementation of optimistic concurrency control in Convex instead provides true
+[serializability](https://en.wikipedia.org/wiki/Serializability) and will yield
+correct results regardless of what transactions are issued concurrently.
+
+## No need to think about this
+
+The beauty of this approach is that you can simply write your mutation functions
+as if they will _always succeed_, and always be guaranteed to be atomic.
+
+Aside from sheer curiosity about how Convex works, day to day there's no need to
+worry about conflicts, locking, or atomicity when you make changes to your
+tables and documents. The "obvious way" to write your mutation functions will
+just work.
diff --git a/synced/convex/docs/database/advanced/schema-philosophy.md b/synced/convex/docs/database/advanced/schema-philosophy.md
new file mode 100644
index 0000000..ab04577
--- /dev/null
+++ b/synced/convex/docs/database/advanced/schema-philosophy.md
@@ -0,0 +1,29 @@
+---
+title: Schema Philosophy
+sidebar_position: 450
+---
+
+With Convex there is no need to write any `CREATE TABLE` statements, or think
+through your stored table structure ahead of time so you can name your field and
+types. You simply put your objects into Convex and keep building your app!
+
+However, moving fast early can be problematic later. "Was that field a number or
+a string? I think I changed it when I fixed that one bug?"
+
+Storage systems which are too permissive can sometimes become liabilities as
+your system matures and you want to be able to reason assuredly about exactly
+what data is in your system.
+
+The good news is Convex is always typed. It's just implicitly typed! When you
+submit a document to Convex, tracks all the types of all the fields in your
+document. You can go to your [dashboard](/dashboard.md) and view the inferred
+schema of any table to understand what you've ended up with.
+
+"What about that field I changed from a string to a number?" Convex can handle
+this too. Convex will track those changes, in this case the field is a union
+like `v.union(v.number(), v.string())`. That way even when you change your mind
+about your documents fields and types, Convex has your back.
+
+Once you are ready to formalize your schema, you can define it using our
+[schema builder](/database/schemas.mdx) to enable schema validation and generate
+types based on it.
diff --git a/synced/convex/docs/database/advanced/system-tables.md b/synced/convex/docs/database/advanced/system-tables.md
new file mode 100644
index 0000000..0d28daf
--- /dev/null
+++ b/synced/convex/docs/database/advanced/system-tables.md
@@ -0,0 +1,18 @@
+---
+title: "System Tables"
+sidebar_position: 1
+---
+
+System tables enable read-only access to metadata for built-in Convex features.
+Currently there are two system tables exposed:
+
+- `"_scheduled_functions"` table contains metadata for
+  [scheduled functions](/scheduling/scheduled-functions.mdx#retrieving-scheduled-function-status)
+- `"_storage"` table contains metadata for
+  [stored files](/file-storage/file-metadata.mdx)
+
+You can read data from system tables using the `db.system.get` and
+`db.system.query` methods, which work the same as the standard `db.get` and
+`db.query` methods. Queries reading from system tables are reactive and realtime
+just like queries reading from all other tables, and pagination can be used to
+enumerate all documents even when there are too many to read in a single query.
diff --git a/synced/convex/docs/database/backup-restore.md b/synced/convex/docs/database/backup-restore.md
new file mode 100644
index 0000000..f65c968
--- /dev/null
+++ b/synced/convex/docs/database/backup-restore.md
@@ -0,0 +1,121 @@
+---
+title: "Backup & Restore"
+sidebar_position: 85
+---
+
+Convex supports Backup & Restore of data via the
+[dashboard](https://dashboard.convex.dev/deployment/settings/backups).
+
+![Backups Page](/screenshots/backups.png)
+
+# Backups
+
+A backup is a consistent snapshot of your table data and file storage made at
+the time of your request.
+
+Take a manual backup by pressing the "Backup Now" button. This may take a few
+seconds to a few hours, depending on how much data is in your deployment.
+
+Manual backups are stored for 7 days. You can download or delete backups via
+this page.
+
+Deployment configuration and other data (code, environment variables, scheduled
+functions, etc.) will not be included.
+
+### Periodic Backups
+
+Schedule a periodic daily or weekly backup by checking the "Backup
+automatically" box. You can select what time of day / day of week to have the
+backup occur.
+
+Daily backups are stored for 7 days. Weekly backups are stored for 14 days.
+
+<ProFeatureUpsell feature="Periodic backups" verb="require" />
+
+### Restoring from backup
+
+Restore from a backup by selecting "Restore" from the submenu of an individual
+backup. You can restore from backups in the same deployment or from other
+deployments on the same team by using the deployment selector on the backups
+page. Restores may take a few seconds to a few hours depending on how much data
+is in your backup.
+
+Note that restoring is a destructive operation that wipes your existing data and
+replaces it with that from the backup. It's recommended that you generate an
+additional backup before doing a restore.
+
+### Restoring in an emergency
+
+If your production deployment ends up in a bad state, you may want to consider
+doing a restore to return to a good state. Note that getting your data to a good
+state may not be enough. Consider whether you may need each of the following
+actions. Depending on the nature of your emergency, these may be required.
+
+- Take an additional backup prior to restore, since restores are destructive
+- Do a restore from a good backup - to restore data
+- Use `npx convex dev` to push a known version of good code.
+- Use `npx convex env` or the dashboard to restore to a good set of env vars
+- Use the dashboard to make any manual fixes to the database for your app.
+- Write mutations to make required (more programmatic) manual fixes to the
+  database for your app.
+
+# Downloading a backup
+
+You can download your manual and periodic backups from the dashboard via the
+download button in the menu.
+
+Alternatively, you can generate an export in the same format with the
+[command line](/cli.md#export-data-to-a-file):
+
+```sh
+npx convex export --path ~/Downloads
+```
+
+The backup comes as a generated a ZIP file with all documents in all Convex
+tables in your deployment.
+
+The ZIP file's name has the format `snapshot_{ts}.zip` where `ts` is a UNIX
+timestamp of the snapshot in nanoseconds. The export ZIP file contains documents
+for each table at `<table_name>/documents.jsonl`, with one document per line.
+
+Exported ZIP files also contain data from [file storage](/file-storage) in a
+`_storage` folder, with metadata like IDs and checksums in
+`_storage/documents.jsonl` and each file as `_storage/<id>`.
+
+### Using the downloaded backup.
+
+Downloaded ZIP files can be imported into the same deployment or a different
+deployment
+[with the CLI](/database/import-export/import.mdx#restore-data-from-a-backup-zip-file).
+
+## FAQ
+
+### Are there any limitations?
+
+Each backup is accessible for up to 7 days.
+
+On the Free/Starter plan, up to two backups can stored per deployment at a time.
+Deployments on Convex Professional plan can have many backups with standard
+usage based pricing.
+
+### How are they priced?
+
+Backups uses database bandwidth to read all documents, and file bandwidth to
+include user files. The generation and storage of the backup itself is billed
+with the same bandwidth and storage pricing as user file storage. You can
+observe this bandwidth and storage cost in the
+[usage dashboard](https://dashboard.convex.dev/team/settings/usage). Check the
+[limits docs](/production/state/limits#database) for pricing details.
+
+### What does the backup not contain?
+
+The backup only contains the documents for your tables and files in file
+storage. In particular it lacks:
+
+1. Your deployment's code and configuration. Convex functions, crons.ts,
+   auth.config.js, schema.ts, etc. are configured in your source code.
+2. Pending scheduled functions. You can access pending scheduled functions in
+   the [`_scheduled_functions`](/database/advanced/system-tables.mdx) system
+   table.
+3. Environment variables. Environment variables can be copied from Settings in
+   the Convex dashboard.
diff --git a/synced/convex/docs/database/document-ids.md b/synced/convex/docs/database/document-ids.md
new file mode 100644
index 0000000..c3a3376
--- /dev/null
+++ b/synced/convex/docs/database/document-ids.md
@@ -0,0 +1,152 @@
+---
+title: "Document IDs"
+sidebar_position: 10
+description: "Create complex, relational data models using IDs."
+---
+
+
+
+**Example:**
+[Relational Data Modeling](https://github.com/get-convex/convex-demos/tree/main/relational-data-modeling)
+
+Every document in convex has a globally unique string _document ID_ that is
+automatically generated by the system.
+
+```ts
+const userId = await ctx.db.insert("users", { name: "Michael Jordan" });
+```
+
+You can use this ID to efficiently read a single document using the `get`
+method:
+
+```ts
+const retrievedUser = await ctx.db.get(userId);
+```
+
+You can access the ID of a document in the
+[`_id` field](/database/types.md#system-fields):
+
+```ts
+const userId = retrievedUser._id;
+```
+
+Also, this same ID can be used to update that document in place:
+
+```ts
+await ctx.db.patch(userId, { name: "Steph Curry" });
+```
+
+Convex generates an [`Id`](/generated-api/data-model#id) TypeScript type based
+on your [schema](/database/schemas.mdx) that is parameterized over your table
+names:
+
+```typescript
+import { Id } from "./_generated/dataModel";
+
+const userId: Id<"users"> = user._id;
+```
+
+IDs are strings at runtime, but the [`Id`](/generated-api/data-model#id) type
+can be used to distinguish IDs from other strings at compile time.
+
+## References and relationships
+
+In Convex, you can reference a document simply by embedding its `Id` in another
+document:
+
+```ts
+await ctx.db.insert("books", {
+  title,
+  ownerId: user._id,
+});
+```
+
+You can follow references with `ctx.db.get`:
+
+```ts
+const user = await ctx.db.get(book.ownerId);
+```
+
+And [query for documents](/database/reading-data/reading-data.mdx) with a
+reference:
+
+```ts
+const myBooks = await ctx.db
+  .query("books")
+  .filter((q) => q.eq(q.field("ownerId"), user._id))
+  .collect();
+```
+
+Using `Id`s as references can allow you to build a complex data model.
+
+## Trading off deeply nested documents vs. relationships
+
+While it's useful that Convex supports nested objects and arrays, you should
+keep documents relatively small in size. In practice, we recommend limiting
+Arrays to no more than 5-10 elements and avoiding deeply nested Objects.
+
+Instead, leverage separate tables, documents, and references to structure your
+data. This will lead to better maintainability and performance as your project
+grows.
+
+## Serializing IDs
+
+IDs are strings, which can be easily inserted into URLs or stored outside of
+Convex.
+
+You can pass an ID string from an external source (like a URL) into a Convex
+function and get the corresponding object. If you're using TypeScript on the
+client you can cast a string to the `Id` type:
+
+
+```tsx
+import { useQuery } from "convex/react";
+import { Id } from "../convex/_generated/dataModel";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const id = localStorage.getItem("myIDStorage");
+  const task = useQuery(api.tasks.getTask, { taskId: id as Id<"tasks"> });
+  // ...
+}
+```
+
+
+Since this ID is coming from an external source, use an argument validator or
+[`ctx.db.normalizeId`](/api/interfaces/server.GenericDatabaseReader#normalizeid)
+to confirm that the ID belongs to the expected table before returning the
+object.
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTask = query({
+  args: {
+    taskId: v.id("tasks"),
+  },
+  handler: async (ctx, args) => {
+    const task = await ctx.db.get(args.taskId);
+    // ...
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTask = query({
+  args: {
+    taskId: v.id("tasks"),
+  },
+  handler: async (ctx, args) => {
+    const task = await ctx.db.get(args.taskId);
+    // ...
+  },
+});
+```
+
+
+<StackPosts query="document IDs" />
diff --git a/synced/convex/docs/database/import-export/export.md b/synced/convex/docs/database/import-export/export.md
new file mode 100644
index 0000000..d90a4c8
--- /dev/null
+++ b/synced/convex/docs/database/import-export/export.md
@@ -0,0 +1,16 @@
+---
+title: "Data Export"
+sidebar_label: "Data Export"
+description: "Export your data out of Convex"
+sidebar_position: 168
+---
+
+You can export your data from Convex by
+[taking a backup](/database/backup-restore) and downloading it as a zip file.
+
+Alternatively, you can export the same data with the
+[command line](/cli.md#export-data-to-a-file):
+
+```sh
+npx convex export --path ~/Downloads
+```
diff --git a/synced/convex/docs/database/import-export/import-export.md b/synced/convex/docs/database/import-export/import-export.md
new file mode 100644
index 0000000..44076be
--- /dev/null
+++ b/synced/convex/docs/database/import-export/import-export.md
@@ -0,0 +1,25 @@
+---
+title: "Data Import & Export"
+sidebar_position: 90
+---
+
+If you're bootstrapping your app from existing data, Convex provides three ways
+to get the data in:
+
+- Import from csv/json into a single table via the
+  [CLI](/database/import-export/import.mdx#single-table-import).
+- Restore from a backup via the [dashboard](/database/backup-restore) or
+  [CLI](/database/import-export/import.mdx#restore-data-from-a-backup-zip-file).
+- [Streaming import](/production/integrations/streaming-import-export.md) from
+  any existing database via Airbyte destination connector.
+
+You can export data from Convex in two ways.
+
+- Download a backup as a zip from the [dashboard](/database/backup-restore).
+- Set up [streaming export](/production/integrations/streaming-import-export.md)
+  to any external database via Fivetran or Airbyte. Great for connecting to a
+  custom BI setup (eg [Snowflake](https://www.snowflake.com/),
+  [Databricks](https://www.databricks.com), or
+  [BigQuery](https://cloud.google.com/bigquery)):
+
+<BetaAdmonition feature="Data Import & Export" verb="is" />
diff --git a/synced/convex/docs/database/import-export/import.md b/synced/convex/docs/database/import-export/import.md
new file mode 100644
index 0000000..6b1ac98
--- /dev/null
+++ b/synced/convex/docs/database/import-export/import.md
@@ -0,0 +1,138 @@
+---
+title: "Data Import"
+sidebar_label: "Data Import"
+description: "Import data into Convex"
+sidebar_position: 169
+---
+
+You can import data into Convex from a local file using the command line.
+
+```sh
+npx convex import
+```
+
+<BetaAdmonition feature="Data import" verb="is" />
+
+Use `--help` to see all options. The most common flows are described here.
+
+## Single table import
+
+```sh
+npx convex import --table <tableName> <path>
+```
+
+Import a CSV, JSON, or JSONLines file into a Convex table.
+
+- `.csv` files must have a header, and each row's entries are interpreted either
+  as a (floating point) number or a string.
+- `.jsonl` files must have a JSON object per line.
+- `.json` files must be an array of JSON objects.
+  - JSON arrays have a size limit of 8MiB. To import more data, use CSV or
+    JSONLines. You can convert json to jsonl with a command like
+    `jq -c '.[]' data.json > data.jsonl`
+
+Imports into a table with existing data will fail by default, but you can
+specify `--append` to append the imported rows to the table or `--replace` to
+replace existing data in the table with your import.
+
+The default is to import into your dev deployment. Use `--prod` to import to
+your production deployment or `--preview-name` to import into a preview
+deployment.
+
+## Restore data from a backup ZIP file
+
+```sh
+npx convex import <path>.zip
+```
+
+Import from a [Backup](/database/backup-restore) into a Convex deployment, where
+the backup is a ZIP file that has been downloaded on the dashboard. Documents
+will retain their `_id` and `_creationTime` fields so references between tables
+are maintained.
+
+Imports where tables have existing data will fail by default, but you can
+specify `--replace` to replace existing data in tables mentioned in the ZIP
+file.
+
+## Use cases
+
+1. Seed dev deployments with sample data.
+
+```sh
+# full backup - exported from prod or another dev deployment.
+npx convex import seed_data.zip
+
+# Import single table from jsonl/csv
+npx convex import --table <table name> data.jsonl
+```
+
+2. Restore a deployment from a [backup](/database/backup-restore)
+   programmatically. Download a backup, and restore from this backup if needed.
+
+```sh
+npx convex import --prod --replace backup.zip
+```
+
+3. Seed preview deployments with sample data, exported from prod, dev, or
+   another preview deployment. Example for Vercel, seeding data from
+   `seed_data.zip` committed in the root of the repo.
+
+```sh
+npx convex deploy --cmd 'npm run build' &&
+if [ "$VERCEL_ENV" == "preview" ]; then
+npx convex import --preview-name "$VERCEL_GIT_COMMIT_REF" seed_data.zip;
+fi
+```
+
+4. Clear a table efficiently with an empty import.
+
+```sh
+touch empty_file.jsonl
+npx convex import --replace --table <tableNameToClear> empty_file.jsonl
+```
+
+## Features
+
+- Data import is the only way to create documents with pre-existing `_id` and
+  `_creationTime` fields.
+  - The `_id` field must match Convex's ID format.
+  - If `_id` or `_creationTime` are not provided, new values are chosen during
+    import.
+- Data import creates and replaces tables atomically (except when using
+  `--append`).
+  - Queries and mutations will not view intermediate states where partial data
+    is imported.
+  - Indexes and schemas will work on the new data without needing time for
+    re-backfilling or re-validating.
+- Data import only affects tables that are mentioned in the import, either by
+  `--table` or as entries in the ZIP file.
+- While JSON and JSONLines can import arbitrary JSON values, ZIP imports can
+  additionally import other Convex values: Int64, Bytes, etc. Types are
+  preserved in the ZIP file through the `generated_schema.jsonl` file.
+- Data import of ZIP files that include [file storage](/file-storage) import the
+  files and preserve [`_storage`](/database/advanced/system-tables.mdx)
+  documents, including their `_id`, `_creationTime`, and `contentType` fields.
+
+## Warnings
+
+- [Streaming Export](/production/integrations/streaming-import-export.md)
+  (Fivetran or Airbyte) does not handle data imports or backup restorations,
+  similar to table deletion and creation and some schema changes. We recommend
+  resetting streaming export sync after a restore or a data import.
+- Avoid changing the ZIP file between downloading it from Data Export and
+  importing it with `npx convex import`. Some manual changes of the ZIP file may
+  be possible, but remain undocumented. Please share your use case and check
+  with the Convex team in [Discord](https://convex.dev/community).
+- Data import is not always supported when importing into a deployment that was
+  created before Convex version 1.7.
+  - The import may work, especially when importing a ZIP backup from a
+    deployment created around the same time as the target deployment. As a
+    special case, you can always restore from backups from its own deployment.
+  - Reach out in [Discord](https://convex.dev/community) if you encounter
+    issues, as there may be a workaround.
+
+Data import uses database bandwidth to write all documents, and file bandwidth
+if the export includes file storage. You can observe this bandwidth in the
+[usage dashboard](https://dashboard.convex.dev/team/settings/usage) as function
+name `_cli/import` and associated cost in the
+[limits docs](/production/state/limits#database).
diff --git a/synced/convex/docs/database/pagination.md b/synced/convex/docs/database/pagination.md
new file mode 100644
index 0000000..0affcce
--- /dev/null
+++ b/synced/convex/docs/database/pagination.md
@@ -0,0 +1,649 @@
+---
+title: "Paginated Queries"
+slug: "pagination"
+sidebar_position: 60
+description: "Load paginated queries."
+---
+
+
+
+
+
+Paginated queries are [queries](/functions/query-functions.mdx) that return a
+list of results in incremental pages.
+
+This can be used to build components with "Load More" buttons or "infinite
+scroll" UIs where more results are loaded as the user scrolls.
+
+**Example:**
+[Paginated Messaging App](https://github.com/get-convex/convex-demos/tree/main/pagination)
+
+Using pagination in Convex is as simple as:
+
+1. Writing a paginated query function that calls
+   [`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate).
+2. Using the [`usePaginatedQuery`](/api/modules/react#usepaginatedquery) React
+   hook.
+
+Like other Convex queries, paginated queries are completely reactive.
+
+## Writing paginated query functions
+
+Convex uses cursor-based pagination. This means that paginated queries return a
+string called a [`Cursor`](/api/modules/server#cursor) that represents the point
+in the results that the current page ended. To load more results, you simply
+call the query function again, passing in the cursor.
+
+To build this in Convex, define a query function that:
+
+1. Takes in a single arguments object with a `paginationOpts` property of type
+   [`PaginationOptions`](/api/interfaces/server.PaginationOptions).
+   - `PaginationOptions` is an object with `numItems` and `cursor` fields.
+   - Use `paginationOptsValidator` exported from `"convex/server"` to
+     [validate](/functions/validation.mdx) this argument
+   - The arguments object may include properties as well.
+2. Calls
+   [`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate)
+   on a [database query](/database/reading-data/reading-data.mdx), passing in
+   the `PaginationOptions` and returning its result.
+   - The returned `page` in the
+     [`PaginationResult`](/api/interfaces/server.PaginationResult) is an array
+     of documents. You may
+     [`map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
+     or
+     [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
+     it before returning it.
+
+
+```ts
+// @snippet start list
+import { v } from "convex/values";
+import { query, mutation } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+
+export const list = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const foo = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return foo;
+  },
+});
+// @snippet end list
+
+// @snippet start listWithExtraArg
+export const listWithExtraArg = query({
+  args: { paginationOpts: paginationOptsValidator, author: v.string() },
+  handler: async (ctx, args) => {
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), args.author))
+      .order("desc")
+      .paginate(args.paginationOpts);
+  },
+});
+// @snippet end listWithExtraArg
+
+// @snippet start listWithTransformation
+export const listWithTransformation = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const results = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return {
+      ...results,
+      page: results.page.map((message) => ({
+        author: message.author.slice(0, 1),
+        body: message.body.toUpperCase(),
+      })),
+    };
+  },
+});
+// @snippet end listWithTransformation
+
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+```ts
+// @snippet start list
+import { v } from "convex/values";
+import { query, mutation } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+
+export const list = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const foo = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return foo;
+  },
+});
+// @snippet end list
+
+// @snippet start listWithExtraArg
+export const listWithExtraArg = query({
+  args: { paginationOpts: paginationOptsValidator, author: v.string() },
+  handler: async (ctx, args) => {
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), args.author))
+      .order("desc")
+      .paginate(args.paginationOpts);
+  },
+});
+// @snippet end listWithExtraArg
+
+// @snippet start listWithTransformation
+export const listWithTransformation = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const results = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return {
+      ...results,
+      page: results.page.map((message) => ({
+        author: message.author.slice(0, 1),
+        body: message.body.toUpperCase(),
+      })),
+    };
+  },
+});
+// @snippet end listWithTransformation
+
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+
+### Additional arguments
+
+You can define paginated query functions that take arguments in addition to
+`paginationOpts`:
+
+
+```ts
+// @snippet start list
+import { v } from "convex/values";
+import { query, mutation } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+
+export const list = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const foo = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return foo;
+  },
+});
+// @snippet end list
+
+// @snippet start listWithExtraArg
+export const listWithExtraArg = query({
+  args: { paginationOpts: paginationOptsValidator, author: v.string() },
+  handler: async (ctx, args) => {
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), args.author))
+      .order("desc")
+      .paginate(args.paginationOpts);
+  },
+});
+// @snippet end listWithExtraArg
+
+// @snippet start listWithTransformation
+export const listWithTransformation = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const results = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return {
+      ...results,
+      page: results.page.map((message) => ({
+        author: message.author.slice(0, 1),
+        body: message.body.toUpperCase(),
+      })),
+    };
+  },
+});
+// @snippet end listWithTransformation
+
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+```ts
+// @snippet start list
+import { v } from "convex/values";
+import { query, mutation } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+
+export const list = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const foo = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return foo;
+  },
+});
+// @snippet end list
+
+// @snippet start listWithExtraArg
+export const listWithExtraArg = query({
+  args: { paginationOpts: paginationOptsValidator, author: v.string() },
+  handler: async (ctx, args) => {
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), args.author))
+      .order("desc")
+      .paginate(args.paginationOpts);
+  },
+});
+// @snippet end listWithExtraArg
+
+// @snippet start listWithTransformation
+export const listWithTransformation = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const results = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return {
+      ...results,
+      page: results.page.map((message) => ({
+        author: message.author.slice(0, 1),
+        body: message.body.toUpperCase(),
+      })),
+    };
+  },
+});
+// @snippet end listWithTransformation
+
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+
+### Transforming results
+
+You can apply arbitrary
+[transformations](/database/reading-data/reading-data.mdx#more-complex-queries)
+to the `page` property of the object returned by `paginate`, which contains the
+array of documents:
+
+
+```ts
+// @snippet start list
+import { v } from "convex/values";
+import { query, mutation } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+
+export const list = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const foo = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return foo;
+  },
+});
+// @snippet end list
+
+// @snippet start listWithExtraArg
+export const listWithExtraArg = query({
+  args: { paginationOpts: paginationOptsValidator, author: v.string() },
+  handler: async (ctx, args) => {
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), args.author))
+      .order("desc")
+      .paginate(args.paginationOpts);
+  },
+});
+// @snippet end listWithExtraArg
+
+// @snippet start listWithTransformation
+export const listWithTransformation = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const results = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return {
+      ...results,
+      page: results.page.map((message) => ({
+        author: message.author.slice(0, 1),
+        body: message.body.toUpperCase(),
+      })),
+    };
+  },
+});
+// @snippet end listWithTransformation
+
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+```ts
+// @snippet start list
+import { v } from "convex/values";
+import { query, mutation } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+
+export const list = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const foo = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return foo;
+  },
+});
+// @snippet end list
+
+// @snippet start listWithExtraArg
+export const listWithExtraArg = query({
+  args: { paginationOpts: paginationOptsValidator, author: v.string() },
+  handler: async (ctx, args) => {
+    return await ctx.db
+      .query("messages")
+      .filter((q) => q.eq(q.field("author"), args.author))
+      .order("desc")
+      .paginate(args.paginationOpts);
+  },
+});
+// @snippet end listWithExtraArg
+
+// @snippet start listWithTransformation
+export const listWithTransformation = query({
+  args: { paginationOpts: paginationOptsValidator },
+  handler: async (ctx, args) => {
+    const results = await ctx.db
+      .query("messages")
+      .order("desc")
+      .paginate(args.paginationOpts);
+    return {
+      ...results,
+      page: results.page.map((message) => ({
+        author: message.author.slice(0, 1),
+        body: message.body.toUpperCase(),
+      })),
+    };
+  },
+});
+// @snippet end listWithTransformation
+
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+
+## Paginating within React Components
+
+To paginate within a React component, use the
+[`usePaginatedQuery`](/api/modules/react#usepaginatedquery) hook. This hook
+gives you a simple interface for rendering the current items and requesting
+more. Internally, this hook manages the continuation cursors.
+
+The arguments to this hook are:
+
+- The name of the paginated query function.
+- The arguments object to pass to the query function, excluding the
+  `paginationOpts` (that's injected by the hook).
+- An options object with the `initialNumItems` to load on the first page.
+
+The hook returns an object with:
+
+- `results`: An array of the currently loaded results.
+- `isLoading` - Whether the hook is currently loading results.
+- `status`: The status of the pagination. The possible statuses are:
+  - `"LoadingFirstPage"`: The hook is loading the first page of results.
+  - `"CanLoadMore"`: This query may have more items to fetch. Call `loadMore` to
+    fetch another page.
+  - `"LoadingMore"`: We're currently loading another page of results.
+  - `"Exhausted"`: We've paginated to the end of the list.
+- `loadMore(n)`: A callback to fetch more results. This will only fetch more
+  results if the status is `"CanLoadMore"`.
+
+
+```tsx
+// This file is not used in the demo app.
+// It showcases only the basic pagination call.
+
+// @snippet start example
+import { usePaginatedQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const { results, status, loadMore } = usePaginatedQuery(
+    api.messages.list,
+    {},
+    { initialNumItems: 5 },
+  );
+  return (
+    <div>
+      {results?.map(({ _id, body }) => <div key={_id}>{body}</div>)}
+      <button onClick={() => loadMore(5)} disabled={status !== "CanLoadMore"}>
+        Load More
+      </button>
+    </div>
+  );
+}
+// @snippet end example
+```
+
+```tsx
+// This file is not used in the demo app.
+// It showcases only the basic pagination call.
+
+// @snippet start example
+import { usePaginatedQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const { results, status, loadMore } = usePaginatedQuery(
+    api.messages.list,
+    {},
+    { initialNumItems: 5 },
+  );
+  return (
+    <div>
+      {results?.map(({ _id, body }) => <div key={_id}>{body}</div>)}
+      <button onClick={() => loadMore(5)} disabled={status !== "CanLoadMore"}>
+        Load More
+      </button>
+    </div>
+  );
+}
+// @snippet end example
+```
+
+
+You can also pass additional arguments in the arguments object if your function
+expects them:
+
+
+```tsx
+// This file is not used in the demo app.
+// It showcases only the basic pagination call.
+
+// @snippet start example
+import { usePaginatedQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const { results, status, loadMore } = usePaginatedQuery(
+    api.messages.listWithExtraArg,
+    { author: "Alex" },
+    { initialNumItems: 5 },
+  );
+  return (
+    <div>
+      {results?.map(({ _id, body }) => <div key={_id}>{body}</div>)}
+      <button onClick={() => loadMore(5)} disabled={status !== "CanLoadMore"}>
+        Load More
+      </button>
+    </div>
+  );
+}
+// @snippet end example
+```
+
+```tsx
+// This file is not used in the demo app.
+// It showcases only the basic pagination call.
+
+// @snippet start example
+import { usePaginatedQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const { results, status, loadMore } = usePaginatedQuery(
+    api.messages.listWithExtraArg,
+    { author: "Alex" },
+    { initialNumItems: 5 },
+  );
+  return (
+    <div>
+      {results?.map(({ _id, body }) => <div key={_id}>{body}</div>)}
+      <button onClick={() => loadMore(5)} disabled={status !== "CanLoadMore"}>
+        Load More
+      </button>
+    </div>
+  );
+}
+// @snippet end example
+```
+
+
+### Reactivity
+
+Like any other Convex query functions, paginated queries are **completely
+reactive**. Your React components will automatically rerender if items in your
+paginated list are added, removed or changed.
+
+One consequence of this is that **page sizes in Convex may change!** If you
+request a page of 10 items and then one item is removed, this page may "shrink"
+to only have 9 items. Similarly if new items are added, a page may "grow" beyond
+its initial size.
+
+## Paginating manually
+
+If you're paginating outside of React, you can manually call your paginated
+function multiple times to collect the items:
+
+
+```ts
+import { ConvexHttpClient } from "convex/browser";
+import { api } from "../convex/_generated/api";
+
+require("dotenv").config();
+
+const client = new ConvexHttpClient(process.env.VITE_CONVEX_URL!);
+
+/**
+ * Logs an array containing all messages from the paginated query "listMessages"
+ * by combining pages of results into a single array.
+ */
+async function getAllMessages() {
+  let continueCursor = null;
+  let isDone = false;
+  let page;
+
+  const results = [];
+
+  while (!isDone) {
+    ({ continueCursor, isDone, page } = await client.query(api.messages.list, {
+      paginationOpts: { numItems: 5, cursor: continueCursor },
+    }));
+    console.log("got", page.length);
+    results.push(...page);
+  }
+
+  console.log(results);
+}
+
+getAllMessages();
+```
+
+```ts
+import { ConvexHttpClient } from "convex/browser";
+import { api } from "../convex/_generated/api";
+
+require("dotenv").config();
+
+const client = new ConvexHttpClient(process.env.VITE_CONVEX_URL!);
+
+/**
+ * Logs an array containing all messages from the paginated query "listMessages"
+ * by combining pages of results into a single array.
+ */
+async function getAllMessages() {
+  let continueCursor = null;
+  let isDone = false;
+  let page;
+
+  const results = [];
+
+  while (!isDone) {
+    ({ continueCursor, isDone, page } = await client.query(api.messages.list, {
+      paginationOpts: { numItems: 5, cursor: continueCursor },
+    }));
+    console.log("got", page.length);
+    results.push(...page);
+  }
+
+  console.log(results);
+}
+
+getAllMessages();
+```
+
diff --git a/synced/convex/docs/database/reading-data/filters.md b/synced/convex/docs/database/reading-data/filters.md
new file mode 100644
index 0000000..fc763f6
--- /dev/null
+++ b/synced/convex/docs/database/reading-data/filters.md
@@ -0,0 +1,217 @@
+---
+title: "Filters"
+sidebar_position: 200
+---
+
+# Filtering
+
+The [`filter`](/api/interfaces/server.Query#filter) method allows you to
+restrict the documents that your document query returns. This method takes a
+filter constructed by [`FilterBuilder`](/api/interfaces/server.FilterBuilder)
+and will only select documents that match.
+
+The examples below demonstrate some of the common uses of `filter`. You can see
+the full list of available filtering methods
+[in the reference docs](/api/interfaces/server.FilterBuilder).
+
+If you need to filter to documents containing some keywords, use a
+[search query](/search/search.mdx).
+
+<Admonition type="caution" title="Use indexes instead">
+  Filters effectively loop over your table looking for documents that match.
+  This can be slow or cause your function to hit a
+  [limit](/production/state/limits.mdx) when your table has thousands of rows.
+  For faster more database efficient queries use [indexes
+  instead](/database/reading-data/indexes/indexes.md).
+</Admonition>
+
+### Equality conditions
+
+This document query finds documents in the `users` table where
+`doc.name === "Alex"`:
+
+```ts
+// Get all users named "Alex".
+const usersNamedAlex = await ctx.db
+  .query("users")
+  .filter((q) => q.eq(q.field("name"), "Alex"))
+  .collect();
+```
+
+Here `q` is the [`FilterBuilder`](/api/interfaces/server.FilterBuilder) utility
+object. It contains methods for all of our supported filter operators.
+
+This filter will run on all documents in the table. For each document,
+`q.field("name")` evaluates to the `name` property. Then `q.eq` checks if this
+property is equal to `"Alex"`.
+
+If your query references a field that is missing from a given document then that
+field will be considered to have the value `undefined`.
+
+### Comparisons
+
+Filters can also be used to compare fields against values. This document query
+finds documents where `doc.age >= 18`:
+
+```ts
+// Get all users with an age of 18 or higher.
+const adults = await ctx.db
+  .query("users")
+  .filter((q) => q.gte(q.field("age"), 18))
+  .collect();
+```
+
+Here the `q.gte` operator checks if the first argument (`doc.age`) is greater
+than or equal to the second (`18`).
+
+Here's the full list of comparisons:
+
+| Operator      | Equivalent TypeScript |
+| ------------- | --------------------- |
+| `q.eq(l, r)`  | `l === r`             |
+| `q.neq(l, r)` | `l !== r`             |
+| `q.lt(l, r)`  | `l < r`               |
+| `q.lte(l, r)` | `l <= r`              |
+| `q.gt(l, r)`  | `l > r`               |
+| `q.gte(l, r)` | `l >= r`              |
+
+### Arithmetic
+
+You can also include basic arithmetic in your queries. This document query finds
+documents in the `carpets` table where `doc.height * doc.width > 100`:
+
+```ts
+// Get all carpets that have an area of over 100.
+const largeCarpets = await ctx.db
+  .query("carpets")
+  .filter((q) => q.gt(q.mul(q.field("height"), q.field("width")), 100))
+  .collect();
+```
+
+Here's the full list of arithmetic operators:
+
+| Operator      | Equivalent TypeScript |
+| ------------- | --------------------- |
+| `q.add(l, r)` | `l + r`               |
+| `q.sub(l, r)` | `l - r`               |
+| `q.mul(l, r)` | `l * r`               |
+| `q.div(l, r)` | `l / r`               |
+| `q.mod(l, r)` | `l % r`               |
+| `q.neg(x)`    | `-x`                  |
+
+### Combining operators
+
+You can construct more complex filters using methods like `q.and`, `q.or`, and
+`q.not`. This document query finds documents where
+`doc.name === "Alex" && doc.age >= 18`:
+
+```ts
+// Get all users named "Alex" whose age is at least 18.
+const adultAlexes = await ctx.db
+  .query("users")
+  .filter((q) =>
+    q.and(q.eq(q.field("name"), "Alex"), q.gte(q.field("age"), 18)),
+  )
+  .collect();
+```
+
+Here is a query that finds all users where
+`doc.name === "Alex" || doc.name === "Emma"`:
+
+```ts
+// Get all users named "Alex" or "Emma".
+const usersNamedAlexOrEmma = await ctx.db
+  .query("users")
+  .filter((q) =>
+    q.or(q.eq(q.field("name"), "Alex"), q.eq(q.field("name"), "Emma")),
+  )
+  .collect();
+```
+
+## Advanced filtering techniques
+
+Sometimes the filter syntax is is not expressive enough. For example you may
+want to collect all posts that have a tag. Your schema for the posts looks like
+this:
+
+```ts
+export default defineSchema({
+  posts: defineTable({
+    body: v.string(),
+    tags: v.array(v.string()),
+  }),
+});
+```
+
+One way to solve is by applying the filter on the result of the `collect()`
+call. This is just filtering a JavaScript array:
+
+```ts
+export const postsWithTag = query({
+  args: { tag: v.string() },
+  handler: async (ctx, args) => {
+    const allPosts = await ctx.db.query("posts").collect();
+    return allPosts.filter((post) => post.tags.includes(args.tag));
+  },
+});
+```
+
+But this requires reading the whole table first. If you want to just get the
+first result that matches, reading the whole table could be very inefficient.
+Instead you may want to use the JavaScript
+[`for await...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)
+syntax to loop through the table one document at a time:
+
+```ts
+export const firstPostWithTag = query({
+  args: { tag: v.string() },
+  handler: (ctx, args) => {
+    for await (const post of db.query("posts")) {
+      if (post.tags.includes(args.tag)) {
+        return post;
+      }
+    }
+  },
+});
+```
+
+This works because Convex queries are
+[JavaScript iterables](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
+
+Even with this optimization you are still just looping over the table to find
+the first post that matches and may hit your function limits. Using indexes is
+still the way to go. You can read a
+[detailed discussion of how to handle tags with indexes](https://stack.convex.dev/complex-filters-in-convex#optimize-with-indexes).
+
+## Querying performance and limits
+
+Most of the example document queries above can lead to a _full table scan_. That
+is, for the document query to return the requested results, it might need to
+walk over every single document in the table.
+
+Take this simple example:
+
+```ts
+const tasks = await ctx.db.query("tasks").take(5);
+```
+
+This document query will not scan more than 5 documents.
+
+On the other hand, this document query:
+
+```ts
+const tasks = await ctx.db
+  .query("tasks")
+  .filter((q) => q.eq(q.field("isCompleted"), true))
+  .first();
+```
+
+might need to walk over every single document in the `"tasks"` table just to
+find the first one with `isCompleted: true`.
+
+If a table has more than a few thousand documents, you should use
+[indexes](/database/reading-data/indexes/indexes.md) to improve your document
+query performance. Otherwise, you may run into our enforced limits, detailed in
+[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).
+
+For information on other limits, see [Limits](/production/state/limits.mdx).
diff --git a/synced/convex/docs/database/reading-data/indexes/indexes-and-query-perf.md b/synced/convex/docs/database/reading-data/indexes/indexes-and-query-perf.md
new file mode 100644
index 0000000..41aad32
--- /dev/null
+++ b/synced/convex/docs/database/reading-data/indexes/indexes-and-query-perf.md
@@ -0,0 +1,337 @@
+---
+sidebar_label: "Indexes and Query Performance"
+title: "Introduction to Indexes and Query Performance"
+sidebar_position: 100
+---
+
+How do I ensure my Convex
+[database queries](/database/reading-data/reading-data.mdx) are fast and
+efficient? When should I define an
+[index](/database/reading-data/indexes/indexes.md)? What is an index?
+
+This document explains how you should think about query performance in Convex by
+describing a simplified model of how queries and indexes function.
+
+If you already have a strong understanding of database queries and indexes you
+can jump straight to the reference documentation instead:
+
+- [Reading Data](/database/reading-data/reading-data.mdx)
+- [Indexes](/database/reading-data/indexes/indexes.md)
+
+## A Library of Documents
+
+You can imagine that Convex is a physical library storing documents as physical
+books. In this world, every time you add a document to Convex with
+[`db.insert("books", {...})`](/api/interfaces/server.GenericDatabaseWriter#insert)
+a librarian places the book on a shelf.
+
+By default, Convex organizes your documents in the order they were inserted. You
+can imagine the librarian inserting documents left to right on a shelf.
+
+If you run a query to find the first book like:
+
+```ts
+const firstBook = await ctx.db.query("books").first();
+```
+
+then the librarian could start at the left edge of the shelf and find the first
+book. This is an extremely fast query because the librarian only has to look at
+a single book to get the result.
+
+Similarly, if we want to retrieve the last book that was inserted we could
+instead do:
+
+```ts
+const lastBook = await ctx.db.query("books").order("desc").first();
+```
+
+This is the same query but we've swapped the order to descending. In the
+library, this means that the librarian will start on the right edge of the shelf
+and scan right-to-left. The librarian still only needs to look at a single book
+to determine the result so this query is also extremely fast.
+
+## Full Table Scans
+
+Now imagine that someone shows up at the library and asks "what books do you
+have by Jane Austen?"
+
+This could be expressed as:
+
+```ts
+const books = await ctx.db
+  .query("books")
+  .filter((q) => q.eq(q.field("author"), "Jane Austen"))
+  .collect();
+```
+
+This query is saying "look through all of the books, left-to-right, and collect
+the ones where the `author` field is Jane Austen." To do this the librarian will
+need to look through the entire shelf and check the author of every book.
+
+This query is a _full table scan_ because it requires Convex to look at every
+document in the table. The performance of this query is based on the number of
+books in the library.
+
+If your Convex table has a small number of documents, this is fine! Full table
+scans should still be fast if there are a few hundred documents, but if the
+table has many thousands of documents these queries will become slow.
+
+In the library analogy, this kind of query is fine if the library has a single
+shelf. As the library expands into a bookcase with many shelves or many
+bookcases, this approach becomes infeasible.
+
+## Card Catalogs
+
+How can we more efficiently find books given an author?
+
+One option is to re-sort the entire library by `author`. This will solve our
+immediate problem but now our original queries for `firstBook` and `lastBook`
+would become full table scans because we'd need to examine every book to see
+which was inserted first/last.
+
+Another option is to duplicate the entire library. We could purchase 2 copies of
+every book and put them on 2 separate shelves: one shelf sorted by insertion
+time and another sorted by author. This would work, but it's expensive. We now
+need twice as much space for our library.
+
+A better option is to build an _index_ on `author`. In the library, we could use
+an old-school [card catalog](https://en.wikipedia.org/wiki/Library_catalog) to
+organize the books by author. The idea here is that the librarian will write an
+index card for each book that contains:
+
+- The book's author
+- The location of the book on the shelves
+
+These index cards will be sorted by author and live in a separate organizer from
+the shelves that hold the books. The card catalog should stay small because it
+only has an index card per book (not the entire text of the book).
+
+![Card Catalog](/img/card-catalog.jpg)
+
+When a patron asks for "books by Jane Austen", the librarian can now:
+
+1. Go to the card catalog and quickly find all of the cards for "Jane Austen".
+2. For each card, go and find the book on the shelf.
+
+This is quite fast because the librarian can quickly find the index cards for
+Jane Austen. It's still a little bit of work to find the book for each card but
+the number of index cards is small so this is quite fast.
+
+## Indexes
+
+Database indexes work based on the same concept! With Convex you can define an
+_index_ with:
+
+```ts noDialect title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  books: defineTable({
+    author: v.string(),
+    title: v.string(),
+    text: v.string(),
+  }).index("by_author", ["author"]),
+});
+```
+
+then Convex will create a new index called `by_author` on `author`. This means
+that your `books` table will now have an additional data structure that is
+sorted by the `author` field.
+
+You can query this index with:
+
+```ts
+const austenBooks = await ctx.db
+  .query("books")
+  .withIndex("by_author", (q) => q.eq("author", "Jane Austen"))
+  .collect();
+```
+
+This query instructs Convex to go to the `by_author` index and find all the
+entries where `doc.author === "Jane Austen"`. Because the index is sorted by
+`author`, this is a very efficient operation. This means that Convex can execute
+this query in the same manner that the librarian can:
+
+1. Find the range of the index with entries for Jane Austen.
+2. For each entry in that range, get the corresponding document.
+
+The performance of this query is based on the number of documents where
+`doc.author === "Jane Austen"` which should be quite small. We've dramatically
+sped up the query!
+
+## Backfilling and Maintaining Indexes
+
+One interesting detail to think about is the work needed to create this new
+structure. In the library, the librarian must go through every book on the shelf
+and put a new index card for each one in the card catalog sorted by author. Only
+after that can the librarian trust that the card catalog will give it correct
+results.
+
+The same is true for Convex indexes! When you define a new index, the first time
+you run `npx convex deploy` Convex will need to loop through all of your
+documents and index each one. This is why the first deploy after the creation of
+a new index will be slightly slower than normal; Convex has to do a bit of work
+for each document in your table.
+
+Similarly, even after an index is defined, Convex will have to do a bit of extra
+work to keep this index up to date as the data changes. Every time a document is
+inserted, updated, or deleted in an indexed table, Convex will also update its
+index entry. This is analogous to a librarian creating new index cards for new
+books as they add them to the library.
+
+If you are defining a few indexes there is no need to worry about the
+maintenance cost. As you define more indexes, the cost to maintain them grows
+because every `insert` needs to update every index. This is why Convex has a
+limit of 32 indexes per table. In practice most applications define a handful of
+indexes per table to make their important queries efficient.
+
+## Indexing Multiple Fields
+
+Now imagine that a patron shows up at the library and would like to check out
+_Foundation_ by Isaac Asimov. Given our index on `author`, we can write a query
+that uses the index to find all the books by Isaac Asimov and then examines the
+title of each book to see if it's _Foundation_.
+
+```ts
+const foundation = await ctx.db
+  .query("books")
+  .withIndex("by_author", (q) => q.eq("author", "Isaac Asimov"))
+  .filter((q) => q.eq(q.field("title"), "Foundation"))
+  .unique();
+```
+
+This query describes how a librarian might execute the query. The librarian will
+use the card catalog to find all of the index cards for Isaac Asimov's books.
+The cards themselves don't have the title of the book so the librarian will need
+to find every Asimov book on the shelves and look at its title to find the one
+named _Foundation_. Lastly, this query ends with
+[`.unique`](/api/interfaces/server.Query#unique) because we expect there to be
+at most one result.
+
+This query demonstrates the difference between filtering using
+[`withIndex`](/api/interfaces/server.QueryInitializer#withindex) and
+[`filter`](/api/interfaces/server.Query#filter). `withIndex` only allows you to
+restrict your query based on the index. You can only do operations that the
+index can do efficiently like finding all documents with a given author.
+
+`filter` on the other hand allows you to write arbitrary, complex expressions
+but it won't be run using the index. Instead, `filter` expressions will be
+evaluated on every document in the range.
+
+Given all of this, we can conclude that **the performance of indexed queries is
+based on how many documents are in the index range**. In this case, the
+performance is based on the number of Isaac Asimov books because the librarian
+will need to look at each one to examine its title.
+
+Unfortunately, Isaac Asimov wrote
+[a lot of books](<https://en.wikipedia.org/wiki/Isaac_Asimov_bibliography_(alphabetical)>).
+Realistically even with 500+ books, this will be fast enough on Convex with the
+existing index, but let's consider how we could improve it anyway.
+
+One approach is to build a separate `by_title` index on `title`. This could let
+us swap the work we do in `.filter` and `.withIndex` to instead be:
+
+```ts
+const foundation = await ctx.db
+  .query("books")
+  .withIndex("by_title", (q) => q.eq("title", "Foundation"))
+  .filter((q) => q.eq(q.field("author"), "Isaac Asimov"))
+  .unique();
+```
+
+In this query, we're efficiently using the index to find all the books called
+_Foundation_ and then filtering through to find the one by Isaac Asimov.
+
+This is okay, but we're still at risk of having a slow query because too many
+books have a title of _Foundation_. An even better approach could be to build a
+_compound_ index that indexes both `author` and `title`. Compound indexes are
+indexes on an ordered list of fields.
+
+```ts noDialect title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  books: defineTable({
+    author: v.string(),
+    title: v.string(),
+    text: v.string(),
+  }).index("by_author_title", ["author", "title"]),
+});
+```
+
+In this index, books are sorted first by the author and then within each author
+by title. This means that a librarian can use the index to jump to the Isaac
+Asimov section and quickly find _Foundation_ within it.
+
+Expressing this as a Convex query this looks like:
+
+```ts
+const foundation = await ctx.db
+  .query("books")
+  .withIndex("by_author_title", (q) =>
+    q.eq("author", "Isaac Asimov").eq("title", "Foundation"),
+  )
+  .unique();
+```
+
+Here the index range expression tells Convex to only consider documents where
+the author is Isaac Asimov and the title is _Foundation_. This is only a single
+document so this query will be quite fast!
+
+Because this index sorts by `author` and then by `title`, it also efficiently
+supports queries like "All books by Isaac Asimov that start with F." We could
+express this as:
+
+```ts
+const asimovBooksStartingWithF = await ctx.db
+  .query("books")
+  .withIndex("by_author_title", (q) =>
+    q.eq("author", "Isaac Asimov").gte("title", "F").lt("title", "G"),
+  )
+  .collect();
+```
+
+This query uses the index to find books where
+`author === "Isaac Asimov" && "F" <= title < "G"`. Once again, the performance
+of this query is based on how many documents are in the index range. In this
+case, that's just the Asimov books that begin with "F" which is quite small.
+
+Also note that this index also supports our original query for "books by Jane
+Austen." It's okay to only use the `author` field in an index range expression
+and not restrict by title at all.
+
+Lastly, imagine that a library patron asks for the book _The Three-Body Problem_
+but they don't know the author's name. Our `by_author_title` index won't help us
+here because it's sorted first by `author`, and then by `title`. The title, _The
+Three-Body Problem_, could appear anywhere in the index!
+
+The Convex TypeScript types in the `withIndex` make this clear because they
+require that you compare index fields in order. Because the index is defined on
+`["author", "title"]`, you must first compare the `author` with `.eq` before the
+`title`.
+
+In this case, the best option is probably to create the separate `by_title`
+index to facilitate this query.
+
+## Conclusions
+
+Congrats! You now understand how queries and indexes work within Convex!
+
+Here are the main points we've covered:
+
+1. By default Convex queries are _full table scans_. This is appropriate for
+   prototyping and querying small tables.
+2. As your tables grow larger, you can improve your query performance by adding
+   _indexes_. Indexes are separate data structures that order your documents for
+   fast querying.
+3. In Convex, queries use the _`withIndex`_ method to express the portion of the
+   query that uses the index. The performance of a query is based on how many
+   documents are in the index range expression.
+4. Convex also supports _compound indexes_ that index multiple fields.
+
+To learn more about queries and indexes, check out our reference documentation:
+
+- [Reading Data](/database/reading-data/reading-data.mdx)
+- [Indexes](/database/reading-data/indexes/indexes.md)
diff --git a/synced/convex/docs/database/reading-data/indexes/indexes.md b/synced/convex/docs/database/reading-data/indexes/indexes.md
new file mode 100644
index 0000000..a7a5854
--- /dev/null
+++ b/synced/convex/docs/database/reading-data/indexes/indexes.md
@@ -0,0 +1,309 @@
+---
+title: "Indexes"
+sidebar_position: 100
+---
+
+Indexes are a data structure that allow you to speed up your
+[document queries](/database/reading-data/reading-data.mdx#querying-documents)
+by telling Convex how to organize your documents. Indexes also allow you to
+change the order of documents in query results.
+
+For a more in-depth introduction to indexing see
+[Indexes and Query Performance](/database/reading-data/indexes/indexes-and-query-perf.md).
+
+## Defining indexes
+
+Indexes are defined as part of your Convex [schema](/database/schemas.mdx). Each
+index consists of:
+
+1. A name.
+   - Must be unique per table.
+2. An ordered list of fields to index.
+   - To specify a field on a nested document, use a dot-separated path like
+     `properties.name`.
+
+To add an index onto a table, use the
+[`index`](/api/classes/server.TableDefinition#index) method on your table's
+schema:
+
+```ts noDialect title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+// Define a messages table with two indexes.
+export default defineSchema({
+  messages: defineTable({
+    channel: v.id("channels"),
+    body: v.string(),
+    user: v.id("users"),
+  })
+    .index("by_channel", ["channel"])
+    .index("by_channel_user", ["channel", "user"]),
+});
+```
+
+The `by_channel` index is ordered by the `channel` field defined in the schema.
+For messages in the same channel, they are ordered by the
+[system-generated `_creationTime` field](/database/types.md#system-fields) which
+is added to all indexes automatically.
+
+By contrast, the `by_channel_user` index orders messages in the same `channel`
+by the `user` who sent them, and only then by `_creationTime`.
+
+Indexes are created in [`npx convex dev`](/cli.md#run-the-convex-dev-server) and
+[`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).
+
+You may notice that the first deploy that defines an index is a bit slower than
+normal. This is because Convex needs to _backfill_ your index. The more data in
+your table, the longer it will take Convex to organize it in index order. If
+this is problematic for your workflow, [contact us](/production/contact.md).
+
+You can feel free to query an index in the same deploy that defines it. Convex
+will ensure that the index is backfilled before the new query and mutation
+functions are registered.
+
+<Admonition type="caution" title="Be careful when removing indexes">
+
+In addition to adding new indexes, `npx convex deploy` will delete indexes that
+are no longer present in your schema. Make sure that your indexes are completely
+unused before removing them from your schema!
+
+</Admonition>
+
+## Querying documents using indexes
+
+A query for "messages in `channel` created 1-2 minutes ago" over the
+`by_channel` index would look like:
+
+```ts
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_channel", (q) =>
+    q
+      .eq("channel", channel)
+      .gt("_creationTime", Date.now() - 2 * 60000)
+      .lt("_creationTime", Date.now() - 60000),
+  )
+  .collect();
+```
+
+The [`.withIndex`](/api/interfaces/server.QueryInitializer#withindex) method
+defines which index to query and how Convex will use that index to select
+documents. The first argument is the name of the index and the second is an
+_index range expression_. An index range expression is a description of which
+documents Convex should consider when running the query.
+
+The choice of index both affects how you write the index range expression and
+what order the results are returned in. For instance, by making both a
+`by_channel` and `by_channel_user` index, we can get results within a channel
+ordered by `_creationTime` or by `user`, respectively. If you were to use the
+`by_channel_user` index like this:
+
+```ts
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_channel_user", (q) => q.eq("channel", channel))
+  .collect();
+```
+
+The results would be all of the messages in a `channel` ordered by `user`, then
+by `_creationTime`. If you were to use `by_channel_user` like this:
+
+```ts
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_channel_user", (q) =>
+    q.eq("channel", channel).eq("user", user),
+  )
+  .collect();
+```
+
+The results would be the messages in the given `channel` sent by `user`, ordered
+by `_creationTime`.
+
+An index range expression is always a chained list of:
+
+1. 0 or more equality expressions defined with
+   [`.eq`](/api/interfaces/server.IndexRangeBuilder#eq).
+2. [Optionally] A lower bound expression defined with
+   [`.gt`](/api/interfaces/server.IndexRangeBuilder#gt) or
+   [`.gte`](/api/interfaces/server.IndexRangeBuilder#gte).
+3. [Optionally] An upper bound expression defined with
+   [`.lt`](/api/interfaces/server.IndexRangeBuilder#lt) or
+   [`.lte`](/api/interfaces/server.IndexRangeBuilder#lte).
+
+**You must step through fields in index order.**
+
+Each equality expression must compare a different index field, starting from the
+beginning and in order. The upper and lower bounds must follow the equality
+expressions and compare the next field.
+
+For example, it is not possible to write a query like:
+
+```ts
+// DOES NOT COMPILE!
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_channel", (q) =>
+    q
+      .gt("_creationTime", Date.now() - 2 * 60000)
+      .lt("_creationTime", Date.now() - 60000),
+  )
+  .collect();
+```
+
+This query is invalid because the `by_channel` index is ordered by
+`(channel, _creationTime)` and this query range has a comparison on
+`_creationTime` without first restricting the range to a single `channel`.
+Because the index is sorted first by `channel` and then by `_creationTime`, it
+isn't a useful index for finding messages in all channels created 1-2 minutes
+ago. The TypeScript types within `withIndex` will guide you through this.
+
+To better understand what queries can be run over which indexes, see
+[Introduction to Indexes and Query Performance](/database/reading-data/indexes/indexes-and-query-perf.md).
+
+**The performance of your query is based on the specificity of the range.**
+
+For example, if the query is
+
+```ts
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_channel", (q) =>
+    q
+      .eq("channel", channel)
+      .gt("_creationTime", Date.now() - 2 * 60000)
+      .lt("_creationTime", Date.now() - 60000),
+  )
+  .collect();
+```
+
+then query's performance would be based on the number of messages in `channel`
+created 1-2 minutes ago.
+
+If the index range is not specified, all documents in the index will be
+considered in the query.
+
+<Admonition type="tip" title="Picking a good index range">
+
+For performance, define index ranges that are as specific as possible! If you
+are querying a large table and you're unable to add any equality conditions with
+`.eq`, you should consider defining a new index.
+
+</Admonition>
+
+`.withIndex` is designed to only allow you to specify ranges that Convex can
+efficiently use your index to find. For all other filtering you can use the
+[`.filter`](/api/interfaces/server.Query#filter) method.
+
+For example to query for "messages in `channel` **not** created by me" you could
+do:
+
+```ts
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_channel", q => q.eq("channel", channel))
+  .filter(q => q.neq(q.field("user"), myUserId)
+  .collect();
+```
+
+In this case the performance of this query will be based on how many messages
+are in the channel. Convex will consider each message in the channel and only
+return the messages where the `user` field matches `myUserId`.
+
+## Sorting with indexes
+
+Queries that use `withIndex` are ordered by the columns specified in the index.
+
+The order of the columns in the index dictates the priority for sorting. The
+values of the columns listed first in the index are compared first. Subsequent
+columns are only compared as tie breakers only if all earlier columns match.
+
+Since Convex automatically includes `_creationTime` as the last column in all
+indexes, `_creationTime` will always be the final tie breaker if all other
+columns in the index are equal.
+
+For example, `by_channel_user` includes `channel`, `user`, and `\_creationTime`.
+So queries on `messages` that use `.withIndex("by_channel_user")` will be sorted
+first by channel, then by user within each channel, and finally by the creation
+time.
+
+Sorting with indexes allows you to satisfy use cases like displaying the top `N`
+scoring users, the most recent `N` transactions, or the most `N` liked messages.
+
+For example, to get the top 10 highest scoring players in your game, you might
+define an index on the player's highest score:
+
+```ts
+export default defineSchema({
+  players: defineTable({
+    username: v.string(),
+    highestScore: v.number(),
+  }).index("by_highest_score", ["highestScore"]),
+});
+```
+
+You can then efficiently find the top 10 highest scoring players using your
+index and [`take(10)`](/api/interfaces/server.Query#take):
+
+```ts
+const topScoringPlayers = await ctx.db
+  .query("users")
+  .withIndex("by_highest_score")
+  .order("desc")
+  .take(10);
+```
+
+In this example, the range expression is omitted because we're looking for the
+highest scoring players of all time. This particular query is reasonably
+efficient for large data sets only because we're using `take()`.
+
+If you use an index without a range expression, you should always use one of the
+following in conjunction with `withIndex`:
+
+1. [`.first()`](/api/interfaces/server.Query#first)
+2. [`.unique()`](/api/interfaces/server.Query#unique)
+3. [`.take(n)`](/api/interfaces/server.Query#take)
+4. [`.paginate(ops)`](/database/pagination.mdx)
+
+These APIs allow you to efficiently limit your query to a reasonable size
+without performing a full table scan.
+
+<Admonition type="caution" title="Full Table Scans">
+
+When your query fetches documents from the database, it will scan the rows in
+the range you specify. If you are using `.collect()`, for instance, it will scan
+all of the rows in the range. So if you use `withIndex` without a range
+expression, you will be
+[scanning the whole table](https://docs.convex.dev/database/indexes/indexes-and-query-perf#full-table-scans),
+which can be slow when your table has thousands of rows. `.filter()` doesn't
+affect which documents are scanned. Using `.first()` or `.unique()` or
+`.take(n)` will only scan rows until it has enough documents.
+
+</Admonition>
+
+You can include a range expression to satisfy more targeted queries. For
+example, to get the top scoring players in Canada, you might use both `take()`
+and a range expression:
+
+```ts
+// query the top 10 highest scoring players in Canada.
+const topScoringPlayers = await ctx.db
+  .query("users")
+  .withIndex("by_country_highest_score", (q) => q.eq("country", "CA"))
+  .order("desc")
+  .take(10);
+```
+
+## Limits
+
+Convex supports indexes containing up to 16 fields. You can define 32 indexes on
+each table. Indexes can't contain duplicate fields.
+
+No reserved fields (starting with `_`) are allowed in indexes. The
+`_creationTime` field is automatically added to the end of every index to ensure
+a stable ordering. It should not be added explicitly in the index definition,
+and it's counted towards the index fields limit.
+
+The `by_creation_time` index is created automatically (and is what is used in
+database queries that don't specify an index). The `by_id` index is reserved.
diff --git a/synced/convex/docs/database/reading-data/reading-data.md b/synced/convex/docs/database/reading-data/reading-data.md
new file mode 100644
index 0000000..d1464f1
--- /dev/null
+++ b/synced/convex/docs/database/reading-data/reading-data.md
@@ -0,0 +1,414 @@
+---
+title: "Reading Data"
+sidebar_position: 3
+---
+
+
+
+
+
+
+
+[Query](/functions/query-functions.mdx) and
+[mutation](/functions/mutation-functions.mdx) functions can read data from
+database tables using _document ids_ and _document queries_.
+
+## Reading a single document
+
+Given a single document's id you can read its data with the
+[`db.get`](/api/interfaces/server.GenericDatabaseReader#get) method:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTask = query({
+  args: { taskId: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const task = await ctx.db.get(args.taskId);
+    // do something with `task`
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTask = query({
+  args: { taskId: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const task = await ctx.db.get(args.taskId);
+    // do something with `task`
+  },
+});
+```
+
+
+**Note**: You should use the `v.id` validator like in the example above to make
+sure you are not exposing data from tables other than the ones you intended.
+
+## Querying documents
+
+Document queries always begin by choosing the table to query with the
+[`db.query`](/api/interfaces/server.GenericDatabaseReader#query) method:
+
+
+```ts
+import { query } from "./_generated/server";
+
+export const listTasks = query({
+  handler: async (ctx) => {
+    const tasks = await ctx.db.query("tasks").collect();
+    // do something with `tasks`
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+
+export const listTasks = query({
+  handler: async (ctx) => {
+    const tasks = await ctx.db.query("tasks").collect();
+    // do something with `tasks`
+  },
+});
+```
+
+
+Then you can:
+
+1. filter
+2. order
+3. and `await` the results
+
+We'll see how this works in the examples below.
+
+## Filtering your query
+
+The best way to filter in Convex is to use indexes. Indexes build a special
+internal structure in your database to speed up lookups.
+
+There are two steps to using indexes:
+
+1. Define the index in your `convex/schema.ts` file.
+2. Query via the `withIndex()` syntax.
+
+### 1. Define the index
+
+If you aren't familiar with how to create a Convex schema, read the
+[schema doc](/database/schemas.mdx).
+
+Let’s assume you’re building a chat app and want to get all messages in a
+particular channel. You can define a new index called `by_channel` on the
+`messages` table by using the `.index()` method in your schema.
+
+```ts noDialect title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+// Define a messages table with an index.
+export default defineSchema({
+  messages: defineTable({
+    channel: v.id("channels"),
+    body: v.string(),
+    user: v.id("users"),
+    // highlight-next-line
+  }).index("by_channel", ["channel"]),
+});
+```
+
+### 2. Filter a query with an index
+
+In your query function, you can now filter your `messages` table by using the
+`by_channel` index.
+
+```ts
+const messages = await ctx.db
+  .query("messages")
+  // highlight-next-line
+  .withIndex("by_channel", (q) => q.eq("channel", channel))
+  .collect();
+```
+
+In Convex, you must explicitly use the `withIndex()` syntax to ensure your
+database uses the index. This differs from a more traditional SQL database,
+where the database implicitly chooses to use an index based on heuristics. The
+Convex approach leads to fewer surprises in the long run.
+
+You can create an index across multiple fields at once, query a specific range
+of data, and change the order of your query result.
+[Read the complete index documentation](/database/reading-data/indexes/indexes.md)
+to learn more.
+
+Convex also supports a slower filtering mechanism that effectively loops through
+the table to match the filter. This can be useful if you know your table will be
+small (low thousands of rows), you're prototyping, or you want to filter an
+index query further. You can read more about filters
+[here](/database/reading-data/filters.mdx).
+
+## Ordering
+
+By default Convex always returns documents ordered by
+[`_creationTime`](/database/types.md#system-fields).
+
+You can use [`.order("asc" | "desc")`](/api/interfaces/server.Query#order) to
+pick whether the order is ascending or descending. If the order isn't specified,
+it defaults to ascending.
+
+```ts
+// Get all messages, oldest to newest.
+const messages = await ctx.db.query("messages").order("asc").collect();
+```
+
+```ts
+// Get all messages, newest to oldest.
+const messages = await ctx.db.query("messages").order("desc").collect();
+```
+
+If you need to sort on a field other than `_creationTime` and your document
+query returns a small number of documents (on the order of hundreds rather than
+thousands of documents), consider sorting in Javascript:
+
+```ts
+// Get top 10 most liked messages, assuming messages is a fairly small table:
+const messages = await ctx.db.query("messages").collect();
+const topTenMostLikedMessages = recentMessages
+  .sort((a, b) => b.likes - a.likes)
+  .slice(0, 10);
+```
+
+For document queries that return larger numbers of documents, you'll want to use
+an [index](/database/reading-data/indexes/indexes.md) to improve the
+performance. Document queries that use indexes will be
+[ordered based on the columns in the index](/database/reading-data/indexes/indexes.md#sorting-with-indexes)
+and can avoid slow table scans.
+
+```ts
+// Get the top 20 most liked messages of all time, using the "by_likes" index.
+const messages = await ctx.db
+  .query("messages")
+  .withIndex("by_likes")
+  .order("desc")
+  .take(20);
+```
+
+See [Limits](/database/reading-data/indexes/indexes.md#limits) for details.
+
+### Ordering of different types of values
+
+A single field can have values of any [Convex type](/database/types.md). When
+there are values of different types in an indexed field, their ascending order
+is as follows:
+
+No value set&nbsp;(`undefined`) < Null&nbsp;(`null`) < Int64&nbsp;(`bigint`) <
+Float64 (`number`) < Boolean&nbsp;(`boolean`) < String&nbsp;(`string`) <
+Bytes&nbsp;(`ArrayBuffer`) < Array&nbsp;(`Array`) < Object&nbsp;(`Object`)
+
+The same ordering is used by the filtering comparison operators `q.lt()`,
+`q.lte()`, `q.gt()` and `q.gte()`.
+
+## Retrieving results
+
+Most of our previous examples have ended the document query with the
+[`.collect()`](/api/interfaces/server.Query#collect) method, which returns all
+the documents that match your filters. Here are the other options for retrieving
+results.
+
+### Taking `n` results
+
+[`.take(n)`](/api/interfaces/server.Query#take) selects only the first `n`
+results that match your query.
+
+```ts
+const users = await ctx.db.query("users").take(5);
+```
+
+### Finding the first result
+
+[`.first()`](/api/interfaces/server.Query#first) selects the first document that
+matches your query and returns `null` if no documents were found.
+
+```ts
+// We expect only one user with that email address.
+const userOrNull = await ctx.db
+  .query("users")
+  .withIndex("by_email", (q) => q.eq("email", "test@example.com"))
+  .first();
+```
+
+### Using a unique result
+
+[`.unique()`](/api/interfaces/server.Query#unique) selects the single document
+from your query or returns `null` if no documents were found. If there are
+multiple results it will throw an exception.
+
+```ts
+// Our counter table only has one document.
+const counterOrNull = await ctx.db.query("counter").unique();
+```
+
+### Loading a page of results
+
+[`.paginate(opts)`](/api/interfaces/server.OrderedQuery#paginate) loads a page
+of results and returns a [`Cursor`](/api/modules/server#cursor) for loading
+additional results.
+
+See [Paginated Queries](/database/pagination.mdx) to learn more.
+
+## More complex queries
+
+Convex prefers to have a few, simple ways to walk through and select documents
+from tables. In Convex, there is no specific query language for complex logic
+like a join, an aggregation, or a group by.
+
+Instead, you can write the complex logic in Javascript! Convex guarantees that
+the results will be consistent.
+
+### Join
+
+Table join might look like:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const eventAttendees = query({
+  args: { eventId: v.id("events") },
+  handler: async (ctx, args) => {
+    const event = await ctx.db.get(args.eventId);
+    // highlight-start
+    return Promise.all(
+      (event?.attendeeIds ?? []).map((userId) => ctx.db.get(userId)),
+    );
+    // highlight-end
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const eventAttendees = query({
+  args: { eventId: v.id("events") },
+  handler: async (ctx, args) => {
+    const event = await ctx.db.get(args.eventId);
+    // highlight-start
+    return Promise.all(
+      (event?.attendeeIds ?? []).map((userId) => ctx.db.get(userId)),
+    );
+    // highlight-end
+  },
+});
+```
+
+
+### Aggregation
+
+Here's an example of computing an average:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const averagePurchasePrice = query({
+  args: { email: v.string() },
+  handler: async (ctx, args) => {
+    const userPurchases = await ctx.db
+      .query("purchases")
+      .withIndex("by_buyer", (q) => q.eq("buyer", args.email))
+      .collect();
+    // highlight-start
+    const sum = userPurchases.reduce((a, { value: b }) => a + b, 0);
+    return sum / userPurchases.length;
+    // highlight-end
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const averagePurchasePrice = query({
+  args: { email: v.string() },
+  handler: async (ctx, args) => {
+    const userPurchases = await ctx.db
+      .query("purchases")
+      .withIndex("by_buyer", (q) => q.eq("buyer", args.email))
+      .collect();
+    // highlight-start
+    const sum = userPurchases.reduce((a, { value: b }) => a + b, 0);
+    return sum / userPurchases.length;
+    // highlight-end
+  },
+});
+```
+
+
+> If you need more scalable aggregate options (for example to handle frequent
+> updates or large tables), consider using the
+> [Sharded Counter](https://www.convex.dev/components/sharded-counter) or
+> [Aggregate](https://www.convex.dev/components/aggregate) components. These
+> components can help you handle high-throughput counters, sums, or computations
+> without looping through the whole table.
+
+### Group by
+
+Here's an example of grouping and counting:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const numPurchasesPerBuyer = query({
+  args: { email: v.string() },
+  handler: async (ctx, args) => {
+    const userPurchases = await ctx.db.query("purchases").collect();
+
+    // highlight-start
+    return userPurchases.reduce(
+      (counts, { buyer }) => ({
+        ...counts,
+        [buyer]: counts[buyer] ?? 0 + 1,
+      }),
+      {} as Record<string, number>,
+    );
+    // highlight-end
+  },
+});
+```
+
+```js
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const numPurchasesPerBuyer = query({
+  args: { email: v.string() },
+  handler: async (ctx, args) => {
+    const userPurchases = await ctx.db.query("purchases").collect();
+
+    // highlight-start
+    return userPurchases.reduce(
+      (counts, { buyer }) => ({
+        ...counts,
+        [buyer]: counts[buyer] ?? 0 + 1,
+      }),
+      {},
+    );
+    // highlight-end
+  },
+});
+```
+
+
+## Explore the syntax on the dashboard
+
+You can try out the syntax described above directly from the dashboard by
+[writing a custom test query](/dashboard/deployments/data.md#writing-custom-queries).
diff --git a/synced/convex/docs/database/schemas.md b/synced/convex/docs/database/schemas.md
new file mode 100644
index 0000000..1026e99
--- /dev/null
+++ b/synced/convex/docs/database/schemas.md
@@ -0,0 +1,416 @@
+---
+title: "Schemas"
+sidebar_position: 5
+description:
+  "Schema validation keeps your Convex data neat and tidy. It also gives you
+  end-to-end TypeScript type safety!"
+toc_max_heading_level: 4
+---
+
+
+
+A schema is a description of
+
+1. the tables in your Convex project
+2. the type of documents within your tables
+
+While it is possible to use Convex _without_ defining a schema, adding a
+`schema.ts` file will ensure that the documents in your tables are the correct
+type. If you're using
+[TypeScript](/understanding/best-practices/typescript.mdx), adding a schema will
+also give you end-to-end type safety throughout your app.
+
+We recommend beginning your project without a schema for rapid prototyping and
+then adding a schema once you've solidified your plan. To learn more see our
+[Schema Philosophy](/database/advanced/schema-philosophy.md).
+
+**Example:**
+[TypeScript and Schemas](https://github.com/get-convex/convex-demos/tree/main/typescript)
+
+## Writing schemas
+
+Schemas are defined in a `schema.ts` file in your `convex/` directory and look
+like:
+
+
+```ts
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  messages: defineTable({
+    body: v.string(),
+    user: v.id("users"),
+  }),
+  // @snippet start user
+  users: defineTable({
+    name: v.string(),
+    tokenIdentifier: v.string(),
+  }).index("by_token", ["tokenIdentifier"]),
+  // @snippet end user
+});
+```
+
+
+This schema (which is based on our
+[users and auth example](https://github.com/get-convex/convex-demos/tree/main/users-and-auth)),
+has 2 tables: messages and users. Each table is defined using the
+[`defineTable`](/api/modules/server#definetable) function. Within each table,
+the document type is defined using the validator builder,
+[`v`](/api/modules/values#v). In addition to the fields listed, Convex will also
+automatically add `_id` and `_creationTime` fields. To learn more, see
+[System Fields](/database/types.md#system-fields).
+
+<Admonition type="tip" title="Generating a Schema">
+
+While writing your schema, it can be helpful to consult the
+[Convex Dashboard](/dashboard/deployments/data.md#generating-a-schema). The
+"Generate Schema" button in the "Data" view suggests a schema declaration based
+on the data in your tables.
+
+</Admonition>
+
+### Validators
+
+The validator builder, [`v`](/api/modules/values#v) is used to define the type
+of documents in each table. It has methods for each of
+[Convex's types](/database/types):
+
+```ts noDialect title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  documents: defineTable({
+    id: v.id("documents"),
+    string: v.string(),
+    number: v.number(),
+    boolean: v.boolean(),
+    nestedObject: v.object({
+      property: v.string(),
+    }),
+  }),
+});
+```
+
+It additionally allows you to define unions, optional property, string literals,
+and more. [Argument validation](/functions/validation.mdx) and schemas both use
+the same validator builder, `v`.
+
+#### Optional fields
+
+You can describe optional fields by wrapping their type with `v.optional(...)`:
+
+```typescript
+defineTable({
+  optionalString: v.optional(v.string()),
+  optionalNumber: v.optional(v.number()),
+});
+```
+
+This corresponds to marking fields as optional with `?` in TypeScript.
+
+#### Unions
+
+You can describe fields that could be one of multiple types using `v.union`:
+
+```typescript
+defineTable({
+  stringOrNumber: v.union(v.string(), v.number()),
+});
+```
+
+If your table stores multiple different types of documents, you can use
+`v.union` at the top level:
+
+```typescript
+defineTable(
+  v.union(
+    v.object({
+      kind: v.literal("StringDocument"),
+      value: v.string(),
+    }),
+    v.object({
+      kind: v.literal("NumberDocument"),
+      value: v.number(),
+    }),
+  ),
+);
+```
+
+In this schema, documents either have a `kind` of `"StringDocument"` and a
+string for their `value`:
+
+```json
+{
+  "kind": "StringDocument",
+  "value": "abc"
+}
+```
+
+or they have a `kind` of `"NumberDocument"` and a number for their `value`:
+
+```json
+{
+  "kind": "NumberDocument",
+  "value": 123
+}
+```
+
+#### Literals
+
+Fields that are a constant can be expressed with `v.literal`:
+
+```typescript
+defineTable({
+  oneTwoOrThree: v.union(
+    v.literal("one"),
+    v.literal("two"),
+    v.literal("three"),
+  ),
+});
+```
+
+#### Record objects
+
+You can describe objects that map arbitrary keys to values with `v.record`:
+
+```typescript
+defineTable({
+  simpleMapping: v.record(v.string(), v.boolean()),
+});
+```
+
+You can use other types of string validators for the keys:
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    userIdToValue: v.record(v.id("users"), v.boolean()),
+  },
+  handler: async ({ db }, { userIdToValue }) => {
+    //...
+  },
+});
+```
+
+Notes:
+
+- This type corresponds to the
+  [Record\<K,V\>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
+  type in TypeScript
+- You cannot use string literals as a `record` key
+- Using `v.string()` as a `record` key validator will only allow ASCII
+  characters
+
+#### Any
+
+Fields or documents that could take on any value can be represented with
+`v.any()`:
+
+```typescript
+defineTable({
+  anyValue: v.any(),
+});
+```
+
+This corresponds to the `any` type in TypeScript.
+
+### Options
+
+These options are passed as part of the
+[options](/api/interfaces/server.DefineSchemaOptions) argument to
+[`defineSchema`](/api/modules/server#defineschema).
+
+#### `schemaValidation: boolean`
+
+Whether Convex should validate at runtime that your documents match your schema.
+
+By default, Convex will enforce that all new and existing documents match your
+schema.
+
+You can disable `schemaValidation` by passing in `schemaValidation: false`:
+
+```typescript
+defineSchema(
+  {
+    // Define tables here.
+  },
+  {
+    schemaValidation: false,
+  },
+);
+```
+
+When `schemaValidation` is disabled, Convex will not validate that new or
+existing documents match your schema. You'll still get schema-specific
+TypeScript types, but there will be no validation at runtime that your documents
+match those types.
+
+#### `strictTableNameTypes: boolean`
+
+Whether the TypeScript types should allow accessing tables not in the schema.
+
+By default, the TypeScript table name types produced by your schema are strict.
+That means that they will be a union of strings (ex. `"messages" | "users"`) and
+only support accessing tables explicitly listed in your schema.
+
+Sometimes it's useful to only define part of your schema. For example, if you
+are rapidly prototyping, it could be useful to try out a new table before adding
+it your `schema.ts` file.
+
+You can disable `strictTableNameTypes` by passing in
+`strictTableNameTypes: false`:
+
+```typescript
+defineSchema(
+  {
+    // Define tables here.
+  },
+  {
+    strictTableNameTypes: false,
+  },
+);
+```
+
+When `strictTableNameTypes` is disabled, the TypeScript types will allow access
+to tables not listed in the schema and their document type will be `any`.
+
+Regardless of the value of `strictTableNameTypes`, your schema will only
+validate documents in the tables listed in the schema. You can still create and
+modify documents in other tables in JavaScript or on the dashboard (they just
+won't be validated).
+
+## Schema validation
+
+Schemas are pushed automatically in
+[`npx convex dev`](/cli.md#run-the-convex-dev-server) and
+[`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).
+
+The first push after a schema is added or modified will validate that all
+existing documents match the schema. If there are documents that fail
+validation, the push will fail.
+
+After the schema is pushed, Convex will validate that all future document
+inserts and updates match the schema.
+
+Schema validation is skipped if [`schemaValidation`](#schemavalidation-boolean)
+is set to `false`.
+
+Note that schemas only validate documents in the tables listed in the schema.
+You can still create and modify documents in other tables (they just won't be
+validated).
+
+### Circular references
+
+You might want to define a schema with circular ID references like:
+
+```typescript title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  users: defineTable({
+    preferencesId: v.id("preferences"),
+  }),
+  preferences: defineTable({
+    userId: v.id("users"),
+  }),
+});
+```
+
+In this schema, documents in the `users` table contain a reference to documents
+in `preferences` and vice versa.
+
+Because schema validation enforces your schema on every `db.insert`,
+`db.replace`, and `db.patch` call, creating circular references like this is not
+possible.
+
+The easiest way around this is to make one of the references nullable:
+
+```typescript title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  users: defineTable({
+    preferencesId: v.id("preferences"),
+  }),
+  preferences: defineTable({
+    userId: v.union(v.id("users"), v.null()),
+  }),
+});
+```
+
+This way you can create a preferences document first, then create a user
+document, then set the reference on the preferences document:
+
+
+```ts
+import { mutation } from "./_generated/server";
+
+export default mutation({
+  handler: async (ctx) => {
+    const preferencesId = await ctx.db.insert("preferences", {});
+    const userId = await ctx.db.insert("users", { preferencesId });
+    await ctx.db.patch(preferencesId, { userId });
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+
+export default mutation({
+  handler: async (ctx) => {
+    const preferencesId = await ctx.db.insert("preferences", {});
+    const userId = await ctx.db.insert("users", { preferencesId });
+    await ctx.db.patch(preferencesId, { userId });
+  },
+});
+```
+
+
+[Let us know](/production/contact.md) if you need better support for circular
+references.
+
+## TypeScript types
+
+Once you've defined a schema,
+[`npx convex dev`](/cli.md#run-the-convex-dev-server) will produce new versions
+of [`dataModel.d.ts`](/generated-api/data-model) and
+[`server.d.ts`](/generated-api/server) with types based on your schema.
+
+### `Doc<TableName>`
+
+The [`Doc`](/generated-api/data-model#doc) TypeScript type from
+[`dataModel.d.ts`](/generated-api/data-model) provides document types for all of
+your tables. You can use these both when writing Convex functions and in your
+React components:
+
+```tsx noDialect title="MessageView.tsx"
+import { Doc } from "../convex/_generated/dataModel";
+
+function MessageView(props: { message: Doc<"messages"> }) {
+  ...
+}
+```
+
+If you need the type for a portion of a document, use the
+[`Infer` type helper](/functions/validation#extracting-typescript-types).
+
+### `query` and `mutation`
+
+The [`query`](/generated-api/server#query) and
+[`mutation`](/generated-api/server#mutation) functions in
+[`server.js`](/generated-api/server) have the same API as before but now provide
+a `db` with more precise types. Functions like
+[`db.insert(table, document)`](/api/interfaces/server.GenericDatabaseWriter#insert)
+now understand your schema. Additionally
+[database queries](/database/reading-data/reading-data.mdx) will now return the
+correct document type (not `any`).
+
+<StackPosts query="schemas" />
diff --git a/synced/convex/docs/database/types.md b/synced/convex/docs/database/types.md
new file mode 100644
index 0000000..32daafe
--- /dev/null
+++ b/synced/convex/docs/database/types.md
@@ -0,0 +1,122 @@
+---
+title: "Data Types"
+sidebar_position: 40
+---
+
+import ConvexValues from "@site/docs/\_convexValues.mdx";
+
+All Convex documents are defined as Javascript objects. These objects can have
+field values of any of the types below.
+
+You can codify the shape of documents within your tables by
+[defining a schema](/database/schemas.mdx).
+
+## Convex values
+
+<ConvexValues />
+
+## System fields
+
+Every document in Convex has two automatically-generated system fields:
+
+- `_id`: The [document ID](/database/document-ids.mdx) of the document.
+- `_creationTime`: The time this document was created, in milliseconds since the
+  Unix epoch.
+
+## Limits
+
+Convex values must be less than 1MB in total size. This is an approximate limit
+for now, but if you're running into these limits and would like a more precise
+method to calculate a document's size,
+[reach out to us](https://convex.dev/community). Documents can have nested
+values, either objects or arrays that contain other Convex types. Convex types
+can have at most 16 levels of nesting, and the cumulative size of a nested tree
+of values must be under the 1MB limit.
+
+Table names may contain alphanumeric characters ("a" to "z", "A" to "Z", and "0"
+to "9") and underscores ("\_"), and they cannot start with an underscore.
+
+For information on other limits, see [here](/production/state/limits.mdx).
+
+If any of these limits don't work for you,
+[let us know](https://convex.dev/community)!
+
+## Working with `undefined`
+
+The TypeScript value `undefined` is not a valid Convex value, so it cannot be
+used in Convex function arguments or return values, or in stored documents.
+
+1. Objects/records with `undefined` values are the same as if the field were
+   missing: `{a: undefined}` is transformed into `{}` when passed to a function
+   or stored in the database. You can think of Convex function calls and the
+   Convex database as serializing the data with `JSON.stringify`, which
+   similarly removes `undefined` values.
+2. Validators for object fields can use `v.optional(...)` to indicate that the
+   field might not be present.
+   - If an object's field "a" is missing, i.e. `const obj = {};`, then
+     `obj.a === undefined`. This is a property of TypeScript/JavaScript, not
+     specific to Convex.
+3. You can use `undefined` in filters and index queries, and it will match
+   documents that do not have the field. i.e.
+   `.withIndex("by_a", q=>q.eq("a", undefined))` matches document `{}` and
+   `{b: 1}`, but not `{a: 1}` or `{a: null, b: 1}`.
+   - In Convex's ordering scheme, `undefined < null < all other values`, so you
+     can match documents that _have_ a field via `q.gte("a", null as any)` or
+     `q.gt("a", undefined)`.
+4. There is exactly one case where `{a: undefined}` is different from `{}`: when
+   passed to `ctx.db.patch`. Passing `{a: undefined}` removes the field "a" from
+   the document, while passing `{}` does not change the field "a". See
+   [Updating existing documents](/database/writing-data.mdx#updating-existing-documents).
+5. Since `undefined` gets stripped from function arguments but has meaning in
+   `ctx.db.patch`, there are some tricks to pass patch's argument from the
+   client.
+   - If the client passing `args={}` (or `args={a: undefined}` which is
+     equivalent) should leave the field "a" unchanged, use
+     `ctx.db.patch(id, args)`.
+   - If the client passing `args={}` should remove the field "a", use
+     `ctx.db.patch(id, {a: undefined, ...args})`.
+   - If the client passing `args={}` should leave the field "a" unchanged and
+     `args={a: null}` should remove it, you could do
+     ```ts
+     if (args.a === null) {
+       args.a = undefined;
+     }
+     await ctx.db.patch(id, args);
+     ```
+6. Functions that return a plain `undefined`/`void` are treated as if they
+   returned `null`.
+7. Arrays containing `undefined` values, like `[undefined]`, throw an error when
+   used as Convex values.
+
+If you would prefer to avoid the special behaviors of `undefined`, you can use
+`null` instead, which _is_ a valid Convex value.
+
+## Working with dates and times
+
+Convex does not have a special data type for working with dates and times. How
+you store dates depends on the needs of your application:
+
+1. If you only care about a point in time, you can store a
+   [UTC timestamp](https://en.wikipedia.org/wiki/Unix_time). We recommend
+   following the `_creationTime` field example, which stores the timestamp as a
+   `number` in milliseconds. In your functions and on the client you can create
+   a JavaScript `Date` by passing the timestamp to its constructor:
+   `new Date(timeInMsSinceEpoch)`. You can then print the date and time in the
+   desired time zone (such as your user's machine's configured time zone).
+   - To get the current UTC timestamp in your function and store it in the
+     database, use `Date.now()`
+2. If you care about a calendar date or a specific clock time, such as when
+   implementing a booking app, you should store the actual date and/or time as a
+   string. If your app supports multiple timezones you should store the timezone
+   as well. [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) is a common format
+   for storing dates and times together in a single string like
+   `"2024-03-21T14:37:15Z"`. If your users can choose a specific time zone you
+   should probably store it in a separate `string` field, usually using the
+   [IANA time zone name](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones)
+   (although you could concatenate the two fields with unique character like
+   `"|"`).
+
+For more sophisticated printing (formatting) and manipulation of dates and times
+use one of the popular JavaScript libraries: [date-fns](https://date-fns.org/),
+[Day.js](https://day.js.org/), [Luxon](https://moment.github.io/luxon/) or
+[Moment.js](https://momentjs.com/).
diff --git a/synced/convex/docs/database/writing-data.md b/synced/convex/docs/database/writing-data.md
new file mode 100644
index 0000000..53d0260
--- /dev/null
+++ b/synced/convex/docs/database/writing-data.md
@@ -0,0 +1,267 @@
+---
+title: "Writing Data"
+sidebar_position: 4
+---
+
+
+
+
+
+import { ComponentCardList } from "@site/src/components/ComponentCard";
+
+[Mutations](/functions/mutation-functions.mdx) can insert, update, and remove
+data from database tables.
+
+## Inserting new documents
+
+You can create new documents in the database with the
+[`db.insert`](/api/interfaces/server.GenericDatabaseWriter#insert) method:
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const createTask = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    const taskId = await ctx.db.insert("tasks", { text: args.text });
+    // do something with `taskId`
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const createTask = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    const taskId = await ctx.db.insert("tasks", { text: args.text });
+    // do something with `taskId`
+  },
+});
+```
+
+
+The second argument to `db.insert` is a JavaScript object with data for the new
+document.
+
+The same types of values that can be passed into and returned from
+[queries](/functions/query-functions.mdx) and
+[mutations](/functions/mutation-functions.mdx) can be written into the database.
+See [Data Types](/database/types.md) for the full list of supported types.
+
+The `insert` method returns a globally unique ID for the newly inserted
+document.
+
+## Updating existing documents
+
+Given an existing document ID the document can be updated using the following
+methods:
+
+1. The [`db.patch`](/api/interfaces/server.GenericDatabaseWriter#patch) method
+   will patch an existing document, shallow merging it with the given partial
+   document. New fields are added. Existing fields are overwritten. Fields set
+   to `undefined` are removed.
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const updateTask = mutation({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const { id } = args;
+    console.log(await ctx.db.get(id));
+    // { text: "foo", status: { done: true }, _id: ... }
+
+    // Add `tag` and overwrite `status`:
+    await ctx.db.patch(id, { tag: "bar", status: { archived: true } });
+    console.log(await ctx.db.get(id));
+    // { text: "foo", tag: "bar", status: { archived: true }, _id: ... }
+
+    // Unset `tag` by setting it to `undefined`
+    await ctx.db.patch(id, { tag: undefined });
+    console.log(await ctx.db.get(id));
+    // { text: "foo", status: { archived: true }, _id: ... }
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const updateTask = mutation({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const { id } = args;
+    console.log(await ctx.db.get(id));
+    // { text: "foo", status: { done: true }, _id: ... }
+
+    // Add `tag` and overwrite `status`:
+    await ctx.db.patch(id, { tag: "bar", status: { archived: true } });
+    console.log(await ctx.db.get(id));
+    // { text: "foo", tag: "bar", status: { archived: true }, _id: ... }
+
+    // Unset `tag` by setting it to `undefined`
+    await ctx.db.patch(id, { tag: undefined });
+    console.log(await ctx.db.get(id));
+    // { text: "foo", status: { archived: true }, _id: ... }
+  },
+});
+```
+
+
+2. The [`db.replace`](/api/interfaces/server.GenericDatabaseWriter#replace)
+   method will replace the existing document entirely, potentially removing
+   existing fields:
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const replaceTask = mutation({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const { id } = args;
+    console.log(await ctx.db.get(id));
+    // { text: "foo", _id: ... }
+
+    // Replace the whole document
+    await ctx.db.replace(id, { invalid: true });
+    console.log(await ctx.db.get(id));
+    // { invalid: true, _id: ... }
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const replaceTask = mutation({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const { id } = args;
+    console.log(await ctx.db.get(id));
+    // { text: "foo", _id: ... }
+
+    // Replace the whole document
+    await ctx.db.replace(id, { invalid: true });
+    console.log(await ctx.db.get(id));
+    // { invalid: true, _id: ... }
+  },
+});
+```
+
+
+## Deleting documents
+
+Given an existing document ID the document can be removed from the table with
+the [`db.delete`](/api/interfaces/server.GenericDatabaseWriter#delete) method.
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const deleteTask = mutation({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.id);
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const deleteTask = mutation({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.id);
+  },
+});
+```
+
+
+## Bulk inserts or updates
+
+If you are used to SQL you might be looking for some sort of bulk insert or bulk
+update statement. In Convex the entire `mutation` function is automatically a
+single transaction.
+
+You can just insert or update in a loop in the mutation function. Convex queues
+up all database changes in the function and executes them all in a single
+transaction when the function ends, leading to a single efficient change to the
+database.
+
+````typescript
+/**
+ * Bulk insert multiple products into the database.
+ *
+ * Equivalent to the SQL:
+ * ```sql
+ * INSERT INTO products (product_id, product_name, category, price, in_stock)
+ * VALUES
+ *     ('Laptop Pro', 'Electronics', 1299.99, true),
+ *     ('Wireless Mouse', 'Electronics', 24.95, true),
+ *     ('Ergonomic Keyboard', 'Electronics', 89.50, true),
+ *     ('Ultra HD Monitor', 'Electronics', 349.99, false),
+ *     ('Wireless Headphones', 'Audio', 179.99, true);
+ * ```
+ */
+export const bulkInsertProducts = mutation({
+  args: {
+    products: v.array(
+      v.object({
+        product_name: v.string(),
+        category: v.string(),
+        price: v.number(),
+        in_stock: v.boolean(),
+      }),
+    ),
+  },
+  handler: async (ctx, args) => {
+    const { products } = args;
+
+    // Insert in a loop. This is efficient because Convex queues all the changes
+    // to be executed in a single transaction when the mutation ends.
+    for (const product of products) {
+      const id = await ctx.db.insert("products", {
+        product_name: product.product_name,
+        category: product.category,
+        price: product.price,
+        in_stock: product.in_stock,
+      });
+    }
+  },
+});
+````
+
+## Migrations
+
+Database migrations are done through the migration component. The component is
+designed to run online migrations to safely evolve your database schema over
+time. It allows you to resume from failures, and validate changes with dry runs.
+
+<ComponentCardList
+  items={[
+    {
+      title: "Migrations",
+      description: "Framework for long running data migrations of live data.",
+      href: "https://www.convex.dev/components/migrations",
+    },
+  ]}
+/>
+
+## Write performance and limits
+
+To prevent accidental writes of large amounts of records, queries and mutations
+enforce limits detailed [here](/production/state/limits.mdx#transactions).
diff --git a/synced/convex/docs/error.md b/synced/convex/docs/error.md
new file mode 100644
index 0000000..9c2a025
--- /dev/null
+++ b/synced/convex/docs/error.md
@@ -0,0 +1,96 @@
+# Errors and Warnings
+
+This page explains specific errors thrown by Convex.
+
+See [Error Handling](/functions/error-handling/error-handling.mdx) to learn
+about handling errors in general.
+
+<div id="occ-failure"></div>
+
+## Write conflict: Optimistic concurrency control \{#1}
+
+This system error is thrown when a mutation repeatedly fails due to conflicting
+changes from parallel mutation executions.
+
+### Example A
+
+A mutation `updateCounter` always updates the same document:
+
+```ts
+export const updateCounter = mutation({
+  args: {},
+  handler: async (ctx) => {
+    const doc = await ctx.db.get(process.env.COUNTER_ID);
+    await ctx.db.patch(doc._id, { value: doc.value + 1 });
+  },
+});
+```
+
+If this mutation is called many times per second, many of its executions will
+conflict with each other. Convex internally does several retries to mitigate
+this concern, but if the mutation is called more rapidly than Convex can execute
+it, some of the invocations will eventually throw this error:
+
+<ErrorExample name="updateCounter">
+  Documents read from or written to the table "counters" changed while this
+  mutation was being run and on every subsequent retry. Another call to this
+  mutation changed the document with ID "123456789101112".
+</ErrorExample>
+
+The error message will note the table name, which mutation caused the conflict
+(in this example its another call to the same mutation), and one document ID
+which was part of the conflicting change.
+
+### Example B
+
+Mutation `writeCount` depends on the entire `tasks` table:
+
+```ts
+export const writeCount = mutation({
+  args: {
+    target: v.id("counts"),
+  },
+  handler: async (ctx, args) => {
+    const tasks = await ctx.db.query("tasks").collect();
+    await ctx.db.patch(args.target, { value: tasks });
+  },
+});
+
+export const addTask = mutation({
+  args: {
+    text: v.string(),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("tasks", { text: args.text });
+  },
+});
+```
+
+If the mutation `writeCount` is called at the same time as many calls to
+`addTask` are made, either of the mutations can fail with this error. This is
+because any change to the `"tasks"` table will conflict with the `writeCount`
+mutation:
+
+<ErrorExample name="writeCount">
+  Documents read from or written to the table "tasks" changed while this
+  mutation was being run and on every subsequent retry. A call to "addTask"
+  changed the document with ID "123456789101112".
+</ErrorExample>
+
+### Remediation
+
+To fix this issue:
+
+1. Make sure that your mutations only read the data they need. Consider reducing
+   the amount of data read by using indexed queries with
+   [selective index range expressions](https://docs.convex.dev/database/indexes/).
+2. Make sure you are not calling a mutation an unexpected number of times,
+   perhaps from an action inside a loop.
+3. Design your data model such that it doesn't require making many writes to the
+   same document.
+
+### Resources
+
+- Learn more about [optimistic concurrency control](/database/advanced/occ.md).
+- See this [Stack post](https://stack.convex.dev/waitlist) for an example of
+  designing an app to avoid mutation conflicts.
diff --git a/synced/convex/docs/eslint.md b/synced/convex/docs/eslint.md
new file mode 100644
index 0000000..dba862c
--- /dev/null
+++ b/synced/convex/docs/eslint.md
@@ -0,0 +1,111 @@
+---
+title: ESLint rules
+sidebar_position: 30
+description: ESLint rules for Convex
+---
+
+ESLint rules for Convex functions enforce best practices. Let us know if there's
+a rule you would find helpful!
+
+<BetaAdmonition feature="Convex ESLint rules" verb="are" />
+
+## Setup
+
+### ESLint 8 (.eslintrc.js)
+
+For ESLint 8, install these two libraries
+
+```bash
+npm i @typescript-eslint/eslint-plugin @convex-dev/eslint-plugin
+```
+
+and in .eslintrc.js:
+
+```js
+module.exports = {
+  extends: [
+    // Other configurations
+    "plugin:@typescript-eslint/recommended",
+    "plugin:@convex-dev/recommended",
+  ],
+  ignorePatterns: ["node_modules/", "dist/", "build/"],
+};
+```
+
+### ESLint 9 (eslint.config.js)
+
+For ESLint 9 (flat config), install just this library
+
+```bash
+npm i @convex-dev/eslint-plugin
+```
+
+and in eslint.config.js:
+
+```bash
+
+export default [
+  // Other configurations
+  ...convexPlugin.configs.recommended
+];
+```
+
+## Rules
+
+### no-old-registered-function-syntax
+
+Prefer object syntax for registered functions.
+
+Convex queries, mutations, and actions can be defined with a single function or
+with an object containing a handler property. Using the objects makes it
+possible to add argument and return value validators, so is always preferable.
+
+```ts
+// Allowed by this rule:
+export const list = query({
+  handler: async (ctx) => {
+    const data = await ctx.db.query("messages").collect();
+    ...
+  },
+});
+
+// Not allowed by this rule:
+export const list = query(async (ctx) => {
+  const data = await ctx.db.query("messages").collect();
+  ...
+});
+```
+
+### no-missing-args-validator
+
+Use argument validators.
+
+Convex queries, mutations, and actions can validate their arguments before
+beginning to run the handler function. Besides being a concise way to validate,
+the types of arguments, using argument validators enables generating more
+descriptive function specs and therefore OpenAPI bindings.
+
+```ts
+// Allowed by this rule:
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    ...
+  },
+});
+
+// Allowed by this rule:
+export const list = query({
+  args: { channel: v.id('channel') },
+  handler: async (ctx, { channel }) => {
+    ...
+  },
+});
+
+// Not allowed by this rule:
+export const list = query({
+  handler: async (ctx, { channel }: { channel: Id<"channel">}) => {
+    ...
+  },
+});
+```
diff --git a/synced/convex/docs/file-storage.md b/synced/convex/docs/file-storage.md
new file mode 100644
index 0000000..635b142
--- /dev/null
+++ b/synced/convex/docs/file-storage.md
@@ -0,0 +1,25 @@
+---
+title: "File Storage"
+description: "Store and serve files of any type."
+sidebar_position: 160
+pagination_prev: database
+---
+
+File Storage makes it easy to implement file upload in your app, store files
+from and send files to third-party APIs, and to serve dynamic files to your
+users. All file types are supported.
+
+- [Upload](/file-storage/upload-files.mdx) files to store them in Convex and
+  reference them in your database documents
+- [Store](/file-storage/store-files.mdx) files generated or fetched from
+  third-party APIs
+- [Serve](/file-storage/serve-files.mdx) files via URL
+- [Delete](/file-storage/delete-files.mdx) files stored in Convex
+- Access file [metadata](/file-storage/file-metadata.mdx)
+
+You can manage your stored files on the
+[dashboard](/dashboard/deployments/files.md).
+
+**Examples:**
+[File Storage with HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/file-storage-with-http),
+[File Storage with Queries and Mutations](https://github.com/get-convex/convex-demos/tree/main/file-storage)
diff --git a/synced/convex/docs/file-storage/delete-files.md b/synced/convex/docs/file-storage/delete-files.md
new file mode 100644
index 0000000..d42d08b
--- /dev/null
+++ b/synced/convex/docs/file-storage/delete-files.md
@@ -0,0 +1,49 @@
+---
+title: "Deleting Files"
+sidebar_label: "Delete"
+sidebar_position: 4
+---
+
+
+Files stored in Convex can be deleted from
+[mutations](/functions/mutation-functions.mdx),
+[actions](/functions/actions.mdx), and
+[HTTP actions](/functions/http-actions.mdx) via the
+[`storage.delete()`](/api/interfaces/server.StorageWriter#delete) function,
+which accepts a storage ID.
+
+Storage IDs correspond to documents in the `"_storage"` system table (see
+[Metadata](/file-storage/file-metadata.mdx)), so they can be validated using the
+`v.id("_storage")`.
+
+
+```ts
+import { v } from "convex/values";
+import { Id } from "./_generated/dataModel";
+import { mutation } from "./_generated/server";
+
+export const deleteById = mutation({
+  args: {
+    storageId: v.id("_storage"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.storage.delete(args.storageId);
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+import { Id } from "./_generated/dataModel";
+import { mutation } from "./_generated/server";
+
+export const deleteById = mutation({
+  args: {
+    storageId: v.id("_storage"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.storage.delete(args.storageId);
+  },
+});
+```
+
diff --git a/synced/convex/docs/file-storage/file-metadata.md b/synced/convex/docs/file-storage/file-metadata.md
new file mode 100644
index 0000000..97acc44
--- /dev/null
+++ b/synced/convex/docs/file-storage/file-metadata.md
@@ -0,0 +1,121 @@
+---
+title: "Accessing File Metadata"
+sidebar_label: "Metadata"
+sidebar_position: 5
+---
+
+
+
+Every stored file is reflected as a document in the `"_storage"` system table.
+File metadata of a file can be accessed from
+[queries](/functions/query-functions.mdx) and
+[mutations](/functions/mutation-functions.mdx) via `db.system.get` and
+`db.system.query`:
+
+
+```ts
+import { v } from "convex/values";
+import { query } from "./_generated/server";
+
+// @snippet start getMetadata
+export const getMetadata = query({
+  args: {
+    storageId: v.id("_storage"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.storageId);
+  },
+});
+
+export const listAllFiles = query({
+  handler: async (ctx) => {
+    // You can use .paginate() as well
+    return await ctx.db.system.query("_storage").collect();
+  },
+});
+// @snippet end getMetadata
+```
+
+```ts
+import { v } from "convex/values";
+import { query } from "./_generated/server";
+
+// @snippet start getMetadata
+export const getMetadata = query({
+  args: {
+    storageId: v.id("_storage"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.storageId);
+  },
+});
+
+export const listAllFiles = query({
+  handler: async (ctx) => {
+    // You can use .paginate() as well
+    return await ctx.db.system.query("_storage").collect();
+  },
+});
+// @snippet end getMetadata
+```
+
+
+This is an example of the returned document:
+
+```json
+{
+  "_creationTime": 1700697415295.742,
+  "_id": "3k7ty84apk2zy00ay4st1n5p9kh7tf8",
+  "contentType": "image/jpeg",
+  "sha256": "cb58f529b2ed5a1b8b6681d91126265e919ac61fff6a367b8341c0f46b06a5bd",
+  "size": 125338
+}
+```
+
+The returned document has the following fields:
+
+- `sha256`: a base16 encoded sha256 checksum of the file contents
+- `size`: the size of the file in bytes
+- `contentType`: the `ContentType` of the file if it was provided on upload
+
+You can check the metadata manually on your
+[dashboard](/dashboard/deployments/files.md).
+
+## Accessing metadata from actions (deprecated)
+
+Alternatively, a
+[`storage.getMetadata()`](/api/interfaces/server.StorageReader#getmetadata)
+function is available to access individual file metadata from
+[actions](/functions/actions.mdx) and
+[HTTP actions](/functions/http-actions.mdx):
+
+
+```ts
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const getMetadata = action({
+  args: { storageId: v.id("_storage") },
+  handler: async (ctx, args) => {
+    return await ctx.storage.getMetadata(args.storageId);
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const getMetadata = action({
+  args: { storageId: v.id("_storage") },
+  handler: async (ctx, args) => {
+    return await ctx.storage.getMetadata(args.storageId);
+  },
+});
+```
+
+
+Note that
+[`storage.getMetadata()`](/api/interfaces/server.StorageReader#getmetadata)
+returns a [`FileMetadata`](/api/modules/server#filemetadata), which has a
+slightly different shape than the result from `db.system.get`.
diff --git a/synced/convex/docs/file-storage/serve-files.md b/synced/convex/docs/file-storage/serve-files.md
new file mode 100644
index 0000000..76a6f7b
--- /dev/null
+++ b/synced/convex/docs/file-storage/serve-files.md
@@ -0,0 +1,623 @@
+---
+title: "Serving Files"
+sidebar_label: "Serve"
+sidebar_position: 3
+---
+
+
+
+
+
+
+
+Files stored in Convex can be served to your users by generating a URL pointing
+to a given file.
+
+## Generating file URLs in queries
+
+The simplest way to serve files is to return URLs along with other data required
+by your app from [queries](/functions/query-functions.mdx) and
+[mutations](/functions/mutation-functions.mdx).
+
+A file URL can be generated from a storage ID by the
+[`storage.getUrl`](/api/interfaces/server.StorageReader#geturl) function of the
+[`QueryCtx`](/api/interfaces/server.GenericQueryCtx),
+[`MutationCtx`](/api/interfaces/server.GenericMutationCtx), or
+[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object:
+
+
+```ts
+import { v } from "convex/values";
+// @snippet start query
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => ({
+        ...message,
+        // If the message is an "image" its `body` is an `Id<"_storage">`
+        ...(message.format === "image"
+          ? { url: await ctx.storage.getUrl(message.body) }
+          : {}),
+      })),
+    );
+  },
+});
+// @snippet end query
+
+// @snippet start generateUploadUrl
+import { mutation } from "./_generated/server";
+
+export const generateUploadUrl = mutation({
+  handler: async (ctx) => {
+    return await ctx.storage.generateUploadUrl();
+  },
+});
+// @snippet end generateUploadUrl
+
+// @snippet start saveStorageId
+export const sendImage = mutation({
+  args: { storageId: v.id("_storage"), author: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("messages", {
+      body: args.storageId,
+      author: args.author,
+      format: "image",
+    });
+  },
+});
+// @snippet end saveStorageId
+
+export const sendMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author, format: "text" });
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+// @snippet start query
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => ({
+        ...message,
+        // If the message is an "image" its `body` is an `Id<"_storage">`
+        ...(message.format === "image"
+          ? { url: await ctx.storage.getUrl(message.body) }
+          : {}),
+      })),
+    );
+  },
+});
+// @snippet end query
+
+// @snippet start generateUploadUrl
+import { mutation } from "./_generated/server";
+
+export const generateUploadUrl = mutation({
+  handler: async (ctx) => {
+    return await ctx.storage.generateUploadUrl();
+  },
+});
+// @snippet end generateUploadUrl
+
+// @snippet start saveStorageId
+export const sendImage = mutation({
+  args: { storageId: v.id("_storage"), author: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("messages", {
+      body: args.storageId,
+      author: args.author,
+      format: "image",
+    });
+  },
+});
+// @snippet end saveStorageId
+
+export const sendMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author, format: "text" });
+  },
+});
+```
+
+
+File URLs can be used in `img` elements to render images:
+
+
+```tsx
+import { FormEvent, useRef, useState } from "react";
+import { useMutation, useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function App() {
+  const messages = useQuery(api.messages.list) || [];
+
+  const [newMessageText, setNewMessageText] = useState("");
+  const sendMessage = useMutation(api.messages.sendMessage);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendMessage(event: FormEvent) {
+    event.preventDefault();
+    if (newMessageText) {
+      await sendMessage({ body: newMessageText, author: name });
+    }
+    setNewMessageText("");
+  }
+
+  // @snippet start handlers
+  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);
+  const sendImage = useMutation(api.messages.sendImage);
+
+  const imageInput = useRef<HTMLInputElement>(null);
+  const [selectedImage, setSelectedImage] = useState<File | null>(null);
+
+  async function handleSendImage(event: FormEvent) {
+    event.preventDefault();
+
+    // Step 1: Get a short-lived upload URL
+    const postUrl = await generateUploadUrl();
+    // Step 2: POST the file to the URL
+    const result = await fetch(postUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage!.type },
+      body: selectedImage,
+    });
+    const json = await result.json();
+    if (!result.ok) {
+      throw new Error(`Upload failed: ${JSON.stringify(json)}`);
+    }
+    const { storageId } = json;
+    // Step 3: Save the newly allocated storage id to the database
+    await sendImage({ storageId, author: name });
+
+    setSelectedImage(null);
+    imageInput.current!.value = "";
+  }
+  // @snippet end handlers
+
+  return (
+    <main>
+      <h1>Convex Chat</h1>
+      <p className="badge">
+        <span>{name}</span>
+      </p>
+      <ul>
+        {messages.map((message) => (
+          <li key={message._id}>
+            <span>{message.author}:</span>
+            {/* @snippet start useImageComponent */}
+            {message.format === "image" ? (
+              <Image message={message} />
+            ) : (
+              <span>{message.body}</span>
+            )}
+            {/* @snippet end useImageComponent */}
+            <span>{new Date(message._creationTime).toLocaleTimeString()}</span>
+          </li>
+        ))}
+      </ul>
+      <form onSubmit={handleSendMessage}>
+        <input
+          value={newMessageText}
+          onChange={(event) => setNewMessageText(event.target.value)}
+          placeholder="Write a message…"
+        />
+        <input type="submit" value="Send" disabled={!newMessageText} />
+      </form>
+      {/* @snippet start formInput */}
+      <form onSubmit={handleSendImage}>
+        <input
+          type="file"
+          accept="image/*"
+          ref={imageInput}
+          onChange={(event) => setSelectedImage(event.target.files![0])}
+          className="ms-2 btn btn-primary"
+          disabled={selectedImage !== null}
+        />
+        <input
+          type="submit"
+          value="Send Image"
+          disabled={selectedImage === null}
+        />
+      </form>
+      {/* @snippet end formInput */}
+    </main>
+  );
+}
+
+// @snippet start imageComponent
+function Image({ message }: { message: { url: string } }) {
+  return <img src={message.url} height="300px" width="auto" />;
+}
+// @snippet end imageComponent
+```
+
+```jsx
+// @snippet start fileUpload
+import { useRef, useState } from "react";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function App() {
+  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);
+  const sendImage = useMutation(api.messages.sendImage);
+
+  const imageInput = useRef(null);
+  const [selectedImage, setSelectedImage] = useState(null);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendImage(event) {
+    event.preventDefault();
+
+    // Step 1: Get a short-lived upload URL
+    const postUrl = await generateUploadUrl();
+    // Step 2: POST the file to the URL
+    const result = await fetch(postUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage.type },
+      body: selectedImage,
+    });
+    const { storageId } = await result.json();
+    // Step 3: Save the newly allocated storage id to the database
+    await sendImage({ storageId, author: name });
+
+    setSelectedImage(null);
+    imageInput.current.value = "";
+  }
+  return (
+    <form onSubmit={handleSendImage}>
+      <input
+        type="file"
+        accept="image/*"
+        ref={imageInput}
+        onChange={(event) => setSelectedImage(event.target.files[0])}
+        disabled={selectedImage !== null}
+      />
+      <input
+        type="submit"
+        value="Send Image"
+        disabled={selectedImage === null}
+      />
+    </form>
+  );
+}
+// @snippet end fileUpload
+
+// @snippet start imageComponent
+function Image({ message }) {
+  return <img src={message.url} height="300px" width="auto" />;
+}
+// @snippet end imageComponent
+```
+
+
+In your query you can control who gets access to a file when the URL is
+generated. If you need to control access when the file is _served_, you can
+define your own file serving HTTP actions instead.
+
+## Serving files from HTTP actions
+
+You can serve files directly from [HTTP actions](/functions/http-actions.mdx).
+An HTTP action will need to take some parameter(s) that can be mapped to a
+storage ID, or a storage ID itself.
+
+This enables access control at the time the file is served, such as when an
+image is displayed on a website. But note that the HTTP actions response size is
+[currently limited](/functions/http-actions.mdx#limits) to 20MB. For larger
+files you need to use file URLs as described
+[above](#generating-file-urls-in-queries).
+
+A file [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object
+can be generated from a storage ID by the
+[`storage.get`](/api/interfaces/server.StorageActionWriter#get) function of the
+[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object, which can be
+returned in a `Response`:
+
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+
+The URL of such an action can be used directly in `img` elements to render
+images:
+
+
+```tsx
+import { FormEvent, useRef, useState } from "react";
+import { useMutation, useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function App() {
+  const messages = useQuery(api.messages.list) || [];
+
+  const [newMessageText, setNewMessageText] = useState("");
+  const sendMessage = useMutation(api.messages.send);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendMessage(event: FormEvent) {
+    event.preventDefault();
+    if (newMessageText) {
+      await sendMessage({ body: newMessageText, author: name });
+    }
+    setNewMessageText("");
+  }
+
+  // @snippet start sendImage
+  const imageInput = useRef<HTMLInputElement>(null);
+  const [selectedImage, setSelectedImage] = useState<File | null>(null);
+
+  async function handleSendImage(event: FormEvent) {
+    event.preventDefault();
+
+    // e.g. https://happy-animal-123.convex.site/sendImage?author=User+123
+    const sendImageUrl = new URL(`${convexSiteUrl}/sendImage`);
+    sendImageUrl.searchParams.set("author", name);
+
+    await fetch(sendImageUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage!.type },
+      body: selectedImage,
+    });
+
+    setSelectedImage(null);
+    imageInput.current!.value = "";
+  }
+  // @snippet end sendImage
+
+  return (
+    <main>
+      <h1>Convex Chat</h1>
+      <p className="badge">
+        <span>{name}</span>
+      </p>
+      <ul>
+        {messages.map((message) => (
+          <li key={message._id}>
+            <span>{message.author}:</span>
+            {message.format === "image" ? (
+              <Image storageId={message.body} />
+            ) : (
+              <span>{message.body}</span>
+            )}
+            <span>{new Date(message._creationTime).toLocaleTimeString()}</span>
+          </li>
+        ))}
+      </ul>
+      <form onSubmit={handleSendMessage}>
+        <input
+          value={newMessageText}
+          onChange={(event) => setNewMessageText(event.target.value)}
+          placeholder="Write a message…"
+        />
+        <input type="submit" value="Send" disabled={!newMessageText} />
+      </form>
+      {/* @snippet start imageForm */}
+      <form onSubmit={handleSendImage}>
+        <input
+          type="file"
+          accept="image/*"
+          ref={imageInput}
+          onChange={(event) => setSelectedImage(event.target.files![0])}
+          disabled={selectedImage !== null}
+        />
+        <input
+          type="submit"
+          value="Send Image"
+          disabled={selectedImage === null}
+        />
+      </form>
+      {/* @snippet end imageForm */}
+    </main>
+  );
+}
+
+// @snippet start getImage
+const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;
+
+function Image({ storageId }: { storageId: string }) {
+  // e.g. https://happy-animal-123.convex.site/getImage?storageId=456
+  const getImageUrl = new URL(`${convexSiteUrl}/getImage`);
+  getImageUrl.searchParams.set("storageId", storageId);
+
+  return <img src={getImageUrl.href} height="300px" width="auto" />;
+}
+// @snippet end getImage
+```
+
+```jsx
+// @snippet start getImage
+const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;
+
+function Image({ storageId }) {
+  // e.g. https://happy-animal-123.convex.site/getImage?storageId=456
+  const getImageUrl = new URL(`${convexSiteUrl}/getImage`);
+  getImageUrl.searchParams.set("storageId", storageId);
+
+  return <img src={getImageUrl.href} height="300px" width="auto" />;
+}
+// @snippet end getImage
+```
+
diff --git a/synced/convex/docs/file-storage/store-files.md b/synced/convex/docs/file-storage/store-files.md
new file mode 100644
index 0000000..51a3d7d
--- /dev/null
+++ b/synced/convex/docs/file-storage/store-files.md
@@ -0,0 +1,115 @@
+---
+title: "Storing Generated Files"
+sidebar_label: "Store"
+sidebar_position: 2
+---
+
+
+
+Files can be uploaded to Convex from a client and stored directly, see
+[Upload](/file-storage/upload-files.mdx).
+
+Alternatively files can also be stored after they've been fetched or generated
+in [actions](/functions/actions.mdx) and
+[HTTP actions](/functions/http-actions.mdx). For example you might call a
+third-party API to generate an image based on a user prompt and then store that
+image in Convex.
+
+**Example:**
+[Dall-E Storage & Action](https://github.com/get-convex/convex-demos/tree/main/dall-e-storage-action)
+
+## Storing files in actions
+
+Storing files in actions is similar to
+[uploading a file via an HTTP action](/file-storage/upload-files.mdx#uploading-files-via-an-http-action).
+
+The action takes these steps:
+
+1. Fetch or generate an image.
+2. Store the image using
+   [`storage.store()`](/api/interfaces/server.StorageActionWriter#store) and
+   receive a storage ID.
+3. Save the storage ID into your data model via a mutation.
+
+Storage IDs correspond to documents in the `"_storage"` system table (see
+[Metadata](/file-storage/file-metadata.mdx)), so they can be validated using the
+`v.id("_storage")` validator and typed as `Id<"_storage">` in TypeScript.
+
+
+```ts
+import { action, internalMutation, query } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+import { Id } from "./_generated/dataModel";
+
+export const generateAndStore = action({
+  args: { prompt: v.string() },
+  handler: async (ctx, args) => {
+    // Not shown: generate imageUrl from `prompt`
+    const imageUrl = "https://....";
+
+    // Download the image
+    const response = await fetch(imageUrl);
+    const image = await response.blob();
+
+    // Store the image in Convex
+    const storageId: Id<"_storage"> = await ctx.storage.store(image);
+
+    // Write `storageId` to a document
+    await ctx.runMutation(internal.images.storeResult, {
+      storageId,
+      prompt: args.prompt,
+    });
+  },
+});
+
+export const storeResult = internalMutation({
+  args: {
+    storageId: v.id("_storage"),
+    prompt: v.string(),
+  },
+  handler: async (ctx, args) => {
+    const { storageId, prompt } = args;
+    await ctx.db.insert("images", { storageId, prompt });
+  },
+});
+```
+
+```js
+import { action, internalMutation, query } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const generateAndStore = action({
+  args: { prompt: v.string() },
+  handler: async (ctx, args) => {
+    // Not shown: generate imageUrl from `prompt`
+    const imageUrl = "https://....";
+
+    // Download the image
+    const response = await fetch(imageUrl);
+    const image = await response.blob();
+
+    // Store the image in Convex
+    const storageId = await ctx.storage.store(image);
+
+    // Write `storageId` to a document
+    await ctx.runMutation(internal.images.storeResult, {
+      storageId,
+      prompt: args.prompt,
+    });
+  },
+});
+
+export const storeResult = internalMutation({
+  args: {
+    storageId: v.id("_storage"),
+    prompt: v.string(),
+  },
+  handler: async (ctx, args) => {
+    const { storageId, prompt } = args;
+    await ctx.db.insert("images", { storageId, prompt });
+  },
+});
+```
+
diff --git a/synced/convex/docs/file-storage/upload-files.md b/synced/convex/docs/file-storage/upload-files.md
new file mode 100644
index 0000000..0bd284d
--- /dev/null
+++ b/synced/convex/docs/file-storage/upload-files.md
@@ -0,0 +1,875 @@
+---
+title: "Uploading and Storing Files"
+sidebar_label: "Upload"
+sidebar_position: 1
+---
+
+
+
+
+
+
+
+Upload files to Convex by
+[generated upload urls](#uploading-files-via-upload-urls), or via an
+[custom HTTP Action](#uploading-files-via-an-http-action).
+
+## Uploading files via upload URLs
+
+Arbitrarily large files can be uploaded directly to your backend using a
+generated upload URL. This requires the client to make 3 requests:
+
+1. Generate an upload URL using a mutation that calls
+   [`storage.generateUploadUrl()`](/api/interfaces/server.StorageWriter#generateuploadurl).
+2. Send a POST request with the file contents to the upload URL and receive a
+   storage ID.
+3. Save the storage ID into your data model via another mutation.
+
+In the first mutation that generates the upload URL you can control who can
+upload files to your Convex storage.
+
+**Example**:
+[File Storage with Queries and Mutations](https://github.com/get-convex/convex-demos/tree/main/file-storage)
+
+### Calling the upload APIs from a web page
+
+Here's an example of uploading an image via a form submission handler to an
+upload URL generated by a mutation:
+
+
+```tsx
+// This file is not used in the demo app.
+// It showcases only the code related to file uploading.
+
+// @snippet start fileUpload
+import { FormEvent, useRef, useState } from "react";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function App() {
+  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);
+  const sendImage = useMutation(api.messages.sendImage);
+
+  const imageInput = useRef<HTMLInputElement>(null);
+  const [selectedImage, setSelectedImage] = useState<File | null>(null);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendImage(event: FormEvent) {
+    event.preventDefault();
+
+    // Step 1: Get a short-lived upload URL
+    const postUrl = await generateUploadUrl();
+    // Step 2: POST the file to the URL
+    const result = await fetch(postUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage!.type },
+      body: selectedImage,
+    });
+    const { storageId } = await result.json();
+    // Step 3: Save the newly allocated storage id to the database
+    await sendImage({ storageId, author: name });
+
+    setSelectedImage(null);
+    imageInput.current!.value = "";
+  }
+  return (
+    <form onSubmit={handleSendImage}>
+      <input
+        type="file"
+        accept="image/*"
+        ref={imageInput}
+        onChange={(event) => setSelectedImage(event.target.files![0])}
+        disabled={selectedImage !== null}
+      />
+      <input
+        type="submit"
+        value="Send Image"
+        disabled={selectedImage === null}
+      />
+    </form>
+  );
+}
+// @snippet end fileUpload
+```
+
+```jsx
+// @snippet start fileUpload
+import { useRef, useState } from "react";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function App() {
+  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);
+  const sendImage = useMutation(api.messages.sendImage);
+
+  const imageInput = useRef(null);
+  const [selectedImage, setSelectedImage] = useState(null);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendImage(event) {
+    event.preventDefault();
+
+    // Step 1: Get a short-lived upload URL
+    const postUrl = await generateUploadUrl();
+    // Step 2: POST the file to the URL
+    const result = await fetch(postUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage.type },
+      body: selectedImage,
+    });
+    const { storageId } = await result.json();
+    // Step 3: Save the newly allocated storage id to the database
+    await sendImage({ storageId, author: name });
+
+    setSelectedImage(null);
+    imageInput.current.value = "";
+  }
+  return (
+    <form onSubmit={handleSendImage}>
+      <input
+        type="file"
+        accept="image/*"
+        ref={imageInput}
+        onChange={(event) => setSelectedImage(event.target.files[0])}
+        disabled={selectedImage !== null}
+      />
+      <input
+        type="submit"
+        value="Send Image"
+        disabled={selectedImage === null}
+      />
+    </form>
+  );
+}
+// @snippet end fileUpload
+
+// @snippet start imageComponent
+function Image({ message }) {
+  return <img src={message.url} height="300px" width="auto" />;
+}
+// @snippet end imageComponent
+```
+
+
+### Generating the upload URL
+
+An upload URL can be generated by the
+[`storage.generateUploadUrl`](/api/interfaces/server.StorageWriter#generateuploadurl)
+function of the [`MutationCtx`](/api/interfaces/server.GenericMutationCtx)
+object:
+
+
+```ts
+import { v } from "convex/values";
+// @snippet start query
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => ({
+        ...message,
+        // If the message is an "image" its `body` is an `Id<"_storage">`
+        ...(message.format === "image"
+          ? { url: await ctx.storage.getUrl(message.body) }
+          : {}),
+      })),
+    );
+  },
+});
+// @snippet end query
+
+// @snippet start generateUploadUrl
+import { mutation } from "./_generated/server";
+
+export const generateUploadUrl = mutation({
+  handler: async (ctx) => {
+    return await ctx.storage.generateUploadUrl();
+  },
+});
+// @snippet end generateUploadUrl
+
+// @snippet start saveStorageId
+export const sendImage = mutation({
+  args: { storageId: v.id("_storage"), author: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("messages", {
+      body: args.storageId,
+      author: args.author,
+      format: "image",
+    });
+  },
+});
+// @snippet end saveStorageId
+
+export const sendMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author, format: "text" });
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+// @snippet start query
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => ({
+        ...message,
+        // If the message is an "image" its `body` is an `Id<"_storage">`
+        ...(message.format === "image"
+          ? { url: await ctx.storage.getUrl(message.body) }
+          : {}),
+      })),
+    );
+  },
+});
+// @snippet end query
+
+// @snippet start generateUploadUrl
+import { mutation } from "./_generated/server";
+
+export const generateUploadUrl = mutation({
+  handler: async (ctx) => {
+    return await ctx.storage.generateUploadUrl();
+  },
+});
+// @snippet end generateUploadUrl
+
+// @snippet start saveStorageId
+export const sendImage = mutation({
+  args: { storageId: v.id("_storage"), author: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("messages", {
+      body: args.storageId,
+      author: args.author,
+      format: "image",
+    });
+  },
+});
+// @snippet end saveStorageId
+
+export const sendMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author, format: "text" });
+  },
+});
+```
+
+
+This mutation can control who is allowed to upload files.
+
+The upload URL expires in 1 hour and so should be fetched shortly before the
+upload is made.
+
+### Writing the new storage ID to the database
+
+Since the storage ID is returned to the client it is likely you will want to
+persist it in the database via another mutation:
+
+
+```ts
+import { v } from "convex/values";
+// @snippet start query
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => ({
+        ...message,
+        // If the message is an "image" its `body` is an `Id<"_storage">`
+        ...(message.format === "image"
+          ? { url: await ctx.storage.getUrl(message.body) }
+          : {}),
+      })),
+    );
+  },
+});
+// @snippet end query
+
+// @snippet start generateUploadUrl
+import { mutation } from "./_generated/server";
+
+export const generateUploadUrl = mutation({
+  handler: async (ctx) => {
+    return await ctx.storage.generateUploadUrl();
+  },
+});
+// @snippet end generateUploadUrl
+
+// @snippet start saveStorageId
+export const sendImage = mutation({
+  args: { storageId: v.id("_storage"), author: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("messages", {
+      body: args.storageId,
+      author: args.author,
+      format: "image",
+    });
+  },
+});
+// @snippet end saveStorageId
+
+export const sendMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author, format: "text" });
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+// @snippet start query
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  handler: async (ctx) => {
+    const messages = await ctx.db.query("messages").collect();
+    return Promise.all(
+      messages.map(async (message) => ({
+        ...message,
+        // If the message is an "image" its `body` is an `Id<"_storage">`
+        ...(message.format === "image"
+          ? { url: await ctx.storage.getUrl(message.body) }
+          : {}),
+      })),
+    );
+  },
+});
+// @snippet end query
+
+// @snippet start generateUploadUrl
+import { mutation } from "./_generated/server";
+
+export const generateUploadUrl = mutation({
+  handler: async (ctx) => {
+    return await ctx.storage.generateUploadUrl();
+  },
+});
+// @snippet end generateUploadUrl
+
+// @snippet start saveStorageId
+export const sendImage = mutation({
+  args: { storageId: v.id("_storage"), author: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("messages", {
+      body: args.storageId,
+      author: args.author,
+      format: "image",
+    });
+  },
+});
+// @snippet end saveStorageId
+
+export const sendMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author, format: "text" });
+  },
+});
+```
+
+
+### Limits
+
+The file size is not limited, but upload POST request has a 2 minute timeout.
+
+## Uploading files via an HTTP action
+
+The file upload process can be more tightly controlled by leveraging
+[HTTP action](/functions/http-actions.mdx)s, performing the whole upload flow
+using a single request, but requiring correct CORS headers configuration.
+
+The custom upload HTTP action can control who can upload files to your Convex
+storage. But note that the HTTP action request size is
+[currently limited](/functions/http-actions.mdx#limits) to 20MB. For larger
+files you need to use upload URLs as described
+[above](#uploading-files-via-upload-urls).
+
+**Example:**
+[File Storage with HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/file-storage-with-http)
+
+### Calling the upload HTTP action from a web page
+
+Here's an example of uploading an image via a form submission handler to the
+`sendImage` HTTP action defined next.
+
+The highlighted lines make the actual request to the HTTP action:
+
+
+```tsx
+// This file is not used in the demo app.
+// It showcases only the code related to file uploading.
+
+// @snippet start httpFileUpload
+import { FormEvent, useRef, useState } from "react";
+
+const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;
+
+export default function App() {
+  const imageInput = useRef<HTMLInputElement>(null);
+  const [selectedImage, setSelectedImage] = useState<File | null>(null);
+
+  async function handleSendImage(event: FormEvent) {
+    event.preventDefault();
+
+    // e.g. https://happy-animal-123.convex.site/sendImage?author=User+123
+    const sendImageUrl = new URL(`${convexSiteUrl}/sendImage`);
+    sendImageUrl.searchParams.set("author", "Jack Smith");
+
+    await fetch(sendImageUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage!.type },
+      body: selectedImage,
+    });
+
+    setSelectedImage(null);
+    imageInput.current!.value = "";
+  }
+  return (
+    <form onSubmit={handleSendImage}>
+      <input
+        type="file"
+        accept="image/*"
+        ref={imageInput}
+        onChange={(event) => setSelectedImage(event.target.files![0])}
+        disabled={selectedImage !== null}
+      />
+      <input
+        type="submit"
+        value="Send Image"
+        disabled={selectedImage === null}
+      />
+    </form>
+  );
+}
+// @snippet end httpFileUpload
+```
+
+```jsx
+// @snippet start httpFileUpload
+import { useRef, useState } from "react";
+
+const convexSiteUrl = import.meta.env.VITE_CONVEX_SITE_URL;
+
+export default function App() {
+  const imageInput = useRef(null);
+  const [selectedImage, setSelectedImage] = useState(null);
+
+  async function handleSendImage(event) {
+    event.preventDefault();
+
+    // e.g. https://happy-animal-123.convex.site/sendImage?author=User+123
+    const sendImageUrl = new URL(`${convexSiteUrl}/sendImage`);
+    sendImageUrl.searchParams.set("author", "Jack Smith");
+
+    await fetch(sendImageUrl, {
+      method: "POST",
+      headers: { "Content-Type": selectedImage.type },
+      body: selectedImage,
+    });
+
+    setSelectedImage(null);
+    imageInput.current.value = "";
+  }
+  return (
+    <form onSubmit={handleSendImage}>
+      <input
+        type="file"
+        accept="image/*"
+        ref={imageInput}
+        onChange={(event) => setSelectedImage(event.target.files[0])}
+        disabled={selectedImage !== null}
+      />
+      <input
+        type="submit"
+        value="Send Image"
+        disabled={selectedImage === null}
+      />
+    </form>
+  );
+}
+// @snippet end httpFileUpload
+```
+
+
+### Defining the upload HTTP action
+
+A file sent in the HTTP request body can be stored using the
+[`storage.store`](/api/interfaces/server.StorageActionWriter#store) function of
+the [`ActionCtx`](/api/interfaces/server.GenericActionCtx) object. This function
+returns an `Id<"_storage">` of the stored file.
+
+From the HTTP action you can call a mutation to write the storage ID to a
+document in your database.
+
+To confirm success back to your hosted website, you will need to set the right
+[CORS headers](/functions/http-actions.mdx#cors):
+
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+
+You also need to handle the pre-flight `OPTIONS` request:
+
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
diff --git a/synced/convex/docs/functions.md b/synced/convex/docs/functions.md
new file mode 100644
index 0000000..aaf719f
--- /dev/null
+++ b/synced/convex/docs/functions.md
@@ -0,0 +1,34 @@
+---
+title: "Functions"
+description: "Write functions to define your server behavior."
+hide_table_of_contents: true
+pagination_prev: tutorial/index
+---
+
+Functions run on the backend and are written in JavaScript (or TypeScript). They
+are automatically available as APIs accessed through
+[client libraries](/client/react.mdx). Everything you do in the Convex backend
+starts from functions.
+
+There are three types of functions:
+
+- [Queries](/functions/query-functions.mdx) read data from your Convex database
+  and are automatically cached and subscribable (realtime, reactive).
+- [Mutations](/functions/mutation-functions.mdx) write data to the database and
+  run as a transaction.
+- [Actions](/functions/actions.mdx) can call OpenAI, Stripe, Twilio, or any
+  other service or API you need to make your app work.
+
+You can also build [HTTP actions](/functions/http-actions.mdx) when you want to
+call your functions from a webhook or a custom client.
+
+Here's an overview of the three different types of Convex functions and what
+they can do:
+
+|                            | Queries | Mutations | Actions |
+| -------------------------- | ------- | --------- | ------- |
+| Database access            | Yes     | Yes       | No      |
+| Transactional              | Yes     | Yes       | No      |
+| Cached                     | Yes     | No        | No      |
+| Real-time Updates          | Yes     | No        | No      |
+| External API Calls (fetch) | No      | No        | Yes     |
diff --git a/synced/convex/docs/functions/actions.md b/synced/convex/docs/functions/actions.md
new file mode 100644
index 0000000..0bb0e11
--- /dev/null
+++ b/synced/convex/docs/functions/actions.md
@@ -0,0 +1,692 @@
+---
+title: Actions
+sidebar_position: 30
+---
+
+
+
+
+
+
+
+
+
+
+
+
+
+Actions can call third party services to do things such as processing a payment
+with [Stripe](https://stripe.com). They can be run in Convex's JavaScript
+environment or in Node.js. They can interact with the database indirectly by
+calling [queries](/functions/query-functions.mdx) and
+[mutations](/functions/mutation-functions.mdx).
+
+**Example:**
+[GIPHY Action](https://github.com/get-convex/convex-demos/tree/main/giphy-action)
+
+## Action names
+
+Actions follow the same naming rules as queries, see
+[Query names](/functions/query-functions.mdx#query-names).
+
+## The `action` constructor
+
+To declare an action in Convex you use the action constructor function. Pass it
+an object with a `handler` function, which performs the action:
+
+
+```ts
+import { action } from "./_generated/server";
+
+export const doSomething = action({
+  handler: () => {
+    // implementation goes here
+
+    // optionally return a value
+    return "success";
+  },
+});
+```
+
+```ts
+import { action } from "./_generated/server";
+
+export const doSomething = action({
+  handler: () => {
+    // implementation goes here
+
+    // optionally return a value
+    return "success";
+  },
+});
+```
+
+
+Unlike a query, an action can but does not have to return a value.
+
+### Action arguments and responses
+
+Action arguments and responses follow the same rules as
+[mutations](/functions/mutation-functions.mdx#mutation-arguments):
+
+
+```ts
+import { action } from "./_generated/server";
+import { v } from "convex/values";
+
+export const doSomething = action({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    // do something with `args.a` and `args.b`
+
+    // optionally return a value
+    return "success";
+  },
+});
+```
+
+```ts
+import { action } from "./_generated/server";
+import { v } from "convex/values";
+
+export const doSomething = action({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    // do something with `args.a` and `args.b`
+
+    // optionally return a value
+    return "success";
+  },
+});
+```
+
+
+The first argument to the handler function is reserved for the action context.
+
+### Action context
+
+The `action` constructor enables interacting with the database, and other Convex
+features by passing an [ActionCtx](/api/interfaces/server.GenericActionCtx)
+object to the handler function as the first argument:
+
+
+```ts
+import { action } from "./_generated/server";
+import { v } from "convex/values";
+
+export const doSomething = action({
+  args: { a: v.number(), b: v.number() },
+  handler: (ctx, args) => {
+    // do something with `ctx`
+  },
+});
+```
+
+```ts
+import { action } from "./_generated/server";
+import { v } from "convex/values";
+
+export const doSomething = action({
+  args: { a: v.number(), b: v.number() },
+  handler: (ctx, args) => {
+    // do something with `ctx`
+  },
+});
+```
+
+
+Which part of that action context is used depends on what your action needs to
+do:
+
+- To read data from the database use the `runQuery` field, and call a query that
+  performs the read:
+
+  
+```ts
+// @snippet start action
+import { action, internalQuery } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const doSomething = action({
+  args: { a: v.number() },
+  handler: async (ctx, args) => {
+    const data = await ctx.runQuery(internal.myFunctions.readData, {
+      a: args.a,
+    });
+    // do something with `data`
+  },
+});
+
+export const readData = internalQuery({
+  args: { a: v.number() },
+  handler: async (ctx, args) => {
+    // read from `ctx.db` here
+  },
+});
+// @snippet end action
+
+// Used by client or internal call examples
+import { mutation, query } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+import { internalAction } from "./_generated/server";
+
+export const sum = query({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    return args.a + args.b;
+  },
+});
+
+export const getSomething = query({
+  args: {},
+  handler: () => {
+    return null;
+  },
+});
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args): void => {
+    // do something with `a` and `b`
+  },
+});
+
+export const getSomethingPaginated = query({
+  args: {
+    paginationOpts: paginationOptsValidator,
+  },
+  handler: (ctx, args) => {
+    return ctx.db.query("foods").paginate(args.paginationOpts);
+  },
+});
+
+export const actionThatCallsAPI = internalAction({
+  args: { taskId: v.id("tasks"), text: v.string() },
+  handler: (_, args): void => {
+    // do something with `taskId` and `text`, like call an API
+    // then run another mutation to store the result
+  },
+});
+```
+
+```ts
+// @snippet start action
+import { action, internalQuery } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const doSomething = action({
+  args: { a: v.number() },
+  handler: async (ctx, args) => {
+    const data = await ctx.runQuery(internal.myFunctions.readData, {
+      a: args.a,
+    });
+    // do something with `data`
+  },
+});
+
+export const readData = internalQuery({
+  args: { a: v.number() },
+  handler: async (ctx, args) => {
+    // read from `ctx.db` here
+  },
+});
+// @snippet end action
+
+// Used by client or internal call examples
+import { mutation, query } from "./_generated/server";
+import { paginationOptsValidator } from "convex/server";
+import { internalAction } from "./_generated/server";
+
+export const sum = query({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    return args.a + args.b;
+  },
+});
+
+export const getSomething = query({
+  args: {},
+  handler: () => {
+    return null;
+  },
+});
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args): void => {
+    // do something with `a` and `b`
+  },
+});
+
+export const getSomethingPaginated = query({
+  args: {
+    paginationOpts: paginationOptsValidator,
+  },
+  handler: (ctx, args) => {
+    return ctx.db.query("foods").paginate(args.paginationOpts);
+  },
+});
+
+export const actionThatCallsAPI = internalAction({
+  args: { taskId: v.id("tasks"), text: v.string() },
+  handler: (_, args): void => {
+    // do something with `taskId` and `text`, like call an API
+    // then run another mutation to store the result
+  },
+});
+```
+
+
+  Here `readData` is an [internal query](/functions/internal-functions.mdx)
+  because we don't want to expose it to the client directly. Actions, mutations
+  and queries can be defined in the same file.
+
+- To write data to the database use the `runMutation` field, and call a mutation
+  that performs the write:
+
+  
+```ts
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+import { internal } from "./_generated/api";
+
+export const doSomething = action({
+  args: { a: v.number() },
+  handler: async (ctx, args) => {
+    const data = await ctx.runMutation(internal.myMutations.writeData, {
+      a: args.a,
+    });
+    // do something else, optionally use `data`
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+import { internal } from "./_generated/api";
+
+export const doSomething = action({
+  args: { a: v.number() },
+  handler: async (ctx, args) => {
+    const data = await ctx.runMutation(internal.myMutations.writeData, {
+      a: args.a,
+    });
+    // do something else, optionally use `data`
+  },
+});
+```
+
+
+  Use an [internal mutation](/functions/internal-functions.mdx) when you want to
+  prevent users from calling the mutation directly.
+
+  As with queries, it's often convenient to define actions and mutations in the
+  same file.
+
+- To generate upload URLs for storing files use the `storage` field. Read on
+  about [File Storage](/file-storage.mdx).
+- To check user authentication use the `auth` field. Auth is propagated
+  automatically when calling queries and mutations from the action. Read on
+  about [Authentication](/auth.mdx).
+- To schedule functions to run in the future, use the `scheduler` field. Read on
+  about [Scheduled Functions](/scheduling/scheduled-functions.mdx).
+- To search a vector index, use the `vectorSearch` field. Read on about
+  [Vector Search](/search/vector-search.mdx).
+
+### Dealing with circular type inference
+
+<Details summary={<>
+Working around the TypeScript error: some action <code>implicitly has
+type 'any' because it does not have a type annotation and is
+referenced directly or indirectly in its own initializer.</code>
+</>}>
+
+When the return value of an action depends on the result of calling
+`ctx.runQuery` or `ctx.runMutation`, TypeScript will complain that it cannot
+infer the return type of the action. This is a minimal example of the issue:
+
+
+```ts
+import { api } from "./_generated/api";
+import { action, query } from "./_generated/server";
+
+// @ts-expect-error Circular type
+// @snippet start tsError
+// TypeScript reports an error on `myAction`
+export const myAction = action({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.runQuery(api.myFunctions.getSomething);
+  },
+});
+
+export const getSomething = query({
+  args: {},
+  handler: () => {
+    return null;
+  },
+});
+// @snippet end tsError
+```
+
+
+To work around this, there are two options:
+
+1. Type the return value of the handler function explicitly:
+   
+```ts
+import { api } from "./_generated/api";
+import { action } from "./_generated/server";
+
+// @snippet start fixed
+export const myAction = action({
+  args: {},
+  handler: async (ctx): Promise<null> => {
+    const result = await ctx.runQuery(api.myFunctions.getSomething);
+    return result;
+  },
+});
+// @snippet end fixed
+```
+
+2. Type the the result of the `ctx.runQuery` or `ctx.runMutation` call
+   explicitly:
+   
+```ts
+import { api } from "./_generated/api";
+import { action } from "./_generated/server";
+
+// @snippet start fixed
+export const myAction = action({
+  args: {},
+  handler: async (ctx) => {
+    const result: null = await ctx.runQuery(api.myFunctions.getSomething);
+    return result;
+  },
+});
+// @snippet end fixed
+```
+
+
+TypeScript will check that the type annotation matches what the called query or
+mutation returns, so you don't lose any type safety.
+
+In this trivial example the return type of the query was `null`. See the
+[TypeScript](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
+page for other types which might be helpful when annotating the result.
+
+</Details>
+
+## Choosing the runtime ("use node")
+
+Actions can run in Convex's custom JavaScript environment or in Node.js.
+
+By default, actions run in Convex's environment. This environment supports
+`fetch`, so actions that simply want to call a third-party API using `fetch` can
+be run in this environment:
+
+
+```ts
+import { action } from "./_generated/server";
+
+export const doSomething = action({
+  args: {},
+  handler: async () => {
+    const data = await fetch("https://api.thirdpartyservice.com");
+    // do something with data
+  },
+});
+```
+
+```ts
+import { action } from "./_generated/server";
+
+export const doSomething = action({
+  args: {},
+  handler: async () => {
+    const data = await fetch("https://api.thirdpartyservice.com");
+    // do something with data
+  },
+});
+```
+
+
+Actions running in Convex's environment are faster compared to Node.js, since
+they don't require extra time to start up before running your action (cold
+starts). They can also be defined in the same file as other Convex functions.
+Like queries and mutations they can import NPM packages, but not all are
+supported.
+
+Actions needing unsupported NPM packages or Node.js APIs can be configured to
+run in Node.js by adding the `"use node"` directive at the top of the file. Note
+that other Convex functions cannot be defined in files with the `"use node";`
+directive.
+
+
+```ts
+"use node";
+
+import { action } from "./_generated/server";
+import SomeNpmPackage from "some-npm-package";
+
+export const doSomething = action({
+  args: {},
+  handler: () => {
+    // do something with SomeNpmPackage
+  },
+});
+```
+
+```ts
+"use node";
+
+import { action } from "./_generated/server";
+import SomeNpmPackage from "some-npm-package";
+
+export const doSomething = action({
+  args: {},
+  handler: () => {
+    // do something with SomeNpmPackage
+  },
+});
+```
+
+
+Learn more about the two [Convex Runtimes](/functions/runtimes.mdx).
+
+## Splitting up action code via helpers
+
+<>
+  {/* Fragment for Prettier */}
+  Just like with [queries](/functions/query-functions.mdx#splitting-up-query-code-via-helpers)
+  and [mutations](/functions/mutation-functions.mdx#splitting-up-mutation-code-via-helpers)
+  you can define and call helper
+  <LanguageSelector verbose /> functions to split up the code in your actions or
+  reuse logic across multiple Convex functions.
+
+But note that the [ActionCtx](/api/interfaces/server.GenericActionCtx) only has
+the `auth` field in common with [QueryCtx](/generated-api/server.md#queryctx)
+and [MutationCtx](/generated-api/server.md#mutationctx).
+
+</>
+
+## Calling actions from clients
+
+To call an action from [React](/client/react.mdx) use the
+[`useAction`](/api/modules/react#useaction) hook along with the generated
+[`api`](/generated-api/api) object.
+
+
+```tsx
+import { useAction } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const performMyAction = useAction(api.myFunctions.doSomething);
+  const handleClick = () => {
+    performMyAction({ a: 1 });
+  };
+  // pass `handleClick` to a button
+  // ...
+}
+```
+
+```tsx
+import { useAction } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const performMyAction = useAction(api.myFunctions.doSomething);
+  const handleClick = () => {
+    performMyAction({ a: 1 });
+  };
+  // pass `handleClick` to a button
+  // ...
+}
+```
+
+
+Unlike
+[mutations](/functions/mutation-functions.mdx#calling-mutations-from-clients),
+actions from a single client are parallelized. Each action will be executed as
+soon as it reaches the server (even if other actions and mutations from the same
+client are running). If your app relies on actions running after other actions
+or mutations, make sure to only trigger the action after the relevant previous
+function completes.
+
+**Note:** In most cases calling an action directly from a client **is an
+anti-pattern**. Instead, have the client call a
+[mutation](/functions/mutation-functions.mdx) which captures the user intent by
+writing into the database and then
+[schedules](/scheduling/scheduled-functions.mdx) an action:
+
+
+```ts
+import { v } from "convex/values";
+import { internal } from "./_generated/api";
+import { internalAction, mutation } from "./_generated/server";
+
+export const mutationThatSchedulesAction = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, { text }) => {
+    const taskId = await ctx.db.insert("tasks", { text });
+    await ctx.scheduler.runAfter(0, internal.myFunctions.actionThatCallsAPI, {
+      taskId,
+      text,
+    });
+  },
+});
+
+export const actionThatCallsAPI = internalAction({
+  args: { taskId: v.id("tasks"), text: v.string() },
+  handler: (_, args): void => {
+    // do something with `taskId` and `text`, like call an API
+    // then run another mutation to store the result
+  },
+});
+```
+
+```ts
+import { v } from "convex/values";
+import { internal } from "./_generated/api";
+import { internalAction, mutation } from "./_generated/server";
+
+export const mutationThatSchedulesAction = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, { text }) => {
+    const taskId = await ctx.db.insert("tasks", { text });
+    await ctx.scheduler.runAfter(0, internal.myFunctions.actionThatCallsAPI, {
+      taskId,
+      text,
+    });
+  },
+});
+
+export const actionThatCallsAPI = internalAction({
+  args: { taskId: v.id("tasks"), text: v.string() },
+  handler: (_, args): void => {
+    // do something with `taskId` and `text`, like call an API
+    // then run another mutation to store the result
+  },
+});
+```
+
+
+This way the mutation can enforce invariants, such as preventing the user from
+executing the same action twice.
+
+## Limits
+
+Actions time out after 10 minutes.
+[Node.js](/functions/runtimes.mdx#nodejs-runtime) and
+[Convex runtime](/functions/runtimes.mdx#default-convex-runtime) have 512MB and
+64MB memory limit respectively. Please [contact us](/production/contact.md) if
+you have a use case that requires configuring higher limits.
+
+Actions can do up to 1000 concurrent operations, such as executing queries,
+mutations or performing fetch requests.
+
+For information on other limits, see [here](/production/state/limits.mdx).
+
+## Error handling
+
+Unlike queries and mutations, actions may have side-effects and therefore can't
+be automatically retried by Convex when errors occur. For example, say your
+action calls Stripe to send a customer invoice. If the HTTP request fails,
+Convex has no way of knowing if the invoice was already sent. Like in normal
+backend code, it is the responsibility of the caller to handle errors raised by
+actions and retry the action call if appropriate.
+
+## Dangling promises
+
+Make sure to await all promises created within an action. Async tasks still
+running when the function returns might or might not complete. In addition,
+since the Node.js execution environment might be reused between action calls,
+dangling promises might result in errors in subsequent action invocations.
+
+## Best practices
+
+### `await ctx.runAction` should only be used for crossing JS runtimes
+
+**Why?** `await ctx.runAction` incurs to overhead of another Convex server
+function. It counts as an extra function call, it allocates its own system
+resources, and while you're awaiting this call the parent action call is frozen
+holding all it's resources. If you pile enough of these calls on top of each
+other, your app may slow down significantly.
+
+**Fix:** The reason this api exists is to let you run code in the
+[Node.js environment](/functions/runtimes.mdx). If you want to call an action
+from another action that's in the same runtime, which is the normal case, the
+best way to do this is to pull the code you want to call into a TypeScript
+[helper function](/understanding/best-practices/best-practices.mdx#use-helper-functions-to-write-shared-code)
+and call the helper instead.
+
+### Avoid `await ctx.runMutation` / `await ctx.runQuery`
+
+```ts
+// ❌
+const foo = await ctx.runQuery(...)
+const bar = await ctx.runQuery(...)
+
+// ✅
+const fooAndBar = await ctx.runQuery(...)
+```
+
+**Why?** Multiple runQuery / runMutations execute in separate transactions and
+aren’t guaranteed to be consistent with each other (e.g. foo and bar could read
+the same document and return two different results), while a single runQuery /
+runMutation will always be consistent. Additionally, you’re paying for multiple
+function calls when you don’t have to.
+
+**Fix:** Make a new internal query / mutation that does both things. Refactoring
+the code for the two functions into helpers will make it easy to create a new
+internal function that does both things while still keeping around the original
+functions. Potentially try and refactor your action code to “batch” all the
+database access.
+
+Caveats: Separate runQuery / runMutation calls are valid when intentionally
+trying to process more data than fits in a single transaction (e.g. running a
+migration, doing a live aggregate).
diff --git a/synced/convex/docs/functions/bundling.md b/synced/convex/docs/functions/bundling.md
new file mode 100644
index 0000000..526ccb9
--- /dev/null
+++ b/synced/convex/docs/functions/bundling.md
@@ -0,0 +1,216 @@
+---
+title: "Bundling"
+sidebar_position: 90
+---
+
+Bundling is the process of gathering, optimizing and transpiling the JS/TS
+source code of [functions](/functions.mdx) and their dependencies. During
+development and when deploying, the code is transformed to a format that Convex
+[runtimes](/functions/runtimes.mdx) can directly and efficiently execute.
+
+Convex currently bundles all dependencies automatically, but for the Node.js
+runtime you can disable bundling certain packages via the
+[external packages](#external-packages) config.
+
+## Bundling for Convex
+
+When you push code either via `npx convex dev` or `npx convex deploy`, the
+Convex CLI uses [esbuild](https://esbuild.github.io/) to traverse your `convex/`
+folder and bundle your functions and all of their used dependencies into a
+source code bundle. This bundle is then sent to the server.
+
+Thanks to bundling you can write your code using both modern ECMAScript Modules
+(ESM) or the older CommonJS (CJS) syntax.
+
+<Details summary="ESM vs. CJS">
+    ESM
+    - Is the standard for browser Javascript
+    - Uses static imports via the `import` and `export` **keywords** (not functions)
+    at the global scope
+    - Also supports dynamic imports via the asynchronous `import` function
+
+    CJS
+    - Was previously the standard module system for Node.js
+    - Relies on dynamic imports via the `require` and asynchronous `import`
+    functions for fetching external modules
+    - Uses the `module.exports` object for exports
+
+</Details>
+
+## Bundling limitations
+
+The nature of bundling comes with a few limitations.
+
+### Code size limits
+
+The total size of your bundled function code in your `convex/` folder is
+**limited to 32MiB (~33.55MB)**. Other platform limits can be found
+[here](/production/state/limits.mdx).
+
+While this limit in itself is quite high for just source code, certain
+dependencies can quickly make your bundle size cross over this limit,
+particularly if they are not effectively
+[tree-shakeable](https://webpack.js.org/guides/tree-shaking/) (such as
+[aws-sdk](https://www.npmjs.com/package/aws-sdk) or
+[snowflake-sdk](https://www.npmjs.com/package/snowflake-sdk))
+
+You can follow these steps to debug bundle size:
+
+<StepByStep>
+  <Step title="Make sure you're using the most recent version of convex">
+    ```sh
+    npm install convex@latest
+    ```
+  </Step>
+  <Step title="Generate the bundle">
+   Note that this will not push code, and just generated a bundle for debugging purposes.
+
+    ```sh
+    npx convex dev --once --debug-bundle-path /tmp/myBundle
+    ```
+
+  </Step>
+  <Step title="Visualize the bundle">
+  Use
+   [source-map-explorer](https://github.com/danvk/source-map-explorer/tree/master)
+   to visualize your bundle.
+
+    ```sh
+    npx source-map-explorer /tmp/myBundle/**/*.js
+    ```
+
+  </Step>
+</StepByStep>
+
+Code bundled for the Convex runtime will be in the `isolate` directory while
+code bundled for node actions will be in the `node` directory.
+
+Large node dependencies can be eliminated from the bundle by marking them as
+[external packages](/functions/bundling.mdx#external-packages).
+
+### Dynamic dependencies
+
+Some libraries rely on dynamic imports (via `import`/`require` calls) to avoid
+always including their dependencies. These imports are not supported by the
+[default Convex runtime](/functions/runtimes.mdx#default-convex-runtime) and
+will throw an error at runtime.
+
+Additionally, some libraries rely on local files, which cannot be bundled by
+esbuild. If bundling is used, irrespective of the choice of runtime, these
+imports will always fail in Convex.
+
+<Details summary="Examples of libraries with dynamic dependencies">
+
+Consider the following examples of packages relying on dynamic dependencies:
+
+- [langchain](https://www.npmjs.com/package/langchain) relying on the presence
+  of peer dependencies that it can dynamically import. These dependencies are
+  not statically `import`ed so will not be bundled by `esbuild`.
+- [sharp](https://www.npmjs.com/package/sharp) relying on the presence of
+  `libvips` binaries for image-processing operations
+- [pdf-parse](https://www.npmjs.com/package/pdf-parse) relies on being
+  dynamically imported with `require()` in order to detect if it is being run in
+  test mode. Bundling can eliminate these `require()` calls, making `pdf-parse`
+  assume it is running in test mode.
+- [tiktoken](https://www.npmjs.com/package/tiktoken) relying on local WASM files
+
+</Details>
+
+## External packages
+
+As a workaround for the bundling limitations above, Convex provides an escape
+hatch: **external packages**. This feature is currently exclusive to Convex's
+[Node.js runtime](/functions/runtimes.mdx#nodejs-runtime).
+
+External packages use
+[`esbuild`'s facility for marking a dependency as external](https://esbuild.github.io/api/#external).
+This tells `esbuild` to not bundle the external dependency at all and to leave
+the import as a dynamic runtime import using `require()` or `import()`. Thus,
+your Convex modules will rely on the underlying system having that dependency
+made available at execution-time.
+
+### Package installation on the server
+
+Packages marked as external are installed from [npm](https://www.npmjs.com/) the
+first time you push code that uses them. The version installed matches the
+version installed in the `node_modules` folder on your local machine.
+
+While this comes with a latency penalty the first time you push external
+packages, your packages are cached and this install step only ever needs to
+rerun if your external packages change. Once cached, pushes can actually be
+faster due to smaller source code bundles being sent to the server during
+pushes!
+
+### Specifying external packages
+
+Create a [`convex.json`](/production/project-configuration.mdx#convexjson) file
+in the same directory as your `package.json` if it does not exist already. Set
+the `node.externalPackages` field to `["*"]` to mark all dependencies used
+within your Node actions as external:
+
+```json
+{
+  "node": {
+    "externalPackages": ["*"]
+  }
+}
+```
+
+Alternatively, you can explicitly specify which packages to mark as external:
+
+```json
+{
+  "node": {
+    "externalPackages": ["aws-sdk", "sharp"]
+  }
+}
+```
+
+The package identifiers should match the string used in `import`/`require` in
+your [Node.js action](/functions/actions.mdx#choosing-the-runtime-use-node).
+
+### Troubleshooting external packages
+
+#### Incorrect package versions
+
+The Convex CLI searches for external packages within your local `node_modules`
+directory. Thus, changing version of a package in the `package.json` will not
+affect the version used on the server until you've updated the package version
+installed in your local `node_modules` folder (e.g. running `npm install`).
+
+#### Import errors
+
+Marking a dependency as external may result in errors like this:
+
+> The requested module "some-module" is a CommonJs module, which may not support
+> all module.exports as named exports. CommonJs modules can always be imported
+> via the default export
+
+This requires rewriting any imports for this module as follows:
+
+```ts
+// ❌ old
+import { Foo } from "some-module";
+
+// ✅ new
+
+const { Foo } = SomeModule;
+```
+
+### Limitations
+
+The total size of your source code bundle and external packages cannot exceed
+the following:
+
+- 45MB zipped
+- 240MB unzipped
+
+Packages that are known not to work at this time:
+
+- [Puppeteer](https://www.npmjs.com/package/puppeteer) - browser binary
+  installation exceeds the size limit
+- [@ffmpeg.wasm](https://www.npmjs.com/package/@ffmpeg/ffmpeg) - since 0.12.0,
+  [no longer supports Node environments](https://ffmpegwasm.netlify.app/docs/faq#why-ffmpegwasm-doesnt-support-nodejs)
+
+If there is a package that you would like working in your Convex functions,
+[let us know](https://convex.dev/community).
diff --git a/synced/convex/docs/functions/debugging.md b/synced/convex/docs/functions/debugging.md
new file mode 100644
index 0000000..f7d6ee3
--- /dev/null
+++ b/synced/convex/docs/functions/debugging.md
@@ -0,0 +1,87 @@
+---
+title: Debugging
+sidebar_position: 100
+---
+
+Debugging is the process of figuring out why your code isn't behaving as you
+expect.
+
+## Debugging during development
+
+During development the built-in `console` API allows you to understand what's
+going on inside your functions:
+
+```ts title="convex/myFunctions.ts"
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    console.log("Received args", args);
+    // ...
+  },
+});
+```
+
+The following methods are available in the
+[default Convex runtime](/functions/runtimes.mdx#default-convex-runtime):
+
+- Logging values, with a specified severity level:
+  - `console.log`
+  - `console.info`
+  - `console.warn`
+  - `console.error`
+  - `console.debug`
+- Logging with a stack trace:
+  - [`console.trace`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace_static)
+- Measuring execution time:
+  - [`console.time`](https://developer.mozilla.org/en-US/docs/Web/API/console/time_static)
+  - [`console.timeLog`](https://developer.mozilla.org/en-US/docs/Web/API/console/timelog_static)
+  - [`console.timeEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeend_static)
+
+The Convex backend also automatically logs all successful function executions
+and all errors thrown by your functions.
+
+You can view these logs:
+
+1. When using the [`ConvexReactClient`](/client/react.mdx), in your browser
+   developer tools console pane. The logs are sent from your dev deployment to
+   your client, and the client logs them to the browser. Production deployments
+   [**do not** send logs to the client](/functions/error-handling/error-handling.mdx#differences-in-error-reporting-between-dev-and-prod).
+2. In your Convex dashboard on the [Logs page](/dashboard/deployments/logs.md).
+3. In your terminal with [`npx convex dev`](/cli.md#tail-deployment-logs) during
+   development or [`npx convex logs`](/cli.md#tail-deployment-logs), which only
+   prints logs.
+
+### Using a debugger
+
+You can exercise your functions from tests, in which case you can add
+`debugger;` statements and step through your code. See
+[Testing](/testing/convex-test.mdx#debugging-tests).
+
+## Debugging in production
+
+When debugging an issue in production your options are:
+
+1. Leverage existing logging
+2. Add more logging and deploy a new version of your backend to production
+
+Convex backend currently only preserves a limited number of logs, and logs can
+be erased at any time when the Convex team performs internal maintenance and
+upgrades. You should therefore set up
+[log streaming and error reporting](/production/integrations/integrations.mdx)
+integrations to enable your team easy access to historical logs and additional
+information logged by your client.
+
+## Finding relevant logs by Request ID
+
+To find the appropriate logs for an error you or your users experience, Convex
+includes a Request ID in all exception messages in both dev and prod in this
+format: `[Request ID: <request_id>]`.
+
+You can copy and paste a Request ID into your Convex dashboard to view the logs
+for functions started by that request. See the
+[Dashboard logs page](/dashboard/deployments/logs.md#filter-logs) for details.
+
+{/* TODO: Document how to filter by Request ID in Datadog/Axiom */}
diff --git a/synced/convex/docs/functions/error-handling/application-errors.md b/synced/convex/docs/functions/error-handling/application-errors.md
new file mode 100644
index 0000000..8ff377f
--- /dev/null
+++ b/synced/convex/docs/functions/error-handling/application-errors.md
@@ -0,0 +1,184 @@
+---
+title: "Application Errors"
+sidebar_label: "Application Errors"
+---
+
+
+
+
+If you have expected ways your functions might fail, you can either return
+different values or throw `ConvexError`s.
+
+## Returning different values
+
+If you're using TypeScript different return types can enforce that you're
+handling error scenarios.
+
+For example, a `createUser` mutation could return
+
+```ts
+Id<"users"> | { error: "EMAIL_ADDRESS_IN_USE" };
+```
+
+to express that either the mutation succeeded or the email address was already
+taken.
+
+This ensures that you remember to handle these cases in your UI.
+
+## Throwing application errors
+
+You might prefer to throw errors for the following reasons:
+
+- You can use the exception bubbling mechanism to throw from a deeply nested
+  function call, instead of manually propagating error results up the call
+  stack. This will work for `runQuery`, `runMutation` and `runAction` calls in
+  [actions](/functions/actions.mdx) too.
+- In [mutations](/functions/mutation-functions.mdx), throwing an error will
+  prevent the mutation transaction from committing
+- On the client, it might be simpler to handle all kinds of errors, both
+  expected and unexpected, uniformly
+
+Convex provides an error subclass,
+[`ConvexError`](/api/classes/values.ConvexError), which can be used to carry
+information from the backend to the client:
+
+
+```ts
+// @snippet start example
+import { ConvexError } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const assignRole = mutation({
+  args: {
+    // ...
+  },
+  handler: (ctx, args) => {
+    const isTaken = isRoleTaken(/* ... */);
+    if (isTaken) {
+      throw new ConvexError("Role is already taken");
+    }
+    // ...
+  },
+});
+// @snippet end example
+
+function isRoleTaken() {
+  return false;
+}
+```
+
+```ts
+// @snippet start example
+import { ConvexError } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const assignRole = mutation({
+  args: {
+    // ...
+  },
+  handler: (ctx, args) => {
+    const isTaken = isRoleTaken(/* ... */);
+    if (isTaken) {
+      throw new ConvexError("Role is already taken");
+    }
+    // ...
+  },
+});
+// @snippet end example
+
+function isRoleTaken() {
+  return false;
+}
+```
+
+
+### Application error `data` payload
+
+You can pass the same [data types](/database/types.md) supported by function
+arguments, return types and the database, to the `ConvexError` constructor. This
+data will be stored on the `data` property of the error:
+
+```ts
+// error.data === "My fancy error message"
+throw new ConvexError("My fancy error message");
+
+// error.data === {message: "My fancy error message", code: 123, severity: "high"}
+throw new ConvexError({
+  message: "My fancy error message",
+  code: 123,
+  severity: "high",
+});
+
+// error.data === {code: 123, severity: "high"}
+throw new ConvexError({
+  code: 123,
+  severity: "high",
+});
+```
+
+Error payloads more complicated than a simple `string` are helpful for more
+structured error logging, or for handling sets of errors differently on the
+client.
+
+## Handling application errors on the client
+
+On the client, application errors also use the `ConvexError` class, and the data
+they carry can be accessed via the `data` property:
+
+
+```tsx
+import { ConvexError } from "convex/values";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const doSomething = useMutation(api.myFunctions.mutateSomething);
+  const handleSomething = async () => {
+    try {
+      await doSomething({ a: 1, b: 2 });
+    } catch (error) {
+      const errorMessage =
+        // Check whether the error is an application error
+        error instanceof ConvexError
+          ? // Access data and cast it to the type we expect
+            (error.data as { message: string }).message
+          : // Must be some developer error,
+            // and prod deployments will not
+            // reveal any more information about it
+            // to the client
+            "Unexpected error occurred";
+      // do something with `errorMessage`
+    }
+  };
+  // ...
+}
+```
+
+```jsx
+import { ConvexError } from "convex/values";
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const doSomething = useMutation(api.myFunctions.mutateSomething);
+  const handleSomething = async () => {
+    try {
+      await doSomething({ a: 1, b: 2 });
+    } catch (error) {
+      const errorMessage =
+        // Check whether the error is an application error
+        error instanceof ConvexError
+          ? // Access data
+            error.data.message
+          : // Must be some developer error,
+            // and prod deployments will not
+            // reveal any more information about it
+            // to the client
+            "Unexpected error occurred";
+      // do something with `errorMessage`
+    }
+  };
+  // ...
+}
+```
+
diff --git a/synced/convex/docs/functions/error-handling/error-handling.md b/synced/convex/docs/functions/error-handling/error-handling.md
new file mode 100644
index 0000000..930f3f3
--- /dev/null
+++ b/synced/convex/docs/functions/error-handling/error-handling.md
@@ -0,0 +1,198 @@
+---
+title: "Error Handling"
+sidebar_position: 70
+---
+
+There are four reasons why your Convex [queries](/functions/query-functions.mdx)
+and [mutations](/functions/mutation-functions.mdx) may hit errors:
+
+1. [Application Errors](#application-errors-expected-failures): The function
+   code hits a logical condition that should stop further processing, and your
+   code throws a `ConvexError`
+1. Developer Errors: There is a bug in the function (like calling `db.get(null)`
+   instead of `db.get(id)`).
+1. [Read/Write Limit Errors](#readwrite-limit-errors): The function is
+   retrieving or writing too much data.
+1. Internal Convex Errors: There is a problem within Convex (like a network
+   blip).
+
+Convex will automatically handle internal Convex errors. If there are problems
+on our end, we'll automatically retry your queries and mutations until the
+problem is resolved and your queries and mutations succeed.
+
+On the other hand, you must decide how to handle application, developer and
+read/write limit errors. When one of these errors happens, the best practices
+are to:
+
+1. Show the user some appropriate UI.
+2. Send the error to an exception reporting service using the
+   [Exception Reporting Integration](/production/integrations/exception-reporting).
+3. Log the incident using `console.*` and set up reporting with
+   [Log Streaming](/production/integrations/log-streams/log-streams.mdx). This
+   can be done in addition to the above options, and doesn't require an
+   exception to be thrown.
+
+Additionally, you might also want to send client-side errors to a service like
+[Sentry](https://sentry.io) to capture additional information for debugging and
+observability.
+
+## Errors in queries
+
+If your query function hits an error, the error will be sent to the client and
+thrown from your `useQuery` call site. **The best way to handle these errors is
+with a React
+[error boundary component](https://reactjs.org/docs/error-boundaries.html).**
+
+Error boundaries allow you to catch errors thrown in their child component tree,
+render fallback UI, and send information about the error to your exception
+handling service. Adding error boundaries to your app is a great way to handle
+errors in Convex query functions as well as other errors in your React
+components. If you are using Sentry, you can use their
+[`Sentry.ErrorBoundary`](https://docs.sentry.io/platforms/javascript/guides/react/components/errorboundary/)
+component.
+
+With error boundaries, you can decide how granular you'd like your fallback UI
+to be. One simple option is to wrap your entire application in a single error
+boundary like:
+
+```tsx
+<StrictMode>
+  <ErrorBoundary>
+    <ConvexProvider client={convex}>
+      <App />
+    </ConvexProvider>
+  </ErrorBoundary>
+</StrictMode>,
+```
+
+Then any error in any of your components will be caught by the boundary and
+render the same fallback UI.
+
+On the other hand, if you'd like to enable some portions of your app to continue
+functioning even if other parts hit errors, you can instead wrap different parts
+of your app in separate error boundaries.
+
+<Admonition type="note" title="Retrying">
+
+Unlike other frameworks, there is no concept of "retrying" if your query
+function hits an error. Because Convex functions are
+[deterministic](/functions/query-functions.mdx#caching--reactivity--consistency),
+if the query function hits an error, retrying will always produce the same
+error. There is no point in running the query function with the same arguments
+again.
+
+</Admonition>
+
+## Errors in mutations
+
+If a mutation hits an error, this will
+
+1. Cause the promise returned from your mutation call to be rejected.
+2. Cause your [optimistic update](/client/react/optimistic-updates.mdx) to be
+   rolled back.
+
+If you have an exception service like [Sentry](https://sentry.io/) configured,
+it should report "unhandled promise rejections" like this automatically. That
+means that with no additional work your mutation errors should be reported.
+
+Note that errors in mutations won't be caught by your error boundaries because
+the error doesn't happen as part of rendering your components.
+
+If you would like to render UI specifically in response to a mutation failure,
+you can use `.catch` on your mutation call. For example:
+
+```javascript
+sendMessage(newMessageText).catch((error) => {
+  // Do something with `error` here
+});
+```
+
+If you're using an `async` handled function you can also use `try...catch`:
+
+```javascript
+try {
+  await sendMessage(newMessageText);
+} catch (error) {
+  // Do something with `error` here
+}
+```
+
+<Admonition type="caution" title="Reporting caught errors">
+
+If you handle your mutation error, it will no longer become an unhandled promise
+rejection. You may need to report this error to your exception handling service
+manually.
+
+</Admonition>
+
+## Errors in action functions
+
+Unlike queries and mutations, [actions](//docs/functions/actions.mdx) may have
+side-effects and therefore can't be automatically retried by Convex when errors
+occur. For example, say your action sends a email. If it fails part-way through,
+Convex has no way of knowing if the email was already sent and can't safely
+retry the action. It is responsibility of the caller to handle errors raised by
+actions and retry if appropriate.
+
+## Differences in error reporting between dev and prod
+
+Using a dev deployment any server error thrown on the client will include the
+original error message and a server-side stack trace to ease debugging.
+
+Using a production deployment any server error will be redacted to only include
+the name of the function and a generic `"Server Error"` message, with no stack
+trace. Server
+[application errors](/functions/error-handling/application-errors.mdx) will
+still include their custom `data`.
+
+Both development and production deployments log full errors with stack traces
+which can be found on the [Logs](/dashboard/deployments/logs.md) page of a given
+deployment.
+
+## Application errors, expected failures
+
+If you have expected ways your functions might fail, you can either return
+different values or throw `ConvexError`s.
+
+See [Application Errors](/functions/error-handling/application-errors.mdx).
+
+## Read/write limit errors
+
+To ensure uptime and guarantee performance, Convex will catch queries and
+mutations that try to read or write too much data. These limits are enforced at
+the level of a single query or mutation function execution. The limits are:
+
+Queries and mutations error out when:
+
+- More than 16384 documents are scanned
+- More than 8MiB worth of data is scanned
+- More than 4096 queries calls to `db.get` or `db.query` are made
+- The function spends more than 1 second executing Javascript
+
+In addition, mutations error out when:
+
+- More than 8192 documents are written
+- More than 8MiB worth of data is written
+
+Documents are "scanned" by the database to figure out which documents should be
+returned from `db.query`. So for example `db.query("table").take(5).collect()`
+will only need to scan 5 documents, but `db.query("table").filter(...).first()`
+might scan up to as many documents as there are in `"table"`, to find the first
+one that matches the given filter.
+
+Number of calls to `db.get` and `db.query` has a limit to prevent a single query
+from subscribing to too many index ranges.
+
+In general, if you're running into these limits frequently, we recommend
+[indexing your queries](/database/reading-data/indexes/indexes.md) to reduce the
+number of documents scanned, allowing you to avoid unnecessary reads. Queries
+that scan large swaths of your data may look innocent at first, but can easily
+blow up at any production scale. If your functions are close to hitting these
+limits they will log a warning.
+
+For information on other limits, see [here](/production/state/limits.mdx).
+
+## Debugging Errors
+
+See [Debugging](/functions/debugging.mdx) and specifically
+[Finding relevant logs by Request ID](/functions/debugging.mdx#finding-relevant-logs-by-request-id).
diff --git a/synced/convex/docs/functions/http-actions.md b/synced/convex/docs/functions/http-actions.md
new file mode 100644
index 0000000..8d5f20c
--- /dev/null
+++ b/synced/convex/docs/functions/http-actions.md
@@ -0,0 +1,668 @@
+---
+title: HTTP Actions
+sidebar_position: 35
+---
+
+
+
+
+
+
+HTTP actions allow you to build an HTTP API right in Convex!
+
+HTTP actions take in a
+[Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) and return a
+[Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) following
+the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
+HTTP actions can manipulate the request and response directly, and interact with
+data in Convex indirectly by running [queries](/functions/query-functions.mdx),
+[mutations](/functions/mutation-functions.mdx), and
+[actions](/functions/actions.mdx). HTTP actions might be used for receiving
+webhooks from external applications or defining a public HTTP API.
+
+HTTP actions are exposed at `https://<your deployment name>.convex.site` (e.g.
+`https://happy-animal-123.convex.site`).
+
+**Example:**
+[HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/http)
+
+## Defining HTTP actions
+
+HTTP action handlers are defined using the
+[`httpAction`](/generated-api/server#httpaction) constructor, similar to the
+`action` constructor for normal actions:
+
+
+```ts
+import { httpAction } from "./_generated/server";
+
+export const doSomething = httpAction(async () => {
+  // implementation will be here
+  return new Response();
+});
+```
+
+```ts
+import { httpAction } from "./_generated/server";
+
+export const doSomething = httpAction(async () => {
+  // implementation will be here
+  return new Response();
+});
+```
+
+
+The first argument to the `handler` is an
+[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object, which provides
+[`auth`](/api/interfaces/server.Auth),
+[`storage`](/api/interfaces/server.StorageActionWriter), and
+[`scheduler`](/api/interfaces/server.Scheduler), as well as `runQuery`,
+`runMutation`, `runAction`.
+
+The second argument contains the
+[`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) data. HTTP
+actions do not support argument validation, as the parsing of arguments from the
+incoming Request is left entirely to you.
+
+Here's an example:
+
+
+```ts
+import { httpAction } from "./_generated/server";
+import { internal } from "./_generated/api";
+
+export const postMessage = httpAction(async (ctx, request) => {
+  const { author, body } = await request.json();
+
+  await ctx.runMutation(internal.messages.sendOne, {
+    body: `Sent via HTTP action: ${body}`,
+    author,
+  });
+
+  return new Response(null, {
+    status: 200,
+  });
+});
+```
+
+```ts
+import { httpAction } from "./_generated/server";
+import { internal } from "./_generated/api";
+
+export const postMessage = httpAction(async (ctx, request) => {
+  const { author, body } = await request.json();
+
+  await ctx.runMutation(internal.messages.sendOne, {
+    body: `Sent via HTTP action: ${body}`,
+    author,
+  });
+
+  return new Response(null, {
+    status: 200,
+  });
+});
+```
+
+
+<>
+  {/* Wrapped in fragment because Prettier pushes the JSDialectFileName on new line */}
+  To expose the HTTP Action, export an instance of
+  [`HttpRouter`](/api/classes/server.HttpRouter) from the
+  <JSDialectFileName name="convex/http.ts" /> file. To create the instance call
+  the `httpRouter` function. On the `HttpRouter` you can expose routes using the
+  `route` method:
+</>
+
+
+```ts
+// @snippet start router
+import { httpRouter } from "convex/server";
+import { postMessage, getByAuthor, getByAuthorPathSuffix } from "./messages";
+
+const http = httpRouter();
+
+http.route({
+  path: "/postMessage",
+  method: "POST",
+  handler: postMessage,
+});
+
+// Define additional routes
+http.route({
+  path: "/getMessagesByAuthor",
+  method: "GET",
+  handler: getByAuthor,
+});
+
+// Define a route using a path prefix
+http.route({
+  // Will match /getAuthorMessages/User+123 and /getAuthorMessages/User+234 etc.
+  pathPrefix: "/getAuthorMessages/",
+  method: "GET",
+  handler: getByAuthorPathSuffix,
+});
+
+// Convex expects the router to be the default export of `convex/http.js`.
+export default http;
+// @snippet end router
+```
+
+```ts
+// @snippet start router
+import { httpRouter } from "convex/server";
+import { postMessage, getByAuthor, getByAuthorPathSuffix } from "./messages";
+
+const http = httpRouter();
+
+http.route({
+  path: "/postMessage",
+  method: "POST",
+  handler: postMessage,
+});
+
+// Define additional routes
+http.route({
+  path: "/getMessagesByAuthor",
+  method: "GET",
+  handler: getByAuthor,
+});
+
+// Define a route using a path prefix
+http.route({
+  // Will match /getAuthorMessages/User+123 and /getAuthorMessages/User+234 etc.
+  pathPrefix: "/getAuthorMessages/",
+  method: "GET",
+  handler: getByAuthorPathSuffix,
+});
+
+// Convex expects the router to be the default export of `convex/http.js`.
+export default http;
+// @snippet end router
+```
+
+
+You can now call this action via HTTP and interact with data stored in the
+Convex Database. HTTP actions are exposed on
+`https://<your deployment name>.convex.site`.
+
+```bash
+export DEPLOYMENT_NAME=... # example: "happy-animal-123"
+curl -d '{ "author": "User 123", "body": "Hello world" }' \
+    -H 'content-type: application/json' "https://$DEPLOYMENT_NAME.convex.site/postMessage"
+```
+
+Like other Convex functions, you can view your HTTP actions in the
+[Functions view](/dashboard/deployments/functions.md) of
+[your dashboard](https://dashboard.convex.dev/) and view logs produced by them
+in the [Logs view](/dashboard/deployments/logs.md).
+
+## Limits
+
+HTTP actions run in the same environment as queries and mutations so also do not
+have access to Node.js-specific JavaScript APIs. HTTP actions can call
+[actions](/functions/actions.mdx), which can run in Node.js.
+
+Like [actions](/functions/actions.mdx#error-handling), HTTP actions may have
+side-effects and will not be automatically retried by Convex when errors occur.
+It is a responsibility of the caller to handle errors and retry the request if
+appropriate.
+
+Request and response size is limited to 20MB.
+
+HTTP actions support request and response body types of `.text()`, `.json()`,
+`.blob()`, and `.arrayBuffer()`.
+
+Note that you don't need to define an HTTP action to call your queries,
+mutations and actions over HTTP if you control the caller, since you can use use
+the JavaScript [`ConvexHttpClient`](/api/classes/browser.ConvexHttpClient) or
+the [Python client](/client/python.md) to call these functions directly.
+
+## Debugging
+
+### Step 1: Check that your HTTP actions were deployed.
+
+Check the [functions page](https://dashboard.convex.dev/deployment/functions) in
+the dashboard and make sure there's an entry called `http`.
+
+If not, double check that you've defined your HTTP actions with the `httpRouter`
+in a file called `http.js` or `http.ts` (the name of the file must match
+exactly), and that `npx convex dev` has no errors.
+
+### Step 2: Check that you can access your endpoint using curl
+
+Get your URL from the dashboard under
+[Settings](https://dashboard.convex.dev/deployment/settings) > URL and Deploy
+Key.
+
+Make sure this is the URL that ends in **`.convex.site`**, and not
+`.convex.cloud`. E.g. `https://happy-animal-123.convex.site`
+
+Run a `curl` command to hit one of your defined endpoints, potentially defining
+a new endpoint specifically for testing
+
+```
+curl -X GET https://<deployment name>.convex.site/myEndpoint
+```
+
+Check the [logs page](https://dashboard.convex.dev/deployment/logs) in the
+dashboard to confirm that there's an entry for your HTTP action.
+
+### Step 3: Check the request being made by your browser
+
+If you've determined that your HTTP actions have been deployed and are
+accessible via curl, but there are still issues requesting them from your app,
+check the exact requests being made by your browser.
+
+Open the _Network_ tab in your browser's developer tools, and trigger your HTTP
+requests.
+
+Check that this URL matches what you tested earlier with curl -- it ends in
+`.convex.site` and has the right deployment name.
+
+You should be able to see these requests in the dashboard
+[logs page](https://dashboard.convex.dev/deployment/logs).
+
+If you see "CORS error" or messages in the browser console like
+`Access to fetch at '...' from origin '...' has been blocked by CORS policy`,
+you likely need to configure CORS headers and potentially add a handler for the
+pre-flight `OPTIONS` request. See
+[this section](/functions/http-actions.mdx#cors) below.
+
+## Common patterns
+
+### File Storage
+
+HTTP actions can be used to handle uploading and fetching stored files, see:
+
+- [Uploading files via an HTTP action](/file-storage/upload-files.mdx#uploading-files-via-an-http-action)
+- [Serving files from HTTP actions](/file-storage/serve-files.mdx#serving-files-from-http-actions)
+
+### CORS
+
+To make requests to HTTP actions from a website you need to add
+[Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
+headers to your HTTP actions.
+
+There are existing resources for exactly which CORS headers are required based
+on the use case. [This site](https://httptoolkit.com/will-it-cors/) provides an
+interactive walkthrough for what CORS headers to add. Here's an example of
+adding CORS headers to a Convex HTTP action:
+
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+
+Here's an example of handling a pre-flight `OPTIONS` request:
+
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+```ts
+// @snippet start sendImageStore
+import { httpRouter } from "convex/server";
+import { httpAction } from "./_generated/server";
+import { api } from "./_generated/api";
+import { Id } from "./_generated/dataModel";
+
+const http = httpRouter();
+
+http.route({
+  path: "/sendImage",
+  method: "POST",
+  handler: httpAction(async (ctx, request) => {
+    // Step 1: Store the file
+    const blob = await request.blob();
+    const storageId = await ctx.storage.store(blob);
+
+    // Step 2: Save the storage ID to the database via a mutation
+    const author = new URL(request.url).searchParams.get("author");
+    await ctx.runMutation(api.messages.sendImage, { storageId, author });
+
+    // Step 3: Return a response with the correct CORS headers
+    return new Response(null, {
+      status: 200,
+      // CORS headers
+      headers: new Headers({
+        // e.g. https://mywebsite.com, configured on your Convex dashboard
+        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+        Vary: "origin",
+      }),
+    });
+  }),
+});
+// @snippet end sendImageStore
+
+// @snippet start getImage
+http.route({
+  path: "/getImage",
+  method: "GET",
+  handler: httpAction(async (ctx, request) => {
+    const { searchParams } = new URL(request.url);
+    const storageId = searchParams.get("storageId")! as Id<"_storage">;
+    const blob = await ctx.storage.get(storageId);
+    if (blob === null) {
+      return new Response("Image not found", {
+        status: 404,
+      });
+    }
+    return new Response(blob);
+  }),
+});
+// @snippet end getImage
+
+// @snippet start preflight
+// Pre-flight request for /sendImage
+http.route({
+  path: "/sendImage",
+  method: "OPTIONS",
+  handler: httpAction(async (_, request) => {
+    // Make sure the necessary headers are present
+    // for this to be a valid pre-flight request
+    const headers = request.headers;
+    if (
+      headers.get("Origin") !== null &&
+      headers.get("Access-Control-Request-Method") !== null &&
+      headers.get("Access-Control-Request-Headers") !== null
+    ) {
+      return new Response(null, {
+        headers: new Headers({
+          // e.g. https://mywebsite.com, configured on your Convex dashboard
+          "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
+          "Access-Control-Allow-Methods": "POST",
+          "Access-Control-Allow-Headers": "Content-Type, Digest",
+          "Access-Control-Max-Age": "86400",
+        }),
+      });
+    } else {
+      return new Response();
+    }
+  }),
+});
+// @snippet end preflight
+
+export default http;
+```
+
+
+### Authentication
+
+You can leverage Convex's built-in [authentication](/auth.mdx) integration and
+access a user identity from
+[`ctx.auth.getUserIdentity()`](/api/interfaces/server.Auth#getuseridentity). To
+do this call your endpoint with an `Authorization` header including a JWT token:
+
+
+```ts
+const jwtToken = "...";
+
+fetch("https://<deployment name>.convex.site/myAction", {
+  headers: {
+    Authorization: `Bearer ${jwtToken}`,
+  },
+});
+```
+
+```ts
+const jwtToken = "...";
+
+fetch("https://<deployment name>.convex.site/myAction", {
+  headers: {
+    Authorization: `Bearer ${jwtToken}`,
+  },
+});
+```
+
diff --git a/synced/convex/docs/functions/internal-functions.md b/synced/convex/docs/functions/internal-functions.md
new file mode 100644
index 0000000..b8d66df
--- /dev/null
+++ b/synced/convex/docs/functions/internal-functions.md
@@ -0,0 +1,162 @@
+---
+title: Internal Functions
+sidebar_position: 40
+---
+
+
+
+
+
+Internal functions can only be called by other [functions](/functions.mdx) and
+cannot be called directly from a [Convex client](/client/react.mdx).
+
+By default your Convex functions are public and accessible to clients. Public
+functions may be called by malicious users in ways that cause surprising
+results. Internal functions help you mitigate this risk. We recommend using
+internal functions any time you're writing logic that should not be called from
+a client.
+
+While internal functions help mitigate risk by reducing the public surface area
+of your application, you can still validate internal invariants using
+[argument validation](/functions/validation.mdx) and/or
+[authentication](/auth/functions-auth.mdx).
+
+## Use cases for internal functions
+
+Leverage internal functions by:
+
+- Calling them from [actions](/functions/actions.mdx#action-context) via
+  `runQuery` and `runMutation`
+- Calling them from [HTTP actions](/functions/http-actions.mdx) via `runQuery`,
+  `runMutation`, and `runAction`
+- [Scheduling](/scheduling/scheduled-functions.mdx) them from other functions to
+  run in the future
+- Scheduling them to run periodically from
+  [cron jobs](/scheduling/cron-jobs.mdx)
+- Running them using the
+  [Dashboard](/dashboard/deployments/functions.md#running-functions)
+- Running them from the [CLI](/cli.md#run-convex-functions)
+
+## Defining internal functions
+
+An internal function is defined using `internalQuery`, `internalMutation`, or
+`internalAction`. For example:
+
+
+```ts
+import { internalMutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const markPlanAsProfessional = internalMutation({
+  args: { planId: v.id("plans") },
+  handler: async (ctx, args) => {
+    await ctx.db.patch(args.planId, { planType: "professional" });
+  },
+});
+```
+
+```ts
+import { internalMutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const markPlanAsProfessional = internalMutation({
+  args: { planId: v.id("plans") },
+  handler: async (ctx, args) => {
+    await ctx.db.patch(args.planId, { planType: "professional" });
+  },
+});
+```
+
+
+If you need to pass complicated objects to internal functions you might prefer
+to not use argument validation. Note though that if you're using `internalQuery`
+or `internalMutation` it's a better idea to pass around document IDs instead of
+documents, to ensure the query or mutation is working with the up-to-date state
+of the database.
+
+<Details summary="Internal function without argument validation">
+
+
+```ts
+import { internalAction } from "./_generated/server";
+import { Doc } from "./_generated/dataModel";
+
+export const markPlanAsProfessional = internalAction({
+  handler: async (actionCtx, args) => {
+    // perform an action, perhaps calling a third-party API
+  },
+});
+```
+
+```js
+import { internalAction } from "./_generated/server";
+
+export const markPlanAsProfessional = internalAction({
+  handler: async (actionCtx, args) => {
+    // perform an action, perhaps calling a third-party API
+  },
+});
+```
+
+
+</Details>
+
+## Calling internal functions
+
+Internal functions can be called from actions and scheduled from actions and
+mutation using the [`internal`](/generated-api/api#internal) object.
+
+For example, consider this public `upgrade` action that calls the internal
+`plans.markPlanAsProfessional` mutation we defined above:
+
+
+```ts
+import { action } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const upgrade = action({
+  args: {
+    planId: v.id("plans"),
+  },
+  handler: async (ctx, args) => {
+    // Call out to payment provider (e.g. Stripe) to charge customer
+    const response = await fetch("https://...");
+    if (response.ok) {
+      // Mark the plan as "professional" in the Convex DB
+      await ctx.runMutation(internal.plans.markPlanAsProfessional, {
+        planId: args.planId,
+      });
+    }
+  },
+});
+```
+
+```ts
+import { action } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const upgrade = action({
+  args: {
+    planId: v.id("plans"),
+  },
+  handler: async (ctx, args) => {
+    // Call out to payment provider (e.g. Stripe) to charge customer
+    const response = await fetch("https://...");
+    if (response.ok) {
+      // Mark the plan as "professional" in the Convex DB
+      await ctx.runMutation(internal.plans.markPlanAsProfessional, {
+        planId: args.planId,
+      });
+    }
+  },
+});
+```
+
+
+In this example a user should not be able to directly call
+`internal.plans.markPlanAsProfessional` without going through the `upgrade`
+action — if they did, then they would get a free upgrade.
+
+You can define public and internal functions in the same file.
diff --git a/synced/convex/docs/functions/mutation-functions.md b/synced/convex/docs/functions/mutation-functions.md
new file mode 100644
index 0000000..cf4f0eb
--- /dev/null
+++ b/synced/convex/docs/functions/mutation-functions.md
@@ -0,0 +1,405 @@
+---
+title: Mutations
+sidebar_position: 20
+---
+
+
+
+
+
+
+
+
+
+
+
+
+Mutations insert, update and remove data from the database, check authentication
+or perform other business logic, and optionally return a response to the client
+application.
+
+This is an example mutation, taking in named arguments, writing data to the
+database and returning a result:
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+// Create a new task with the given text
+export const createTask = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    const newTaskId = await ctx.db.insert("tasks", { text: args.text });
+    return newTaskId;
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+// Create a new task with the given text
+export const createTask = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    const newTaskId = await ctx.db.insert("tasks", { text: args.text });
+    return newTaskId;
+  },
+});
+```
+
+
+Read on to understand how to build mutations yourself.
+
+## Mutation names
+
+Mutations follow the same naming rules as queries, see
+[Query names](/functions/query-functions.mdx#query-names).
+
+Queries and mutations can be defined in the same file when using named exports.
+
+## The `mutation` constructor
+
+To declare a mutation in Convex use the `mutation` constructor function. Pass it
+an object with a `handler` function, which performs the mutation:
+
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const mutateSomething = mutation({
+  handler: () => {
+    // implementation will be here
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const mutateSomething = mutation({
+  handler: () => {
+    // implementation will be here
+  },
+});
+```
+
+
+Unlike a query, a mutation can but does not have to return a value.
+
+### Mutation arguments
+
+Just like queries, mutations accept named arguments, and the argument values are
+accessible as fields of the second parameter of the `handler` function:
+
+
+```ts
+import { mutation } from "./_generated/server";
+
+export const mutateSomething = mutation({
+  handler: (_, args: { a: number; b: number }) => {
+    // do something with `args.a` and `args.b`
+
+    // optionally return a value
+    return "success";
+  },
+});
+```
+
+```js
+import { mutation } from "./_generated/server";
+
+export const mutateSomething = mutation({
+  handler: (_, args) => {
+    // do something with `args.a` and `args.b`
+
+    // optionally return a value
+    return "success";
+  },
+});
+```
+
+
+Arguments and responses are automatically serialized and deserialized, and you
+can pass and return most value-like JavaScript data to and from your mutation.
+
+To both declare the types of arguments and to validate them, add an `args`
+object using `v` validators:
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    // do something with `args.a` and `args.b`
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    // do something with `args.a` and `args.b`
+  },
+});
+```
+
+
+See [argument validation](/functions/validation.mdx) for the full list of
+supported types and validators.
+
+The first parameter to the handler function is reserved for the mutation
+context.
+
+### Mutation responses
+
+Queries can return values of any supported
+[Convex type](/functions/validation.mdx) which will be automatically serialized
+and deserialized.
+
+Mutations can also return `undefined`, which is not a valid Convex value. When a
+mutation returns `undefined` **it is translated to `null`** on the client.
+
+### Mutation context
+
+The `mutation` constructor enables writing data to the database, and other
+Convex features by passing a [MutationCtx](/generated-api/server.md#mutationctx)
+object to the handler function as the first parameter:
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (ctx, args) => {
+    // Do something with `ctx`
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const mutateSomething = mutation({
+  args: { a: v.number(), b: v.number() },
+  handler: (ctx, args) => {
+    // Do something with `ctx`
+  },
+});
+```
+
+
+Which part of the mutation context is used depends on what your mutation needs
+to do:
+
+- To read from and write to the database use the `db` field. Note that we make
+  the handler function an `async` function so we can `await` the promise
+  returned by `db.insert()`:
+
+  
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const addItem = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("tasks", { text: args.text });
+  },
+});
+```
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const addItem = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("tasks", { text: args.text });
+  },
+});
+```
+
+
+  Read on about [Writing Data](/database/writing-data.mdx).
+
+- To generate upload URLs for storing files use the `storage` field. Read on
+  about [File Storage](/file-storage.mdx).
+- To check user authentication use the `auth` field. Read on about
+  [Authentication](/auth.mdx).
+- To schedule functions to run in the future, use the `scheduler` field. Read on
+  about [Scheduled Functions](/scheduling/scheduled-functions.mdx).
+
+## Splitting up mutation code via helpers
+
+<>
+  {/* Fragment for Prettier */}
+  When you want to split up the code in your mutation or reuse logic across
+  multiple Convex functions you can define and call helper
+  <LanguageSelector verbose /> functions:
+</>
+
+
+```ts
+import { v } from "convex/values";
+import { mutation, MutationCtx } from "./_generated/server";
+
+export const addItem = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("tasks", { text: args.text });
+    await trackChange(ctx, "addItem");
+  },
+});
+
+async function trackChange(ctx: MutationCtx, type: "addItem" | "removeItem") {
+  await ctx.db.insert("changes", { type });
+}
+```
+
+```js
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+export const addItem = mutation({
+  args: { text: v.string() },
+  handler: async (ctx, args) => {
+    await ctx.db.insert("tasks", { text: args.text });
+    await trackChange(ctx, "addItem");
+  },
+});
+
+async function trackChange(ctx, type) {
+  await ctx.db.insert("changes", { type });
+}
+```
+
+
+Mutations can call helpers that take a
+[QueryCtx](/generated-api/server.md#queryctx) as argument, since the mutation
+context can do everything query context can.
+
+You can `export` helpers to use them across multiple files. They will not be
+callable from outside of your Convex functions.
+
+See
+[Type annotating server side helpers](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
+for more guidance on TypeScript types.
+
+## Using NPM packages
+
+Mutations can import NPM packages installed in `node_modules`. Not all NPM
+packages are supported, see
+[Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details.
+
+```sh
+npm install @faker-js/faker
+```
+
+
+```ts
+import { faker } from "@faker-js/faker";
+import { mutation } from "./_generated/server";
+
+export const randomName = mutation({
+  args: {},
+  handler: async (ctx) => {
+    faker.seed();
+    await ctx.db.insert("tasks", { text: "Greet " + faker.person.fullName() });
+  },
+});
+```
+
+```ts
+import { faker } from "@faker-js/faker";
+import { mutation } from "./_generated/server";
+
+export const randomName = mutation({
+  args: {},
+  handler: async (ctx) => {
+    faker.seed();
+    await ctx.db.insert("tasks", { text: "Greet " + faker.person.fullName() });
+  },
+});
+```
+
+
+## Calling mutations from clients
+
+To call a mutation from [React](/client/react.mdx) use the
+[`useMutation`](/client/react.mdx#editing-data) hook along with the generated
+[`api`](/generated-api/api) object.
+
+
+```tsx
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const mutateSomething = useMutation(api.myFunctions.mutateSomething);
+  const handleClick = () => {
+    mutateSomething({ a: 1, b: 2 });
+  };
+  // pass `handleClick` to a button
+  // ...
+}
+```
+
+```tsx
+import { useMutation } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const mutateSomething = useMutation(api.myFunctions.mutateSomething);
+  const handleClick = () => {
+    mutateSomething({ a: 1, b: 2 });
+  };
+  // pass `handleClick` to a button
+  // ...
+}
+```
+
+
+See the [React](/client/react.mdx) client documentation for all the ways queries
+can be called.
+
+When mutations are called from the [React](/client/react.mdx) or
+[Rust](/client/rust.md) clients, they are executed one at a time in a single,
+ordered queue. You don't have to worry about mutations editing the database in a
+different order than they were triggered.
+
+## Transactions
+
+Mutations run **transactionally**. This means that:
+
+1. All database reads inside the transaction get a consistent view of the data
+   in the database. You don't have to worry about a concurrent update changing
+   the data in the middle of the execution.
+2. All database writes get committed together. If the mutation writes some data
+   to the database, but later throws an error, no data is actually written to
+   the database.
+
+For this to work, similarly to queries, mutations must be deterministic, and
+cannot call third party APIs. To call third party APIs, use
+[actions](/functions/actions.mdx).
+
+## Limits
+
+Mutations have a limit to the amount of data they can read and write at once to
+guarantee good performance. Learn more in
+[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).
+
+For information on other limits, see [Limits](/production/state/limits.mdx).
diff --git a/synced/convex/docs/functions/query-functions.md b/synced/convex/docs/functions/query-functions.md
new file mode 100644
index 0000000..b96daef
--- /dev/null
+++ b/synced/convex/docs/functions/query-functions.md
@@ -0,0 +1,441 @@
+---
+title: Queries
+sidebar_position: 10
+---
+
+
+
+
+
+
+
+
+
+
+
+
+Queries are the bread and butter of your backend API. They fetch data from the
+database, check authentication or perform other business logic, and return data
+back to the client application.
+
+This is an example query, taking in named arguments, reading data from the
+database and returning a result:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+// Return the last 100 tasks in a given task list.
+export const getTaskList = query({
+  args: { taskListId: v.id("taskLists") },
+  handler: async (ctx, args) => {
+    const tasks = await ctx.db
+      .query("tasks")
+      .filter((q) => q.eq(q.field("taskListId"), args.taskListId))
+      .order("desc")
+      .take(100);
+    return tasks;
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+// Return the last 100 tasks in a given task list.
+export const getTaskList = query({
+  args: { taskListId: v.id("taskLists") },
+  handler: async (ctx, args) => {
+    const tasks = await ctx.db
+      .query("tasks")
+      .filter((q) => q.eq(q.field("taskListId"), args.taskListId))
+      .order("desc")
+      .take(100);
+    return tasks;
+  },
+});
+```
+
+
+Read on to understand how to build queries yourself.
+
+## Query names
+
+Queries are defined in <LanguageSelector verbose /> files inside your `convex/`
+directory.
+
+The path and name of the file, as well as the way the function is exported from
+the file, determine the name the client will use to call it:
+
+```ts title="convex/myFunctions.ts"
+// This function will be referred to as `api.myFunctions.myQuery`.
+export const myQuery = …;
+
+// This function will be referred to as `api.myFunctions.sum`.
+export const sum = …;
+```
+
+To structure your API you can nest directories inside the `convex/` directory:
+
+```ts title="convex/foo/myQueries.ts"
+// This function will be referred to as `api.foo.myQueries.listMessages`.
+export const listMessages = …;
+```
+
+Default exports receive the name `default`.
+
+```ts title="convex/myFunctions.ts"
+// This function will be referred to as `api.myFunctions.default`.
+export default …;
+```
+
+The same rules apply to [mutations](/functions/mutation-functions.mdx) and
+[actions](/functions/actions.mdx), while
+[HTTP actions](/functions/http-actions.mdx) use a different routing approach.
+
+Client libraries in languages other than JavaScript and TypeScript use strings
+instead of API objects:
+
+- `api.myFunctions.myQuery` is `"myFunctions:myQuery"`
+- `api.foo.myQueries.myQuery` is `"foo/myQueries:myQuery"`.
+- `api.myFunction.default` is `"myFunction:default"` or `"myFunction"`.
+
+## The `query` constructor
+
+To actually declare a query in Convex you use the `query` constructor function.
+Pass it an object with a `handler` function, which returns the query result:
+
+
+```ts
+import { query } from "./_generated/server";
+
+export const myConstantString = query({
+  handler: () => {
+    return "My never changing string";
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+
+export const myConstantString = query({
+  handler: () => {
+    return "My never changing string";
+  },
+});
+```
+
+
+### Query arguments
+
+Queries accept named arguments. The argument values are accessible as fields of
+the second parameter of the handler function:
+
+
+```ts
+import { query } from "./_generated/server";
+
+export const sum = query({
+  handler: (_, args: { a: number; b: number }) => {
+    return args.a + args.b;
+  },
+});
+```
+
+```js
+import { query } from "./_generated/server";
+
+export const sum = query({
+  handler: (_, args) => {
+    return args.a + args.b;
+  },
+});
+```
+
+
+Arguments and responses are automatically serialized and deserialized, and you
+can pass and return most value-like JavaScript data to and from your query.
+
+To both declare the types of arguments and to validate them, add an `args`
+object using `v` validators:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const sum = query({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    return args.a + args.b;
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const sum = query({
+  args: { a: v.number(), b: v.number() },
+  handler: (_, args) => {
+    return args.a + args.b;
+  },
+});
+```
+
+
+See [argument validation](/functions/validation.mdx) for the full list of
+supported types and validators.
+
+The first parameter of the handler function contains the query context.
+
+### Query responses
+
+Queries can return values of any supported
+[Convex type](/functions/validation.mdx) which will be automatically serialized
+and deserialized.
+
+Queries can also return `undefined`, which is not a valid Convex value. When a
+query returns `undefined` **it is translated to `null`** on the client.
+
+### Query context
+
+The `query` constructor enables fetching data, and other Convex features by
+passing a [QueryCtx](/generated-api/server.md#queryctx) object to the handler
+function as the first parameter:
+
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const myQuery = query({
+  args: { a: v.number(), b: v.number() },
+  handler: (ctx, args) => {
+    // Do something with `ctx`
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const myQuery = query({
+  args: { a: v.number(), b: v.number() },
+  handler: (ctx, args) => {
+    // Do something with `ctx`
+  },
+});
+```
+
+
+Which part of the query context is used depends on what your query needs to do:
+
+- To fetch from the database use the `db` field. Note that we make the handler
+  function an `async` function so we can `await` the promise returned by
+  `db.get()`:
+
+  
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTask = query({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    return await ctx.db.get(args.id);
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTask = query({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    return await ctx.db.get(args.id);
+  },
+});
+```
+
+
+  Read more about [Reading Data](/database/reading-data/reading-data.mdx).
+
+- To return URLs to stored files use the `storage` field. Read more about
+  [File Storage](/file-storage.mdx).
+- To check user authentication use the `auth` field. Read more about
+  [Authentication](/auth.mdx).
+
+## Splitting up query code via helpers
+
+When you want to split up the code in your query or reuse logic across multiple
+Convex functions you can define and call helper <LanguageSelector verbose />
+functions:
+
+
+```ts
+import { Id } from "./_generated/dataModel";
+import { query, QueryCtx } from "./_generated/server";
+import { v } from "convex/values";
+
+export const getTaskAndAuthor = query({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const task = await ctx.db.get(args.id);
+    if (task === null) {
+      return null;
+    }
+    return { task, author: await getUserName(ctx, task.authorId ?? null) };
+  },
+});
+
+async function getUserName(ctx: QueryCtx, userId: Id<"users"> | null) {
+  if (userId === null) {
+    return null;
+  }
+  return (await ctx.db.get(userId))?.name;
+}
+```
+
+```js
+import { v } from "convex/values";
+import { query } from "./_generated/server";
+
+export const getTaskAndAuthor = query({
+  args: { id: v.id("tasks") },
+  handler: async (ctx, args) => {
+    const task = await ctx.db.get(args.id);
+    if (task === null) {
+      return null;
+    }
+    return { task, author: await getUserName(ctx, task.authorId ?? null) };
+  },
+});
+
+async function getUserName(ctx, userId) {
+  if (userId === null) {
+    return null;
+  }
+  return (await ctx.db.get(userId))?.name;
+}
+```
+
+
+You can `export` helpers to use them across multiple files. They will not be
+callable from outside of your Convex functions.
+
+See
+[Type annotating server side helpers](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
+for more guidance on TypeScript types.
+
+## Using NPM packages
+
+Queries can import NPM packages installed in `node_modules`. Not all NPM
+packages are supported, see
+[Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details.
+
+```sh
+npm install @faker-js/faker
+```
+
+
+```ts
+import { query } from "./_generated/server";
+import { faker } from "@faker-js/faker";
+
+export const randomName = query({
+  args: {},
+  handler: () => {
+    faker.seed();
+    return faker.person.fullName();
+  },
+});
+```
+
+```ts
+import { query } from "./_generated/server";
+import { faker } from "@faker-js/faker";
+
+export const randomName = query({
+  args: {},
+  handler: () => {
+    faker.seed();
+    return faker.person.fullName();
+  },
+});
+```
+
+
+## Calling queries from clients
+
+To call a query from [React](/client/react.mdx) use the
+[`useQuery`](/client/react.mdx#fetching-data) hook along with the generated
+[`api`](/generated-api/api) object.
+
+
+```tsx
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const data = useQuery(api.myFunctions.sum, { a: 1, b: 2 });
+  // do something with `data`
+}
+```
+
+```tsx
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyApp() {
+  const data = useQuery(api.myFunctions.sum, { a: 1, b: 2 });
+  // do something with `data`
+}
+```
+
+
+See the [React](/client/react.mdx) client documentation for all the ways queries
+can be called.
+
+## Caching & reactivity & consistency
+
+Queries have three awesome attributes:
+
+1. **Caching**: Convex caches query results automatically. If many clients
+   request the same query, with the same arguments, they will receive a cached
+   response.
+2. **Reactivity**: clients can subscribe to queries to receive new results when
+   the underlying data changes.
+3. **Consistency**: All database reads inside a single query call are performed
+   at the same logical timestamp. Concurrent writes do not affect the query
+   results.
+
+To have these attributes the handler function must be _deterministic_, which
+means that given the same arguments (including the query context) it will return
+the same response.
+
+For this reason queries cannot `fetch` from third party APIs. To call third
+party APIs, use [actions](/functions/actions.mdx).
+
+You might wonder whether you can use non-deterministic language functionality
+like `Math.random()` or `Date.now()`. The short answer is that Convex takes care
+of implementing these in a way that you don't have to think about the
+deterministic constraint.
+
+See [Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details
+on the Convex runtime.
+
+## Limits
+
+Queries have a limit to the amount of data they can read at once to guarantee
+good performance. Check out these limits in
+[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).
+
+For information on other limits, see [Limits](/production/state/limits.mdx).
diff --git a/synced/convex/docs/functions/runtimes.md b/synced/convex/docs/functions/runtimes.md
new file mode 100644
index 0000000..db90359
--- /dev/null
+++ b/synced/convex/docs/functions/runtimes.md
@@ -0,0 +1,160 @@
+---
+title: Runtimes
+sidebar_position: 80
+---
+
+# Runtimes
+
+Convex functions can run in two runtimes:
+
+- Default [Convex runtime](#default-convex-runtime)
+- Opt-in [Node.js runtime](#nodejs-runtime)
+
+## Default Convex runtime
+
+All Convex backend functions are written in JavaScript or TypeScript. By default
+all functions run in a custom JavaScript runtime very similar to the
+[Cloudflare Workers runtime](https://blog.cloudflare.com/cloud-computing-without-containers/)
+with access to most
+[web standard globals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).
+
+The default runtime has many advantages including:
+
+- **No cold starts**. The runtime is always up, and ready to handle any function
+  at a moments notice.
+- **Latest web JavaScript standards**. The runtime is based on V8 that also
+  powers Google Chrome. This ensures it provides an interface very similar to
+  your frontend code, allowing further simplification to your code.
+- **Low overhead access to your data**. The runtime is designed to have low
+  overhead access to your data via query & mutation functions, allowing you to
+  access your database via a simple
+  [JavaScript interface](/database/reading-data/reading-data.mdx).
+
+### Supported APIs
+
+The default runtime supports most npm libraries that work in the browser,
+[Deno](https://deno.com/), and
+[Cloudflare workers](https://developers.cloudflare.com/workers/). If your
+library isn't supported, you can use an action with the
+[Node.js runtime](#nodejs-runtime), or reach out in
+[Discord](https://convex.dev/community). We are improving support all the time.
+
+#### Network APIs
+
+- [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
+- [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event)
+- [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)
+- [fetch](https://developer.mozilla.org/en-US/docs/Web/API/fetch) — in
+  [Actions](#actions) only
+- [File](https://developer.mozilla.org/en-US/docs/Web/API/File)
+- [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)
+- [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)
+- [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
+- [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)
+
+#### Encoding APIs
+
+- [TextDecoder](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder)
+- [TextEncoder](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder)
+- [atob](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob)
+- [btoa](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa)
+
+#### Web Stream APIs
+
+- [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
+- [ReadableStreamBYOBReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader)
+- [ReadableStreamDefaultReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader)
+- [TransformStream](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream)
+- [WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)
+- [WritableStreamDefaultWriter](https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultWriter)
+
+#### Web Crypto APIs
+
+- [crypto](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
+- [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)
+- [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)
+
+### Restrictions on queries and mutations
+
+Query and mutation functions are further **restricted by the runtime to be
+[deterministic](https://en.wikipedia.org/wiki/Deterministic_algorithm)**. This
+allows Convex to automatically retry them by the system as necessary.
+
+Determinism means that no matter how many times your function is run, as long as
+it is given the same arguments, it will have identical side effects and return
+the same value.
+
+You don't have to think all that much about maintaining these properties of
+determinism when you write your Convex functions. Convex will provide helpful
+error messages as you go, so you can't *accidentally* do something forbidden.
+
+#### Using randomness and time in queries and mutations
+
+Convex provides a "seeded" strong pseudo-random number generator
+at `Math.random()` so that it can guarantee the determinism of your function.
+The random number generator's seed is an implicit parameter to your function.
+Multiple calls to `Math.random()` in one function call will return different
+random values. Note that Convex does not reevaluate the Javascript modules on
+every function run, so a call to `Math.random()` stored in a global variable
+will not change between function runs.
+
+To ensure the logic within your function is reproducible, the system time used
+globally (outside of any function) is "frozen" at deploy time, while the system
+time during Convex function execution is "frozen" when the function
+begins. `Date.now()` will return the same result for the entirety of your
+function's execution. For example,
+
+```javascript
+const globalRand = Math.random(); // `globalRand` does not change between runs.
+const globalNow = Date.now(); // `globalNow` is the time when Convex functions were deployed.
+
+export const updateSomething = mutation({
+  args: {},
+  handler: () => {
+    const now1 = Date.now(); // `now1` is the time when the function execution started.
+    const rand1 = Math.random(); // `rand1` has a new value for each function run.
+    // implementation
+    const now2 = Date.now(); // `now2` === `now1`
+    const rand2 = Math.random(); // `rand1` !== `rand2`
+  },
+});
+```
+
+### Actions
+
+Actions are unrestricted by the same rules of determinism as query and mutation
+functions. Notably actions are allowed to call third-party HTTP endpoints via
+the browser-standard
+[`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) function.
+
+By default actions also run in Convex’s custom JavaScript runtime with all of
+its advantages including no cold starts and a browser-like API environment. They
+can also live in the same file as your query and mutation functions.
+
+## Node.js runtime
+
+Some JavaScript and TypeScript libraries use features that are not included in
+the default Convex runtime. This is why Convex actions provide an escape hatch
+to [Node.js 18](https://nodejs.org/en/about) via the `"use node"` directive at
+the top of a file that contains your action.
+[Learn more](/functions/actions.mdx#choosing-the-runtime-use-node).
+
+Use of the Node.js environment is restricted to **action functions only**. If
+you want to use a library designed for Node.js and interact with the Convex
+database, you need to call the Node.js library from an action, and use
+[`runQuery`](/functions/actions.mdx#action-context) or
+[`runMutation`](/functions/actions.mdx#action-context) helper to call a query or
+mutation.
+
+Every `.ts` and `.js` file in the convex directory
+[is bundled](/functions/bundling.mdx) either for the default Convex JavaScript
+runtime or Node.js, along with any code it imports.
+
+Files with the `"use node"` directive should not contain any Convex queries or
+mutations since they cannot be run in the Node.js runtime. Additionally, files
+without the `"use node"` directive should not import any files with the
+`"use node"` directive. Files that contain no Convex functions, like a
+`convex/utils.ts` file, also need the "use node" directive if they use
+Node.js-specific libraries.
+
+Note that argument size limits are lower (5MiB instead of 16MiB).
diff --git a/synced/convex/docs/functions/validation.md b/synced/convex/docs/functions/validation.md
new file mode 100644
index 0000000..c6c3094
--- /dev/null
+++ b/synced/convex/docs/functions/validation.md
@@ -0,0 +1,261 @@
+---
+title: "Argument and Return Value Validation"
+sidebar_label: "Validation"
+sidebar_position: 50
+---
+
+
+
+Argument and return value validators ensure that
+[queries](./query-functions.mdx), [mutations](./mutation-functions.mdx), and
+[actions](./actions.mdx) are called with the correct types of arguments and
+return the expected types of return values.
+
+**This is important for security!** Without argument validation, a malicious
+user can call your public functions with unexpected arguments and cause
+surprising results. [TypeScript](/understanding/best-practices/typescript) alone
+won't help because TypeScript types aren't present at runtime. We recommend
+adding argument validation for all public functions in production apps. For
+non-public functions that are not called by clients, we recommend
+[internal functions](/functions/internal-functions.mdx) and optionally
+validation.
+
+**Example:**
+[Argument Validation](https://github.com/get-convex/convex-demos/tree/main/args-validation)
+
+## Adding validators
+
+To add argument validation to your functions, pass an object with `args` and
+`handler` properties to the `query`, `mutation` or `action` constructor. To add
+return value validation, use the `returns` property in this object:
+
+
+```ts
+// @snippet start mutation
+import { mutation, query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const send = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  returns: v.null(),
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+// @snippet end mutation
+
+export const list = query({
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+```
+
+```ts
+// @snippet start mutation
+import { mutation, query } from "./_generated/server";
+import { v } from "convex/values";
+
+export const send = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  returns: v.null(),
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+// @snippet end mutation
+
+export const list = query({
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+```
+
+
+If you define your function with an argument validator, there is no need to
+include [TypeScript](/understanding/best-practices/typescript.mdx) type
+annotations! The type of your function will be inferred automatically.
+Similarly, if you define a return value validator, the return type of your
+function will be inferred from the validator, and TypeScript will check that it
+matches the inferred return type of the `handler` function.
+
+Unlike TypeScript, validation for an object will throw if the object contains
+properties that are not declared in the validator.
+
+If the client supplies arguments not declared in `args`, or if the function
+returns a value that does not match the validator declared in `returns`. This is
+helpful to prevent bugs caused by mistyped names of arguments or returning more
+data than intended to a client.
+
+Even `args: {}` is a helpful use of validators because TypeScript will show an
+error on the client if you try to pass any arguments to the function which
+doesn't expect them.
+
+## Supported types
+
+All functions, both public and internal, can accept and return the following
+data types. Each type has a corresponding validator that can be accessed on the
+[`v`](/api/modules/values#v) object imported from `"convex/values"`.
+
+The [database](/database.mdx) can store the exact same set of
+[data types](/database/types.md).
+
+Additionally you can also express type unions, literals, `any` types, and
+optional fields.
+
+### Convex values
+
+<ConvexValues />
+
+### Unions
+
+You can describe fields that could be one of multiple types using `v.union`:
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    stringOrNumber: v.union(v.string(), v.number()),
+  },
+  handler: async ({ db }, { stringOrNumber }) => {
+    //...
+  },
+});
+```
+
+### Literals
+
+Fields that are a constant can be expressed with `v.literal`. This is especially
+useful when combined with unions:
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    oneTwoOrThree: v.union(
+      v.literal("one"),
+      v.literal("two"),
+      v.literal("three"),
+    ),
+  },
+  handler: async ({ db }, { oneTwoOrThree }) => {
+    //...
+  },
+});
+```
+
+### Record objects
+
+You can describe objects that map arbitrary keys to values with `v.record`:
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    simpleMapping: v.record(v.string(), v.boolean()),
+  },
+  handler: async ({ db }, { simpleMapping }) => {
+    //...
+  },
+});
+```
+
+You can use other types of string validators for the keys:
+
+```typescript
+defineTable({
+  userIdToValue: v.record(v.id("users"), v.boolean()),
+});
+```
+
+Notes:
+
+- This type corresponds to the
+  [Record\<K,V\>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
+  type in TypeScript
+- You cannot use string literals as a `record` key
+- Using `v.string()` as a `record` key validator will only allow ASCII
+  characters
+
+### Any
+
+Fields that could take on any value can be represented with `v.any()`:
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    anyValue: v.any(),
+  },
+  handler: async ({ db }, { anyValue }) => {
+    //...
+  },
+});
+```
+
+This corresponds to the `any` type in TypeScript.
+
+### Optional fields
+
+You can describe optional fields by wrapping their type with `v.optional(...)`:
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    optionalString: v.optional(v.string()),
+    optionalNumber: v.optional(v.number()),
+  },
+  handler: async ({ db }, { optionalString, optionalNumber }) => {
+    //...
+  },
+});
+```
+
+This corresponds to marking fields as optional with `?` in TypeScript.
+
+## Extracting TypeScript types
+
+The [`Infer`](/api/modules/values#infer) type allows you to turn validator calls
+into TypeScript types. This can be useful to remove duplication between your
+validators and TypeScript types:
+
+```ts
+import { mutation } from "./_generated/server";
+import { Infer, v } from "convex/values";
+
+const nestedObject = v.object({
+  property: v.string(),
+});
+
+// Resolves to `{property: string}`.
+export type NestedObject = Infer<typeof nestedObject>;
+
+export default mutation({
+  args: {
+    nested: nestedObject,
+  },
+  handler: async ({ db }, { nested }) => {
+    //...
+  },
+});
+```
diff --git a/synced/convex/docs/generated-api/_category_.json b/synced/convex/docs/generated-api/_category_.json
new file mode 100644
index 0000000..336d578
--- /dev/null
+++ b/synced/convex/docs/generated-api/_category_.json
@@ -0,0 +1,3 @@
+{
+  "label": "Generated Code"
+}
diff --git a/synced/convex/docs/generated-api/api.md b/synced/convex/docs/generated-api/api.md
new file mode 100644
index 0000000..f0a2760
--- /dev/null
+++ b/synced/convex/docs/generated-api/api.md
@@ -0,0 +1,56 @@
+---
+title: "api.js"
+sidebar_position: 2
+---
+
+<Admonition type="caution" title="This code is generated">
+
+These exports are not directly available in the `convex` package!
+
+Instead you need to run `npx convex dev` to create `convex/_generated/api.js`
+and `convex/_generated/api.d.ts`.
+
+</Admonition>
+
+These types require running code generation because they are specific to the
+Convex functions you define for your app.
+
+If you aren't using code generation, you can use
+[`makeFunctionReference`](/api/modules/server#makefunctionreference) instead.
+
+### api
+
+An object of type `API` describing your app's public Convex API.
+
+Its `API` type includes information about the arguments and return types of your
+app's Convex functions.
+
+The api object is used by client-side React hooks and Convex functions that run
+or schedule other functions.
+
+```javascript title="src/App.jsx"
+import { api } from "../convex/_generated/api";
+import { useQuery } from "convex/react";
+
+const data = useQuery(api.messages.list);
+```
+
+### internal
+
+Another object of type `API` describing your app's internal Convex API.
+
+```js title="convex/upgrade.js"
+import { action } from "../_generated/server";
+import { internal } from "../_generated/api";
+
+export default action({
+  handler: async ({ runMutation }, { planId, ... }) => {
+    // Call out to payment provider (e.g. Stripe) to charge customer
+    const response = await fetch(...);
+    if (response.ok) {
+      // Mark the plan as "professional" in the Convex DB
+      await runMutation(internal.plans.markPlanAsProfessional, { planId });
+    }
+  },
+});
+```
diff --git a/synced/convex/docs/generated-api/data-model.md b/synced/convex/docs/generated-api/data-model.md
new file mode 100644
index 0000000..b018edc
--- /dev/null
+++ b/synced/convex/docs/generated-api/data-model.md
@@ -0,0 +1,75 @@
+---
+title: "dataModel.d.ts"
+sidebar_position: 1
+---
+
+<Admonition type="caution" title="This code is generated">
+
+These exports are not directly available in the `convex` package!
+
+Instead you must run `npx convex dev` to create
+`convex/_generated/dataModel.d.ts`.
+
+</Admonition>
+
+Generated data model types.
+
+## Types
+
+### TableNames
+
+Ƭ **TableNames**: `string`
+
+The names of all of your Convex tables.
+
+---
+
+### Doc
+
+Ƭ **Doc**`<TableName>`: `Object`
+
+The type of a document stored in Convex.
+
+#### Type parameters
+
+| Name        | Type                                | Description                                             |
+| :---------- | :---------------------------------- | :------------------------------------------------------ |
+| `TableName` | extends [`TableNames`](#tablenames) | A string literal type of the table name (like "users"). |
+
+---
+
+### Id
+
+An identifier for a document in Convex.
+
+Convex documents are uniquely identified by their `Id`, which is accessible on
+the `_id` field. To learn more, see [Document IDs](/database/document-ids.mdx).
+
+Documents can be loaded using `db.get(id)` in query and mutation functions.
+
+IDs are just strings at runtime, but this type can be used to distinguish them
+from other strings when type checking.
+
+This is an alias of [`GenericId`](/api/modules/values#genericid) that is typed
+for your data model.
+
+#### Type parameters
+
+| Name        | Type                                | Description                                             |
+| :---------- | :---------------------------------- | :------------------------------------------------------ |
+| `TableName` | extends [`TableNames`](#tablenames) | A string literal type of the table name (like "users"). |
+
+---
+
+### DataModel
+
+Ƭ **DataModel**: `Object`
+
+A type describing your Convex data model.
+
+This type includes information about what tables you have, the type of documents
+stored in those tables, and the indexes defined on them.
+
+This type is used to parameterize methods like
+[`queryGeneric`](/api/modules/server#querygeneric) and
+[`mutationGeneric`](/api/modules/server#mutationgeneric) to make them type-safe.
diff --git a/synced/convex/docs/generated-api/index.md b/synced/convex/docs/generated-api/index.md
new file mode 100644
index 0000000..e1a3e45
--- /dev/null
+++ b/synced/convex/docs/generated-api/index.md
@@ -0,0 +1,23 @@
+---
+title: Generated Code
+---
+
+Convex uses code generation to create code that is specific to your app's data
+model and API. Convex generates JavaScript files (`.js`) with TypeScript type
+definitions (`.d.ts`).
+
+Code generation isn't required to use Convex, but using the generated code will
+give you more better autocompletion in your editor and more type safety if
+you're using TypeScript.
+
+To generate the code, run:
+
+```
+npx convex dev
+```
+
+This creates a `convex/_generated` directory that contains:
+
+- [`api.js` and `api.d.ts`](./api.md)
+- [`dataModel.d.ts`](./data-model.md)
+- [`server.js` and `server.d.ts`](./server.md)
diff --git a/synced/convex/docs/generated-api/server.md b/synced/convex/docs/generated-api/server.md
new file mode 100644
index 0000000..64dd40b
--- /dev/null
+++ b/synced/convex/docs/generated-api/server.md
@@ -0,0 +1,305 @@
+---
+title: "server.js"
+sidebar_position: 4
+---
+
+<Admonition type="caution" title="This code is generated">
+
+These exports are not directly available in the `convex` package!
+
+Instead you must run `npx convex dev` to create `convex/_generated/server.js`
+and `convex/_generated/server.d.ts`.
+
+</Admonition>
+
+Generated utilities for implementing server-side Convex query and mutation
+functions.
+
+## Functions
+
+### query
+
+▸ **query**(`func`): [`RegisteredQuery`](/api/modules/server#registeredquery)
+
+Define a query in this Convex app's public API.
+
+This function will be allowed to read your Convex database and will be
+accessible from the client.
+
+This is an alias of [`queryGeneric`](/api/modules/server#querygeneric) that is
+typed for your app's data model.
+
+#### Parameters
+
+| Name   | Description                                                                             |
+| :----- | :-------------------------------------------------------------------------------------- |
+| `func` | The query function. It receives a [QueryCtx](server.md#queryctx) as its first argument. |
+
+#### Returns
+
+[`RegisteredQuery`](/api/modules/server#registeredquery)
+
+The wrapped query. Include this as an `export` to name it and make it
+accessible.
+
+---
+
+### internalQuery
+
+▸ **internalQuery**(`func`):
+[`RegisteredQuery`](/api/modules/server#registeredquery)
+
+Define a query that is only accessible from other Convex functions (but not from
+the client).
+
+This function will be allowed to read from your Convex database. It will not be
+accessible from the client.
+
+This is an alias of
+[`internalQueryGeneric`](/api/modules/server#internalquerygeneric) that is typed
+for your app's data model.
+
+#### Parameters
+
+| Name   | Description                                                                             |
+| :----- | :-------------------------------------------------------------------------------------- |
+| `func` | The query function. It receives a [QueryCtx](server.md#queryctx) as its first argument. |
+
+#### Returns
+
+[`RegisteredQuery`](/api/modules/server#registeredquery)
+
+The wrapped query. Include this as an `export` to name it and make it
+accessible.
+
+---
+
+### mutation
+
+▸ **mutation**(`func`):
+[`RegisteredMutation`](/api/modules/server#registeredmutation)
+
+Define a mutation in this Convex app's public API.
+
+This function will be allowed to modify your Convex database and will be
+accessible from the client.
+
+This is an alias of [`mutationGeneric`](/api/modules/server#mutationgeneric)
+that is typed for your app's data model.
+
+#### Parameters
+
+| Name   | Description                                                                             |
+| :----- | :-------------------------------------------------------------------------------------- |
+| `func` | The mutation function. It receives a [MutationCtx](#mutationctx) as its first argument. |
+
+#### Returns
+
+[`RegisteredMutation`](/api/modules/server#registeredmutation)
+
+The wrapped mutation. Include this as an `export` to name it and make it
+accessible.
+
+---
+
+### internalMutation
+
+▸ **internalMutation**(`func`):
+[`RegisteredMutation`](/api/modules/server#registeredmutation)
+
+Define a mutation that is only accessible from other Convex functions (but not
+from the client).
+
+This function will be allowed to read and write from your Convex database. It
+will not be accessible from the client.
+
+This is an alias of
+[`internalMutationGeneric`](/api/modules/server#internalmutationgeneric) that is
+typed for your app's data model.
+
+#### Parameters
+
+| Name   | Description                                                                                      |
+| :----- | :----------------------------------------------------------------------------------------------- |
+| `func` | The mutation function. It receives a [MutationCtx](server.md#mutationctx) as its first argument. |
+
+#### Returns
+
+[`RegisteredMutation`](/api/modules/server#registeredmutation)
+
+The wrapped mutation. Include this as an `export` to name it and make it
+accessible.
+
+---
+
+### action
+
+▸ **action**(`func`): [`RegisteredAction`](/api/modules/server#registeredaction)
+
+Define an action in this Convex app's public API.
+
+An action is a function which can execute any JavaScript code, including
+non-deterministic code and code with side-effects, like calling third-party
+services. They can be run in Convex's JavaScript environment or in Node.js using
+the `"use node"` directive. They can interact with the database indirectly by
+calling queries and mutations using the [`ActionCtx`](#actionctx).
+
+This is an alias of [`actionGeneric`](/api/modules/server#actiongeneric) that is
+typed for your app's data model.
+
+#### Parameters
+
+| Name   | Description                                                                        |
+| :----- | :--------------------------------------------------------------------------------- |
+| `func` | The action function. It receives an [ActionCtx](#actionctx) as its first argument. |
+
+#### Returns
+
+[`RegisteredAction`](/api/modules/server#registeredaction)
+
+The wrapped function. Include this as an `export` to name it and make it
+accessible.
+
+---
+
+### internalAction
+
+▸ **internalAction**(`func`):
+[`RegisteredAction`](/api/modules/server#registeredaction)
+
+Define an action that is only accessible from other Convex functions (but not
+from the client).
+
+This is an alias of
+[`internalActionGeneric`](/api/modules/server#internalactiongeneric) that is
+typed for your app's data model.
+
+#### Parameters
+
+| Name   | Description                                                                                 |
+| :----- | :------------------------------------------------------------------------------------------ |
+| `func` | The action function. It receives an [ActionCtx](server.md#actionctx) as its first argument. |
+
+#### Returns
+
+[`RegisteredAction`](/api/modules/server#registeredaction)
+
+The wrapped action. Include this as an `export` to name it and make it
+accessible.
+
+---
+
+### httpAction
+
+▸
+**httpAction**(`func: (ctx: ActionCtx, request: Request) => Promise<Response>`):
+[`PublicHttpAction`](/api/modules/server#publichttpaction)
+
+#### Parameters
+
+| Name   | Type                                                      | Description                                                                                                                                                                                         |
+| :----- | :-------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `func` | `(ctx: ActionCtx, request: Request) => Promise<Response>` | The function. It receives an [`ActionCtx`](/api/modules/server#actionctx) as its first argument and a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) as its second argument. |
+
+#### Returns
+
+[`PublicHttpAction`](/api/modules/server#publichttpaction)
+
+The wrapped function. Import this function from `convex/http.js` and route it to
+hook it up.
+
+## Types
+
+### QueryCtx
+
+Ƭ **QueryCtx**: `Object`
+
+A set of services for use within Convex query functions.
+
+The query context is passed as the first argument to any Convex query function
+run on the server.
+
+This differs from the [MutationCtx](#mutationctx) because all of the services
+are read-only.
+
+This is an alias of [`GenericQueryCtx`](/api/interfaces/server.GenericQueryCtx)
+that is typed for your app's data model.
+
+#### Type declaration
+
+| Name      | Type                                                       |
+| :-------- | :--------------------------------------------------------- |
+| `db`      | [`DatabaseReader`](#databasereader)                        |
+| `auth`    | [`Auth`](/api/interfaces/server.Auth.md)                   |
+| `storage` | [`StorageReader`](/api/interfaces/server.StorageReader.md) |
+
+---
+
+### MutationCtx
+
+Ƭ **MutationCtx**: `Object`
+
+A set of services for use within Convex mutation functions.
+
+The mutation context is passed as the first argument to any Convex mutation
+function run on the server.
+
+This is an alias of
+[`GenericMutationCtx`](/api/interfaces/server.GenericMutationCtx) that is typed
+for your app's data model.
+
+#### Type declaration
+
+| Name        | Type                                                       |
+| :---------- | :--------------------------------------------------------- |
+| `db`        | [`DatabaseWriter`](#databasewriter)                        |
+| `auth`      | [`Auth`](/api/interfaces/server.Auth.md)                   |
+| `storage`   | [`StorageWriter`](/api/interfaces/server.StorageWriter.md) |
+| `scheduler` | [`Scheduler`](/api/interfaces/server.Scheduler.md)         |
+
+---
+
+### ActionCtx
+
+Ƭ **ActionCtx**: `Object`
+
+A set of services for use within Convex action functions.
+
+The action context is passed as the first argument to any Convex action function
+run on the server.
+
+This is an alias of [`ActionCtx`](/api/modules/server#actionctx) that is typed
+for your app's data model.
+
+#### Type declaration
+
+| Name           | Type                                                                                                                                                                         |
+| :------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `runQuery`     | (`name`: `string`, `args`?: `Record<string, Value>`) => `Promise<Value>`                                                                                                     |
+| `runMutation`  | (`name`: `string`, `args`?: `Record<string, Value>`) => `Promise<Value>`                                                                                                     |
+| `runAction`    | (`name`: `string`, `args`?: `Record<string, Value>`) => `Promise<Value>`                                                                                                     |
+| `auth`         | [`Auth`](/api/interfaces/server.Auth.md)                                                                                                                                     |
+| `scheduler`    | [`Scheduler`](/api/interfaces/server.Scheduler.md)                                                                                                                           |
+| `storage`      | [`StorageActionWriter`](/api/interfaces/server.StorageActionWriter.md)                                                                                                       |
+| `vectorSearch` | (`tableName`: `string`, `indexName`: `string`, `query`: [`VectorSearchQuery`](/api/interfaces/server.VectorSearchQuery.md)) => `Promise<Array<{ _id: Id, _score: number }>>` |
+
+---
+
+### DatabaseReader
+
+An interface to read from the database within Convex query functions.
+
+This is an alias of
+[`GenericDatabaseReader`](/api/interfaces/server.GenericDatabaseReader) that is
+typed for your app's data model.
+
+---
+
+### DatabaseWriter
+
+An interface to read from and write to the database within Convex mutation
+functions.
+
+This is an alias of
+[`GenericDatabaseWriter`](/api/interfaces/server.GenericDatabaseWriter) that is
+typed for your app's data model.
diff --git a/synced/convex/docs/home.md b/synced/convex/docs/home.md
new file mode 100644
index 0000000..3c01427
--- /dev/null
+++ b/synced/convex/docs/home.md
@@ -0,0 +1,146 @@
+---
+title: "Convex Docs"
+slug: "home"
+hide_table_of_contents: true
+---
+
+
+import {
+  QuickFrameworksList,
+  QuickLanguagesList,
+} from "@site/src/QuickstartsList.tsx";
+import { LargeCardList } from "@site/src/QuickstartsList.tsx";
+import { YouTubeList } from "@site/src/YouTubeLink.tsx";
+
+Convex is the open source, reactive database where queries are TypeScript code
+running right in the database. Just like React components react to state
+changes, Convex queries react to database changes.
+
+Convex provides a database, a place to write your server functions, and client
+libraries. It makes it easy to build and scale dynamic live-updating apps.
+
+<LargeCardList
+  items={[
+    {
+      title: "Tutorial: Build a chat app",
+      description:
+        "Follow a step-by-step tutorial to build your first Convex app - a real-time chat application.",
+      href: "/tutorial",
+    },
+    {
+      title: "Understanding Convex",
+      description:
+        "Learn about the core concepts and architecture that make Convex unique and powerful.",
+      href: "/understanding",
+    },
+  ]}
+/>
+
+## Get Started
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "https://chef.convex.dev",
+    label: "Prompt to start an app with Convex Chef",
+  }}
+/>
+
+Your favorite frameworks:
+
+<QuickFrameworksList />
+
+Your favorite languages:
+
+<QuickLanguagesList />
+
+## Why Convex?
+
+<YouTubeList
+  items={[
+    {
+      src: "https://www.youtube.com/embed/Xjud1weG4z8?si=OMMfKzK_Dp8RgmgM",
+      label: "Backends for Product Developers",
+    },
+    {
+      src: "https://www.youtube.com/embed/UVvd7BF99-4?si=Z9_pLHMnpL9kaduE",
+      label: "Intro to Convex",
+    },
+    {
+      src: "https://www.youtube.com/embed/V6En7UO4Ui0?si=kcj1aftxV-tqe9Q-",
+      label: "Supercharging your app with a reactive backend",
+    },
+
+    {
+      src: "https://www.youtube.com/embed/O_HXVAMPEbc?si=qtA8nLyGjGUsXVkL",
+      label: "Why I use Convex over Supabase as my BaaS",
+    },
+
+]} />
+
+Read the team's Perspectives on [Stack](https://stack.convex.dev):
+
+<DocCardList
+  items={[
+    {
+      type: "link",
+      href: "https://stack.convex.dev/convex-vs-relational-databases",
+      label: "Convex vs Relational Databases",
+    },
+    {
+      type: "link",
+      href: "https://stack.convex.dev/convex-vs-firebase",
+      label: "Convex vs Firebase",
+    },
+    {
+      type: "link",
+      href: "https://stack.convex.dev/how-convex-works",
+      label: "How Convex Works",
+    },
+  ]}
+/>
+
+## Learn Convex
+
+<YouTubeList
+  items={[
+    {
+      src: "https://www.youtube.com/embed/vaQZYRSiimI?si=JLfdVVs3QkCLTZwc",
+      label: "Convex with Next.js Quickstart",
+    },
+    {
+      src: "https://www.youtube.com/embed/0OaDyjB9Ib8?si=V5_9FN3UieZmnOM5",
+      label: "Notion Clone: Next.js 13, React, Convex, Tailwind",
+    },
+    {
+      src: "https://www.youtube.com/embed/zfAb95tJvZQ?si=PaiBxNxCO0s2BuEZ",
+      label: "Build a Saas Podcast Platform in Next.js",
+    },
+    {
+      src: "https://www.youtube.com/embed/Vjtn9pWAZDI?si=of21uqly5laJQJAs",
+      label: "Building a Subscription Based SaaS with Stripe",
+    },
+
+]} />
+
+See more walkthroughs and patterns on [Stack](https://stack.convex.dev)
+
+<DocCardList
+  items={[
+    {
+      type: "link",
+      href: "https://stack.convex.dev/tag/AI",
+      label: "Build AI Apps",
+    },
+    {
+      type: "link",
+      href: "https://stack.convex.dev/tag/Patterns",
+      label: "Convex Patterns",
+    },
+    {
+      type: "link",
+      href: "https://stack.convex.dev/tag/Walkthroughs",
+      label: "Convex Walkthroughs",
+    },
+  ]}
+/>
diff --git a/synced/convex/docs/http-api/_category_.json b/synced/convex/docs/http-api/_category_.json
new file mode 100644
index 0000000..196eb9e
--- /dev/null
+++ b/synced/convex/docs/http-api/_category_.json
@@ -0,0 +1,3 @@
+{
+  "label": "HTTP API"
+}
diff --git a/synced/convex/docs/http-api/index.md b/synced/convex/docs/http-api/index.md
new file mode 100644
index 0000000..67b4603
--- /dev/null
+++ b/synced/convex/docs/http-api/index.md
@@ -0,0 +1,433 @@
+---
+title: "Convex HTTP API"
+sidebar_label: "HTTP API"
+description: "Connecting to Convex directly with HTTP"
+---
+
+import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';
+
+# HTTP APIs
+
+HTTP APIs include:
+
+- [Functions API](#functions-api)
+- [Streaming export API](#streaming-export-api)
+- [Streaming import API](#streaming-import-api)
+
+## Convex value format
+
+Each of the HTTP APIs take a `format` query param that describes how documents
+are formatted. Currently the only supported value is `json`. See our
+[types page](/database/types#convex-values) for details. Note that for
+simplicity, the `json` format does not support all Convex data types as input,
+and uses overlapping representation for several data types in output. We plan to
+add a new format with support for all Convex data types in the future.
+
+## API authentication
+
+The Functions API can be optionally authenticated as a user via a bearer token
+in a `Authorization` header. The value is `Bearer <access_key>` where the key is
+a token from your auth provider. See the
+[under the hood](/auth/clerk#under-the-hood) portion of the Clerk docs for
+details on how this works with Clerk.
+
+Streaming export and streaming import requests require deployment admin
+authorization via the HTTP header `Authorization`. The value is
+`Convex <access_key>` where the access key comes from "Deploy key" on the Convex
+dashboard and gives full read and write access to your Convex data.
+
+## Functions API
+
+### POST `/api/query`, `/api/mutation`, `/api/action`
+
+These HTTP endpoints allow you to call Convex functions and get the result as a
+value.
+
+You can find your backend deployment URL on the dashboard
+[Settings](/dashboard/deployments/settings.md) page, then the API URL will be
+`<CONVEX_URL>/api/query` etc., for example:
+
+<Tabs>
+<TabItem value="shell" label="Shell">
+
+```
+curl https://acoustic-panther-728.convex.cloud/api/query \
+   -d '{"path": "messages:list", "args": {}, "format": "json"}' \
+   -X POST -H "Content-Type: application/json"
+```
+
+</TabItem>
+<TabItem value="js" label="NodeJS">
+
+```js
+const url = "https://acoustic-panther-728.convex.cloud/api/query";
+const request = { path: "messages:list", args: {}, format: "json" };
+
+const response = fetch(url, {
+  method: "POST",
+  headers: {
+    "Content-Type": "application/json",
+  },
+  body: JSON.stringify(request),
+});
+```
+
+</TabItem>
+<TabItem value="py" label="Python">
+
+```py
+import requests
+
+url = "https://acoustic-panther-728.convex.cloud/api/query"
+headers = {"accept": "application/json"}
+body = {"path": "messages:list", "args": {}, "format": "json"}
+
+response = requests.post(url, headers=headers, json=body)
+```
+
+</TabItem>
+</Tabs>
+
+**JSON Body parameters**
+
+| Name   | Type   | Required | Description                                                                                                  |
+| ------ | ------ | -------- | ------------------------------------------------------------------------------------------------------------ |
+| path   | string | y        | Path to the Convex function formatted as a string as defined [here](/functions/query-functions#query-names). |
+| args   | object | y        | Named argument object to pass to the Convex function.                                                        |
+| format | string | n        | Output format for values. Valid values: [`json`]                                                             |
+
+**Result JSON on success**
+
+| Field Name | Type         | Description                                            |
+| ---------- | ------------ | ------------------------------------------------------ |
+| status     | string       | "success"                                              |
+| value      | object       | Result of the Convex function in the requested format. |
+| logLines   | list[string] | Log lines printed out during the function execution.   |
+
+**Result JSON on error**
+
+| Field Name   | Type         | Description                                                                                              |
+| ------------ | ------------ | -------------------------------------------------------------------------------------------------------- |
+| status       | string       | "error"                                                                                                  |
+| errorMessage | string       | The error message.                                                                                       |
+| errorData    | object       | Error data within an [application error](/functions/error-handling/application-errors) if it was thrown. |
+| logLines     | list[string] | Log lines printed out during the function execution.                                                     |
+
+### POST `/api/run/{functionIdentifier}`
+
+This HTTP endpoint allows you to call arbitrary Convex function types with the
+path in the request URL and get the result as a value. The function identifier
+is formatted as a string as defined
+[here](/functions/query-functions#query-names) with a `/` replacing the `:`.
+
+You can find your backend deployment URL on the dashboard
+[Settings](/dashboard/deployments/settings.md) page, then the API URL will be
+`<CONVEX_URL>/api/run/{functionIdentifier}` etc., for example:
+
+<Tabs>
+<TabItem value="shell" label="Shell">
+
+```
+curl https://acoustic-panther-728.convex.cloud/api/run/messages/list \
+   -d '{"args": {}, "format": "json"}' \
+   -X POST -H "Content-Type: application/json"
+```
+
+</TabItem>
+<TabItem value="js" label="NodeJS">
+
+```js
+const url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list";
+const request = { args: {}, format: "json" };
+
+const response = fetch(url, {
+  method: "POST",
+  headers: {
+    "Content-Type": "application/json",
+  },
+  body: JSON.stringify(request),
+});
+```
+
+</TabItem>
+<TabItem value="py" label="Python">
+
+```py
+import requests
+
+url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list"
+headers = {"accept": "application/json"}
+body = {"args": {}, "format": "json"}
+
+response = requests.get(url, headers=headers, body=json)
+```
+
+</TabItem>
+</Tabs>
+
+**JSON Body parameters**
+
+| Name   | Type   | Required | Description                                                          |
+| ------ | ------ | -------- | -------------------------------------------------------------------- |
+| args   | object | y        | Named argument object to pass to the Convex function.                |
+| format | string | n        | Output format for values. Defaults to `json`. Valid values: [`json`] |
+
+**Result JSON on success**
+
+| Field Name | Type         | Description                                            |
+| ---------- | ------------ | ------------------------------------------------------ |
+| status     | string       | "success"                                              |
+| value      | object       | Result of the Convex function in the requested format. |
+| logLines   | list[string] | Log lines printed out during the function execution.   |
+
+**Result JSON on error**
+
+| Field Name   | Type         | Description                                                                                              |
+| ------------ | ------------ | -------------------------------------------------------------------------------------------------------- |
+| status       | string       | "error"                                                                                                  |
+| errorMessage | string       | The error message.                                                                                       |
+| errorData    | object       | Error data within an [application error](/functions/error-handling/application-errors) if it was thrown. |
+| logLines     | list[string] | Log lines printed out during the function execution.                                                     |
+
+## Streaming export API
+
+Convex supports streaming export. Convex provides connector implementations for
+[Fivetran and Airbyte](/production/integrations/streaming-import-export.md).
+Those connectors use the following APIs.
+
+Sign up for a [Professional plan](https://www.convex.dev/pricing) for streaming
+export support. You can also read the
+[documentation on streaming export](/production/integrations/streaming-import-export.md).
+
+<BetaAdmonition feature="Streaming Export HTTP APIs" verb="are" />
+
+### GET `/api/json_schemas`
+
+The JSON Schemas endpoint lists tables, and for each table describes how
+documents will be encoded, given as [JSON Schema](https://json-schema.org/).
+This endpoint returns `$description` tags throughout the schema to describe
+unintuitive encodings and give extra information like the table referenced by
+`Id` fields.
+
+**Query parameters**
+
+| Name        | Type    | Required | Description                                                                                                     |
+| ----------- | ------- | -------- | --------------------------------------------------------------------------------------------------------------- |
+| deltaSchema | boolean | n        | If set, include metadata fields returned by document_deltas and list_snapshot (`_ts`, `_deleted`, and `_table`) |
+| format      | string  | n        | Output format for values. Valid values: [`json`]                                                                |
+
+### GET `/api/list_snapshot`
+
+The `list_snapshot` endpoint walks a consistent snapshot of documents. It may
+take one or more calls to `list_snapshot` to walk a full snapshot.
+
+**Query parameters**
+
+| Name      | Type   | Required | Description                                                                                                                                  |
+| --------- | ------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
+| snapshot  | int    | n        | Database timestamp at which to continue the snapshot. The timestamp must not be older than 30 days. If omitted, select the latest timestamp. |
+| cursor    | string | n        | An opaque cursor representing the progress in paginating through the snapshot. If omitted, start from the first page of the snapshot.        |
+| tableName | string | n        | If provided, filters the snapshot to a table. If omitted, provide snapshot across all tables.                                                |
+| format    | string | n        | Output format for values. Valid values: [`json`]                                                                                             |
+
+**Result JSON**
+
+| Field Name | Type              | Description                                                                                             |
+| ---------- | ----------------- | ------------------------------------------------------------------------------------------------------- |
+| values     | List[ConvexValue] | List of convex values in the requested format. Each value includes extra fields `_ts` and `_table`.     |
+| hasMore    | boolean           | True if there are more pages to the snapshot.                                                           |
+| snapshot   | int               | A value that represents the database timestamp at which the snapshot was taken.                         |
+| cursor     | string            | An opaque cursor representing the end of the progress on the given page. Pass this to subsequent calls. |
+
+Expected API usage (pseudocode):
+
+```python
+def list_full_snapshot()
+    snapshot_values = []
+    snapshot = None
+    cursor = None
+    while True:
+        result = api.list_snapshot(cursor, snapshot)
+        snapshot_values.extend(result.values)
+        (cursor, snapshot) = (result.cursor, result.snapshot)
+        if !result.hasMore:
+            break
+    return (snapshot_values, result.snapshot)
+```
+
+### GET `/api/document_deltas`
+
+The `document_deltas` endpoint walks the change log of documents to find new,
+updated, and deleted documents in the order of their mutations. This order is
+given by a `_ts` field on the returned documents. Deletions are represented as
+JSON objects with fields `_id`, `_ts`, and `_deleted: true`.
+
+**Query parameters**
+
+| Name      | Type   | Required | Description                                                                                                                              |
+| --------- | ------ | -------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
+| cursor    | int    | y        | Database timestamp after which to continue streaming document deltas. Initial value is the `snapshot` field returned from list_snapshot. |
+| tableName | string | n        | If provided, filters the document deltas to a table. If omitted, provide deltas across all tables.                                       |
+| format    | string | n        | Output format for values. Valid values: [`json`]                                                                                         |
+
+**Result JSON**
+
+| Field Name | Type              | Description                                                                                                                                    |
+| ---------- | ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
+| values     | List[ConvexValue] | List of convex values in the requested format. Each value includes extra fields for `_ts`, and `_table`. Deletions include a field `_deleted`. |
+| hasMore    | boolean           | True if there are more pages to the snapshot.                                                                                                  |
+| cursor     | int               | A value that represents the database timestamp at the end of the page. Pass to subsequent calls to document_deltas.                            |
+
+Expected API usage (pseudocode):
+
+```python
+def delta_sync(delta_cursor):
+    delta_values = []
+    while True:
+        result = api.document_deltas(cursor)
+        delta_values.extend(result.values)
+        cursor = result.cursor
+        if !hasMore:
+            break
+    return (delta_values, delta_cursor)
+
+(snapshot_values, delta_cursor) = list_full_snapshot()
+(delta_values, delta_cursor) = delta_sync(delta_cursor)
+# Save delta_cursor for the next sync
+```
+
+## Streaming import API
+
+Convex supports streaming import. Convex provides a connector implementation for
+[Airbyte](/production/integrations/streaming-import-export.md). Those connectors
+use the following APIs.
+
+Streaming import support is automatically enabled for all Convex projects.
+
+### Headers
+
+Streaming import endpoints accept a `Convex-Client: streaming-import-<version>`
+header, where the version follows [Semver](https://semver.org/) guidelines. If
+this header is not specified, Convex will default to the latest version. We
+recommend using the header to ensure the consumer of this API does not break as
+the API changes.
+
+### GET `/api/streaming_import/primary_key_indexes_ready`
+
+The `primary_key_indexes_ready` endpoint takes a list of table names and returns
+true if the primary key indexes (created by `add_primary_key_indexes`) on all
+those tables are ready. If the tables are newly created, the indexes should be
+ready immediately; however if there are existing documents in the tables, it may
+take some time to backfill the primary key indexes. The response looks like:
+
+```json
+{
+  "indexesReady": true
+}
+```
+
+### PUT `/api/streaming_import/add_primary_key_indexes`
+
+The `add_primary_key_indexes` endpoint takes a JSON body containing the primary
+keys for tables and creates indexes on the primary keys to be backfilled. Note
+that they are not immediately ready to query - the `primary_key_indexes_ready`
+endpoint needs to be polled until it returns True before calling
+`import_airbyte_records` with records that require primary key indexes. Also
+note that Convex queries will not have access to these added indexes. These are
+solely for use in `import_airbyte_records`. The body takes the form of a map of
+index names to list of field paths to index. Each field path is represented by a
+list of fields that can represent nested field paths.
+
+```json
+{
+  "indexes": {
+    "<table_name>": [["<field1>"], ["<field2>", "<nested_field>"]]
+  }
+}
+```
+
+Expected API Usage:
+
+1. Add indexes for primary keys by making a request to
+   `add_primary_key_indexes`.
+2. Poll `primary_key_indexes_ready` until the response is true.
+3. Query using the added indexes.
+
+### PUT `api/streaming_import/clear_tables`
+
+The `clear_tables` endpoint deletes all documents from the specified tables.
+Note that this may require multiple transactions. If there is an intermediate
+error only some documents may be deleted. The JSON body to use this API request
+contains a list of table names:
+
+```json
+{
+  "tableNames": ["<table_1>", "<table_2>"]
+}
+```
+
+### POST `api/streaming_import/replace_tables`
+
+This endpoint is no longer supported. Use `api/streaming_import/clear_tables`
+instead.
+
+The `replace_tables` endpoint renames tables with temporary names to their final
+names, deleting any existing tables with the final names.
+
+The JSON body to use this API request contains a list of table names:
+
+```json
+{
+  "tableNames": { "<table_1_temp>": "<table_1>", "<table_2_temp>": "<table_2>" }
+}
+```
+
+### POST `api/streaming_import/import_airbyte_records`
+
+The `import_airbyte_records` endpoint enables streaming ingress into a Convex
+deployment and is designed to be called from an Airbyte destination connector.
+
+It takes a map of streams and a list of messages in the JSON body. Each stream
+has a name and JSON schema that will correspond to a Convex table. Streams where
+records should be deduplicated include a primary key as well, which is
+represented as a list of lists of strings that are field paths. Records for
+streams without a primary key are appended to tables; records for streams with a
+primary key replace an existing record where the primary key value matches or
+are appended if there is no match. If you are using primary keys, you must call
+the `add_primary_key_indexes` endpoint first and wait for them to backfill by
+polling `primary_key_indexes_ready`.
+
+Each message contains a stream name and a JSON document that will be inserted
+(or replaced, in the case of deduplicated sync) into the table with the
+corresponding stream name. Table names are same as the stream names. Airbyte
+records become Convex documents.
+
+```json
+{
+   "tables": {
+      "<stream_name>": {
+         "primaryKey": [["<field1>"], ["<field2>", "<nested_field>"]],
+         "jsonSchema": // see https://json-schema.org/ for examples
+      }
+   },
+   "messages": [{
+      "tableName": "<table_name>",
+      "data": {} // JSON object conforming to the `json_schema` for that stream
+   }]
+}
+```
+
+Similar to `clear_tables`, it is possible to execute a partial import using
+`import_airbyte_records` if there is a failure after a transaction has
+committed.
+
+Expected API Usage:
+
+1. [Optional] Add any indexes if using primary keys and
+   [deduplicated sync](https://docs.airbyte.com/understanding-airbyte/connections/incremental-deduped-history/)
+   (see `add_primary_key_indexes` above).
+2. [Optional] Delete all documents in specified tables using `clear_tables` if
+   using
+   [overwrite sync](https://docs.airbyte.com/understanding-airbyte/connections/full-refresh-overwrite).
+3. Make a request to `import_airbyte_records` with new records to sync and
+   stream information.
diff --git a/synced/convex/docs/production.md b/synced/convex/docs/production.md
new file mode 100644
index 0000000..bc356a4
--- /dev/null
+++ b/synced/convex/docs/production.md
@@ -0,0 +1,120 @@
+---
+title: "Deploying Your App to Production"
+hide_table_of_contents: true
+pagination_prev: search
+---
+
+Convex is built to serve live, production app traffic. Here we cover how to
+deploy and maintain a production version of your app.
+
+## Project management
+
+When you sign up for Convex, a Convex team is created for you. You can
+[create more teams from the dashboard](/dashboard/teams.md) and add other people
+to them as members. You can upgrade your team to the
+[Starter](https://www.convex.dev/pricing) plan to pay as you go or the
+[Professional](https://www.convex.dev/pricing) for additional features, higher
+built-in limits, 24h support, and discounted usage-based pricing.
+
+Each team can have multiple projects. When you run `npx convex dev` for the
+first time, a project is created for you automatically. You can also create a
+project from the dashboard.
+
+Every project has one shared production deployment and one development
+deployment per team member. This allows each team member to make and test
+changes independently before they are deployed to the production deployment.
+
+Usually all deployments belonging to a single project run the same code base (or
+a version of it), but Convex doesn't enforce this. You can also run the same
+code base on multiple different prod deployments belonging to different
+projects, see [staging](#staging-environment) below.
+
+## Deploying to production
+
+Your Convex deployments run your backend logic and in most cases you will also
+develop a client that uses the backend. If your client is a web app, follow the
+[Hosting and Deployment](/production/hosting/hosting.mdx) guide, to learn how to
+deploy your client and your Convex backend together.
+
+You can also deploy your backend on its own. Check out the
+[Project Configuration](/production/project-configuration.mdx) page to learn
+more.
+
+## Staging environment
+
+With Convex [preview deployments](/production/hosting/preview-deployments.mdx)
+your team can test out changes before deploying them to production. If you need
+a more permanent staging environment, you can use a separate Convex project, and
+deploy to it by setting the `CONVEX_DEPLOY_KEY` environment variable when
+running [`npx convex deploy`](/cli.md#deploy-convex-functions-to-production).
+
+## Typical team development workflow
+
+Teams developing on Convex usually follow this workflow:
+
+1. If this is the team's first project, one team member creates a team on the
+   dashboard.
+2. One team member creates a project by running `npx convex dev`, perhaps
+   starting with a [quickstart](/quickstarts.mdx) or a
+   [template](https://www.convex.dev/templates).
+3. The team member creates a Git repository from the initial code and shares it
+   with their team (via GitHub, GitLab etc.).
+4. Other team members pull the codebase, and get their own dev deployments by
+   running `npx convex dev`.
+5. All team members can make backend changes and test them out with their
+   individual dev deployments. When a change is ready the team member opens a
+   pull-request (or commits to a shared branch).
+   - [Backup / Restore](/database/backup-restore) can be used to populate a dev
+     deployment with data from a prod deployment.
+   - [Data import](/database/import-export/import.mdx) can be used to populate a
+     dev deployment with synthetic seed data.
+   - Members of a team with the [Pro plan](https://www.convex.dev/pricing) can
+     get separate
+     [preview deployments](/production/hosting/preview-deployments.mdx) to test
+     each other's pull-requests.
+6. Deployment to production can happen
+   [automatically](/production/hosting/hosting.mdx) when changes get merged to
+   the designated branch (say `main`).
+   - Alternatively one of the team members can deploy to production manually by
+     running `npx convex deploy`.
+
+### Making safe changes
+
+Especially if your app is live you want to make sure that changes you make to
+your Convex codebase do not break it.
+
+Some unsafe changes are handled and caught by Convex, but others you need handle
+yourself.
+
+1. **Schema must always match existing data.** Convex enforces this constraint.
+   You cannot push a schema to a deployment with existing data that doesn't
+   match it, unless you turn off schema enforcement. In general it safe to:
+   1. Add new tables to the schema.
+   2. Add an `optional` field to an existing table's schema, set the field on
+      all documents in the table, and then make the field required.
+   3. Mark an existing field as `optional`, remove the field from all documents,
+      and then remove the field.
+   4. Mark an existing field as a `union` of the existing type and a new type,
+      modify the field on all documents to match the new type, and then change
+      the type to the new type.
+2. **Functions should be backwards compatible.** Even if your only client is a
+   website, and you deploy it together with your backend, your users might still
+   be running the old version of your website when your backend changes.
+   Therefore you should make your functions backwards compatible until you are
+   OK to break old clients. In general it is safe to:
+   1. Add new functions.
+   2. Add an `optional` named argument to an existing function.
+   3. Mark an existing named argument as `optional`.
+   4. Mark an existing named argument as a `union` of the existing type and a
+      new type.
+   5. Change the behavior of the function in such a way that given the arguments
+      from an old client its behavior will still be acceptable to the old
+      client.
+3. **Scheduled functions should be backwards compatible.** When you schedule a
+   function to run in the future, you provide the argument values it will
+   receive. Whenever a function runs, it always runs its currently deployed
+   version. If you change the function between the time it was scheduled and the
+   time it runs, you must ensure the new version will behave acceptably given
+   the old arguments.
+
+<StackPosts query="deploy" />
diff --git a/synced/convex/docs/production/_category_.json b/synced/convex/docs/production/_category_.json
new file mode 100644
index 0000000..91e6567
--- /dev/null
+++ b/synced/convex/docs/production/_category_.json
@@ -0,0 +1,3 @@
+{
+  "label": "Production"
+}
diff --git a/synced/convex/docs/production/contact.md b/synced/convex/docs/production/contact.md
new file mode 100644
index 0000000..80abde1
--- /dev/null
+++ b/synced/convex/docs/production/contact.md
@@ -0,0 +1,34 @@
+---
+title: "Contact Us"
+sidebar_position: 500
+---
+
+Convex is a rapidly developing platform and we're always eager to hear your
+feedback.
+
+## Feedback and Support
+
+Please share any general questions, feature requests, or product feedback in our
+[Convex Discord Community](https://convex.dev/community). We're particularly
+excited to see what you build on Convex!
+
+Any specific support questions that aren't able to be adequately addressed on
+our Discord channel can be directed to
+[support@convex.dev](mailto:support@convex.dev).
+
+## Following Convex
+
+Release notes are shared on [Convex News](https://news.convex.dev/tag/releases)
+and the [Convex Discord Community](https://convex.dev/community).
+
+Product announcements, articles and demos are posted on
+[Stack](https://stack.convex.dev/), [News](https://news.convex.dev/),
+[our YouTube channel](https://www.youtube.com/channel/UCoC_9mdiPwIu1sDxDtGQggQ),
+and [X (fka Twitter)](https://x.com/convex_dev).
+
+## Vulnerability Disclosure
+
+If you believe you've discovered a bug in Convex's security, please get in touch
+at [security@convex.dev](mailto:security@convex.dev) and we'll get back to you
+within 24 hours. We request that you not publicly disclose the issue until we
+have had a chance to address it.
diff --git a/synced/convex/docs/production/environment-variables.md b/synced/convex/docs/production/environment-variables.md
new file mode 100644
index 0000000..ffc7391
--- /dev/null
+++ b/synced/convex/docs/production/environment-variables.md
@@ -0,0 +1,106 @@
+---
+title: "Environment Variables"
+sidebar_label: "Environment Variables"
+sidebar_position: 2
+description: "Store and access environment variables in Convex"
+---
+
+Environment variables are key-value pairs that are useful for storing values you
+wouldn't want to put in code or in a table, such as an API key. You can set
+environment variables in Convex through the dashboard, and you can access them
+in [functions](/functions.mdx) using `process.env`.
+
+## Setting environment variables
+
+Under [Deployment Settings](/dashboard/deployments/settings.md) in the
+Dashboard, you can see a list of environment variables in the current
+deployment.
+![Environment Variables Table](/screenshots/environment_variables_table.png)
+
+You can add up to 100 environment variables. Environment variable names cannot
+be more than 40 characters long, and they must start with a letter and only
+contain letters numbers, and underscores. Environment variable values cannot be
+larger than 8KB.
+
+You can modify environment variables using the pencil icon button:
+
+![Edit Environment Variable](/screenshots/edit_environment_variable.png)
+
+Environment variables can also be viewed and modified with the
+[command line](/cli.md#read-and-write-environment-variables).
+
+```sh
+npx convex env list
+npx convex env set API_KEY secret-api-key
+```
+
+### Using environment variables in dev and prod deployments
+
+Since environment variables are set per-deployment, you can use different values
+for the same key in dev and prod deployments. This can be useful for when you
+have different external accounts you'd like to use depending on the environment.
+For example, you might have a dev and prod SendGrid account for sending emails,
+and your function expects an environment variable called `SENDGRID_API_KEY` that
+should work in both environments.
+
+If you expect an environment variable to be always present in a function, you
+must add it to **all** your deployments. In this example, you would add an
+environment variable with the name `SENDGRID_API_KEY` to your dev and prod
+deployments, with a different value for dev and prod.
+
+## Accessing environment variables
+
+You can access environment variables in Convex functions using
+`process.env.KEY`. If the variable is set it is a `string`, otherwise it is
+`undefined`. Here is an example of accessing an environment variable with the
+key `GIPHY_KEY`:
+
+```javascript
+function giphyUrl(query) {
+  return (
+    "https://api.giphy.com/v1/gifs/translate?api_key=" +
+    process.env.GIPHY_KEY +
+    "&s=" +
+    encodeURIComponent(query)
+  );
+}
+```
+
+Note that you should not condition your Convex function exports on environment
+variables. The set of Convex functions that can be called is determined during
+deployment and is not reevaluated when you change an environment variable. The
+following code will throw an error at runtime, if the DEBUG environment variable
+changes between deployment and calling the function.
+
+```javascript
+// THIS WILL NOT WORK!
+export const myFunc = process.env.DEBUG ? mutation(...) : internalMutation(...);
+```
+
+Similarly, environment variables used in cron definitions will only be
+reevaluated on deployment.
+
+## System environment variables
+
+The following environment variables are always available in Convex functions:
+
+- `CONVEX_CLOUD_URL` - Your deployment URL (eg.
+  `https://dusty-nightingale-847.convex.cloud`) for use with Convex clients.
+- `CONVEX_SITE_URL` - Your deployment site URL (eg.
+  `https://dusty-nightingale-847.convex.site`) for use with
+  [HTTP Actions](/functions/http-actions.mdx)
+
+## Project environment variable defaults
+
+You can set up default environment variable values for a project for development
+and preview deployments in Project Settings.
+
+![Project Default Environment Variables](/screenshots/project_default_environment_variables.png)
+
+These default values will be used when creating a new development or preview
+deployment, and will have no effect on existing deployments (they are not kept
+in sync).
+
+The Deployment Settings will indicate when a deployment has environment
+variables that do not match the project defaults.
+![Environment Variable Default Mismatch](/screenshots/environment_variable_default_diff.png)
diff --git a/synced/convex/docs/production/hosting/custom.md b/synced/convex/docs/production/hosting/custom.md
new file mode 100644
index 0000000..91d6ba3
--- /dev/null
+++ b/synced/convex/docs/production/hosting/custom.md
@@ -0,0 +1,158 @@
+---
+title: "Custom Domains & Hosting"
+sidebar_label: "Custom Domains & Hosting"
+description:
+  "Serve requests from any domains and host your frontend on any static hosting
+  provider, such as GitHub."
+sidebar_position: 100
+---
+
+## Custom Domains
+
+You can configure a custom domain, like `api.example.com`, to serve HTTP actions
+or Convex functions from your production Convex deployments. The settings for
+this feature are accessed through the Project Settings page on any of your
+projects.
+
+![Add Custom Domain](/screenshots/add_custom_domain.png)
+
+After you enter a domain, you will be shown which records to set on your DNS
+provider. Some popular DNS providers that you can use to buy a domain are
+Cloudflare and GoDaddy. We will verify your domain in the background, and once
+these records are set, you will see a green checkmark.
+
+When you see that checkmark, your backend will now serve traffic from that
+domain. The first request may take up to a minute because Convex will have to
+mint a new SSL certificate.
+
+Reach out to support@convex.dev if you have any questions about getting set up!
+
+<ProFeatureUpsell feature="Custom domains" verb="require" />
+
+### Hosting with a Custom Domain
+
+To use a custom domain to serve your Convex functions, there's an additional
+step: override the `CONVEX_CLOUD_URL` environment variable.
+
+![Override system environment variables](/screenshots/override_system_env_vars.png)
+
+Then re-deploy your project. This may entail clicking "Redeploy" in Vercel or
+Netlify, or directly running `npx convex deploy --cmd 'npm run build'`. The
+newly deployed code will access your Convex functions through your custom
+domain.
+
+The `CONVEX_CLOUD_URL` environment variable is used in several places:
+
+- `npx convex deploy --cmd '...'` sets `CONVEX_URL` (or similarly named) for
+  your frontend to connect websockets and HTTP clients
+- In your Convex functions, it is available as `process.env.CONVEX_CLOUD_URL`
+- File storage URLs: `ctx.storage.getUrl(id)` and
+  `ctx.storage.generateUploadUrl()`
+- Generate an OpenAPI spec with `npx convex function-spec --prod`
+
+You may also override the `CONVEX_SITE_URL` environment variable to be a custom
+HTTP Action domain.
+
+- In your Convex functions, it is available as `process.env.CONVEX_SITE_URL`
+- It may be used for webhooks
+- It may be used in `auth.config.ts` as the `issuer` for Convex Auth
+
+## Custom Hosting
+
+If you're using only Convex for backend functionality you can host your web app
+on any static hosting provider. This guide will use
+[GitHub Pages](https://pages.github.com/) as an example.
+
+If you're using Next.js or other framework with server functionality you'll need
+to use a provider that supports it, such as
+[Netlify](/production/hosting/netlify.mdx) or
+[Vercel](/production/hosting/vercel.mdx). You can still host Next.js statically
+via a
+[static export](https://nextjs.org/docs/pages/building-your-application/deploying/static-exports).
+
+### Configure your build
+
+First make sure that you have a working build process.
+
+In this guide we'll set up a local build, but your hosting provider might
+support a remote build. For example see
+[Vite's Deploying to GitHub Pages guide](https://vitejs.dev/guide/static-deploy.html#github-pages)
+which uses GitHub actions.
+
+We'll use Vite and GitHub Pages as an example.
+
+1. Configure <JSDialectFileName name="vite.config.mts" />:
+
+   ```ts title="vite.config.mts"
+   import { defineConfig } from "vite";
+   import react from "@vitejs/plugin-react";
+
+   // https://vitejs.dev/config/
+   export default defineConfig({
+     plugins: [react()],
+     // highlight-next-line
+     build: {
+       // highlight-next-line
+       outDir: "docs",
+       // highlight-next-line
+     },
+     // highlight-next-line
+     base: "/some-repo-name/",
+   });
+   ```
+
+   The `build.outDir` field specifies where Vite will place the production
+   build, and we use `docs` because that's the directory GitHub Pages allow
+   hosting from.
+
+   The `base` field specifies the URL path under which you'll serve your app, in
+   this case we will serve on
+   `https://<some username>.github.io/<some repo name>`.
+
+### Configure your hosting provider
+
+With GitHub Pages, you can choose whether you want to include your build output
+in your main working branch or publish from a separate branch.
+
+Open your repository's GitHub page > _Settings_ > _Pages_. Under _Build and
+deployment_ > _Source_ choose `Deploy from a branch`.
+
+Under _branch_ choose a branch (if you want to use a separate branch, push at
+least one commit to it first), and the `/docs` folder name. Hit _Save_.
+
+### Build and deploy to Convex and GitHub Pages
+
+To manually deploy to GitHub pages follow these steps:
+
+1. Checkout the branch you chose to publish from
+2. Run `npx convex deploy --cmd 'npm run build'` and confirm that you want to
+   push your current backend code to your **production** deployment
+3. Commit the build output changes and push to GitHub.
+
+### How it works
+
+First, `npx convex deploy` runs through these steps:
+
+1. It sets the `VITE_CONVEX_URL` (or similarly named) environment variable to
+   your **production** Convex deployment.
+2. It invokes the frontend framework build process, via `npm run build`. The
+   build process reads the environment variable and uses it to point the built
+   site at your **production** deployment.
+3. It deploys your backend code, from the `convex` directory, to your
+   **production** deployment.
+
+Afterwards you deploy the built frontend code to your hosting provider. In this
+case you used Git, but for other providers you might use a different method,
+such as an old-school FTP request.
+
+You can use `--cmd-url-env-var-name` to customize the variable name used by your
+frontend code if the `deploy` command cannot infer it, like
+
+```sh
+npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
+```
+
+### Authentication
+
+You will want to configure your [authentication](/auth.mdx) provider (Clerk,
+Auth0 or other) to accept your production URL, where your frontend is served.
diff --git a/synced/convex/docs/production/hosting/hosting.md b/synced/convex/docs/production/hosting/hosting.md
new file mode 100644
index 0000000..81154eb
--- /dev/null
+++ b/synced/convex/docs/production/hosting/hosting.md
@@ -0,0 +1,23 @@
+---
+title: "Hosting and Deployment"
+description: "Share your Convex backend and web app with the world."
+sidebar_position: 1
+---
+
+The easiest way to publish your full-stack web app is to use a hosting provider
+like [Vercel](https://vercel.com) or [Netlify](https://netlify.com).
+
+Both Vercel and Netlify integrate with Git to deploy code whenever a new
+revision is pushed. To host your app:
+
+1. Commit all files and push to your favorite Git hosting provider such as
+   [GitHub](https://github.com/), [GitLab](https://gitlab.com/) or
+   [Bitbucket](https://bitbucket.org/).
+
+2. Follow the appropriate guide below.
+
+If you aren't using Netlify or Vercel, you can follow the Custom Hosting guide.
+
+- [Vercel](/production/hosting/vercel.mdx)
+- [Netlify](/production/hosting/netlify.mdx)
+- [Custom Hosting](/production/hosting/custom.mdx)
diff --git a/synced/convex/docs/production/hosting/netlify.md b/synced/convex/docs/production/hosting/netlify.md
new file mode 100644
index 0000000..6e7d5cf
--- /dev/null
+++ b/synced/convex/docs/production/hosting/netlify.md
@@ -0,0 +1,192 @@
+---
+title: "Using Convex with Netlify"
+sidebar_label: "Netlify"
+description: "Host your frontend on Netlify and your backend on Convex."
+sidebar_position: 20
+---
+
+Hosting your Convex app on Netlify allows you to automatically re-deploy both
+your backend and your frontend whenever you push your code.
+
+## Deploying to Netlify
+
+This guide assumes you already have a working React app with Convex. If not
+follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:
+
+<StepByStep>
+  <Step title="Create a Netlify account">
+    If you haven't done so, create a [Netlify](https://netlify.com) account.
+    This is free for small projects and should take less than a minute to set
+    up.
+
+    <></>
+
+  </Step>
+  <Step title="Link your project on Netlify">
+    Create a Netlify project at https://app.netlify.com/start and link it to the
+    source code repository for your project on GitHub or other Git platform.
+
+    <div className="screenshot-border">
+      ![Netlify import project](/screenshots/netlify_import.png)
+    </div>
+
+  </Step>
+  <Step title="Override the Build command">
+    Override the _Build command_ to be
+    `npx convex deploy --cmd 'npm run build'`.
+
+    If your project lives in a subdirectory of your repository you'll
+    also need to change _Base directory_ in Netlify accordingly.
+
+    <div className="screenshot-border">
+      ![Netlify build settings](/screenshots/netlify_build_settings.png)
+    </div>
+
+  </Step>
+  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
+    On your [Convex Dashboard](https://dashboard.convex.dev/)
+    go to your project's _Settings_ page. Click the _Generate_ button to generate a **Production** deploy key.
+    Then click the copy button to copy the key.
+
+    In Netlify, click _Add environment variables_ and _New variable_.
+
+    Create an environment variable `CONVEX_DEPLOY_KEY` and paste
+    in your deploy key.
+
+    <div className="screenshot-border">
+      ![Netlify environment variable CONVEX_DEPLOY_KEY](/screenshots/netlify_prod_deploy_key.png)
+    </div>
+
+  </Step>
+  <Step title="Deploy your site">
+    Now click the _Deploy_ button and your work here is done!
+
+    <></>
+
+  </Step>
+
+</StepByStep>
+
+Netlify will automatically publish your site to a URL
+`https://<site-name>.netlify.app` listed at the top of the site overview page.
+Every time you push to your git repository, Netlify will automatically deploy
+your Convex functions and publish your site changes.
+
+<Admonition type="info" title="Using a Custom Domain?">
+  If you're using a custom domain to serve your Convex functions, you'll need
+  additional configuration. See [Custom
+  Domains](/production/hosting/custom.mdx#hosting-with-a-custom-domain) for more
+  information.
+</Admonition>
+### How it works
+
+In Netlify, we overrode the _Build Command_ to be
+`npx convex deploy --cmd 'npm run build'`.
+
+`npx convex deploy` will read `CONVEX_DEPLOY_KEY` from the environment and use
+it to set the `CONVEX_URL` (or similarly named) environment variable to point to
+your **production** deployment.
+
+Your frontend framework of choice invoked by `npm run build` will read the
+`CONVEX_URL` environment variable and point your deployed site (via
+`ConvexReactClient`) at your **production** deployment.
+
+Finally, `npx convex deploy` will push your Convex functions to your production
+deployment.
+
+Now, your production deployment has your newest functions and your app is
+configured to connect to it.
+
+You can use `--cmd-url-env-var-name` to customize the variable name used by your
+frontend code if the `deploy` command cannot infer it, like
+
+```sh
+npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
+```
+
+## Authentication
+
+You will want to configure your [authentication](/auth.mdx) provider (Clerk,
+Auth0 or other) to accept your production `<site-name>.netlify.app` URL.
+
+## Deploy Previews
+
+Netlify's Deploy Previews allow you to preview changes to your app before
+they're merged in. In order to preview both changes to frontend code and Convex
+functions, you can set up
+[Convex preview deployments](/production/hosting/preview-deployments.mdx).
+
+This will create a fresh Convex backend for each preview and leave your
+production and development deployments unaffected.
+
+This assumes you have already followed the steps in
+[Deploying to Netlify](#deploying-to-netlify) above.
+
+<StepByStep>
+  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
+    On your [Convex Dashboard](https://dashboard.convex.dev/)
+    go to your project's _Settings_ page. Click the _Generate Preview Deploy Key_ button to generate a **Preview** deploy key.
+    Then click the copy button to copy the key.
+
+    In Netlify, click _Site configuration_ > _Environment variables_. Edit your existing `CONVEX_DEPLOY_KEY` environment variable.
+    Select _Different value for each deploy context_ and paste the key under _Deploy Previews_.
+
+
+    <div className="screenshot-border">
+      ![Netlify environment variable CONVEX_DEPLOY_KEY](/screenshots/netlify_preview_deploy_key.png)
+    </div>
+
+  </Step>
+  <Step title="(optional) Set up default environment variables">
+    If your app depends on certain Convex environment variables, you can set up [default
+    environment variables](/production/environment-variables.mdx#project-environment-variable-defaults) for preview and development deployments in your project.
+    <div className="screenshot-border">
+      ![Project Default Environment Variables](/screenshots/project_default_environment_variables.png)
+    </div>
+  </Step>
+
+<Step title="(optional) Run a function to set up initial data">
+  Deploy Previews run against fresh Convex backends, which do not share data
+  with development or production Convex deployments. You can call a Convex
+  function to set up data by adding `--preview-run 'functionName'` to the `npx
+  convex deploy` command. This function will only be run for preview deployments, and will be ignored
+  when deploying to production.
+
+```sh title="Netlify > Site configuration > Build & deploy > Build settings > Build command"
+npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
+```
+
+</Step>
+
+  <Step title="Now test out creating a PR and generating a Deploy Preview!">
+
+    You can find the Convex deployment for your branch in the Convex dashboard.
+    <div className="screenshot-border">
+      ![Preview Deployment in Deployment Picker](/screenshots/preview_deployment_deployment_picker.png)
+    </div>
+
+  </Step>
+
+</StepByStep>
+
+### How it works
+
+For Deploy Previews, `npx convex deploy` will read `CONVEX_DEPLOY_KEY` from the
+environment, and use it to create a Convex deployment associated with the Git
+branch name for the Deploy Preview. It will set the `CONVEX_URL` (or similarly
+named) environment variable to point to the new Convex deployment.
+
+Your frontend framework of choice invoked by `npm run build` will read the
+`CONVEX_URL` environment variable and point your deployed site (via
+`ConvexReactClient`) at the Convex preview deployment.
+
+Finally, `npx convex deploy` will push your Convex functions to the preview
+deployment and run the `--preview-run` function (if provided). This deployment
+has separate functions, data, crons and all other configuration from any other
+deployments.
+
+`npx convex deploy` will infer the Git branch name for Vercel, Netlify, GitHub,
+and GitLab environments, but the `--preview-create` option can be used to
+customize the name associated with the newly created deployment.
+
+Production deployments will work exactly the same as before.
diff --git a/synced/convex/docs/production/hosting/preview-deployments.md b/synced/convex/docs/production/hosting/preview-deployments.md
new file mode 100644
index 0000000..8c2397e
--- /dev/null
+++ b/synced/convex/docs/production/hosting/preview-deployments.md
@@ -0,0 +1,55 @@
+---
+title: "Preview Deployments"
+sidebar_label: "Preview Deployments"
+description: "Use Convex with your hosting provider's preview deployments"
+sidebar_position: 200
+---
+
+Convex preview deployments allow your team to test out backend changes before
+pushing them to production.
+
+In combination with Vercel Preview Deployments or Netlify Deploy Previews, you
+can preview both frontend and backend changes together.
+
+<ProFeatureUpsell feature="Convex preview deployments" verb="require" />
+
+<BetaAdmonition feature="Convex preview deployments" verb="are" />
+
+## Setup
+
+Follow the [Vercel](/production/hosting/vercel.mdx#preview-deployments) or
+[Netlify](/production/hosting/netlify.mdx#deploy-previews) hosting guide for
+setting up frontend and backend previews together, as well as details on how
+Convex preview deployments work.
+
+See `npx convex deploy --help` for all available options for
+`npx convex deploy`.
+
+## Limits
+
+Convex preview deployments are automatically cleaned up 14 days after creation,
+or when a new preview deployment with the same name is created. They can also be
+manually deleted from the Convex dashboard.
+
+When a Convex preview deployment is deleted, the Vercel/Netlify preview link
+will open and show UI, but will be unable to run any Convex functions since it
+is pointing at a Convex deployment that no longer exists. In these cases,
+re-deploying in Vercel/Netlify should produce a link pointing at a new Convex
+deployment.
+
+Convex allows a single deployment at a time for a given name (Git branch). When
+pushing updates to an existing branch, the deployment will be deleted, resulting
+in a preview link unable to run Convex functions, before it is replaced by a new
+Convex deployment.
+
+Initial data can be set up on a Convex preview deployment by running a function.
+There are currently no other ways to set up data on a Convex preview deployment
+-- viewing changes against a copy of production data or importing data from a
+different Convex deployment is not supported.
+
+Note that if the function call fails, the `deploy` command will fail, but the
+new preview deployment will have already been provisioned. Best course of action
+is to fix the issue in the function and redeploy.
+
+Support for preview deployments is a beta feature, so
+[let us know on Discord](https://convex.dev/community) if you have feedback!
diff --git a/synced/convex/docs/production/hosting/vercel.md b/synced/convex/docs/production/hosting/vercel.md
new file mode 100644
index 0000000..27a7d70
--- /dev/null
+++ b/synced/convex/docs/production/hosting/vercel.md
@@ -0,0 +1,187 @@
+---
+title: "Using Convex with Vercel"
+sidebar_label: "Vercel"
+description: "Host your frontend on Vercel and your backend on Convex."
+sidebar_position: 10
+---
+
+Hosting your Convex app on Vercel allows you to automatically re-deploy both
+your backend and your frontend whenever you push your code.
+
+## Deploying to Vercel
+
+This guide assumes you already have a working React app with Convex. If not
+follow the [Convex React Quickstart](/quickstart/react.mdx) first. Then:
+
+<StepByStep>
+  <Step title="Create a Vercel account">    
+    If you haven't done so, create a [Vercel](https://vercel.com) account. This is
+    free for small projects and should take less than a minute to set up.
+
+    <></>
+
+  </Step>
+  <Step title="Link your project on Vercel">
+    Create a Vercel project at https://vercel.com/new and link it to the
+    source code repository for your project on GitHub or other Git platform.
+
+    ![Vercel import project](/screenshots/vercel_import.png)
+
+  </Step>
+  <Step title="Override the Build command">
+    Override the "Build command" to be
+    `npx convex deploy --cmd 'npm run build'`.
+
+    If your project lives in a subdirectory of your repository you'll
+    also need to change _Root Directory_ above accordingly.
+
+    ![Vercel build settings](/screenshots/vercel_build_command.png)
+
+  </Step>
+
+  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
+    On your [Convex Dashboard](https://dashboard.convex.dev/)
+    go to your project's _Settings_ page. Click the _Generate Production Deploy Key_ button to generate a **Production** deploy key.
+    Then click the copy button to copy the key.
+
+    In Vercel, click _Environment Variables_.
+    Create an environment variable named `CONVEX_DEPLOY_KEY` and paste
+    in your deploy key. Under _Environment_, uncheck all except _Production_ and click _Save_.
+
+    ![Vercel environment variable CONVEX_DEPLOY_KEY](/screenshots/vercel_prod_deploy_key.png)
+
+  </Step>
+  <Step title="Deploy your site">
+    Now click the _Deploy_ button and your work here is done!
+
+    <></>
+
+  </Step>
+
+</StepByStep>
+
+Vercel will automatically publish your site to an URL like
+`https://<site-name>.vercel.app`, shown on the page after deploying. Every time
+you push to your Git repository, Vercel will automatically deploy your Convex
+functions and publish your site changes.
+
+<Admonition type="info" title="Using a Custom Domain?">
+  If you're using a custom domain to serve your Convex functions, you'll need
+  additional configuration. See [Custom
+  Domains](/production/hosting/custom.mdx#hosting-with-a-custom-domain) for more
+  information.
+</Admonition>
+
+### How it works
+
+In Vercel, we overrode the _Build Command_ to be
+`npx convex deploy --cmd 'npm run build'`.
+
+`npx convex deploy` will read `CONVEX_DEPLOY_KEY` from the environment and use
+it to set the `CONVEX_URL` (or similarly named) environment variable to point to
+your **production** deployment.
+
+Your frontend framework of choice invoked by `npm run build` will read the
+`CONVEX_URL` (or similarly named) environment variable to point your deployed
+site (via `ConvexReactClient`) at your **production** deployment.
+
+Finally, `npx convex deploy` will push your Convex functions to your production
+deployment.
+
+Now, your production deployment has your newest functions and your app is
+configured to connect to it.
+
+You can use `--cmd-url-env-var-name` to customize the variable name used by your
+frontend code if the `deploy` command cannot infer it, like
+
+```sh
+npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
+```
+
+### Authentication
+
+You will want to configure your [authentication](/auth.mdx) provider (Clerk,
+Auth0 or other) to accept your production URL. Note that Clerk does not support
+`https://<site-name>.vercel.app`, so you'll have to configure a custom domain.
+
+## Preview Deployments
+
+Vercel Preview Deployments allow you to preview changes to your app before
+they're merged in. In order to preview both changes to frontend code and Convex
+functions, you can set up
+[Convex preview deployments](/production/hosting/preview-deployments.mdx).
+
+This will create a fresh Convex backend for each preview and leave your
+production and development deployments unaffected.
+
+This assumes you have already followed the steps in
+[Deploying to Vercel](#deploying-to-vercel) above.
+
+<StepByStep>
+  <Step title="Set up the CONVEX_DEPLOY_KEY environment variable">
+    On your [Convex Dashboard](https://dashboard.convex.dev/)
+    go to your project's _Settings_ page. Click the _Generate Preview Deploy Key_ button to generate a **Preview** deploy key.
+    Then click the copy button to copy the key.
+
+    In Vercel, click _Environment Variables_.
+    Create an environment variable named `CONVEX_DEPLOY_KEY` and paste
+    in your deploy key. Under _Environment_, uncheck all except _Preview_ and click _Save_.
+
+    <div className="screenshot-border">
+      ![Vercel environment variable CONVEX_DEPLOY_KEY](/screenshots/vercel_preview_deploy_key.png)
+    </div>
+
+  </Step>
+  <Step title="(optional) Set up default environment variables">
+    If your app depends on certain Convex environment variables, you can set up [default
+    environment variables](/production/environment-variables.mdx#project-environment-variable-defaults) for preview and development deployments in your project.
+    <div className="screenshot-border">
+      ![Project Default Environment Variables](/screenshots/project_default_environment_variables.png)
+    </div>
+  </Step>
+
+<Step title="(optional) Run a function to set up initial data">
+  Vercel Preview Deployments run against fresh Convex backends, which do not share data
+  with development or production Convex deployments. You can call a Convex
+  function to set up data by adding `--preview-run 'functionName'` to the `npx
+  convex deploy` command. This function will only be run for preview deployments, and will be ignored
+  when deploying to production.
+
+```sh title="Vercel > Settings > Build & Development settings > Build Command"
+npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
+```
+
+</Step>
+
+  <Step title="Now test out creating a PR and generating a Preview Deployment!">
+
+    You can find the Convex deployment for your branch in the Convex dashboard.
+    <div className="screenshot-border">
+      ![Preview Deployment in Deployment Picker](/screenshots/preview_deployment_deployment_picker.png)
+    </div>
+
+  </Step>
+
+</StepByStep>
+
+### How it works
+
+For Preview Deployments, `npx convex deploy` will read `CONVEX_DEPLOY_KEY` from
+the environment, and use it to create a Convex deployment associated with the
+Git branch name for the Vercel Preview Deployment. It will set the `CONVEX_URL`
+(or similarly named) environment variable to point to the new Convex deployment.
+
+Your frontend framework of choice invoked by `npm run build` will read the
+`CONVEX_URL` environment variable and point your deployed site (via
+`ConvexReactClient`) at the Convex preview deployment.
+
+Finally, `npx convex deploy` will push your Convex functions to the preview
+deployment and run the `--preview-run` function (if provided). This deployment
+has separate functions, data, crons and all other configuration from any other
+deployments.
+
+`npx convex deploy` will infer the Git branch name for Vercel, Netlify, GitHub,
+and GitLab environments, but the `--preview-create` option can be used to
+customize the name associated with the newly created deployment.
+
+Production deployments will work exactly the same as before.
diff --git a/synced/convex/docs/production/integrations/exception-reporting.md b/synced/convex/docs/production/integrations/exception-reporting.md
new file mode 100644
index 0000000..c113135
--- /dev/null
+++ b/synced/convex/docs/production/integrations/exception-reporting.md
@@ -0,0 +1,63 @@
+---
+title: "Exception Reporting"
+sidebar_label: "Exception Reporting"
+sidebar_position: 3
+description:
+  "Configure exception reporting integrations for your Convex deployment"
+---
+
+Configure exception reporting to gain visibility into errors from your Convex
+function executions. Convex supports integration with
+[Sentry](https://sentry.io/) and with
+[Datadog Error Tracking](https://www.datadoghq.com/product/error-tracking/).
+
+Currently, exception reporting is only available to Pro users.
+
+## Configuring Sentry
+
+To configure sentry, navigate to the
+[Deployment Settings](/dashboard/deployments/settings.md) in the Dashboard, and
+the "Integrations" tab in the sidebar.
+
+![Integrations Page](/screenshots/integrations_page.png)
+
+Click on the Sentry card and follow the setup directions. You will need your
+[Sentry DSN](https://docs.sentry.io/product/sentry-basics/concepts/dsn-explainer/).
+You may optionally specify additional tags to be added to each exception event.
+
+![Configure sentry](/screenshots/configure_sentry.png)
+
+## Supported Tags
+
+Convex automatically tags exception events on their way to sentry with the
+following tags. These tags cannot be overridden.
+
+- `func`: The name of the running function in
+  [string format](/functions/query-functions#query-names)
+- `func_type`: One of `["query", "mutation", "action", "http_action"]`
+- `func_runtime`: One of the [function runtimes](/functions/runtimes.mdx) -
+  `["default", "node"]`
+- `request_id`: The
+  [request id](/functions/debugging.mdx#finding-relevant-logs-by-request-id) of
+  the function that errored.
+- `server_name`: The name of the deployment. e.g. `happy-animal-123`
+- `environment`: One of `["prod", "dev", "preview"]`
+- `user`: If the function is [authenticated](/auth.mdx), then the
+  [tokenIdentifier](/api/interfaces/server.UserIdentity#tokenidentifier) is used
+  as the user id on Sentry. The `tokenIdentifier` is a stable and globally
+  unique string representing the authenticated user.
+
+## Sentry Notes
+
+- Sentry Exceptions may take a minute or two to propagate to Sentry.
+- Convex's built-in sentry support does not yet support the advanced
+  customization provided by the sentry SDK.
+- Please reach out with any questions, comments, or suggestions
+  [on Discord](https://convex.dev/community).
+
+## Configuring Datadog Error Tracking
+
+Follow the instructions in the
+[Datadog application](https://app.datadoghq.com/error-tracking/settings/setup/sentry)
+to configure Datadog error tracking via the Sentry SDK. Then use the
+Convex-Sentry integration to proceed.
diff --git a/synced/convex/docs/production/integrations/integrations.md b/synced/convex/docs/production/integrations/integrations.md
new file mode 100644
index 0000000..2dde17c
--- /dev/null
+++ b/synced/convex/docs/production/integrations/integrations.md
@@ -0,0 +1,37 @@
+---
+title: "Integrations"
+description: "Integrate Convex with third party services."
+sidebar_position: 1
+---
+
+Convex integrates with a variety of supported third party tools for log
+streaming and exception reporting.
+
+- [Log Streams](/production/integrations/log-streams) enable streaming of log
+  events from your Convex deployment to supported destinations, such as Axiom,
+  Datadog, or a custom webhook.
+- [Exception Reporting](/production/integrations/exception-reporting) gives
+  visibility into errors in your Convex function executions.
+
+## Configuring an Integration
+
+To configure an integration, navigate to the
+[Deployment Settings](https://dashboard.convex.dev/deployment/settings) in the
+Dashboard, and the "Integrations" tab in the sidebar. This page provides a list
+of your configured integrations, their current health status, and other
+integrations available to be configured. To configure a integration, click on
+the card and follow the setup directions.
+
+![Integrations Page](/screenshots/integrations_page.png)
+
+## Deleting an Integration
+
+To remove an integration and stop further events from being piped out to the
+configured destination, select the menu icon in the upper-right corner of a
+configured panel and select "Delete integration". After confirming, the
+integration will stop running within a few seconds.
+
+## Feedback
+
+Please reach out with any questions, comments, or suggestions
+[on Discord](https://convex.dev/community).
diff --git a/synced/convex/docs/production/integrations/log-streams/legacy-event-schema.md b/synced/convex/docs/production/integrations/log-streams/legacy-event-schema.md
new file mode 100644
index 0000000..58d6d33
--- /dev/null
+++ b/synced/convex/docs/production/integrations/log-streams/legacy-event-schema.md
@@ -0,0 +1,158 @@
+# (Legacy) Event schema
+
+<Admonition type="info">
+  Log streams configured before May 23, 2024 will use the legacy format
+  documented here. We recommend updating your log stream to use the new format.
+</Admonition>
+
+## Updating to the new format
+
+You can update existing log streams to the new format in the dashboard under
+your [deployment's Settings](https://dashboard.convex.dev/deployment/settings) >
+Integrations.
+
+You can either create an entirely new dataset to hold events using the new
+format, or can reuse your existing dataset to hold historical events in the
+legacy format as well as events in the new format going forward.
+
+We recommend reading the documentation on both the legacy format and the
+[current format](/production/integrations/log-streams/log-streams.mdx#log-event-schema)
+for the full set of differences, but here are a few key differences:
+
+- Many fields have been renamed to drop leading underscores and use `snake_case`
+- Fields have been added, e.g.
+  - `function.request_id`
+  - `usage.vector_storage_read_bytes`
+  - `log_level`
+- Fields have been renamed or nested for clarity, e.g.
+  - `reason` -> `error_message`
+  - `_functionPath` -> `function.path`
+
+## (Legacy) Event schema
+
+Log events have a well-defined JSON schema that allow building complex,
+type-safe pipelines ingesting log events.
+
+## System fields
+
+System fields are reserved fields which are included on log events and prefixed
+by an underscore.
+
+All log events include the following system fields:
+
+- `_topic`: string that categorizes a log event by its internal source
+- `_timestamp`: Unix epoch timestamp in milliseconds. This is as an integer.
+
+## Log sources
+
+This section outlines the source and data model of all log events.
+
+### `console` logs
+
+Convex function logs via the `console` API.
+
+Schema:
+
+- `_topic = "_console"`
+- `_timestamp` = Unix epoch timestamp in milliseconds
+- `_functionType = "query" | "mutation" | "action" | "httpAction"`
+- `_functionPath` =
+  - If this is an HTTP action, this is a string of the HTTP method and URL
+    pathname i.e. `POST /my_endpoint`
+  - Otherwise, this is a path to function within `convex/` directory including
+    an optional module export identifier i.e. `myDir/myFile:myFunction`.
+- `_functionCached = true | false`. This field is only set if
+  `_functionType = "query"` and says if this log event came from a cached
+  function execution.
+- `message` = payload string of arguments to `console` API
+
+Example query log event:
+
+```json
+{
+  "_topic": "_console",
+  "_timestamp": 1695066350531,
+  "_functionType": "query",
+  "_functionPath": "myDir/myFile",
+  "_functionCached": true,
+  "message": "[LOG] 'My log message'"
+}
+```
+
+### Function execution record logs
+
+Function executions which log a record of their execution and their result.
+
+Schema:
+
+- `_topic = "_execution_record"`
+- `_timestamp` = Unix epoch timestamp in milliseconds
+- `_functionType = "query" | "mutation" | "action" | "httpAction"`
+- `_functionPath` = path to function within `convex/` directory including module
+  export identifier
+- `_functionCached = true | false`. This field is only set if
+  `_functionType = "query"` and says if this log event came from a cached
+  function execution.
+- `status = "success" | "failure"`
+- `reason` = error message from function. Only set if `status = "failure"`
+- `executionTimeMs` = length of execution of this function in milliseconds
+- `databaseReadBytes` = the database read bandwidth used by this function in
+  bytes
+- `databaseWriteBytes` = the database write bandwidth used by this function in
+  bytes
+- `storageReadBytes` = the file storage read bandwidth this function used in
+  bytes
+- `storageWriteBytes` = the file storage write bandwidth this function used in
+  bytes
+
+Example execution record log from an HTTP action:
+
+```json
+{
+  "_topic": "_execution_record",
+  "_timestamp": 1695066350531,
+  "_functionType": "httpAction",
+  "_functionPath": "POST /sendImage",
+  "status": "failure",
+  "reason": "Unexpected Error: Some error message\n\n  at ....",
+  "executionTimeMs": 73
+}
+```
+
+### Audit trail logs
+
+Audit logs of deployment events.
+
+Schema:
+
+- `_topic = "_audit_log"`
+- `_timestamp` = Unix epoch timestamp in milliseconds
+- `action = "create_environment_variable" | "update_environment_variable" | "delete_environment_variable" | "replace_environment_variable" | "push_config" | "build_indexes" | "change_deployment_state"`
+- `actionMetadata` = object whose fields depends on the value of the `action`
+  field.
+
+Example `push_config` audit log:
+
+```json
+{
+  "_topic": "_audit_log",
+  "_timestamp": 1695066350531,
+  "action": "push_config",
+  "actionMetadata": {
+    "modules": {
+      "added": ["ffmpeg.js", "fetch.js", "test.js"],
+      "removed": ["removed.js"]
+    }
+  }
+}
+```
+
+### Verification logs
+
+Internal logging events used to verify access to a log stream.
+
+Schema
+
+- `_topic = "_verification"`
+- `_timestamp` = Unix epoch timestamp in milliseconds.
+- `message = Convex connection test`
diff --git a/synced/convex/docs/production/integrations/log-streams/log-streams.md b/synced/convex/docs/production/integrations/log-streams/log-streams.md
new file mode 100644
index 0000000..bf5f749
--- /dev/null
+++ b/synced/convex/docs/production/integrations/log-streams/log-streams.md
@@ -0,0 +1,276 @@
+---
+title: "Log Streams"
+sidebar_label: "Log Streams"
+sidebar_position: 2
+description: "Configure logging integrations for your Convex deployment"
+---
+
+Log streams enable streaming of events such as function executions and
+`console.log`s from your Convex deployment to supported destinations, such as
+Axiom, Datadog, or a custom webhook.
+
+The most recent logs produced by your Convex deployment can be viewed in the
+Dashboard [Logs page](/dashboard/deployments/logs.md), the
+[Convex CLI](/cli.md), or in the browser console, providing a quick and easy way
+to view recent logs.
+
+Log streaming to a third-party destination like Axiom or Datadog enables storing
+historical logs, more powerful querying and data visualization, and integrations
+with other tools (e.g. PagerDuty, Slack).
+
+<ProFeatureUpsell feature="Log streams" verb="require" />
+
+## Configuring log streams
+
+We currently support the following log streams, with plans to support many more:
+
+- [Axiom](https://www.axiom.co)
+- [Datadog](https://www.datadoghq.com/)
+- Webhook to a custom URL
+
+See the instructions for
+[configuring an integration](/production/integrations/integrations.mdx#configuring-an-integration).
+The specific information needed for each log stream is covered below.
+
+### Axiom
+
+Configuring an Axiom log stream requires specifying:
+
+- The name of your
+  [Axiom dataset](https://axiom.co/docs/reference/settings#dataset)
+- An Axiom [API key](https://axiom.co/docs/reference/settings#api-token)
+- An optional list of attributes and their values to be included in all log
+  events send to Axiom. These will be sent via the `attributes` field in the
+  [Ingest API](https://axiom.co/docs/send-data/ingest#ingest-api).
+
+### Datadog
+
+Configuring a Datadog log stream requires specifying:
+
+- The [site location](https://docs.datadoghq.com/getting_started/site/) of your
+  Datadog deployment
+- A Datadog
+  [API key](https://docs.datadoghq.com/account_management/api-app-keys/#add-an-api-key-or-client-token)
+- A comma-separated list of tags that will be passed using the
+  [`ddtags` field](https://docs.datadoghq.com/getting_started/tagging/) in all
+  payloads sent to Datadog. This can be used to include any other metadata that
+  can be useful for querying or categorizing your Convex logs ingested by your
+  Datadog deployment.
+
+### Webhook
+
+A webhook log stream is the simplest and most generic stream, allowing piping
+logs via POST requests to any URL you configure. The only parameter required to
+set up this stream is the desired webhook URL.
+
+A request to this webhook contains as its body a JSON array of events in the
+schema defined below.
+
+## Log event schema
+
+<Admonition type="info">
+  Log streams configured before May 23, 2024 will use the legacy format
+  documented on [this
+  page](/production/integrations/log-streams/legacy-event-schema.mdx). We
+  recommend updating your log stream to use the new format.
+</Admonition>
+
+Log events have a well-defined JSON schema that allow building complex,
+type-safe pipelines ingesting log events.
+
+All events will have the following three fields:
+
+- `topic`: string, categorizes a log event, one of
+  `["verification", "console", "function_execution", "audit_log"]`
+- `timestamp`: number, Unix epoch timestamp in milliseconds as an integer
+- `convex`: An object containing metadata related to your Convex deployment,
+  including `deployment_name`, `deployment_type`, `project_name`, and
+  `project_slug`.
+
+Note: In the Axiom integration, event-specific information will be available
+under the `data` field.
+
+### `verification` events
+
+This is an event sent to confirm the log stream is working. Schema:
+
+- `topic`: `"verification"`
+- `timestamp`: Unix epoch timestamp in milliseconds
+- `message`: string
+
+### `console` events
+
+Convex function logs via the [`console` API](/functions/debugging.mdx).
+
+Schema:
+
+- `topic`: `"console"`
+- `timestamp`: Unix epoch timestamp in milliseconds
+- `function`: object, see
+  [function fields](/production/integrations/log-streams/log-streams.mdx#function-fields)
+- `log_level`: string, one of `["DEBUG", "INFO", "LOG", "WARN", "ERROR"]`
+- `message`: string, the
+  [`object-inspect`](https://www.npmjs.com/package/object-inspect)
+  representation of the `console.log` payload
+- `is_truncated`: boolean, whether this message was truncated to fit within our
+  logging limits
+- `system_code`: optional string, present for automatically added warnings when
+  functions are approaching [limits](/production/state/limits.mdx#functions)
+
+Example event for `console.log("Sent message!")` from a mutation:
+
+```json
+{
+    "topic": "console"
+    "timestamp": 1715879172882,
+    "function": {
+      "path": "messages:send",
+      "request_id": "d064ef901f7ec0b7",
+      "type": "mutation"
+    },
+    "log_level": "LOG",
+    "message": "'Sent message!'"
+}
+```
+
+### `function_execution` events
+
+These events occur whenever a function is run.
+
+Schema:
+
+- `topic`: `"function_execution"`
+- `timestamp`: Unix epoch timestamp in milliseconds
+- `function`: object, see
+  [function fields](/production/integrations/log-streams/log-streams.mdx#function-fields)
+- `execution_time_ms`: number, the time in milliseconds this function took to
+- `status`: string, one of `["success", "failure"]`
+- `error_message`: string, present for functions with status `failure`,
+  containing the error and any stack trace.
+- `mutation_queue_length`: optional number (for mutations only), the length of
+  the per-session mutation queue at the time the mutation was executed. This is
+  useful for monitoring and debugging mutation queue backlogs in individual
+  sessions.
+- `mutation_retry_count`: number, the number of previous failed executions (for
+  mutations only) run before a successful one. Only applicable to mutations and
+  actions.
+- `occ_info`: object, if the function call resulted in an OCC (write conflict
+  between two functions), this field will be present and contain information
+  relating to the OCC.
+  [Learn more about write conflicts](https://docs.convex.dev/error/#1).
+  - `table_name`: table the conflict occurred in
+  - `document_id`: Id of the document that received conflicting writes
+  - `write_source`: name of the function that conflicted writes against
+    `table_name`
+  - `retry_count`: the number of previously failed attempts before the current
+    function execution
+- `scheduler_info`: object, if set, indicates that the function execution was
+  originally invoked by a scheduled job either directly, or via a subfunction
+  execution.
+- `usage`:
+  - `database_read_bytes`: number
+  - `database_write_bytes`: number, this and `database_read_bytes` make up the
+    database bandwidth used by the function
+  - `database_read_documents`: number, the number of documents read by the
+    function
+  - `file_storage_read_bytes`: number
+  - `file_storage_write_bytes`: number, this and `file_storage_read_bytes` make
+    up the file bandwidth used by the function
+  - `vector_storage_read_bytes`: number
+  - `vector_storage_write_bytes`: number, this and `vector_storage_read_bytes`
+    make up the vector bandwidth used by the function
+  - `action_memory_used_mb`: number, for actions, the memory used in MiB. This
+    combined with `execution_time_ms` makes up the action compute.
+
+Example event for a query:
+
+```json
+{
+  "data": {
+    "execution_time_ms": 294,
+    "function": {
+      "cached": false,
+      "path": "message:list",
+      "request_id": "892104e63bd39d9a",
+      "type": "query"
+    },
+    "status": "success",
+    "timestamp": 1715973841548,
+    "topic": "function_execution",
+    "usage": {
+      "database_read_bytes": 1077,
+      "database_write_bytes": 0,
+      "database_read_documents": 3,
+      "file_storage_read_bytes": 0,
+      "file_storage_write_bytes": 0,
+      "vector_storage_read_bytes": 0,
+      "vector_storage_write_bytes": 0
+    }
+  }
+}
+```
+
+### Function fields
+
+The following fields are added under `function` for all `console` and
+`function_execution` events:
+
+- `type`: string, one of `["query", "mutation", "action", "http_action"]`
+- `path`: string, e.g. `"myDir/myFile:myFunction"`, or `"POST /my_endpoint"`
+- `cached`: optional boolean, for queries this denotes whether this event came
+  from a cached function execution
+- `request_id`: string, the
+  [request ID](/functions/debugging.mdx#finding-relevant-logs-by-request-id) of
+  the function.
+
+### `scheduler_stats` events
+
+These events are periodically sent by the scheduler reporting statistics from
+the scheduled function executor.
+
+Schema:
+
+- `topic`: `"scheduler_stats"`
+- `timestamp`: Unix epoch timestamp in milliseconds
+- `lag_seconds`: The difference between `timestamp` and the scheduled run time
+  of the oldest overdue scheduled job, in seconds.
+- `num_running_jobs`: number, the number of scheduled jobs currently running
+
+### `audit_log` events
+
+These events represent changes to your deployment, which also show up in the
+[History tab](https://dashboard.convex.dev/deployment/history) in the dashboard.
+
+Schema:
+
+- `topic`: `audit_log`
+- `timestamp`: Unix epoch timestamp in milliseconds
+- `audit_log_action`: string, e.g. `"create_environment_variable"`,
+  `"push_config"`, `"change_deployment_state"`
+- `audit_log_metadata`: string, stringified JSON holding metadata about the
+  event. The exact format of this event may change.
+
+Example `push_config` audit log:
+
+```json
+{
+  "topic": "audit_log",
+  "timestamp": 1714421999886,
+  "audit_log_action": "push_config",
+  "audit_log_metadata": "{\"auth\":{\"added\":[],\"removed\":[]},\"crons\":{\"added\":[],\"deleted\":[],\"updated\":[]},..."
+}
+```
+
+## Guarantees
+
+Log events provide a best-effort delivery guarantee. Log streams are buffered
+in-memory and sent out in batches to your deployment's configured streams. This
+means that logs can be dropped if ingestion throughput is too high. Similarly,
+due to network retries, it is possible for a log event to be duplicated in a log
+stream.
+
+That's it! Your logs are now configured to stream out. If there is a log
+streaming destination that you would like to see supported,
+[please let us know](/production/contact.md)!
+
+<StackPosts query="axiom" />
diff --git a/synced/convex/docs/production/integrations/streaming-import-export.md b/synced/convex/docs/production/integrations/streaming-import-export.md
new file mode 100644
index 0000000..387ce81
--- /dev/null
+++ b/synced/convex/docs/production/integrations/streaming-import-export.md
@@ -0,0 +1,79 @@
+---
+title: "Streaming Data in and out of Convex"
+sidebar_label: "Streaming Import/Export"
+description: "Streaming Data in and out of Convex"
+sidebar_position: 4
+---
+
+[Fivetran](https://www.fivetran.com) and [Airbyte](https://airbyte.com) are data
+integration platforms that allow you to sync your Convex data with other
+databases.
+
+Fivetran enables streaming export from Convex to any of their
+[supported destinations](https://fivetran.com/docs/destinations). The Convex
+team maintains a Convex source connector, for streaming export. Streaming import
+into Convex via Fivetran is not supported at the moment.
+
+Using Airbyte enables streaming import from any of their
+[supported sources](https://airbyte.com/connectors?connector-type=Sources) into
+Convex and streaming export from Convex into any of their
+[supported destinations](https://airbyte.com/connectors?connector-type=Destinations).
+The Convex team maintains a Convex source connector for streaming export and a
+Convex destination connector for streaming import.
+
+<BetaAdmonition feature="Fivetran & Airbyte integrations" verb="are" />
+
+## Streaming Export
+
+Exporting data can be useful for handling workloads that aren't supported by
+Convex directly. Some use cases include:
+
+1. Analytics
+   - Convex isn't optimized for queries that load huge amounts of data. A data
+     platform like [Databricks](https://www.databricks.com) or
+     [Snowflake](https://www.snowflake.com/) is more appropriate.
+2. Flexible querying
+   - While Convex has powerful
+     [database queries](/database/reading-data/reading-data.mdx#querying-documents)
+     and built-in [full text search](/search.mdx) support, there are still some
+     queries that are difficult to write within Convex. If you need very dynamic
+     sorting and filtering for something like an "advanced search" view,
+     databases like [ElasticSearch](https://www.elastic.co) can be helpful.
+3. Machine learning training
+   - Convex isn't optimized for queries running computationally intensive
+     machine learning algorithms.
+
+<ProFeatureUpsell feature="Streaming export" verb="requires" />
+
+See the [Fivetran](https://fivetran.com/integrations/convex) or
+[Airbyte](https://docs.airbyte.com/integrations/sources/convex) docs to learn
+how to set up a streaming export. [Contact us](https://convex.dev/community) if
+you need help or have questions.
+
+## Streaming Import
+
+Adopting new technologies can be a slow, daunting process, especially when the
+technologies involve databases. Streaming import enables adopting Convex
+alongside your existing stack without having to write your own migration or data
+sync tooling. Some use cases include:
+
+1. Prototyping how Convex could replace your project's existing backend using
+   its own data.
+2. Building new products faster by using Convex alongside existing databases.
+3. Developing a reactive UI-layer on top of an existing dataset.
+4. Migrating your data to Convex (if the [CLI](/cli.md) tool doesn't meet your
+   needs).
+
+<Admonition type="caution" title="Make imported tables read-only">
+A common use case is to "mirror" a table in the source database to Convex to
+build something new using Convex. We recommend leaving imported
+tables as read-only in Convex because syncing the results back to the source
+database could result in dangerous write conflicts. While Convex doesn't yet
+have access controls that would ensure a table is read-only, you can make sure that
+there are no mutations or actions writing to imported tables in your code and avoid editing
+documents in imported tables in the dashboard.
+</Admonition>
+
+Streaming import is included with all Convex plans. See the Airbyte docs on how
+to set up the Convex destination connector
+[here](https://docs.airbyte.com/integrations/destinations/convex).
diff --git a/synced/convex/docs/production/multiple-repos.md b/synced/convex/docs/production/multiple-repos.md
new file mode 100644
index 0000000..863527e
--- /dev/null
+++ b/synced/convex/docs/production/multiple-repos.md
@@ -0,0 +1,191 @@
+---
+title: Multiple Repositories
+sidebar_label: Multiple Repositories
+description: "Use Convex in multiple repositories"
+sidebar_position: 180
+---
+
+
+
+
+Your TypeScript clients can call Convex functions in a type-safe way outside of
+the repository where your Convex functions are defined. By following the steps
+below, you can generate a file similar to `convex/_generated/api.d.ts` that you
+can check in and use in a separate repository.
+
+<BetaAdmonition feature="TypeScript API generation" verb="is" />
+
+<StepByStep>
+  <Step title="Install the Convex Helpers npm package">
+    Install the `convex-helpers` package, which contains a CLI command to generate an api file.
+
+    ```sh
+    npm install convex-helpers
+    ```
+
+  </Step>
+  <Step title="Run a command to generate a TypeScript API file">
+    Running this command will call into your configured Convex deployment and generate an `api.ts` file based
+    on it. You can see additional flags by passing `--help` to the command.
+
+    ```sh
+    npx convex-helpers ts-api-spec
+    ```
+
+  </Step>
+</StepByStep>
+
+## Example
+
+Below are code snippets of what this workflow looks like in action. These
+snippets include three different files:
+
+- `convex/messages.ts` - contains Convex function definitions
+- `api.ts` - a generated file from running the command above
+- `src/App.tsx` - frontend code in a separate repository where `api.ts` is
+  checked in
+
+
+```ts
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+// @snippet start send
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  returns: v.null(),
+  handler: async (ctx, { body, author }) => {
+    const message = { body, author };
+    await ctx.db.insert("messages", message);
+  },
+});
+// @snippet end send
+```
+
+```ts
+import { v } from "convex/values";
+import { mutation } from "./_generated/server";
+
+// @snippet start send
+export const send = mutation({
+  args: { body: v.string(), author: v.string() },
+  returns: v.null(),
+  handler: async (ctx, { body, author }) => {
+    const message = { body, author };
+    await ctx.db.insert("messages", message);
+  },
+});
+// @snippet end send
+```
+
+
+
+```ts
+import { FunctionReference, anyApi } from "convex/server";
+
+export const api: PublicApiType = anyApi as unknown as PublicApiType;
+
+export type PublicApiType = {
+  messages: {
+    send: FunctionReference<
+      "mutation",
+      "public",
+      { author: string; body: string },
+      null
+    >;
+  };
+};
+```
+
+```ts
+import { FunctionReference, anyApi } from "convex/server";
+
+export const api: PublicApiType = anyApi as unknown as PublicApiType;
+
+export type PublicApiType = {
+  messages: {
+    send: FunctionReference<
+      "mutation",
+      "public",
+      { author: string; body: string },
+      null
+    >;
+  };
+};
+```
+
+
+
+```tsx
+import { FormEvent, useState } from "react";
+import { useMutation } from "convex/react";
+// Note: This file is importing from the file we generated,`api`,
+// and not from `../convex/_generated/api`
+import { api } from "../api";
+
+export default function App() {
+  const [newMessageText, setNewMessageText] = useState("");
+  const sendMessage = useMutation(api.messages.send);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendMessage(event: FormEvent) {
+    event.preventDefault();
+    await sendMessage({ body: newMessageText, author: name });
+    setNewMessageText("");
+  }
+  return (
+    <main>
+      <h1>Send Messages</h1>
+      <form onSubmit={handleSendMessage}>
+        <input
+          value={newMessageText}
+          onChange={(event) => setNewMessageText(event.target.value)}
+          placeholder="Write a message…"
+        />
+        <input type="submit" value="Send" disabled={!newMessageText} />
+      </form>
+    </main>
+  );
+}
+```
+
+```tsx
+import { FormEvent, useState } from "react";
+import { useMutation } from "convex/react";
+// Note: This file is importing from the file we generated,`api`,
+// and not from `../convex/_generated/api`
+import { api } from "../api";
+
+export default function App() {
+  const [newMessageText, setNewMessageText] = useState("");
+  const sendMessage = useMutation(api.messages.send);
+
+  const [name] = useState(() => "User " + Math.floor(Math.random() * 10000));
+  async function handleSendMessage(event: FormEvent) {
+    event.preventDefault();
+    await sendMessage({ body: newMessageText, author: name });
+    setNewMessageText("");
+  }
+  return (
+    <main>
+      <h1>Send Messages</h1>
+      <form onSubmit={handleSendMessage}>
+        <input
+          value={newMessageText}
+          onChange={(event) => setNewMessageText(event.target.value)}
+          placeholder="Write a message…"
+        />
+        <input type="submit" value="Send" disabled={!newMessageText} />
+      </form>
+    </main>
+  );
+}
+```
+
+
+## Limits
+
+- Argument and return value validators are not required, but they will enrich
+  the types of your TypeScript API. Where validators aren't defined, we default
+  to `v.any()` as the validator.
+- You cannot call internal functions from outside of your Convex deployment.
diff --git a/synced/convex/docs/production/pause-deployment.md b/synced/convex/docs/production/pause-deployment.md
new file mode 100644
index 0000000..69a63e4
--- /dev/null
+++ b/synced/convex/docs/production/pause-deployment.md
@@ -0,0 +1,28 @@
+---
+title: "Pausing a Deployment"
+sidebar_label: "Pausing a Deployment"
+sidebar_position: 4
+---
+
+Pausing a deployment is a way to "turn off" a deployment without deleting any
+data. This can be useful if you have an action that is blowing through a
+third-party API quota and you just need a big red stop button.
+
+When a deployment is paused:
+
+- New function calls will return an error.
+- Scheduled jobs will queue and run when the deployment is resumed.
+- Cron jobs will be skipped.
+- Everything else (e.g. code push, dashboard edits) should work as usual.
+
+**This is important!** All new function calls will return an error when a
+deployment is paused, so if you are running an app in production you may want to
+consider alternatives like pushing code that disables a feature you are trying
+to "turn off". We recommend testing this feature in a dev deployment first
+before pausing a production deployment.
+
+![Pause Deployment Button](/screenshots/pause_deployment.png)
+
+A deployment can be resumed with this button on the same page:
+
+![Resume Deployment](/screenshots/resume_deployment.png)
diff --git a/synced/convex/docs/production/project-configuration.md b/synced/convex/docs/production/project-configuration.md
new file mode 100644
index 0000000..e7f58b9
--- /dev/null
+++ b/synced/convex/docs/production/project-configuration.md
@@ -0,0 +1,108 @@
+---
+title: "Project Configuration"
+sidebar_label: "Project Configuration"
+sidebar_position: 3
+---
+
+## Local development
+
+When you're developing locally you need two pieces of information:
+
+1. The name of your dev deployment. This is where your functions are pushed to
+   and served from. It is stored in the `CONVEX_DEPLOYMENT` environment
+   variable. `npx convex dev` writes it to the `.env.local` file.
+2. The URL of your dev deployment, for your client to connect to. The name of
+   the variable and which file it can be read from varies between client
+   frameworks. `npx convex dev` writes the URL to the `.env.local` or `.env`
+   file.
+
+## Production deployment
+
+You should only be deploying to your production deployment once you have tested
+your changes on your local deployment. When you're ready, you can deploy either
+via a hosting/CI provider or from your local machine.
+
+For a CI environment you can follow the
+[hosting](/production/hosting/hosting.mdx) docs. `npx convex deploy` run by the
+CI pipeline will use the `CONVEX_DEPLOY_KEY`, and the frontend build command
+will use the deployment URL variable, both configured in your CI environment.
+
+You can also deploy your backend from your local machine. `npx convex deploy`
+will ask for a confirmation and then deploy to the production deployment in the
+same project as your configured development `CONVEX_DEPLOYMENT`.
+
+## `convex.json`
+
+Additional project configuration can be specified in the `convex.json` file in
+the root of your project (in the same directory as your `package.json`).
+
+You can use the JSON schema for editor validation by adding a `$schema`
+property:
+
+```json title="convex.json"
+{
+  "$schema": "https://raw.githubusercontent.com/get-convex/convex-backend/refs/heads/main/npm-packages/convex/schemas/convex.schema.json",
+  "functions": "src/convex/"
+}
+```
+
+The file supports the following configuration options:
+
+### Changing the `convex/` folder name or location
+
+You can choose a different name or location for the `convex/` folder via the
+`functions` field. For example, Create React App doesn't allow importing from
+outside the `src/` directory, so if you're using Create React App you should
+have the following config:
+
+```json title="convex.json"
+{
+  "functions": "src/convex/"
+}
+```
+
+### Installing packages on the server
+
+You can specify which packages used by Node actions should be installed on the
+server, instead of being bundled, via the `node.externalPackages` field.
+[Read more](/functions/bundling.mdx#external-packages).
+
+### Importing the generated functions API via `require()` syntax
+
+The Convex code generation can be configured to generate a CommonJS-version of
+the `_generated/api.js` file via the `generateCommonJSApi` field.
+[Read more](/client/javascript/node.mdx#javascript-with-commonjs-require-syntax).
+
+### Using static code generation (beta)
+
+Convex's code generation heavily relies on TypeScript's type inference. This
+makes updates snappy and jump-to-definition work for the `api` and `internal`
+objects, but it often slows down with large codebases.
+
+If you're running into language server performance issues, you can instruct the
+Convex CLI to generate static versions of the `_generated/api.d.ts` and
+`_generated/dataModel.d.ts`:
+
+```json title="convex.json"
+{
+  "codegen": {
+    "staticApi": true,
+    "staticDataModel": true
+  }
+}
+```
+
+This will greatly improve autocomplete and incremental typechecking performance,
+but it does have some tradeoffs:
+
+- These types only update when `convex dev` is running.
+- Jump-to-definition no longer works. To find `api.example.f`, you'll need to
+  manually open `convex/example.ts` and find `f`.
+- Functions no longer have return type inference and will default to `v.any()`
+  if they don't have a returns validator.
+- [TypeScript enums](https://www.typescriptlang.org/docs/handbook/enums.html) no
+  longer work in schema or API definitions. Use unions of string literal types
+  instead.
+
+This feature is currently in beta, and we'd love to improve these limitations.
+Let us know if you run into any issues or have any feedback!
diff --git a/synced/convex/docs/production/state/limits.md b/synced/convex/docs/production/state/limits.md
new file mode 100644
index 0000000..d443274
--- /dev/null
+++ b/synced/convex/docs/production/state/limits.md
@@ -0,0 +1,159 @@
+---
+title: "Limits"
+sidebar_position: 2
+---
+
+We’d love for you to have _unlimited_ joy building on Convex but engineering
+practicalities dictate a few limits. This page outlines current limits in the
+Convex ecosystem.
+
+Many of these limits will become more permissive over time. Please get in touch
+if any are prohibitive for your application.
+
+Limits are applied per team unless stated otherwise.
+
+## Team
+
+|            | Free/Starter | Professional                  |
+| ---------- | ------------ | ----------------------------- |
+| Developers | 1-6          | 1-20<br/>$25/member per month |
+| Projects   | 20           | 100                           |
+
+## Database
+
+|                   | Free/Starter                                                      | Professional                                       | Notes                                                                                     |
+| ----------------- | ----------------------------------------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------- |
+| Storage           | 0.5 GiB included<br/>(on Starter: $0.22/month per additional GiB) | 50 GiB included<br/>$0.20/month per additional GiB | Includes database rows and indexes but not files or backups.                              |
+| Bandwidth         | 1 GiB/month included<br/>(on Starter: $0.22 per additional GiB)   | 50 GiB/month included<br/>$0.20 per additional GiB | Document and index data transferred between Convex functions and the underlying database. |
+| Tables            | 10,000                                                            | 10,000                                             | Per deployment.                                                                           |
+| Indexes per table | 32                                                                | 32                                                 |                                                                                           |
+| Fields per index  | 16                                                                | 16                                                 |
+| Index name length | 64 characters                                                     | 64 characters                                      |                                                                                           |
+
+### Restrictions
+
+- Table and index names must be valid identifiers and cannot start with an
+  underscore.
+
+## Documents
+
+Applied per document and to any nested `Object` unless stated otherwise.
+
+|                     |               | Notes                                                            |
+| ------------------- | ------------- | ---------------------------------------------------------------- |
+| Size                | 1 MiB         |                                                                  |
+| Fields              | 1024          | The number of fields/keys                                        |
+| Field name length   | 64 characters | Nested `Object` keys can have length up to 1024 characters.      |
+| Field nesting depth | 16            | How many times objects and arrays can be nested, e.g. `[[[[]]]]` |
+| Array elements      | 8192          |                                                                  |
+
+### Restrictions
+
+- Field names must only contain non-control alphanumeric ASCII characters and
+  underscores and must start with an alphabetic character or underscore.
+- Documents cannot contain top-level fields that start with an underscore, other
+  than the system-provided `_id` and `_creationTime` fields.
+- Strings must be valid Unicode sequences with no unpaired surrogates.
+
+## Functions
+
+|                                                                              | Free/Starter                                                              | Professional                                              | Notes                                                                                                         |
+| ---------------------------------------------------------------------------- | ------------------------------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
+| Function calls                                                               | 1,000,000/month included<br/>(on Starter: $2.20 per additional 1,000,000) | 25,000,000/month included<br/>$2 per additional 1,000,000 | Explicit client calls, scheduled executions, subscription updates, and file accesses count as function calls. |
+| Action execution                                                             | 20 GiB-hours included<br/>(on Starter: $0.33/GiB-hour additional)         | 250 GiB-hours included<br/>$0.30/GiB-hour additional      | Convex runtime: 64 MiB RAM.<br/>Node.js runtime: 512 MiB RAM.                                                 |
+| Code size                                                                    | 32 MiB                                                                    | 32 MiB                                                    | Per deployment.                                                                                               |
+| Function argument size                                                       | 16 MiB                                                                    | 16 MiB                                                    | Node actions only support arguments up to 5MiB.                                                               |
+| Function return value size                                                   | 16 MiB                                                                    | 16 MiB                                                    |                                                                                                               |
+| HTTP action response size                                                    | 20 MiB                                                                    | 20 MiB                                                    | There is no specific limit on request size                                                                    |
+| Length of a console.log line                                                 | 4 KiB                                                                     | 4 KiB                                                     |                                                                                                               |
+| [Log streaming](/production/integrations/log-streams/log-streams.mdx) limits | 4096 logs, flushed every 10 seconds                                       | 4096 logs, flushed every 10 seconds                       | How many logs can be buffered when streaming                                                                  |
+
+## Concurrent Function Executions
+
+Number of functions you can run at a time for each function type.
+
+|                | Free/Starter | Professional<sup>\*</sup> |
+| -------------- | ------------ | ------------------------- |
+| Queries        | 16           | 256                       |
+| Mutations      | 16           | 256                       |
+| V8 actions     | 64           | 256                       |
+| Node actions   | 64           | 1000                      |
+| HTTP actions   | 16           | 128                       |
+| Scheduled jobs | 10           | 100                       |
+
+<sup>*</sup> Limits can be lifted for Professional plan customers on a
+case-by-case basis. Send us support message through the dashboard to discuss
+your needs. Usually this is only needed if your product has highly bursty
+traffic.
+
+## Execution time and scheduling
+
+|                                              |                 | Notes                                                                                                                   |
+| -------------------------------------------- | --------------- | ----------------------------------------------------------------------------------------------------------------------- |
+| Query/mutation execution time                | 1 second        | Limit applies only to user code and doesn’t include database operations.                                                |
+| Action execution time                        | 10&nbsp;minutes |                                                                                                                         |
+| Scheduled functions                          | 1000            | The number of other functions a single mutation can schedule.                                                           |
+| Total size of scheduled functions' arguments | 16 MiB          | Applies only to mutations.                                                                                              |
+| Concurrent IO operations per function        | 1000            | The number of IO operations a single function can perform, e.g., a database operation, or a fetch request in an action. |
+| Outstanding scheduled functions              | 1,000,000       |                                                                                                                         |
+
+## Transactions
+
+These limits apply to each `query` or `mutation` function.
+
+|                            |        | Notes                                                     |
+| -------------------------- | ------ | --------------------------------------------------------- |
+| Data read                  | 16 MiB | Data not returned due to a `filter` counts as scanned     |
+| Data written               | 16 MiB |
+| Documents scanned          | 32,000 | Documents not returned due to a `filter` count as scanned |
+| Documents written          | 16,000 |
+| Function return value size | 16 MiB |
+
+## Environment Variables
+
+Applied per-deployment.
+
+|                     |               |
+| ------------------- | ------------- |
+| Number of variables | 100           |
+| Maximum name length | 40 characters |
+| Maximum value size  | 8 KiB         |
+
+## File Storage
+
+|           | Free/Starter                                                     | Professional                                        | Notes                                                                                                     |
+| --------- | ---------------------------------------------------------------- | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
+| Storage   | 1 GiB included<br/>(on Starter: $0.033/month per additional GiB) | 100 GiB included<br/>$0.03/month per additional GiB | Includes user files and backups.                                                                          |
+| Bandwidth | 1 GiB/month included<br/>(on Starter: $0.33 per additional GiB)  | 50 GiB/month included<br/>$0.30 per additional GiB  | Includes serving user files, accessing user files inside functions, and generating and restoring backups. |
+
+## Full text search
+
+|                          | Value |
+| ------------------------ | ----- |
+| Search indexes per table | 4     |
+| Filters per search index | 16    |
+| Terms per search query   | 16    |
+| Filters per search query | 8     |
+| Maximum term length      | 32 B  |
+| Maximum result set       | 1024  |
+
+## Vector search
+
+|                          | Value                    |
+| ------------------------ | ------------------------ |
+| Vector indexes per table | 4                        |
+| Filters per vector index | 16                       |
+| Terms per search query   | 16                       |
+| Vectors to search by     | 1                        |
+| Dimension fields         | 1 (value between 2-4096) |
+| Filters per search query | 64                       |
+| Maximum term length      | 32 B                     |
+| Maximum result set       | 256 (defaults to 10)     |
+
+If any of these limits don't work for you,
+[let us know](https://convex.dev/community)!
+
+Please see our [plans and pricing page](https://www.convex.dev/pricing) for
+resource limits. After these limits are hit on a free plan, new mutations that
+attempt to commit more insertions or updates may fail. Paid plans have no hard
+resource limits - they can scale to billions of documents and TBs of storage.
diff --git a/synced/convex/docs/production/state/state.md b/synced/convex/docs/production/state/state.md
new file mode 100644
index 0000000..7960317
--- /dev/null
+++ b/synced/convex/docs/production/state/state.md
@@ -0,0 +1,86 @@
+---
+title: "Status and Guarantees"
+id: "state"
+sidebar_position: 1
+---
+
+Please [contact us](mailto:support@convex.dev) with any specific requirements or
+if you want to build a project on Convex that is not yet satisfied by our
+guarantees.
+
+## Guarantees
+
+The official Convex Terms of Service, Privacy Policy and Customer Agreements are
+[outlined in our official terms](https://www.convex.dev/legal/tos). We do not
+yet have contractual agreements beyond what is listed in our official terms and
+the discussions within this document don't constitute an amendment to these
+terms.
+
+Convex is always under continual development and future releases may require
+code changes in order to upgrade to a new version. Code developed on Convex 1.0
+or later will continue to operate as-is. If we are required to make a breaking
+change in future we will contact teams directly to provide substantial advance
+notice.
+
+All user data in Convex is encrypted at rest. Database state is replicated
+durably across multiple physical availability zones. Regular periodic and
+incremental database backups are performed and stored with 99.999999999% (11
+9's) durability.
+
+We target an availability of 99.99% (4 9's) for Convex deployments although
+these may experience downtime for maintenance without notice. A physical outage
+may affect availability of a deployment but will not affect durability of the
+data stored in Convex.
+
+## Limits
+
+For information on limits, see [here](/production/state/limits.mdx).
+
+## Beta Features
+
+Features tagged with **beta** in these docs are still in development. They can
+be used in production but their APIs might change in the future, requiring
+additional effort when upgrading to a new version of the Convex NPM package and
+other Convex client libraries.
+
+## Future Features
+
+Convex is still under very active development and here we list some of the
+missing functionality on our radar. We'd love to hear more about your
+requirements in the [Convex Discord Community](https://convex.dev/community).
+
+### Authorization
+
+Convex currently has an [_authentication framework_](/auth.mdx) which verifies
+user identities. In the future we plan to add an _authorization framework_ which
+will allow developers to define what data a user can access.
+
+For now, you can implement manual authorization checks within your queries and
+mutations, but stay tuned for a more comprehensive, fool-proof solution in the
+future.
+
+### Telemetry
+
+Currently, the dashboard provides only basic metrics. Serious sites at scale are
+going to need to integrate our logs and metrics into more fully fledged
+observability systems that categorize them and empower things like alerting.
+
+Convex will eventually have methods to publish deployment data in formats that
+can be ingested by third parties.
+
+### Analytics / OLAP
+
+Convex is designed to primarily service all your app's realtime implementation
+(OLTP) needs. It is less suited to be a good solution for the kinds of complex
+queries and huge table scans that are necessary to address the requirements of
+analytics (OLAP) use cases.
+
+Convex exposes
+[Fivetran and Airbyte connectors](/production/integrations/streaming-import-export.md)
+to export Convex data to external analytics systems.
+
+### Browser support
+
+Convex does not yet have an official browser support policy, but we strive to
+support most modern browsers with significant
+[usage](https://caniuse.com/usage-table).
diff --git a/synced/convex/docs/quickstart/android.md b/synced/convex/docs/quickstart/android.md
new file mode 100644
index 0000000..9b55317
--- /dev/null
+++ b/synced/convex/docs/quickstart/android.md
@@ -0,0 +1,237 @@
+---
+title: Android Kotlin Quickstart
+sidebar_label: Android Kotlin
+description: "Add Convex to an Android Kotlin project"
+hide_table_of_contents: true
+sidebar_position: 600
+---
+
+Learn how to query data from Convex in a Android Kotlin project.
+
+This quickstart assumes that you have Android Studio, node and npm installed. If
+you don’t have those tools, take time to install them first.
+
+<StepByStep>
+  <Step title="Create a new Android app in Android Studio">
+    Choose the following options in the wizard.
+
+    ```
+    1. Choose the "Empty Activity" template
+    2. Name it "Convex Quickstart"
+    3. Choose min SDK as 26
+    4. Choose Kotlin as the Gradle DSL
+    ```
+
+  </Step>
+
+  <Step title="Configure the AndroidManifest">
+    Add the following to your `AndroidManifest.xml`.
+
+    ```xml
+    <?xml version="1.0" encoding="utf-8"?>
+    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools">
+        // highlight-next-line
+        <uses-permission android:name="android.permission.INTERNET"/>
+        <application>
+            <!-- ... existing application contents -->
+        </application>
+    </manifest>
+    ```
+
+  </Step>
+
+  <Step title="Configure your dependencies">
+    Add the following entries to the `:app` `build.gradle.kts` file (ignore IDE
+    suggestion to move them to version catalog for now, if present).
+    
+    Ensure that you sync Gradle when all of the above is complete (Android
+    Studio should prompt you to do so).
+
+    ```kotlin
+    plugins {
+        // ... existing plugins
+        // highlight-next-line
+        kotlin("plugin.serialization") version "1.9.0"
+    }
+
+    dependencies {
+        // ... existing dependencies
+        // highlight-next-line
+        implementation("dev.convex:android-convexmobile:0.4.1@aar") {
+            // highlight-next-line
+            isTransitive = true
+        // highlight-next-line
+        }
+        // highlight-next-line
+        implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
+    }
+    ```
+
+  </Step>
+
+  <Step title="Install the Convex Backend">
+    Open a terminal in your Android Studio instance and install the Convex 
+    client and server library.
+
+    ```bash
+    npm init -y
+    npm install convex
+    ```
+
+  </Step>
+
+  <Step title="Start Convex">
+    Start a Convex dev deployment. Follow the command line instructions.
+
+    ```bash
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create a sample data for your database">
+    Create a new `sampleData.jsonl` file with these contents.
+
+    ```json
+    {"text": "Buy groceries", "isCompleted": true}
+    {"text": "Go for a swim", "isCompleted": true}
+    {"text": "Integrate Convex", "isCompleted": false}
+    ```
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Open another terminal tab and run.
+
+    ```bash
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Create a `tasks.ts` file in your `convex/` directory with the following 
+    contents.
+
+    ```tsx
+    import { query } from "./_generated/server";
+
+    export const get = query({
+      args: {},
+      handler: async (ctx) => {
+        return await ctx.db.query("tasks").collect();
+      },
+    });
+    ```
+
+  </Step>
+
+  <Step title="Create a data class">
+    Add a new `data class` to your `MainActivity` to support the task data 
+    defined above. Import whatever it asks you to.
+
+    ```kotlin
+    @Serializable
+    data class Task(val text: String, val isCompleted: Boolean)
+    ```
+
+  </Step>
+
+  <Step title="Create your UI">
+    Delete the template `@Composable` functions that Android Studio created and
+    add a new one to display data from your Convex deployment. Again, import
+    whatever it asks you to.
+
+    ```kotlin
+    @Composable
+    fun Tasks(client: ConvexClient, modifier: Modifier = Modifier) {
+        var tasks: List<Task> by remember { mutableStateOf(listOf()) }
+        LaunchedEffect(key1 = "launch") {
+            client.subscribe<List<Task>>("tasks:get").collect { result ->
+                result.onSuccess { remoteTasks ->
+                    tasks = remoteTasks
+                }
+            }
+        }
+        LazyColumn(
+            modifier = modifier
+        ) {
+            items(tasks) { task ->
+                Text(text = "Text: ${task.text}, Completed?: ${task.isCompleted}")
+            }
+        }
+    }
+    ```
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+    1. Get the deployment URL of your dev server with
+        `cat .env.local | grep CONVEX_URL`
+    2. Update the `onCreate` method in your `MainActivity.kt` to look like
+
+    ```kotlin
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        enableEdgeToEdge()
+        setContent {
+            ConvexQuickstartTheme {
+                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
+                    // highlight-next-line
+                    Tasks(
+                        // highlight-next-line
+                        client = ConvexClient($YOUR_CONVEX_URL),
+                        // highlight-next-line
+                        modifier = Modifier.padding(innerPadding)
+                    // highlight-next-line
+                    )
+                }
+            }
+        }
+    }
+    ```
+
+  </Step>
+
+  <Step title="Fix any missing imports">
+    Fix up any missing imports (your import declarations should look something
+    like this):
+
+    ```kotlin
+    import android.os.Bundle
+    import androidx.activity.ComponentActivity
+    import androidx.activity.compose.setContent
+    import androidx.activity.enableEdgeToEdge
+    import androidx.compose.foundation.layout.fillMaxSize
+    import androidx.compose.foundation.layout.padding
+    import androidx.compose.foundation.lazy.LazyColumn
+    import androidx.compose.foundation.lazy.items
+    import androidx.compose.material3.Scaffold
+    import androidx.compose.material3.Text
+    import androidx.compose.runtime.Composable
+    import androidx.compose.runtime.LaunchedEffect
+    import androidx.compose.runtime.getValue
+    import androidx.compose.runtime.mutableStateOf
+    import androidx.compose.runtime.remember
+    import androidx.compose.runtime.setValue
+    import androidx.compose.ui.Modifier
+    import dev.convex.android.ConvexClient
+    import kotlinx.serialization.Serializable
+    ```
+
+  </Step>
+  <Step title="Run the app">
+    You can also try adding, updating or deleting documents in your `tasks`
+    table at `dashboard.convex.dev` - the app will update with the changes in
+    real-time.
+
+    ```
+    From the IDE menu choose "Run" > "Run 'app'"
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete [Android Kotlin documentation](/client/android.md).
diff --git a/synced/convex/docs/quickstart/bun.md b/synced/convex/docs/quickstart/bun.md
new file mode 100644
index 0000000..fa7d4e8
--- /dev/null
+++ b/synced/convex/docs/quickstart/bun.md
@@ -0,0 +1,135 @@
+---
+title: Bun Quickstart
+sidebar_label: Bun
+description: "Add Convex to a Bun project"
+hide_table_of_contents: true
+sidebar_position: 450
+---
+
+
+
+
+Learn how to query data from Convex in a Bun project.
+
+For instructions for subscriptions instead of point-in-time queries see
+[Bun notes](/client/javascript/bun.mdx).
+
+# Using Convex with Bun
+
+<StepByStep>
+  <Step title="Create a new Bun project">
+    Create a new directory for your Bun project.
+
+    ```sh
+    mkdir my-project && cd my-project && bun init -y
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    Install the `convex` package.
+
+    ```sh
+    bun add convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `bunx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    bunx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    bunx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Connect the script to your backend">
+    In a new file `index.ts`, create a `ConvexClient` using
+    the URL of your development environment.
+
+    
+```ts
+import { ConvexClient } from "convex/browser";
+import { api } from "./convex/_generated/api.js";
+
+const client = new ConvexClient(process.env["CONVEX_URL"]);
+
+const unsubscribe = client.onUpdate(api.tasks.get, {}, async (tasks) => {
+  console.log(tasks);
+});
+
+await Bun.sleep(1000);
+unsubscribe();
+await client.close();
+```
+
+
+  </Step>
+
+  <Step title="Run the script">
+    Run the script from the same directory and see the list of tasks logged to the terminal.
+
+    ```sh
+    bun index.ts
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete [Bun documentation](/client/javascript/bun.mdx).
diff --git a/synced/convex/docs/quickstart/nextjs.md b/synced/convex/docs/quickstart/nextjs.md
new file mode 100644
index 0000000..1b66867
--- /dev/null
+++ b/synced/convex/docs/quickstart/nextjs.md
@@ -0,0 +1,308 @@
+---
+title: Next.js Quickstart
+sidebar_label: Next.js
+description: "Add Convex to a Next.js project"
+hide_table_of_contents: true
+sidebar_position: 200
+---
+
+
+
+
+
+
+
+
+
+
+<Admonition type="tip" title="Convex + Next.js">
+
+Convex is an all-in-one backend and database that integrates quickly and easily
+with Next.js.
+
+Once you've gotten started, see how to set up
+[hosting](/production/hosting/hosting.mdx),
+[server rendering](/client/react/nextjs/nextjs-server-rendering.mdx), and
+[auth](https://docs.convex.dev/client/react/nextjs/).
+
+</Admonition>
+
+To get setup quickly with Convex and Next.js run
+
+<p>
+  <b>
+    <CodeWithCopyButton text="npm create convex@latest" />
+  </b>
+</p>
+
+or follow the guide below.
+
+---
+
+Learn how to query data from Convex in a Next.js app using the App Router
+and<LanguageSelector verbose />
+
+Alternatively see the
+[Pages Router](/client/react/nextjs-pages-router/quickstart-nextjs-pages-router.mdx)
+version of this quickstart.
+
+<StepByStep>
+  <Step title="Create a Next.js app">
+    Create a Next.js app using the `npx create-next-app` command.
+
+    Choose the default option for every prompt (hit Enter).
+
+    <JSDialectVariants>
+      ```sh
+      npx create-next-app@latest my-app
+      ```
+
+      ```sh
+      npx create-next-app@latest my-app --js
+      ```
+    </JSDialectVariants>
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    To get started, install the `convex` package.
+
+    Navigate to your app and install `convex`.
+
+
+    ```sh
+    cd my-app && npm install convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Use the [`import`](/database/import-export/import) command to add a `tasks` table with the sample data into your Convex database.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    In the `convex/` folder, add a new file <JSDialectFileName name="tasks.ts" /> with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name: `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Create a client component for the Convex provider">
+    For `<ConvexProvider>` to work on the client, `ConvexReactClient` must be passed to it.
+
+    In the `app/` folder, add a new file <JSDialectFileName name="ConvexClientProvider.tsx" /> with the following code. This creates a client component that wraps `<ConvexProvider>` and passes it the `<ConvexReactClient>`.
+
+    
+```tsx
+"use client";
+
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+import { ReactNode } from "react";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
+
+export function ConvexClientProvider({ children }: { children: ReactNode }) {
+  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
+}
+```
+
+```jsx
+"use client";
+
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);
+
+export function ConvexClientProvider({ children }) {
+  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
+}
+```
+
+
+  </Step>
+
+  <Step title="Wire up the ConvexClientProvider">
+    In <JSDialectFileName name="app/layout.tsx" ext="js" />, wrap the children of the `body` element with the `<ConvexClientProvider>`.
+
+    
+```tsx
+import type { Metadata } from "next";
+import { Geist, Geist_Mono } from "next/font/google";
+import "./globals.css";
+import { ConvexClientProvider } from "./ConvexClientProvider";
+
+const geistSans = Geist({
+  variable: "--font-geist-sans",
+  subsets: ["latin"],
+});
+
+const geistMono = Geist_Mono({
+  variable: "--font-geist-mono",
+  subsets: ["latin"],
+});
+
+export const metadata: Metadata = {
+  title: "Create Next App",
+  description: "Generated by create next app",
+};
+
+// @snippet start sendMessageHook
+export default function RootLayout({
+  children,
+}: Readonly<{
+  children: React.ReactNode;
+}>) {
+  return (
+    <html lang="en">
+      <body
+        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
+      >
+        <ConvexClientProvider>{children}</ConvexClientProvider>
+      </body>
+    </html>
+  );
+}
+// @snippet end sendMessageHook
+```
+
+```js
+import "./globals.css";
+import { Inter } from "next/font/google";
+import ConvexClientProvider from "./ConvexClientProvider";
+
+const inter = Inter({ subsets: ["latin"] });
+
+export const metadata = {
+  title: "Create Next App",
+  description: "Generated by create next app",
+};
+
+export default function RootLayout({ children }) {
+  return (
+    <html lang="en">
+      <body className={inter.className}>
+        <ConvexClientProvider>{children}</ConvexClientProvider>
+      </body>
+    </html>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In <JSDialectFileName name="app/page.tsx" ext="js" />, use the `useQuery()` hook to fetch from your `api.tasks.get`
+    API function.
+
+    
+```tsx
+"use client";
+
+import Image from "next/image";
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function Home() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <main className="flex min-h-screen flex-col items-center justify-between p-24">
+      {tasks?.map(({ _id, text }) => <div key={_id}>{text}</div>)}
+    </main>
+  );
+}
+```
+
+```js
+"use client";
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export default function Home() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <main className="flex min-h-screen flex-col items-center justify-between p-24">
+      {tasks?.map(({ _id, text }) => (
+        <div key={_id}>{text}</div>
+      ))}
+    </main>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Run your Next.js development server, open [http://localhost:3000](http://localhost:3000) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete [Next.js documentation](/client/react/nextjs/nextjs.mdx).
diff --git a/synced/convex/docs/quickstart/nodejs.md b/synced/convex/docs/quickstart/nodejs.md
new file mode 100644
index 0000000..e4c5e98
--- /dev/null
+++ b/synced/convex/docs/quickstart/nodejs.md
@@ -0,0 +1,134 @@
+---
+title: Node.js Quickstart
+sidebar_label: Node.js
+description: "Add Convex to a Node.js project"
+hide_table_of_contents: true
+sidebar_position: 400
+---
+
+
+
+
+Learn how to query data from Convex in a Node.js project.
+
+For instructions for subscriptions instead of point-in-time queries and more
+project configurations (TypeScript, bundlers, CJS vs ESM) see
+[Node.js notes](/client/javascript/node.mdx).
+
+<StepByStep>
+  <Step title="Create a new npm project">
+    Create a new directory for your Node.js project.
+
+    ```sh
+    mkdir my-project && cd my-project && npm init -y && npm pkg set type="module"
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    Install the `convex`
+    package which provides a convenient interface for working
+    with Convex from JavaScript.
+
+    Also install the `dotenv` library for loading `.env` files.
+
+    ```sh
+    npm install convex dotenv
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Connect the script to your backend">
+    In a new file `script.js`, create a `ConvexHttpClient` using
+    the URL of your development environment.
+
+    
+```js
+import { ConvexHttpClient } from "convex/browser";
+import { api } from "./convex/_generated/api.js";
+import * as dotenv from "dotenv";
+dotenv.config({ path: ".env.local" });
+
+const client = new ConvexHttpClient(process.env["CONVEX_URL"]);
+
+client.query(api.tasks.get).then(console.log);
+```
+
+
+  </Step>
+
+  <Step title="Run the script">
+    Run the script from the same directory and see the list of tasks logged to the terminal.
+
+    ```sh
+    node script.js
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete [Node.js documentation](/client/javascript/node.mdx).
diff --git a/synced/convex/docs/quickstart/python.md b/synced/convex/docs/quickstart/python.md
new file mode 100644
index 0000000..61a561d
--- /dev/null
+++ b/synced/convex/docs/quickstart/python.md
@@ -0,0 +1,142 @@
+---
+title: Python Quickstart
+sidebar_label: Python
+description: "Add Convex to a Python project"
+hide_table_of_contents: true
+sidebar_position: 500
+---
+
+
+
+
+Learn how to query data from Convex in a Python app.
+
+<StepByStep>
+  <Step title="Create a Python script folder">
+    Create a folder for your Python script
+    with a virtual environment.
+
+    ```sh
+    python3 -m venv my-app/venv
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server libraries">
+    To get started, install the `convex` npm
+    package which enables you to write your
+    backend.
+
+    And also install the `convex` Python client
+    library and `python-dotenv` for working with `.env` files.
+
+    ```sh
+    cd my-app && npm init -y && npm install convex && venv/bin/pip install convex python-dotenv
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `"tasks:get"`.
+
+    
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  handler: async ({ db }) => {
+    return await db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Create a script to load data from Convex">
+    In a new file `main.py`, create a `ConvexClient` and use it
+    to fetch from your `"tasks:get"` API.
+    
+    
+```py
+import os
+
+from dotenv import load_dotenv
+
+from convex import ConvexClient
+
+load_dotenv(".env.local")
+CONVEX_URL = os.getenv("CONVEX_URL")
+# or you can hardcode your deployment URL instead
+# CONVEX_URL = "https://happy-otter-123.convex.cloud"
+
+client = ConvexClient(CONVEX_URL)
+
+print(client.query("tasks:get"))
+
+for tasks in client.subscribe("tasks:get"):
+    print(tasks)
+    # this loop lasts forever, ctrl-c to exit it
+```
+
+
+  </Step>
+
+  <Step title="Run the script">
+      Run the script 
+      and see the serialized list of tasks.
+
+      ```sh
+      venv/bin/python -m main
+      ```
+
+  </Step>
+
+</StepByStep>
+
+See the [docs on PyPI](https://pypi.org/project/convex/) for more details.
diff --git a/synced/convex/docs/quickstart/react-native.md b/synced/convex/docs/quickstart/react-native.md
new file mode 100644
index 0000000..e889e4f
--- /dev/null
+++ b/synced/convex/docs/quickstart/react-native.md
@@ -0,0 +1,177 @@
+---
+title: React Native Quickstart
+sidebar_label: React Native
+description: "Add Convex to a React Native Expo project"
+hide_table_of_contents: true
+sidebar_position: 300
+---
+
+
+
+
+
+Learn how to query data from Convex in a React Native app.
+
+<StepByStep>
+  <Step title="Create a React Native app">
+    Create a React Native app using the `npx create-expo-app` command.
+
+    ```sh
+    npx create-expo-app my-app
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    To get started, install the `convex`
+    package which provides a convenient interface for working
+    with Convex from a React app.
+
+    Navigate to your app and install `convex`.
+
+    ```sh
+    cd my-app && npm install convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    Create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table with the sample data into
+    your Convex database with the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.ts` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Reset the Expo project">
+    If you haven't done so yet, reset the Expo project to get a fresh
+    `app` directory.
+
+    ```
+    npm run reset-project
+    ```
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+    In `_layout.tsx`, create a `ConvexReactClient` and pass it to a `ConvexProvider`
+    wrapping your component tree.
+
+    
+```tsx
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+import { Stack } from "expo-router";
+
+const convex = new ConvexReactClient(process.env.EXPO_PUBLIC_CONVEX_URL!, {
+  unsavedChangesWarning: false,
+});
+
+export default function RootLayout() {
+  return (
+    <ConvexProvider client={convex}>
+      <Stack>
+        <Stack.Screen name="index" />
+      </Stack>
+    </ConvexProvider>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In `index.tsx` use the `useQuery` hook to fetch
+    from your `api.tasks.get` API.
+
+    
+```tsx
+import { api } from "@/convex/_generated/api";
+import { useQuery } from "convex/react";
+import { Text, View } from "react-native";
+
+export default function Index() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <View
+      style={{
+        flex: 1,
+        justifyContent: "center",
+        alignItems: "center",
+      }}
+    >
+      {tasks?.map(({ _id, text }) => <Text key={_id}>{text}</Text>)}
+    </View>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, scan the provided QR code with your phone,
+    and see the serialized list of tasks in the center of the screen.
+
+    ```sh
+    npm start
+    ```
+
+  </Step>
+</StepByStep>
+
+React native uses the same library as React web. See the complete
+[React documentation](/client/react.mdx).
diff --git a/synced/convex/docs/quickstart/react.md b/synced/convex/docs/quickstart/react.md
new file mode 100644
index 0000000..d5314fd
--- /dev/null
+++ b/synced/convex/docs/quickstart/react.md
@@ -0,0 +1,264 @@
+---
+title: React Quickstart
+sidebar_label: React
+description: "Add Convex to a React project"
+hide_table_of_contents: true
+sidebar_position: 100
+---
+
+
+
+
+
+
+
+
+To get setup quickly with Convex and React run
+
+<p>
+  <b>
+    <CodeWithCopyButton text="npm create convex@latest" />
+  </b>
+</p>
+
+or follow the guide below.
+
+---
+
+Learn how to query data from Convex in a React app using Vite
+and<LanguageSelector verbose />
+
+<StepByStep>
+  <Step title="Create a React app">
+    Create a React app using the `create vite` command.
+
+    <JSDialectVariants>
+      ```sh
+      npm create vite@latest my-app -- --template react-ts
+      ```
+
+      ```sh
+      npm create vite@latest my-app -- --template react
+      ```
+    </JSDialectVariants>
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    To get started, install the `convex`
+    package which provides a convenient interface for working
+    with Convex from a React app.
+
+    Navigate to your app directory and install `convex`.
+
+
+    ```sh
+    cd my-app && npm install convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="(optional) Define a schema">
+    Add a new file `schema.ts` in the `convex/` folder
+    with a description of your data.
+
+    This will declare the types of your data for optional
+    typechecking with TypeScript, and it will be also
+    enforced at runtime.
+
+    <JSDialectVariants>
+    Alternatively remove the line `'plugin:@typescript-eslint/recommended-requiring-type-checking',`
+    from the `.eslintrc.cjs` file to lower the type checking strictness.
+
+    <></>
+    </JSDialectVariants>
+
+    ```ts noDialect title="convex/schema.ts"
+    import { defineSchema, defineTable } from "convex/server";
+    import { v } from "convex/values";
+
+    export default defineSchema({
+      tasks: defineTable({
+        text: v.string(),
+        isCompleted: v.boolean(),
+      }),
+    });
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+    In <JSDialectFileName name="src/main.jsx" />, create a `ConvexReactClient` and pass it to a `ConvexProvider`
+    wrapping your app.
+
+    
+```tsx
+import React from "react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);
+
+ReactDOM.createRoot(document.getElementById("root")!).render(
+  <React.StrictMode>
+    <ConvexProvider client={convex}>
+      <App />
+    </ConvexProvider>
+  </React.StrictMode>,
+);
+```
+
+```jsx
+import React from "react";
+import ReactDOM from "react-dom/client";
+import App from "./App";
+import "./index.css";
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+
+const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
+
+ReactDOM.createRoot(document.getElementById("root")).render(
+  <React.StrictMode>
+    <ConvexProvider client={convex}>
+      <App />
+    </ConvexProvider>
+  </React.StrictMode>,
+);
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In <JSDialectFileName name="src/App.jsx" />, use the `useQuery` hook to fetch from your `api.tasks.get`
+    API function and display the data.
+
+    
+```tsx
+import "./App.css";
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+function App() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <div className="App">
+      {tasks?.map(({ _id, text }) => <div key={_id}>{text}</div>)}
+    </div>
+  );
+}
+
+export default App;
+```
+
+```jsx
+import "./App.css";
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+function App() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <div className="App">
+      {tasks?.map(({ _id, text }) => (
+        <div key={_id}>{text}</div>
+      ))}
+    </div>
+  );
+}
+
+export default App;
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, open [http://localhost:5173/](http://localhost:5173/) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete [React documentation](/client/react.mdx).
diff --git a/synced/convex/docs/quickstart/remix.md b/synced/convex/docs/quickstart/remix.md
new file mode 100644
index 0000000..3be80e9
--- /dev/null
+++ b/synced/convex/docs/quickstart/remix.md
@@ -0,0 +1,197 @@
+---
+title: Remix Quickstart
+sidebar_label: Remix
+description: "Add Convex to a Remix project"
+hide_table_of_contents: true
+sidebar_position: 200
+---
+
+
+
+
+
+Learn how to query data from Convex in a Remix app.
+
+<StepByStep>
+  <Step title="Create a Remix site">
+    Create a Remix site using the `npx create-remix@latest` command.
+
+    <br></br>
+
+    ```sh
+    npx create-remix@latest my-remix-app
+    ```
+
+  </Step>
+
+  <Step title="Install the Convex library">
+    To get started, install the `convex` package.
+
+    ```sh
+    cd my-remix-app && npm install convex
+    ```
+
+  </Step>
+
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Wire up the ConvexProvider">
+    Modify `app/root.tsx` to set up the Convex client there to make it available on every page of your app.
+
+    
+```tsx
+import {
+  Links,
+  Meta,
+  Outlet,
+  Scripts,
+  ScrollRestoration,
+  json,
+  useLoaderData,
+} from "@remix-run/react";
+import { ConvexProvider, ConvexReactClient } from "convex/react";
+import { useState } from "react";
+
+export async function loader() {
+  const CONVEX_URL = process.env["CONVEX_URL"]!;
+  return json({ ENV: { CONVEX_URL } });
+}
+
+export function Layout({ children }: { children: React.ReactNode }) {
+  const { ENV } = useLoaderData<typeof loader>();
+  const [convex] = useState(() => new ConvexReactClient(ENV.CONVEX_URL));
+  return (
+    <html lang="en">
+      <head>
+        <meta charSet="utf-8" />
+        <meta name="viewport" content="width=device-width, initial-scale=1" />
+        <Meta />
+        <Links />
+      </head>
+      <body>
+        <ConvexProvider client={convex}>{children}</ConvexProvider>
+        <ScrollRestoration />
+        <Scripts />
+      </body>
+    </html>
+  );
+}
+
+export default function App() {
+  return <Outlet />;
+}
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In `app/routes/_index.tsx` use `useQuery` to subscribe your `api.tasks.get`
+    API function.
+
+    
+```tsx
+import type { MetaFunction } from "@remix-run/node";
+import { api } from "convex/_generated/api";
+import { useQuery } from "convex/react";
+
+export const meta: MetaFunction = () => {
+  return [
+    { title: "New Remix App" },
+    { name: "description", content: "Welcome to Remix!" },
+  ];
+};
+
+export default function Index() {
+  const tasks = useQuery(api.tasks.get);
+  return (
+    <div style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.8" }}>
+      <h1>Welcome to Remix</h1>
+      {tasks === undefined
+        ? "loading..."
+        : tasks.map(({ _id, text }) => <div key={_id}>{text}</div>)}
+    </div>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, open [http://localhost:5173](http://localhost:5173) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
+
+Remix uses the React web library. See the complete
+[React documentation](/client/react.mdx).
diff --git a/synced/convex/docs/quickstart/rust.md b/synced/convex/docs/quickstart/rust.md
new file mode 100644
index 0000000..05f5196
--- /dev/null
+++ b/synced/convex/docs/quickstart/rust.md
@@ -0,0 +1,104 @@
+---
+title: Rust Quickstart
+sidebar_label: Rust
+description: "Add Convex to a Rust project"
+hide_table_of_contents: true
+sidebar_position: 700
+---
+
+
+
+
+Learn how to query data from Convex in a Rust app with Tokio.
+
+<StepByStep>
+  <Step title="Create a Cargo project">
+    Create a new Cargo project.
+
+    ```sh
+    cargo new my_app
+    cd my_app
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server libraries">
+    To get started, install the `convex` npm
+    package which enables you to write your
+    backend.
+
+    And also install the `convex` Rust client library,
+    the `tokio` runtime, and `dotenvy` for working with `.env` files.
+
+    ```sh
+    npm init -y && npm install convex && cargo add convex tokio dotenvy
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    > **⚠ snippet "sampleData" not found**
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `"tasks:get"`.
+
+    > **⚠ snippet "tasks" not found**
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+    In the file `src/main.rs`, create a `ConvexClient` and use it
+    to fetch from your `"tasks:get"` API.
+    
+    > **⚠ snippet "main" not found**
+
+  </Step>
+
+  <Step title="Run the app">
+      Run the app and see the serialized list of tasks.
+
+      ```sh
+      cargo run
+      ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete [Rust documentation](https://docs.rs/convex/latest/convex/).
diff --git a/synced/convex/docs/quickstart/script-tag.md b/synced/convex/docs/quickstart/script-tag.md
new file mode 100644
index 0000000..d02fb37
--- /dev/null
+++ b/synced/convex/docs/quickstart/script-tag.md
@@ -0,0 +1,131 @@
+---
+title: Script Tag Quickstart
+sidebar_label: Script Tag
+description: "Add Convex to any website"
+hide_table_of_contents: true
+sidebar_position: 450
+---
+
+
+
+
+Learn how to query data from Convex from script tags in HTML.
+
+<StepByStep>
+  <Step title="Create a new npm project">
+    Create a new directory for your Convex project.
+
+    ```sh
+    mkdir my-project && cd my-project && npm init -y
+    ```
+
+  </Step>
+  <Step title="Install the Convex client and server library">
+    Install the `convex`
+    package which provides a convenient interface for working
+    with Convex from JavaScript.
+
+    ```sh
+    npm install convex
+    ```
+
+  </Step>
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.js` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```js
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Copy the deployment URL">
+    Open the `.env.local` file and copy the `CONVEX_URL` of your development
+    environment for use in the HTML file.
+
+    <></>
+
+  </Step>
+
+  <Step title="Add the script to your webpage">
+    In a new file `index.html`, create a `ConvexClient` using
+    the URL of your development environment.
+
+    Open this file in a web browser and you'll see it run each time the `tasks`
+    table is modified.
+
+    
+```html
+<!doctype html>
+<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
+<script>
+  const CONVEX_URL = "http://localhost:8000";
+  const client = new convex.ConvexClient(CONVEX_URL);
+  client.onUpdate("messages:list", {}, (messages) =>
+    console.log(messages.map((msg) => msg.body)),
+  );
+</script>
+```
+
+
+  </Step>
+
+</StepByStep>
+
+See the complete [Script Tag documentation](/client/javascript/script-tag.mdx).
diff --git a/synced/convex/docs/quickstart/svelte.md b/synced/convex/docs/quickstart/svelte.md
new file mode 100644
index 0000000..974beaf
--- /dev/null
+++ b/synced/convex/docs/quickstart/svelte.md
@@ -0,0 +1,157 @@
+---
+title: Svelte Quickstart
+sidebar_label: Svelte
+description: "Add Convex to a Svelte project"
+hide_table_of_contents: true
+sidebar_position: 350
+---
+
+
+
+
+
+Learn how to query data from Convex in a Svelte app.
+
+<StepByStep>
+  <Step title="Create a SvelteKit app">
+    Create a SvelteKit app using the `npx sv create` command.
+
+    Other sets of options will work with the library but for this quickstart guide:
+
+    - For "Which Svelte app template," choose **"SvelteKit minimal."**
+    - For a package manager, choose **"npm."**
+    - For "Add type checking with TypeScript," choose **"Yes, using TypeScript syntax."**
+    - For "Select additional options," you don't need to enable anything.
+
+    <br></br>
+
+    ```sh
+    npx sv@latest create my-app
+    ```
+
+  </Step>
+
+  <Step title="Install the Convex client and server library">
+    To get started, install the `convex` and `convex-svelte` packages.
+
+    ```sh
+    cd my-app && npm install convex convex-svelte
+    ```
+
+  </Step>
+
+  <Step title="Customize the convex path">
+    SvelteKit doesn't like referencing code outside of source, so customize
+    the convex functionsDir to be under `src/`.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    const tasks = await ctx.db.query("tasks").collect();
+    return tasks.map((task) => ({ ...task, assigner: "tom" }));
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Set up Convex">
+    Create a new file `src/routes/+layout.svelte` and set up the Convex client there to make it available on every page of your app.
+
+    
+```svelte
+<script lang="ts">
+	import { PUBLIC_CONVEX_URL } from '$env/static/public';
+	import { setupConvex } from 'convex-svelte';
+
+	const { children } = $props();
+	setupConvex(PUBLIC_CONVEX_URL);
+</script>
+
+{@render children()}
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In `src/routes/+page.svelte` use `useQuery` to subscribe your `api.tasks.get`
+    API function.
+
+    
+```svelte
+<script lang="ts">
+	import { useQuery } from 'convex-svelte';
+	import { api } from '../convex/_generated/api.js';
+
+	const query = useQuery(api.tasks.get, {});
+</script>
+
+{#if query.isLoading}
+	Loading...
+{:else if query.error}
+	failed to load: {query.error.toString()}
+{:else}
+	<ul>
+		{#each query.data as task}
+			<li>
+				{task.isCompleted ? '☑' : '☐'}
+				<span>{task.text}</span>
+				<span>assigned by {task.assigner}</span>
+			</li>
+		{/each}
+	</ul>
+{/if}
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, open [http://localhost:5173](http://localhost:5173) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the
+[Svelte npm package documentation](https://www.npmjs.com/package/convex-svelte).
diff --git a/synced/convex/docs/quickstart/swift.md b/synced/convex/docs/quickstart/swift.md
new file mode 100644
index 0000000..49f8270
--- /dev/null
+++ b/synced/convex/docs/quickstart/swift.md
@@ -0,0 +1,187 @@
+---
+title: iOS Swift Quickstart
+sidebar_label: iOS Swift
+description: "Add Convex to an iOS Swift project"
+hide_table_of_contents: true
+sidebar_position: 600
+---
+
+Learn how to query data from Convex in an application targeting iOS and MacOS
+devices built with Swift and SwiftUI.
+
+This quickstart assumes that you have a Mac with Xcode, node and npm installed.
+If you don’t have those tools, take time to install them first.
+
+<StepByStep>
+  <Step title="Create a new iOS app in Xcode">
+    1. Click *Create New Project*
+    2. Select iOS App and click *Next*
+    3. Name your project something like “ConvexQuickstart”
+    4. Ensure Language is set to Swift and User Interface is SwiftUI
+    5. Click *Next*
+    
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/swift_qs_step_1.png" alt="Create new iOS project" width={600} />
+    </p>
+  </Step>
+
+  <Step title="Configure dependencies">
+    1. Click on the top-level ConvexQuickstart app container in the project
+      navigator on the left
+    2.  Click on ConvexQuickstart under the PROJECT heading
+    3.  Click the Package Dependencies tab
+    4.  Click the + button (See Screenshot)
+    5.  Paste
+        ```
+        https://github.com/get-convex/convex-swift
+        ```
+        into the search box and press enter
+    6.  When the `convex-swift` package loads, click the *Add Package* button
+    7.  In the *Package Products* dialog, select ConvexQuickstart in the 
+        *Add to Target* dropdown
+    8.  Click the Add Package button
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/swift_qs_step_2.png" alt="Add Convex dependency to package" width={600} />
+    </p>
+
+  </Step>
+  <br/>
+  <Step title="Install the Convex backend">
+    Open a terminal and `cd` to the directory for the Xcode project you
+    created. Run the following commands to install the Convex client and
+    server library.
+
+    ```bash
+    npm init -y
+    npm install convex
+    ```
+
+  </Step>
+
+  <Step title="Start Convex">
+    Start a Convex dev deployment. Follow the command line instructions to
+    create a new project.
+
+    ```bash
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    Create a new `sampleData.jsonl` file in your Swift project directory with
+    these contents
+
+    ```json
+    {"text": "Buy groceries", "isCompleted": true}
+    {"text": "Go for a swim", "isCompleted": true}
+    {"text": "Integrate Convex", "isCompleted": false}
+    ```
+
+  </Step>
+
+  <Step title="Add the sample data to a table called `tasks` in your database">
+    Open another terminal tab by pressing ⌘+T which should open in your Swift
+    project directory and run
+
+    ```bash
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Create a `tasks.ts` file in the `convex/` directory within your Swift
+    project with the following contents
+
+    ```tsx
+    import { query } from "./_generated/server";
+
+    export const get = query({
+      args: {},
+      handler: async (ctx) => {
+        return await ctx.db.query("tasks").collect();
+      },
+    });
+    ```
+
+  </Step>
+
+  <Step title="Create a Swift struct">
+    Back in Xcode, create a `struct` at the bottom of the `ContentView` file to
+    match the sample data
+
+    ```swift
+    // We're using the name Todo instead of Task to avoid clashing with
+    // Swift's builtin Task type.
+    struct Todo: Decodable {
+      let _id: String
+      let text: String
+      let isCompleted: Bool
+    }
+    ```
+
+  </Step>
+
+  <Step title="Connect the app to your backend">
+   1. Get the deployment URL of your dev server
+      with `cat .env.local | grep CONVEX_URL`
+   2. Create a `ConvexClient` instance near the top of the file, just above the
+      `ContentView` struct
+
+    ```swift
+    import SwiftUI
+    import ConvexMobile
+
+    // highlight-next-line
+    let convex = ConvexClient(deploymentUrl: "YOUR_CONVEX_URL")
+
+    struct ContentView: View {
+    ...
+    ```
+
+  </Step>
+
+  <Step title="Create your UI">
+
+    Replace the default `ContentView` with the following code that will
+    refresh the list of todo items whenever the backend data changes.
+
+    ```swift
+    struct ContentView: View {
+      @State private var todos: [Todo] = []
+
+      var body: some View {
+        List {
+          ForEach(todos, id: \._id) { todo in
+            Text(todo.text)
+          }
+        }.task {
+          for await todos: [Todo] in convex.subscribe(to: "tasks:get")
+            .replaceError(with: []).values
+          {
+            self.todos = todos
+          }
+        }.padding()
+      }
+    }
+    ```
+
+  </Step>
+
+  <Step title="Run the app">
+    1. Press ⌘+R or click *Product → Run*
+    2. You can also try adding, updating or
+    deleting documents in your `tasks` table at `dashboard.convex.dev` - the app
+    will update with the changes in real-time.
+
+    <p style={{textAlign: 'center'}}>
+      <img src="/screenshots/swift_qs_final.png" alt="App preview" width={400} />
+    </p>
+
+  </Step>
+
+</StepByStep>
+
+See the complete [iOS Swift documentation](/client/swift.md).
diff --git a/synced/convex/docs/quickstart/tanstack-start.md b/synced/convex/docs/quickstart/tanstack-start.md
new file mode 100644
index 0000000..31ebc86
--- /dev/null
+++ b/synced/convex/docs/quickstart/tanstack-start.md
@@ -0,0 +1,304 @@
+---
+title: TanStack Start Quickstart
+sidebar_label: TanStack Start
+description: "Add Convex to a TanStack Start project"
+hide_table_of_contents: true
+sidebar_position: 200
+---
+
+
+
+
+
+
+<Admonition type="caution" title="TanStack Start is in Beta">
+
+[TanStack Start](https://tanstack.com/start/latest) is a new React framework
+currently in beta. You can try it today but there are likely to be breaking
+changes before a stable release.
+
+</Admonition>
+
+To get setup quickly with Convex and TanStack Start run
+
+<p>
+  <b>
+    <CodeWithCopyButton text="npm create convex@latest -- -t tanstack-start" />
+  </b>
+</p>
+
+or follow the guide below.
+
+To use Clerk with Convex and TanStack Start, see the
+[TanStack Start + Clerk guide](/client/react/tanstack-start/clerk.mdx)
+
+---
+
+Learn how to query data from Convex in a TanStack Start site.
+
+<StepByStep>
+  <Step title="Create a TanStack Start site">
+
+The TanStack team intends to release a CLI template starter soon, but until the
+official way to create a new TanStack Start site is to follow the TanStack Start
+[getting started](https://tanstack.com/router/latest/docs/framework/react/start/getting-started)
+guide.
+
+Once you've finished you'll have a directory called myApp with a minimal
+TanStack Start app in it.
+
+      ```sh
+      .
+      ├── app/
+      │   ├── routes/
+      │   │   ├── `index.tsx`
+      │   │   └── `__root.tsx`
+      │   ├── `client.tsx`
+      │   ├── `router.tsx`
+      │   ├── `routeTree.gen.ts`
+      │   └── `ssr.tsx`
+      ├── `.gitignore`
+      ├── `app.config.ts`
+      ├── `package.json`
+      └── `tsconfig.json`
+      ```
+
+</Step>
+  <Step title="Install the Convex client and server library">
+    To get started with Convex install the `convex` package and a few React Query-related packages.
+
+    ```sh
+    npm install convex @convex-dev/react-query @tanstack/react-router-with-query @tanstack/react-query
+    ```
+
+  </Step>
+
+  <Step title="Update app/routes/__root.tsx">
+    Add a `QueryClient` to the router context to make React Query usable anywhere in the TanStack Start site.
+
+    
+```tsx
+import { QueryClient } from "@tanstack/react-query";
+import { createRootRouteWithContext } from "@tanstack/react-router";
+import { Outlet, ScrollRestoration } from "@tanstack/react-router";
+import { Meta, Scripts } from "@tanstack/start";
+import * as React from "react";
+
+export const Route = createRootRouteWithContext<{
+  queryClient: QueryClient;
+}>()({
+  head: () => ({
+    meta: [
+      {
+        charSet: "utf-8",
+      },
+      {
+        name: "viewport",
+        content: "width=device-width, initial-scale=1",
+      },
+      {
+        title: "TanStack Start Starter",
+      },
+    ],
+  }),
+  component: RootComponent,
+});
+
+function RootComponent() {
+  return (
+    <RootDocument>
+      <Outlet />
+    </RootDocument>
+  );
+}
+
+function RootDocument({ children }: { children: React.ReactNode }) {
+  return (
+    <html>
+      <head>
+        <Meta />
+      </head>
+      <body>
+        {children}
+        <ScrollRestoration />
+        <Scripts />
+      </body>
+    </html>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Update app/router.tsx">
+    Replace the file `app/router.tsx` with these contents.
+
+    This creates a `ConvexClient` and a `ConvexQueryClient` and wires in a `ConvexProvider`.
+
+    
+```tsx
+import { createRouter as createTanStackRouter } from "@tanstack/react-router";
+import { QueryClient } from "@tanstack/react-query";
+import { routerWithQueryClient } from "@tanstack/react-router-with-query";
+import { ConvexQueryClient } from "@convex-dev/react-query";
+import { ConvexProvider } from "convex/react";
+import { routeTree } from "./routeTree.gen";
+
+export function createRouter() {
+  const CONVEX_URL = (import.meta as any).env.VITE_CONVEX_URL!;
+  if (!CONVEX_URL) {
+    console.error("missing envar VITE_CONVEX_URL");
+  }
+  const convexQueryClient = new ConvexQueryClient(CONVEX_URL);
+
+  const queryClient: QueryClient = new QueryClient({
+    defaultOptions: {
+      queries: {
+        queryKeyHashFn: convexQueryClient.hashFn(),
+        queryFn: convexQueryClient.queryFn(),
+      },
+    },
+  });
+  convexQueryClient.connect(queryClient);
+
+  const router = routerWithQueryClient(
+    createTanStackRouter({
+      routeTree,
+      defaultPreload: "intent",
+      context: { queryClient },
+      Wrap: ({ children }) => (
+        <ConvexProvider client={convexQueryClient.convexClient}>
+          {children}
+        </ConvexProvider>
+      ),
+    }),
+    queryClient,
+  );
+
+  return router;
+}
+
+declare module "@tanstack/react-router" {
+  interface Register {
+    router: ReturnType<typeof createRouter>;
+  }
+}
+```
+
+
+  </Step>
+
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file <JSDialectFileName name="tasks.ts" /> in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    Replace the file `app/routes/index.tsx` with these contents.
+
+    The `useSuspenseQuery` hook renders the API function `api.tasks.get`
+    query result on the server initially, then it updates live in the browser.
+
+    
+```tsx
+import { convexQuery } from "@convex-dev/react-query";
+import { useSuspenseQuery } from "@tanstack/react-query";
+import { createFileRoute } from "@tanstack/react-router";
+import { api } from "../../convex/_generated/api";
+
+export const Route = createFileRoute("/")({
+  component: Home,
+});
+
+function Home() {
+  const { data } = useSuspenseQuery(convexQuery(api.tasks.get, {}));
+
+  return (
+    <div>
+      {data.map(({ _id, text }) => (
+        <div key={_id}>{text}</div>
+      ))}
+    </div>
+  );
+}
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, open [http://localhost:3000](http://localhost:3000) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
+
+For more see the
+[TanStack Start with Convex](/client/react/tanstack-start/tanstack-start.mdx)
+client documentation page.
diff --git a/synced/convex/docs/quickstart/vue.md b/synced/convex/docs/quickstart/vue.md
new file mode 100644
index 0000000..db9209b
--- /dev/null
+++ b/synced/convex/docs/quickstart/vue.md
@@ -0,0 +1,173 @@
+---
+title: Vue Quickstart
+sidebar_label: Vue
+description: "Add Convex to a Vue project"
+hide_table_of_contents: true
+sidebar_position: 325
+---
+
+
+
+
+
+Learn how to query data from Convex in a Vue app.
+
+This quickstart guide uses a [community-maintained](/client/vue.md) Vue client
+for Convex.
+
+<StepByStep>
+  <Step title="Create a Vue site">
+    Create a Vue site using the `npm create vue@latest my-vue-app` command.
+
+    Convex will work with any set of options but to follow this quickstart most closely choose:
+    * Yes to "Add TypeScript?"
+    * No to everything else
+
+    <br></br>
+
+    ```sh
+    npm create vue@latest my-vue-app
+    ```
+
+  </Step>
+
+  <Step title="Install the Convex library">
+    To get started, install the `convex` package.
+
+    ```sh
+    cd my-vue-app && npm install @convex-vue/core @vueuse/core convex
+    ```
+
+  </Step>
+
+  <Step title="Set up a Convex dev deployment">
+    Next, run `npx convex dev`. This
+    will prompt you to log in with GitHub,
+    create a project, and save your production and deployment URLs.
+
+    It will also create a `convex/` folder for you
+    to write your backend API functions in. The `dev` command
+    will then continue running to sync your functions
+    with your dev deployment in the cloud.
+
+
+    ```sh
+    npx convex dev
+    ```
+
+  </Step>
+
+  <Step title="Create sample data for your database">
+    In a new terminal window, create a `sampleData.jsonl`
+    file with some sample data.
+
+    
+```json
+{"text": "Buy groceries", "isCompleted": true}
+{"text": "Go for a swim", "isCompleted": true}
+{"text": "Integrate Convex", "isCompleted": false}
+```
+
+
+  </Step>
+
+  <Step title="Add the sample data to your database">
+    Now that your project is ready, add a `tasks` table
+    with the sample data into your Convex database with
+    the `import` command.
+
+    ```
+    npx convex import --table tasks sampleData.jsonl
+    ```
+
+  </Step>
+
+  <Step title="Expose a database query">
+    Add a new file `tasks.ts` in the `convex/` folder
+    with a query function that loads the data.
+
+    Exporting a query function from this file
+    declares an API function named after the file
+    and the export name, `api.tasks.get`.
+
+    
+```ts
+import { query } from "./_generated/server";
+
+export const get = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("tasks").collect();
+  },
+});
+```
+
+
+  </Step>
+
+  <Step title="Wire up the ConvexProvider">
+    In `src/main.ts` set up the Convex client there to make it available on every page of your app.
+
+    
+```ts
+import "./assets/main.css";
+
+import { createApp } from "vue";
+import App from "./App.vue";
+import { createConvexVue } from "@convex-vue/core";
+
+const app = createApp(App);
+
+const convexVue = createConvexVue({
+  convexUrl: import.meta.env.VITE_CONVEX_URL,
+});
+
+app.use(convexVue).mount("#app");
+```
+
+
+  </Step>
+
+  <Step title="Display the data in your app">
+    In `src/App.vue` use `useQuery` to subscribe your `api.tasks.get`
+    API function.
+
+    
+```vue
+<script setup lang="ts">
+
+import { useConvexQuery } from "@convex-vue/core";
+import { api } from "../convex/_generated/api";
+
+const { data, isLoading } = useConvexQuery(api.tasks.get, {});
+</script>
+
+<template>
+  <div class="wrapper">
+    <ul v-if="!isLoading">
+      <li v-for="todo in data">
+        {{ todo.text }} {{ todo.isCompleted ? "☑" : "☐" }}
+      </li>
+    </ul>
+    <span v-else> loading... </span>
+  </div>
+</template>
+```
+
+
+  </Step>
+
+  <Step title="Start the app">
+    Start the app, open [http://localhost:5173](http://localhost:5173) in a browser,
+    and see the list of tasks.
+
+    ```sh
+    npm run dev
+    ```
+
+  </Step>
+
+</StepByStep>
+
+See the complete
+[Vue npm package documentation](https://www.npmjs.com/package/@convex-vue/core).
diff --git a/synced/convex/docs/quickstarts.md b/synced/convex/docs/quickstarts.md
new file mode 100644
index 0000000..90e3297
--- /dev/null
+++ b/synced/convex/docs/quickstarts.md
@@ -0,0 +1,17 @@
+---
+title: Quickstarts
+hide_table_of_contents: true
+---
+
+import {
+  QuickLanguagesList,
+  QuickFrameworksList,
+} from "@site/src/QuickstartsList.tsx";
+
+Quickly get up and running with your favorite frontend tooling:
+
+<QuickFrameworksList />
+
+Quickly get up and running with your favorite languages:
+
+<QuickLanguagesList />
diff --git a/synced/convex/docs/realtime.md b/synced/convex/docs/realtime.md
new file mode 100644
index 0000000..31afdf7
--- /dev/null
+++ b/synced/convex/docs/realtime.md
@@ -0,0 +1,41 @@
+---
+title: "Realtime"
+sidebar_position: 100
+description: "Building realtime apps with Convex"
+---
+
+Turns out Convex is automatically realtime! You don’t have to do anything
+special if you are already using [query functions](./functions/query-functions),
+[database](./database), and [client libraries](./client/react/) in your app.
+Convex tracks the dependencies to your query functions, including database
+changes, and triggers the subscription in the client libraries.
+
+<div align="center">
+  ![Convex is automatically reactive and realtime](/img/realtime.gif)
+</div>
+
+Aside from building a highly interactive app with ease, there are other benefits
+to the realtime architecture of Convex:
+
+## Automatic caching
+
+Convex automatically caches the result of your query functions so that future
+calls just read from the cache. The cache is updated if the data ever changes.
+You don't get charged for database bandwidth for cached reads.
+
+This requires no work or bookkeeping from you.
+
+## Consistent data across your app
+
+Every client subscription gets updated simultaneously to the same snapshot of
+the database. Your app always displays the most consistent view of your data.
+
+This avoids bugs like increasing the number of items in the shopping cart and
+not showing that an item is sold out.
+
+## Learn more
+
+Learn how to work with realtime and reactive queries in Convex on
+[Stack](https://stack.convex.dev/tag/Reactivity).
+
+<StackPosts query="reactivity" />
diff --git a/synced/convex/docs/scheduling.md b/synced/convex/docs/scheduling.md
new file mode 100644
index 0000000..67ca6a2
--- /dev/null
+++ b/synced/convex/docs/scheduling.md
@@ -0,0 +1,55 @@
+---
+title: "Scheduling"
+hide_table_of_contents: true
+pagination_prev: auth
+---
+
+import { ComponentCardList } from "@site/src/components/ComponentCard";
+
+Convex lets you easily schedule a function to run once or repeatedly in the
+future. This allows you to build durable workflows like sending a welcome email
+a day after someone joins or regularly reconciling your accounts with Stripe.
+Convex provides two different features for scheduling:
+
+- [Scheduled Functions](/scheduling/scheduled-functions.mdx) can be scheduled
+  durably by any other function to run at a later point in time. You can
+  schedule functions minutes, days, and even months in the future.
+- [Cron Jobs](/scheduling/cron-jobs.mdx) schedule functions to run on a
+  recurring basis, such as daily.
+
+## Durable function components
+
+Built-in scheduled functions and crons work well for simpler apps and workflows.
+If you're operating at high scale or need more specific guarantees, use the
+following higher-level [components](/components.mdx) for durable functions.
+
+<ComponentCardList
+  items={[
+    {
+      title: "Workpool",
+      description:
+        "Workpool give critical tasks priority by organizing async operations into separate, customizable queues.",
+      href: "https://www.convex.dev/components/workpool",
+    },
+    {
+      title: "Workflow",
+      description:
+        "Simplify programming long running code flows. Workflows execute durably with configurable retries and delays.",
+      href: "https://www.convex.dev/components/workflow",
+    },
+    {
+      title: "Action Retrier",
+      description:
+        "Add reliability to an unreliable external service. Retry idempotent calls a set number of times.",
+      href: "https://www.convex.dev/components/retrier",
+    },
+    {
+      title: "Crons",
+      description:
+        "Use cronspec to run functions on a repeated schedule at runtime.",
+      href: "https://www.convex.dev/components/crons",
+    },
+  ]}
+/>
+
+<StackPosts query="scheduler" />
diff --git a/synced/convex/docs/scheduling/cron-jobs.md b/synced/convex/docs/scheduling/cron-jobs.md
new file mode 100644
index 0000000..697cbdd
--- /dev/null
+++ b/synced/convex/docs/scheduling/cron-jobs.md
@@ -0,0 +1,127 @@
+---
+title: "Cron Jobs"
+sidebar_position: 2
+---
+
+
+Convex allows you to schedule functions to run on a recurring basis. For
+example, cron jobs can be used to clean up data at a regular interval, send a
+reminder email at the same time every month, or schedule a backup every
+Saturday.
+
+**Example:**
+[Cron Jobs](https://github.com/get-convex/convex-demos/tree/main/cron-jobs)
+
+## Defining your cron jobs
+
+Cron jobs are defined in a `crons.ts` file in your `convex/` directory and look
+like:
+
+
+```ts
+import { cronJobs } from "convex/server";
+import { internal } from "./_generated/api";
+
+const crons = cronJobs();
+
+crons.interval(
+  "clear messages table",
+  { minutes: 1 }, // every minute
+  internal.messages.clearAll,
+);
+
+crons.monthly(
+  "payment reminder",
+  { day: 1, hourUTC: 16, minuteUTC: 0 }, // Every month on the first day at 8:00am PST
+  internal.payments.sendPaymentEmail,
+  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail
+);
+
+// An alternative way to create the same schedule as above with cron syntax
+crons.cron(
+  "payment reminder duplicate",
+  "0 16 1 * *",
+  internal.payments.sendPaymentEmail,
+  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail
+);
+
+export default crons;
+```
+
+```ts
+import { cronJobs } from "convex/server";
+import { internal } from "./_generated/api";
+
+const crons = cronJobs();
+
+crons.interval(
+  "clear messages table",
+  { minutes: 1 }, // every minute
+  internal.messages.clearAll,
+);
+
+crons.monthly(
+  "payment reminder",
+  { day: 1, hourUTC: 16, minuteUTC: 0 }, // Every month on the first day at 8:00am PST
+  internal.payments.sendPaymentEmail,
+  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail
+);
+
+// An alternative way to create the same schedule as above with cron syntax
+crons.cron(
+  "payment reminder duplicate",
+  "0 16 1 * *",
+  internal.payments.sendPaymentEmail,
+  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail
+);
+
+export default crons;
+```
+
+
+The first argument is a unique identifier for the cron job.
+
+The second argument is the schedule at which the function should run, see
+[Supported schedules](/scheduling/cron-jobs.mdx#supported-schedules) below.
+
+The third argument is the name of the public function or
+[internal function](/functions/internal-functions.mdx), either a
+[mutation](/functions/mutation-functions.mdx) or an
+[action](/functions/actions.mdx).
+
+## Supported schedules
+
+- [`crons.interval()`](/api/classes/server.Crons#interval) runs a function every
+  specified number of `seconds`, `minutes`, or `hours`. The first run occurs
+  when the cron job is first deployed to Convex. Unlike traditional crons, this
+  option allows you to have seconds-level granularity.
+- [`crons.cron()`](/api/classes/server.Crons#cron) the traditional way of
+  specifying cron jobs by a string with five fields separated by spaces
+  <nobr>(e.g. `"* * * * *"`)</nobr>. Times in cron syntax are in the UTC
+  timezone. [Crontab Guru](https://crontab.guru/) is a helpful resource for
+  understanding and creating schedules in this format.
+- [`crons.hourly()`](/api/classes/server.Crons#cron),
+  [`crons.daily()`](/api/classes/server.Crons#daily),
+  [`crons.weekly()`](/api/classes/server.Crons#weekly),
+  [`crons.monthly()`](/api/classes/server.Crons#monthly) provide an alternative
+  syntax for common cron schedules with explicitly named arguments.
+
+## Viewing your cron jobs
+
+You can view all your cron jobs in the
+[Convex dashboard cron jobs view](/dashboard/deployments/schedules.md#cron-jobs-ui).
+You can view added, updated, and deleted cron jobs in the logs and history view.
+Results of previously executed runs of the cron jobs are also available in the
+logs view.
+
+## Error handling
+
+Mutations and actions have the same guarantees that are described in
+[Error handling](/scheduling/scheduled-functions.mdx#error-handling) for
+scheduled functions.
+
+At most one run of each cron job can be executing at any moment. If the function
+scheduled by the cron job takes too long to run, following runs of the cron job
+may be skipped to avoid execution from falling behind. Skipping a scheduled run
+of a cron job due to the previous run still executing logs a message visible in
+the logs view of the dashboard.
diff --git a/synced/convex/docs/scheduling/scheduled-functions.md b/synced/convex/docs/scheduling/scheduled-functions.md
new file mode 100644
index 0000000..794697f
--- /dev/null
+++ b/synced/convex/docs/scheduling/scheduled-functions.md
@@ -0,0 +1,868 @@
+---
+title: Scheduled Functions
+sidebar_position: 1
+---
+
+
+Convex allows you to schedule functions to run in the future. This allows you to
+build powerful durable workflows without the need to set up and maintain queues
+or other infrastructure.
+
+Scheduled functions are stored in the database. This means you can schedule
+functions minutes, days, and even months in the future. Scheduling is resilient
+against unexpected downtime or system restarts.
+
+**Example:**
+[Scheduling](https://github.com/get-convex/convex-demos/tree/main/scheduling)
+
+## Scheduling functions
+
+You can schedule public functions and
+[internal functions](/functions/internal-functions.mdx) from mutations and
+actions via the [scheduler](/api/interfaces/server.Scheduler) provided in the
+respective function context.
+
+- [runAfter](/api/interfaces/server.Scheduler#runafter) schedules a function to
+  run after a delay (measured in milliseconds).
+- [runAt](/api/interfaces/server.Scheduler#runat) schedules a function run at a
+  date or timestamp (measured in milliseconds elapsed since the epoch).
+
+The rest of the arguments are the path to the function and its arguments,
+similar to invoking a function from the client. For example, here is how to send
+a message that self-destructs in five seconds.
+
+
+```ts
+// @snippet start scheduling-runAfter
+import { mutation, internalMutation } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const sendExpiringMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    const id = await ctx.db.insert("messages", { body, author });
+    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {
+      messageId: id,
+    });
+  },
+});
+
+export const destruct = internalMutation({
+  args: {
+    messageId: v.id("messages"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.messageId);
+  },
+});
+// @snippet end scheduling-runAfter
+
+// @snippet start scheduling-status
+export const listScheduledMessages = query({
+  args: {},
+  handler: async (ctx, args) => {
+    return await ctx.db.system.query("_scheduled_functions").collect();
+  },
+});
+
+export const getScheduledMessage = query({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.id);
+  },
+});
+// @snippet end scheduling-status
+
+// @snippet start scheduling-cancel
+export const cancelMessage = mutation({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.scheduler.cancel(args.id);
+  },
+});
+// @snippet end scheduling-cancel
+
+// Don't use this in examples, it's here just for typechecking
+
+export const clearAll = internalMutation({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+
+import { query } from "./_generated/server";
+export const list = query({
+  args: {
+    channel: v.string(),
+  },
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const send = mutation({
+  args: { body: v.string(), channel: v.id("channels") },
+  handler: async (ctx, args) => {
+    const { body, channel } = args;
+    const id = await ctx.db.insert("messages", { body, channel });
+    return id;
+  },
+});
+
+// just here for typechecking
+export const sendAnon = mutation({
+  args: { body: v.string() },
+  handler: async () => {},
+});
+// just here for typechecking
+export const listAll = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const sendOne = internalMutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const like = mutation({
+  args: { liker: v.string(), messageId: v.id("messages") },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+```
+
+```ts
+// @snippet start scheduling-runAfter
+import { mutation, internalMutation } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const sendExpiringMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    const id = await ctx.db.insert("messages", { body, author });
+    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {
+      messageId: id,
+    });
+  },
+});
+
+export const destruct = internalMutation({
+  args: {
+    messageId: v.id("messages"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.messageId);
+  },
+});
+// @snippet end scheduling-runAfter
+
+// @snippet start scheduling-status
+export const listScheduledMessages = query({
+  args: {},
+  handler: async (ctx, args) => {
+    return await ctx.db.system.query("_scheduled_functions").collect();
+  },
+});
+
+export const getScheduledMessage = query({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.id);
+  },
+});
+// @snippet end scheduling-status
+
+// @snippet start scheduling-cancel
+export const cancelMessage = mutation({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.scheduler.cancel(args.id);
+  },
+});
+// @snippet end scheduling-cancel
+
+// Don't use this in examples, it's here just for typechecking
+
+export const clearAll = internalMutation({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+
+import { query } from "./_generated/server";
+export const list = query({
+  args: {
+    channel: v.string(),
+  },
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const send = mutation({
+  args: { body: v.string(), channel: v.id("channels") },
+  handler: async (ctx, args) => {
+    const { body, channel } = args;
+    const id = await ctx.db.insert("messages", { body, channel });
+    return id;
+  },
+});
+
+// just here for typechecking
+export const sendAnon = mutation({
+  args: { body: v.string() },
+  handler: async () => {},
+});
+// just here for typechecking
+export const listAll = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const sendOne = internalMutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const like = mutation({
+  args: { liker: v.string(), messageId: v.id("messages") },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+```
+
+
+A single function can schedule up to 1000 functions with total argument size of
+8MB.
+
+### Scheduling from mutations
+
+Scheduling functions from
+[mutations](/functions/mutation-functions.mdx#transactions) is atomic with the
+rest of the mutation. This means that if the mutation succeeds, the scheduled
+function is guaranteed to be scheduled. On the other hand, if the mutations
+fails, no function will be scheduled, even if the function fails after the
+scheduling call.
+
+### Scheduling from actions
+
+Unlike mutations, [actions](//docs/functions/actions.mdx) don't execute as a
+single database transaction and can have side effects. Thus, scheduling from
+actions does not depend on the outcome of the function. This means that an
+action might succeed to schedule some functions and later fail due to transient
+error or a timeout. The scheduled functions will still be executed.
+
+### Scheduling immediately
+
+Using `runAfter()` with delay set to 0 is used to immediately add a function to
+the event queue. This usage may be familiar to you if you're used to calling
+`setTimeout(fn, 0)`.
+
+As noted above, actions are not atomic and are meant to cause side effects.
+Scheduling immediately becomes useful when you specifically want to trigger an
+action from a mutation that is conditional on the mutation succeeding.
+[This post](https://stack.convex.dev/pinecone-and-embeddings#kick-off-a-background-action)
+goes over a direct example of this in action, where the application depends on
+an external service to fill in information to the database.
+
+## Retrieving scheduled function status
+
+Every scheduled function is reflected as a document in the
+`"_scheduled_functions"` system table. `runAfter()` and `runAt()` return the id
+of scheduled function. You can read data from system tables using the
+`db.system.get` and `db.system.query` methods, which work the same as the
+standard `db.get` and `db.query` methods.
+
+
+```ts
+// @snippet start scheduling-runAfter
+import { mutation, internalMutation } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const sendExpiringMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    const id = await ctx.db.insert("messages", { body, author });
+    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {
+      messageId: id,
+    });
+  },
+});
+
+export const destruct = internalMutation({
+  args: {
+    messageId: v.id("messages"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.messageId);
+  },
+});
+// @snippet end scheduling-runAfter
+
+// @snippet start scheduling-status
+export const listScheduledMessages = query({
+  args: {},
+  handler: async (ctx, args) => {
+    return await ctx.db.system.query("_scheduled_functions").collect();
+  },
+});
+
+export const getScheduledMessage = query({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.id);
+  },
+});
+// @snippet end scheduling-status
+
+// @snippet start scheduling-cancel
+export const cancelMessage = mutation({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.scheduler.cancel(args.id);
+  },
+});
+// @snippet end scheduling-cancel
+
+// Don't use this in examples, it's here just for typechecking
+
+export const clearAll = internalMutation({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+
+import { query } from "./_generated/server";
+export const list = query({
+  args: {
+    channel: v.string(),
+  },
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const send = mutation({
+  args: { body: v.string(), channel: v.id("channels") },
+  handler: async (ctx, args) => {
+    const { body, channel } = args;
+    const id = await ctx.db.insert("messages", { body, channel });
+    return id;
+  },
+});
+
+// just here for typechecking
+export const sendAnon = mutation({
+  args: { body: v.string() },
+  handler: async () => {},
+});
+// just here for typechecking
+export const listAll = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const sendOne = internalMutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const like = mutation({
+  args: { liker: v.string(), messageId: v.id("messages") },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+```
+
+```ts
+// @snippet start scheduling-runAfter
+import { mutation, internalMutation } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const sendExpiringMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    const id = await ctx.db.insert("messages", { body, author });
+    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {
+      messageId: id,
+    });
+  },
+});
+
+export const destruct = internalMutation({
+  args: {
+    messageId: v.id("messages"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.messageId);
+  },
+});
+// @snippet end scheduling-runAfter
+
+// @snippet start scheduling-status
+export const listScheduledMessages = query({
+  args: {},
+  handler: async (ctx, args) => {
+    return await ctx.db.system.query("_scheduled_functions").collect();
+  },
+});
+
+export const getScheduledMessage = query({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.id);
+  },
+});
+// @snippet end scheduling-status
+
+// @snippet start scheduling-cancel
+export const cancelMessage = mutation({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.scheduler.cancel(args.id);
+  },
+});
+// @snippet end scheduling-cancel
+
+// Don't use this in examples, it's here just for typechecking
+
+export const clearAll = internalMutation({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+
+import { query } from "./_generated/server";
+export const list = query({
+  args: {
+    channel: v.string(),
+  },
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const send = mutation({
+  args: { body: v.string(), channel: v.id("channels") },
+  handler: async (ctx, args) => {
+    const { body, channel } = args;
+    const id = await ctx.db.insert("messages", { body, channel });
+    return id;
+  },
+});
+
+// just here for typechecking
+export const sendAnon = mutation({
+  args: { body: v.string() },
+  handler: async () => {},
+});
+// just here for typechecking
+export const listAll = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const sendOne = internalMutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const like = mutation({
+  args: { liker: v.string(), messageId: v.id("messages") },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+```
+
+
+This is an example of the returned document:
+
+```json
+{
+  "_creationTime": 1699931054642.111,
+  "_id": "3ep33196167235462543626ss0scq09aj4gqn9kdxrdr",
+  "args": [{}],
+  "completedTime": 1699931054690.366,
+  "name": "messages.js:destruct",
+  "scheduledTime": 1699931054657,
+  "state": { "kind": "success" }
+}
+```
+
+The returned document has the following fields:
+
+- `name`: the path of the scheduled function
+- `args`: the arguments passed to the scheduled function
+- `scheduledTime`: the timestamp of when the function is scheduled to run
+  (measured in milliseconds elapsed since the epoch)
+- `completedTime`: the timestamp of when the function finished running, if it
+  has completed (measured in milliseconds elapsed since the epoch)
+- `state`: the status of the scheduled function. Here are the possible states a
+  scheduled function can be in:
+  - `Pending`: the function has not been started yet
+  - `InProgress`: the function has started running is not completed yet (only
+    applies to actions)
+  - `Success`: the function finished running successfully with no errors
+  - `Failed`: the function hit an error while running, which can either be a
+    user error or an internal server error
+  - `Canceled`: the function was canceled via the dashboard,
+    `ctx.scheduler.cancel`, or recursively by a parent scheduled function that
+    was canceled while in progress
+
+Scheduled function results are available for 7 days after they have completed.
+
+## Canceling scheduled functions
+
+You can cancel a previously scheduled function with
+[`cancel`](/api/interfaces/server.Scheduler#cancel) via the
+[scheduler](/api/interfaces/server.Scheduler) provided in the respective
+function context.
+
+
+```ts
+// @snippet start scheduling-runAfter
+import { mutation, internalMutation } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const sendExpiringMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    const id = await ctx.db.insert("messages", { body, author });
+    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {
+      messageId: id,
+    });
+  },
+});
+
+export const destruct = internalMutation({
+  args: {
+    messageId: v.id("messages"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.messageId);
+  },
+});
+// @snippet end scheduling-runAfter
+
+// @snippet start scheduling-status
+export const listScheduledMessages = query({
+  args: {},
+  handler: async (ctx, args) => {
+    return await ctx.db.system.query("_scheduled_functions").collect();
+  },
+});
+
+export const getScheduledMessage = query({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.id);
+  },
+});
+// @snippet end scheduling-status
+
+// @snippet start scheduling-cancel
+export const cancelMessage = mutation({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.scheduler.cancel(args.id);
+  },
+});
+// @snippet end scheduling-cancel
+
+// Don't use this in examples, it's here just for typechecking
+
+export const clearAll = internalMutation({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+
+import { query } from "./_generated/server";
+export const list = query({
+  args: {
+    channel: v.string(),
+  },
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const send = mutation({
+  args: { body: v.string(), channel: v.id("channels") },
+  handler: async (ctx, args) => {
+    const { body, channel } = args;
+    const id = await ctx.db.insert("messages", { body, channel });
+    return id;
+  },
+});
+
+// just here for typechecking
+export const sendAnon = mutation({
+  args: { body: v.string() },
+  handler: async () => {},
+});
+// just here for typechecking
+export const listAll = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const sendOne = internalMutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const like = mutation({
+  args: { liker: v.string(), messageId: v.id("messages") },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+```
+
+```ts
+// @snippet start scheduling-runAfter
+import { mutation, internalMutation } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { v } from "convex/values";
+
+export const sendExpiringMessage = mutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    const id = await ctx.db.insert("messages", { body, author });
+    await ctx.scheduler.runAfter(5000, internal.messages.destruct, {
+      messageId: id,
+    });
+  },
+});
+
+export const destruct = internalMutation({
+  args: {
+    messageId: v.id("messages"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.db.delete(args.messageId);
+  },
+});
+// @snippet end scheduling-runAfter
+
+// @snippet start scheduling-status
+export const listScheduledMessages = query({
+  args: {},
+  handler: async (ctx, args) => {
+    return await ctx.db.system.query("_scheduled_functions").collect();
+  },
+});
+
+export const getScheduledMessage = query({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    return await ctx.db.system.get(args.id);
+  },
+});
+// @snippet end scheduling-status
+
+// @snippet start scheduling-cancel
+export const cancelMessage = mutation({
+  args: {
+    id: v.id("_scheduled_functions"),
+  },
+  handler: async (ctx, args) => {
+    await ctx.scheduler.cancel(args.id);
+  },
+});
+// @snippet end scheduling-cancel
+
+// Don't use this in examples, it's here just for typechecking
+
+export const clearAll = internalMutation({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+
+import { query } from "./_generated/server";
+export const list = query({
+  args: {
+    channel: v.string(),
+  },
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const send = mutation({
+  args: { body: v.string(), channel: v.id("channels") },
+  handler: async (ctx, args) => {
+    const { body, channel } = args;
+    const id = await ctx.db.insert("messages", { body, channel });
+    return id;
+  },
+});
+
+// just here for typechecking
+export const sendAnon = mutation({
+  args: { body: v.string() },
+  handler: async () => {},
+});
+// just here for typechecking
+export const listAll = query({
+  args: {},
+  handler: async (ctx) => {
+    return await ctx.db.query("messages").collect();
+  },
+});
+
+export const sendOne = internalMutation({
+  args: { body: v.string(), author: v.string() },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const like = mutation({
+  args: { liker: v.string(), messageId: v.id("messages") },
+  handler: async () => {
+    // empty
+  },
+});
+
+export const getForCurrentUser = query({
+  args: {},
+  handler: async () => {
+    // empty
+  },
+});
+```
+
+
+What `cancel` does depends on the state of the scheduled function:
+
+- If it hasn't started running, it won't run.
+- If it already started, it will continue to run, but any functions it schedules
+  will not run.
+
+## Debugging
+
+You can view logs from previously executed scheduled functions in the Convex
+dashboard [Logs view](/dashboard/deployments/logs.md). You can view and cancel
+yet to be executed functions in the
+[Functions view](/dashboard/deployments/functions.md).
+
+## Error handling
+
+Once scheduled, mutations are guaranteed to be executed exactly once. Convex
+will automatically retry any internal Convex errors, and only fail on developer
+errors. See [Error Handling](/functions/error-handling/error-handling.mdx) for
+more details on different error types.
+
+Since actions may have side effects, they are not automatically retried by
+Convex. Thus, actions will be executed at most once, and permanently fail if
+there are transient errors while executing them. Developers can retry those
+manually by scheduling a mutation that checks if the desired outcome has been
+achieved and if not schedule the action again.
+
+## Auth
+
+The auth is not propagated from the scheduling to the scheduled function. If you
+want to authenticate or check authorization, you'll have to pass the requisite
+user information in as a parameter.
diff --git a/synced/convex/docs/search.md b/synced/convex/docs/search.md
new file mode 100644
index 0000000..a074bd2
--- /dev/null
+++ b/synced/convex/docs/search.md
@@ -0,0 +1,26 @@
+---
+title: "AI & Search"
+sidebar_position: 105
+description: "Run search queries over your Convex documents"
+slug: "search"
+pagination_prev: "scheduling"
+---
+
+Whether building RAG enabled chatbots or quick search in your applications,
+Convex provides easy apis to create powerful AI and search enabled products.
+
+[Vector Search](/search/vector-search.mdx) enables searching for documents based
+on their semantic meaning. It uses vector embeddings to calculate similarity and
+retrieve documents that are similar to a given query. Vector search is a key
+part of common AI techniques like RAG.
+
+[Full Text Search](/search/search.mdx) enables keyword and phrase search within
+your documents. It supports prefix matching to enable typeahead search. Convex
+full text search is also reactive and always up to date like all Convex queries,
+making it easy to build reliable quick search boxes.
+
+[Convex Actions](functions/actions) easily enable you to call AI apis, save data
+to your database, and drive your user interface. See examples of how you can use
+this to [build sophisticated AI applications](https://stack.convex.dev/tag/AI).
+
+<StackPosts query="AI" />
diff --git a/synced/convex/docs/search/search.md b/synced/convex/docs/search/search.md
new file mode 100644
index 0000000..1f2188d
--- /dev/null
+++ b/synced/convex/docs/search/search.md
@@ -0,0 +1,243 @@
+---
+title: "Full Text Search"
+sidebar_position: 110
+description: "Run search queries over your Convex documents"
+slug: "text-search"
+---
+
+Full text search allows you to find Convex documents that approximately match a
+search query.
+
+Unlike normal
+[document queries](/database/reading-data/reading-data.mdx#querying-documents),
+search queries look _within_ a string field to find the keywords. Search queries
+are useful for building features like searching for messages that contain
+certain words.
+
+Search queries are automatically reactive, consistent, transactional, and work
+seamlessly with pagination. They even include new documents created with a
+mutation!
+
+**Example:**
+[Search App](https://github.com/get-convex/convex-demos/tree/main/search)
+
+To use full text search you need to:
+
+1. Define a search index.
+2. Run a search query.
+
+Search indexes are built and queried using Convex's multi-segment search
+algorithm on top of [Tantivy](https://github.com/quickwit-oss/tantivy), a
+powerful, open-source, full-text search library written in Rust.
+
+## Defining search indexes
+
+Like [database indexes](/database/reading-data/indexes/indexes.md), search
+indexes are a data structure that is built in advance to enable efficient
+querying. Search indexes are defined as part of your Convex
+[schema](/database/schemas.mdx).
+
+Every search index definition consists of:
+
+1. A name.
+   - Must be unique per table.
+2. A `searchField`
+   - This is the field which will be indexed for full text search.
+   - It must be of type `string`.
+3. [Optional] A list of `filterField`s
+   - These are additional fields that are indexed for fast equality filtering
+     within your search index.
+
+To add a search index onto a table, use the
+[`searchIndex`](/api/classes/server.TableDefinition#searchindex) method on your
+table's schema. For example, if you want an index which can search for messages
+matching a keyword in a channel, your schema could look like:
+
+```ts noDialect title="convex/schema.ts"
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  messages: defineTable({
+    body: v.string(),
+    channel: v.string(),
+  }).searchIndex("search_body", {
+    searchField: "body",
+    filterFields: ["channel"],
+  }),
+});
+```
+
+You can specify search and filter fields on nested documents by using a
+dot-separated path like `properties.name`.
+
+## Running search queries
+
+A query for "10 messages in channel '#general' that best match the query 'hello
+hi' in their body" would look like:
+
+```js
+const messages = await ctx.db
+  .query("messages")
+  .withSearchIndex("search_body", (q) =>
+    q.search("body", "hello hi").eq("channel", "#general"),
+  )
+  .take(10);
+```
+
+This is just a normal [database read](/database/reading-data/reading-data.mdx)
+that begins by querying the search index!
+
+The
+[`.withSearchIndex`](/api/interfaces/server.QueryInitializer#withsearchindex)
+method defines which search index to query and how Convex will use that search
+index to select documents. The first argument is the name of the index and the
+second is a _search filter expression_. A search filter expression is a
+description of which documents Convex should consider when running the query.
+
+A search filter expression is always a chained list of:
+
+1. 1 search expression against the index's search field defined with
+   [`.search`](/api/interfaces/server.SearchFilterBuilder#search).
+2. 0 or more equality expressions against the index's filter fields defined with
+   [`.eq`](/api/interfaces/server.SearchFilterFinalizer#eq).
+
+### Search expressions
+
+Search expressions are issued against a search index, filtering and ranking
+documents by their relevance to the search expression's query. Internally,
+Convex will break up the query into separate words (called _terms_) and
+approximately rank documents matching these terms.
+
+In the example above, the expression `search("body", "hello hi")` would
+internally be split into `"hi"` and `"hello"` and matched against words in your
+document (ignoring case and punctuation).
+
+The behavior of search incorporates [prefix matching rules](#search-behavior).
+
+### Equality expressions
+
+Unlike search expressions, equality expressions will filter to only documents
+that have an exact match in the given field. In the example above,
+`eq("channel", "#general")` will only match documents that have exactly
+`"#general"` in their `channel` field.
+
+Equality expressions support fields of any type (not just text).
+
+To filter to documents that are missing a field, use
+`q.eq("fieldName", undefined)`.
+
+### Other filtering
+
+Because search queries are normal database queries, you can also
+[filter results](/database/reading-data/filters.mdx) using the
+[`.filter` method](/api/interfaces/server.Query#filter)!
+
+Here's a query for "messages containing 'hi' sent in the last 10 minutes":
+
+```js
+const messages = await ctx.db
+  .query("messages")
+  .withSearchIndex("search_body", (q) => q.search("body", "hi"))
+  .filter((q) => q.gt(q.field("_creationTime", Date.now() - 10 * 60000)))
+  .take(10);
+```
+
+**For performance, always put as many of your filters as possible into
+`.withSearchIndex`.**
+
+Every search query is executed by:
+
+1. First, querying the search index using the search filter expression in
+   `withSearchIndex`.
+2. Then, filtering the results one-by-one using any additional `filter`
+   expressions.
+
+Having a very specific search filter expression will make your query faster and
+less likely to hit Convex's limits because Convex will use the search index to
+efficiently cut down on the number of results to consider.
+
+### Retrieving results and paginating
+
+Just like ordinary database queries, you can
+[retrieve the results](/database/reading-data/reading-data.mdx#retrieving-results)
+using [`.collect()`](/api/interfaces/server.Query#collect),
+[`.take(n)`](/api/interfaces/server.Query#take),
+[`.first()`](/api/interfaces/server.Query#first), and
+[`.unique()`](/api/interfaces/server.Query#unique).
+
+Additionally, search results can be [paginated](/database/pagination.mdx) using
+[`.paginate(paginationOpts)`](/api/interfaces/server.OrderedQuery#paginate).
+
+Note that `collect()` will throw an exception if it attempts to collect more
+than the limit of 1024 documents. It is often better to pick a smaller limit and
+use `take(n)` or paginate the results.
+
+### Ordering
+
+Search queries always return results in [relevance order](#relevance-order)
+based on how well the document matches the search query. Different ordering of
+results are not supported.
+
+## Search Behavior
+
+### Typeahead Search
+
+Convex full-text search is designed to power as-you-type search experiences. In
+your search queries, the final search term has _prefix search_ enabled, matching
+any term that is a prefix of the original term. For example, the expression
+`search("body", "r")` would match the documents:
+
+- `"rabbit"`
+- `"send request"`
+
+Fuzzy search matches are deprecated. After January 15, 2025, search results will
+not include `"snake"` for a typo like `"stake"`.
+
+### Relevance order
+
+**Relevance order is subject to change.** The relevance of search results and
+the exact typo-tolerance rules Convex applies is subject to change to improve
+the quality of search results.
+
+Search queries return results in relevance order. Internally, Convex ranks the
+relevance of a document based on a combination of its
+[BM25 score](https://en.wikipedia.org/wiki/Okapi_BM25) and several other
+criteria such as the number of typos of matched terms in the document, the
+proximity of matches, the number of exact matches, and more. The BM25 score
+takes into account:
+
+- How many words in the search query appear in the field?
+- How many times do they appear?
+- How long is the text field?
+
+If multiple documents have the same score, the newest documents are returned
+first.
+
+## Limits
+
+Search indexes work best with English or other Latin-script languages. Text is
+tokenized using Tantivy's
+[`SimpleTokenizer`](https://docs.rs/tantivy/latest/tantivy/tokenizer/struct.SimpleTokenizer.html),
+which splits on whitespace and punctuation. We also limit terms to 32 characters
+in length and lowercase them.
+
+Search indexes must have:
+
+- Exactly 1 search field.
+- Up to 16 filter fields.
+
+Search indexes count against the
+[limit of 32 indexes per table](/database/reading-data/indexes/indexes.md#limits).
+
+Search queries can have:
+
+- Up to 16 terms (words) in the search expression.
+- Up to 8 filter expressions.
+
+Additionally, search queries can scan up to 1024 results from the search index.
+
+The source of truth for these limits is our
+[source code](https://github.com/get-convex/convex-backend/blob/main/crates/search/src/constants.rs).
+
+For information on other limits, see [here](/production/state/limits.mdx).
diff --git a/synced/convex/docs/search/vector-search.md b/synced/convex/docs/search/vector-search.md
new file mode 100644
index 0000000..afe2548
--- /dev/null
+++ b/synced/convex/docs/search/vector-search.md
@@ -0,0 +1,1034 @@
+---
+title: "Vector Search"
+sidebar_position: 100
+description: "Run vector search queries on embeddings"
+slug: "vector-search"
+---
+
+
+
+
+
+
+Vector search allows you to find Convex documents similar to a provided vector.
+Typically, vectors will be embeddings which are numerical representations of
+text, images, or audio.
+
+Embeddings and vector search enable you to provide useful context to LLMs for AI
+powered applications, recommendations for similar content and more.
+
+Vector search is consistent and fully up-to-date. You can write a vector and
+immediately read it from a vector search. Unlike
+[full text search](/search.mdx), however, vector search is only available in
+[Convex actions](/functions/actions.mdx).
+
+**Example:**
+[Vector Search App](https://github.com/get-convex/convex-demos/tree/main/vector-search)
+
+To use vector search you need to:
+
+1. Define a vector index.
+1. Run a vector search from within an [action](/functions/actions.mdx).
+
+## Defining vector indexes
+
+Like [database indexes](/database/reading-data/indexes/indexes.md), vector
+indexes are a data structure that is built in advance to enable efficient
+querying. Vector indexes are defined as part of your Convex
+[schema](/database/schemas.mdx).
+
+To add a vector index onto a table, use the
+[`vectorIndex`](/api/classes/server.TableDefinition#vectorindex) method on your
+table's schema. Every vector index has a unique name and a definition with:
+
+1. `vectorField` string
+   - The name of the field indexed for vector search.
+1. `dimensions` number
+   - The fixed size of the vectors index. If you're using embeddings, this
+     dimension should match the size of your embeddings (e.g. `1536` for
+     OpenAI).
+1. [Optional] `filterFields` array
+   - The names of additional fields that are indexed for fast filtering within
+     your vector index.
+
+For example, if you want an index that can search for similar foods within a
+given cuisine, your table definition could look like:
+
+
+```ts
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  // @snippet start schemaOneTable
+  foods: defineTable({
+    description: v.string(),
+    cuisine: v.string(),
+    embedding: v.array(v.float64()),
+  }).vectorIndex("by_embedding", {
+    vectorField: "embedding",
+    dimensions: 1536,
+    filterFields: ["cuisine"],
+  }),
+  // @snippet end schemaOneTable
+  // @snippet start schemaTwoTables
+  movieEmbeddings: defineTable({
+    embedding: v.array(v.float64()),
+    genre: v.string(),
+  }).vectorIndex("by_embedding", {
+    vectorField: "embedding",
+    dimensions: 1536,
+    filterFields: ["genre"],
+  }),
+  movies: defineTable({
+    title: v.string(),
+    genre: v.string(),
+    description: v.string(),
+    votes: v.number(),
+    embeddingId: v.optional(v.id("movieEmbeddings")),
+  }).index("by_embedding", ["embeddingId"]),
+  // @snippet end schemaTwoTables
+});
+```
+
+
+You can specify vector and filter fields on nested documents by using a
+dot-separated path like `properties.name`.
+
+## Running vector searches
+
+Unlike database queries or full text search, vector searches can only be
+performed in a [Convex action](/functions/actions.mdx).
+
+They generally involve three steps:
+
+1. Generate a vector from provided input (e.g. using OpenAI)
+1. Use
+   [`ctx.vectorSearch`](/api/interfaces/server.GenericActionCtx#vectorsearch) to
+   fetch the IDs of similar documents
+1. Load the desired information for the documents
+
+Here's an example of the first two steps for searching for similar French foods
+based on a description:
+
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+
+An example of the first step can be found
+[here](https://github.com/get-convex/convex-demos/blob/main/vector-search/convex/foods.ts#L18)
+in the vector search demo app.
+
+Focusing on the second step, the `vectorSearch` API takes in the table name, the
+index name, and finally a
+[`VectorSearchQuery`](/api/interfaces/server.VectorSearchQuery) object
+describing the search. This object has the following fields:
+
+1. `vector` array
+   - An array of numbers (e.g. embedding) to use in the search.
+   - The search will return the document IDs of the documents with the most
+     similar stored vectors.
+   - It must have the same length as the `dimensions` of the index.
+2. [Optional] `limit` number
+   - The number of results to get back. If specified, this value must be between
+     1 and 256.
+3. [Optional] `filter`
+   - An expression that restricts the set of results based on the `filterFields`
+     in the `vectorIndex` in your schema. See
+     [Filter expressions](#filter-expressions) for details.
+
+It returns an `Array` of objects containing exactly two fields:
+
+1. `_id`
+   - The [Document ID](https://docs.convex.dev/database/document-ids) for the
+     matching document in the table
+2. `_score`
+   - An indicator of how similar the result is to the vector you were searching
+     for, ranging from -1 (least similar) to 1 (most similar)
+
+Neither the underlying document nor the vector are included in `results`, so
+once you have the list of results, you will want to load the desired information
+about the results.
+
+There are a few strategies for loading this information documented in the
+[Advanced Patterns](#advanced-patterns) section.
+
+For now, let's load the documents and return them from the action. To do so,
+we'll pass the list of results to a Convex query and run it inside of our
+action, returning the result:
+
+
+```ts
+import { v } from "convex/values";
+import { internalQuery } from "./_generated/server";
+
+// used for vector search
+
+// @snippet start fetchResults
+export const fetchResults = internalQuery({
+  args: { ids: v.array(v.id("foods")) },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db.get(id);
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchResults
+```
+
+```ts
+import { v } from "convex/values";
+import { internalQuery } from "./_generated/server";
+
+// used for vector search
+
+// @snippet start fetchResults
+export const fetchResults = internalQuery({
+  args: { ids: v.array(v.id("foods")) },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db.get(id);
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchResults
+```
+
+
+
+```ts
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { Doc } from "./_generated/dataModel";
+
+// @snippet start fetchResults
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-start
+    // 3. Fetch the results
+    const foods: Array<Doc<"foods">> = await ctx.runQuery(
+      internal.foods.fetchResults,
+      { ids: results.map((result) => result._id) },
+    );
+    return foods;
+    // highlight-end
+  },
+});
+// @snippet end fetchResults
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+```
+
+```ts
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+import { internal } from "./_generated/api";
+import { Doc } from "./_generated/dataModel";
+
+// @snippet start fetchResults
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-start
+    // 3. Fetch the results
+    const foods: Array<Doc<"foods">> = await ctx.runQuery(
+      internal.foods.fetchResults,
+      { ids: results.map((result) => result._id) },
+    );
+    return foods;
+    // highlight-end
+  },
+});
+// @snippet end fetchResults
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+```
+
+
+### Filter expressions
+
+As mentioned above, vector searches support efficiently filtering results by
+additional fields on your document using either exact equality on a single
+field, or an `OR` of expressions.
+
+For example, here's a filter for foods with cuisine exactly equal to "French":
+
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+
+You can also filter documents by a single field that contains several different
+values using an `or` expression. Here's a filter for French or Indonesian
+dishes:
+
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+
+For indexes with multiple filter fields, you can also use `.or()` filters on
+different fields. Here's a filter for dishes whose cuisine is French or whose
+main ingredient is butter:
+
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+
+**Both `cuisine` and `mainIngredient` would need to be included in the
+`filterFields` in the `.vectorIndex` definition.**
+
+### Other filtering
+
+Results can be filtered based on how similar they are to the provided vector
+using the `_score` field in your action:
+
+```ts
+const results = await ctx.vectorSearch("foods", "by_embedding", {
+  vector: embedding,
+});
+const filteredResults = results.filter((result) => result._score >= 0.9);
+```
+
+Additional filtering can always be done by passing the vector search results to
+a query or mutation function that loads the documents and performs filtering
+using any of the fields on the document.
+
+**For performance, always put as many of your filters as possible into
+`.vectorSearch`.**
+
+### Ordering
+
+Vector queries always return results in relevance order.
+
+Currently Convex searches vectors using an
+[approximate nearest neighbor search](https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor)
+based on [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity).
+Support for more similarity metrics
+[will come in the future](#future-development).
+
+If multiple documents have the same score, ties are broken by the document ID.
+
+## Advanced patterns
+
+### Using a separate table to store vectors
+
+There are two main options for setting up a vector index:
+
+1. Storing vectors in the same table as other metadata
+1. Storing vectors in a separate table, with a reference
+
+The examples above show the first option, which is simpler and works well for
+reading small amounts of documents. The second option is more complex, but
+better supports reading or returning large amounts of documents.
+
+Since vectors are typically large and not useful beyond performing vector
+searches, it's nice to avoid loading them from the database when reading other
+data (e.g. `db.get()`) or returning them from functions by storing them in a
+separate table.
+
+A table definition for movies, and a vector index supporting search for similar
+movies filtering by genre would look like this:
+
+
+```ts
+import { defineSchema, defineTable } from "convex/server";
+import { v } from "convex/values";
+
+export default defineSchema({
+  // @snippet start schemaOneTable
+  foods: defineTable({
+    description: v.string(),
+    cuisine: v.string(),
+    embedding: v.array(v.float64()),
+  }).vectorIndex("by_embedding", {
+    vectorField: "embedding",
+    dimensions: 1536,
+    filterFields: ["cuisine"],
+  }),
+  // @snippet end schemaOneTable
+  // @snippet start schemaTwoTables
+  movieEmbeddings: defineTable({
+    embedding: v.array(v.float64()),
+    genre: v.string(),
+  }).vectorIndex("by_embedding", {
+    vectorField: "embedding",
+    dimensions: 1536,
+    filterFields: ["genre"],
+  }),
+  movies: defineTable({
+    title: v.string(),
+    genre: v.string(),
+    description: v.string(),
+    votes: v.number(),
+    embeddingId: v.optional(v.id("movieEmbeddings")),
+  }).index("by_embedding", ["embeddingId"]),
+  // @snippet end schemaTwoTables
+});
+```
+
+
+Generating an embedding and running a vector search are the same as using a
+single table. Loading the relevant documents given the vector search result is
+different since we have an ID for `movieEmbeddings` but want to load a `movies`
+document. We can do this using the `by_embedding` database index on the `movies`
+table:
+
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+```ts
+// @snippet start vectorSearchQuery
+import { v } from "convex/values";
+import { action } from "./_generated/server";
+
+export const similarFoods = action({
+  args: {
+    descriptionQuery: v.string(),
+  },
+  handler: async (ctx, args) => {
+    // 1. Generate an embedding from you favorite third party API:
+    const embedding = await embed(args.descriptionQuery);
+    // 2. Then search for similar foods!
+    // highlight-start
+    const results = await ctx.vectorSearch("foods", "by_embedding", {
+      vector: embedding,
+      limit: 16,
+      filter: (q) => q.eq("cuisine", "French"),
+    });
+    // highlight-end
+    // ...
+  },
+});
+// @snippet end vectorSearchQuery
+
+const embed = (...args: any[]): number[] => {
+  return [];
+};
+
+import { query } from "./_generated/server";
+// @snippet start fetchMovies
+export const fetchMovies = query({
+  args: {
+    ids: v.array(v.id("movieEmbeddings")),
+  },
+  handler: async (ctx, args) => {
+    const results = [];
+    for (const id of args.ids) {
+      const doc = await ctx.db
+        .query("movies")
+        .withIndex("by_embedding", (q) => q.eq("embeddingId", id))
+        .unique();
+      if (doc === null) {
+        continue;
+      }
+      results.push(doc);
+    }
+    return results;
+  },
+});
+// @snippet end fetchMovies
+
+const filters = action({
+  args: {},
+  handler: async (ctx, args) => {
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterSingleValue
+      filter: (q) => q.eq("cuisine", "French"),
+      // @snippet end filterSingleValue
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleValues
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("cuisine", "Indonesian")),
+      // @snippet end filterMultipleValues
+    });
+
+    await ctx.vectorSearch("foods", "by_embedding", {
+      vector: [],
+      // @snippet start filterMultipleFields
+      filter: (q) =>
+        q.or(q.eq("cuisine", "French"), q.eq("mainIngredient", "butter")),
+      // @snippet end filterMultipleFields
+    });
+  },
+});
+```
+
+
+### Fetching results and adding new documents
+
+Returning information from a vector search involves an action (since vector
+search is only available in actions) and a query or mutation to load the data.
+
+The example above used a query to load data and return it from an action. Since
+this is an action, the data returned is not reactive. An alternative would be to
+return the results of the vector search in the action, and have a separate query
+that reactively loads the data. The search results will not update reactively,
+but the data about each result would be reactive.
+
+The
+[Vector Search Demo App](https://github.com/get-convex/convex-demos/tree/main/vector-search)
+uses this strategy to show similar movies with a reactive "Votes" count.
+
+## Limits
+
+Convex supports millions of vectors today. This is an ongoing project and we
+will continue to scale this offering out with the rest of Convex.
+
+Vector indexes must have:
+
+- Exactly 1 vector index field.
+  - The field must be of type `v.array(v.float64())` (or a union in which one of
+    the possible types is `v.array(v.float64())`)
+- Exactly 1 dimension field with a value between 2 and 4096.
+- Up to 16 filter fields.
+
+Vector indexes count towards the
+[limit of 32 indexes per table](/database/reading-data/indexes/indexes.md#limits).
+In addition you can have up to 4 vector indexes per table.
+
+Vector searches can have:
+
+- Exactly 1 vector to search by in the `vector` field
+- Up to 64 filter expressions
+- Up to 256 requested results (defaulting to 10).
+
+If your action performs a vector search then passes the results to a query or
+mutation function, you may find that one or more results from the vector search
+have been deleted or mutated. Because vector search is only available in
+actions, you cannot perform additional transactional queries or mutations based
+on the results. If this is important for your use case, please
+[let us know on Discord](https://convex.dev/community)!
+
+Only documents that contain a vector of the size and in the field specified by a
+vector index will be included in the index and returned by the vector search.
+
+For information on limits, see [here](/production/state/limits.mdx).
+
+## Future development
+
+We're always open to customer feedback and requests. Some ideas we've considered
+for improving vector search in Convex include:
+
+- More sophisticated filters and filter syntax
+- Filtering by score in the `vectorSearch` API
+- Better support for generating embeddings
+
+If any of these features is important for your app,
+[let us know on Discord](https://convex.dev/community)!
diff --git a/synced/convex/docs/self-hosting.md b/synced/convex/docs/self-hosting.md
new file mode 100644
index 0000000..fe73cc6
--- /dev/null
+++ b/synced/convex/docs/self-hosting.md
@@ -0,0 +1,63 @@
+---
+title: "Self Hosting"
+sidebar_position: 100
+description: "Self Hosting Convex Projects"
+---
+
+If you're excited about self-hosting, you can run the Convex backend on your own
+servers. Self-hosted Convex runs the
+[open-source backend](https://github.com/get-convex/convex-backend), and
+contains the same fully up-to-date code the cloud service uses.
+
+To get started with self hosting, follow the self-hosting guide:
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "https://github.com/get-convex/convex-backend/blob/main/self-hosted/README.md",
+    label: "Self-hosting guide",
+  }}
+/>
+
+Join the `#self-hosted` channel in the
+[Discord community](https://convex.dev/community) for self-hosting support.
+
+Self hosting is not for everyone. If you're looking for a more hands-off
+solution, we recommend using the
+[Convex-hosted product](https://convex.dev/pricing).
+
+## Open Source Convex Backend
+
+The majority of the backend is written in Rust, with a healthy dose of
+TypeScript supporting the server-side function environment.
+
+You can learn more about open-sourcing at Convex in our
+[announcement](https://news.convex.dev/convex-goes-open-source/) and the
+[software engineering daily podcast](https://softwareengineeringdaily.com/2024/03/20/going-open-source-at-convex-with-james-cowling/).
+It is released under the [FSL Apache 2.0 License](https://fsl.software/).
+
+## Other Convex Open Source Projects
+
+The Convex backend, client libraries, dashboard, and CLI are all open-source.
+You can explore everything on the
+[Convex GitHub page](https://github.com/get-convex).
+
+### Convex Clients
+
+All Convex Clients are open-source.
+
+- [Convex JavaScript/TypeScript clients & CLI](https://github.com/get-convex/convex-js)
+- [Convex Python Client](https://github.com/get-convex/convex-py)
+- [Convex Rust Client](https://github.com/get-convex/convex-rs)
+
+### Much Much More
+
+Convex also open-sources many other helpful projects including
+[helpers](https://github.com/get-convex/convex-helpers),
+[templates](https://github.com/orgs/get-convex/repositories?type=all&q=template),
+[demos](https://github.com/get-convex/convex-demos), a
+[testing harness](https://github.com/get-convex/convex-test) and much more. See
+the complete list of all our public repositories
+[at GitHub](https://github.com/orgs/get-convex/repositories?type=all).
+
+<StackPosts query="open-source" />
diff --git a/synced/convex/docs/testing.md b/synced/convex/docs/testing.md
new file mode 100644
index 0000000..e019e9e
--- /dev/null
+++ b/synced/convex/docs/testing.md
@@ -0,0 +1,50 @@
+---
+title: "Testing"
+sidebar_position: 105
+description: "Testing your backend"
+slug: "testing"
+pagination_prev: "search"
+---
+
+Convex makes it easy to test your app via automated tests running in JS or
+against a real backend, and manually in dev, preview and staging environments.
+
+## Automated tests
+
+### `convex-test` library
+
+[Use the `convex-test` library](/testing/convex-test.mdx) to test your functions
+in JS via the excellent Vitest testing framework.
+
+### Testing against a real backend
+
+Convex open source builds allow you to test all of your backend logic running on
+a real [local Convex backend](/testing/convex-backend.mdx).
+
+### Set up testing in CI
+
+It's a good idea to test your app continuously in a controlled environment. No
+matter which way automated method you use, it's easy to run them with
+[GitHub Actions](/testing/ci.mdx).
+
+{/* todo: automated testing against preview deployments */}
+{/* todo: testing React+Convex - all the different ways */}
+
+## Manual tests
+
+### Running a function in dev
+
+Manually run a function in dev to quickly see if things are working:
+
+- [Run functions from the command line](/cli.md#run-convex-functions)
+- [Run functions from the dashboard](/dashboard/deployments/functions.md#running-functions)
+
+### Preview deployments
+
+[Use preview deployments](/production/hosting/preview-deployments.mdx) to get
+early feedback from your team for your in-progress features.
+
+### Staging environment
+
+You can set up a separate project as a staging environment to test against. See
+[Deploying Your App to Production](/production.mdx#staging-environment).
diff --git a/synced/convex/docs/testing/ci.md b/synced/convex/docs/testing/ci.md
new file mode 100644
index 0000000..602bfe6
--- /dev/null
+++ b/synced/convex/docs/testing/ci.md
@@ -0,0 +1,34 @@
+---
+title: Continuous Integration
+sidebar_label: CI
+sidebar_position: 300
+---
+
+Continuous integration allows your team to move fast by combining changes from
+all team members and automatically testing them on a remote machine.
+
+## Testing in GitHub Actions
+
+It's easy if you're using [GitHub](https://docs.github.com/en/actions) to set up
+[CI](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)
+workflow for running your test suite:
+
+```yaml title=".github/workflows/test.yml"
+name: Run Tests
+
+on: [pull_request, push]
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - uses: actions/setup-node@v4
+      - run: npm ci
+      - run: npm run test
+```
+
+After you commit and push this file to your repository, GitHub will run
+`npm run test` every time you create a pull request or push a new commit.
+
+{/* todo: testing against preview deployments */}
diff --git a/synced/convex/docs/testing/convex-backend.md b/synced/convex/docs/testing/convex-backend.md
new file mode 100644
index 0000000..efd94df
--- /dev/null
+++ b/synced/convex/docs/testing/convex-backend.md
@@ -0,0 +1,44 @@
+---
+title: Testing Local Backend
+sidebar_label: Local Backend
+sidebar_position: 200
+---
+
+Alternatively to [`convex-test`](/testing/convex-test.mdx) you can test your
+functions using the
+[open-source version of the Convex backend](https://github.com/get-convex/convex-backend).
+
+## Getting Started
+
+Follow [this guide](https://stack.convex.dev/testing-with-local-oss-backend) for
+the instructions.
+
+Compared to `convex-test`, which uses a JS mock of the backend, running your
+tests against the real backend has these advantages:
+
+- Your tests will run against the same code as your Convex production (as long
+  you keep the local backend up-to-date).
+- Limits on argument, data, query sizes are enforced.
+- You can bootstrap a large test dataset from a data import.
+- You can test your client code in combination with your backend logic.
+
+## Limitations
+
+Note that testing against the local backend also has some drawbacks:
+
+- It requires setting up the local backend, which is more involved.
+- No control over time and any scheduled functions will run as scheduled.
+- Crons will also run unless disabled via
+  [`IS_TEST`](https://stack.convex.dev/testing-with-local-oss-backend#setting-up-a-local-backend).
+- No way to mock `fetch` calls.
+- No way to mock dependencies or parts of the codebase.
+- No way to control randomness (tests may not be deterministic).
+- No way to set environment variable values from within tests.
+
+To test your functions in JS with a mocked Convex backend, check out
+[convex-test](/testing/convex-test.mdx).
+
+## CI
+
+See [Continuous Integration](/testing/ci.mdx) to run your tests on a shared
+remote machine.
diff --git a/synced/convex/docs/testing/convex-test.md b/synced/convex/docs/testing/convex-test.md
new file mode 100644
index 0000000..108c097
--- /dev/null
+++ b/synced/convex/docs/testing/convex-test.md
@@ -0,0 +1,477 @@
+---
+title: convex-test
+sidebar_label: convex-test
+sidebar_position: 100
+---
+
+The `convex-test` library provides a mock implementation of the Convex backend
+in JavaScript. It enables fast automated testing of the logic in your
+[functions](/functions.mdx).
+
+**Example:** The library includes a
+[test suite](https://github.com/get-convex/convex-test/tree/main/convex) which
+you can browse to see examples of using it.
+
+## Get Started
+
+<StepByStep>
+
+  <Step title="Install test dependencies">
+    Install [Vitest](https://vitest.dev/) and the [`convex-test`](https://www.npmjs.com/package/convex-test) library.
+
+    ```sh
+    npm install --save-dev convex-test vitest @edge-runtime/vm
+    ```
+
+  </Step>
+
+  <Step title="Setup NPM scripts">
+    
+    Add these scripts to your `package.json`
+
+    ```json title="package.json"
+    "scripts": {
+      "test": "vitest",
+      "test:once": "vitest run",
+      "test:debug": "vitest --inspect-brk --no-file-parallelism",
+      "test:coverage": "vitest run --coverage --coverage.reporter=text",
+    }
+    ```
+
+  </Step>
+
+  <Step title="Configure Vitest">
+    
+    Add <JSDialectFileName name="vitest.config.mts" /> file to configure the test
+    environment to better match the Convex runtime, and to inline the test library
+    for better dependency tracking.
+
+    ```ts title="vitest.config.mts"
+    import { defineConfig } from "vitest/config";
+
+    export default defineConfig({
+      test: {
+        environment: "edge-runtime",
+        server: { deps: { inline: ["convex-test"] } },
+      },
+    });
+    ```
+
+  </Step>
+
+  <Step title="Add a test file">
+    
+    In your `convex` folder add a file ending in <JSDialectFileName name=".test.ts" />
+
+    The example test calls the `api.messages.send` mutation twice
+    and then asserts that the `api.messages.list` query returns
+    the expected results.
+
+    ```ts title="convex/messages.test.ts"
+    import { convexTest } from "convex-test";
+    import { expect, test } from "vitest";
+    import { api } from "./_generated/api";
+    import schema from "./schema";
+
+    test("sending messages", async () => {
+      const t = convexTest(schema);
+      await t.mutation(api.messages.send, { body: "Hi!", author: "Sarah" });
+      await t.mutation(api.messages.send, { body: "Hey!", author: "Tom" });
+      const messages = await t.query(api.messages.list);
+      expect(messages).toMatchObject([
+        { body: "Hi!", author: "Sarah" },
+        { body: "Hey!", author: "Tom" }
+      ]);
+    });
+    ```
+
+  </Step>
+
+  <Step title="Run tests">
+
+    Start the tests with `npm run test`. When you change the test file or your
+    functions the tests will rerun automatically.
+
+    ```sh
+    npm run test
+    ```
+
+  </Step>
+
+</StepByStep>
+
+If you're not familiar with Vitest or Jest read the
+[Vitest Getting Started docs](https://vitest.dev/guide) first.
+
+## `convexTest`
+
+The library exports a `convexTest` function which should be called at the start
+of each of your tests. The function returns an object which is by convention
+stored in the `t` variable and which provides methods for exercising your Convex
+functions.
+
+If your project uses a [schema](/database/schemas.mdx) you should pass it to the
+`convexTest` function:
+
+```ts title="convex/myFunctions.test.ts"
+import { convexTest } from "convex-test";
+import { test } from "vitest";
+
+test("some behavior", async () => {
+  const t = convexTest(schema);
+  // use `t`...
+});
+```
+
+Passing in the schema is required for the tests to correctly implement schema
+validation and for correct typing of
+[`t.run`](#setting-up-and-inspecting-data-and-storage-with-trun).
+
+If you don't have a schema, call `convexTest()` with no argument.
+
+## Calling functions with `t.query`, `t.mutation` and `t.action`
+
+Your test can call public and internal Convex [functions](/functions.mdx) in
+your project:
+
+```ts title="convex/myFunctions.test.ts"
+import { convexTest } from "convex-test";
+import { test } from "vitest";
+import { api, internal } from "./_generated/api";
+
+test("functions", async () => {
+  const t = convexTest();
+  const x = await t.query(api.myFunctions.myQuery, { a: 1, b: 2 });
+  const y = await t.query(internal.myFunctions.internalQuery, { a: 1, b: 2 });
+  const z = await t.mutation(api.myFunctions.mutateSomething, { a: 1, b: 2 });
+  const w = await t.mutation(internal.myFunctions.mutateSomething, { a: 1 });
+  const u = await t.action(api.myFunctions.doSomething, { a: 1, b: 2 });
+  const v = await t.action(internal.myFunctions.internalAction, { a: 1, b: 2 });
+});
+```
+
+## Setting up and inspecting data and storage with `t.run`
+
+Sometimes you might want to directly [write](/database/writing-data.mdx) to the
+mock database or [file storage](/file-storage.mdx) from your test, without
+needing a declared function in your project. You can use the `t.run` method
+which takes a handler that is given a `ctx` that allows reading from and writing
+to the mock backend:
+
+```ts title="convex/tasks.test.ts"
+import { convexTest } from "convex-test";
+import { expect, test } from "vitest";
+
+test("functions", async () => {
+  const t = convexTest();
+  const firstTask = await t.run(async (ctx) => {
+    await ctx.db.insert("tasks", { text: "Eat breakfast" });
+    return await ctx.db.query("tasks").first();
+  });
+  expect(firstTask).toMatchObject({ text: "Eat breakfast" });
+});
+```
+
+## Testing HTTP actions with `t.fetch`
+
+Your test can call [HTTP actions](/functions/http-actions.mdx) registered by
+your router:
+
+```ts title="convex/http.test.ts"
+import { convexTest } from "convex-test";
+import { test } from "vitest";
+
+test("functions", async () => {
+  const t = convexTest();
+  const response = await t.fetch("/some/path", { method: "POST" });
+});
+```
+
+Mocking the global `fetch` function doesn't affect `t.fetch`, but you can use
+`t.fetch` in a `fetch` mock to route to your HTTP actions.
+
+## Testing scheduled functions
+
+One advantage of using a mock implementation running purely in JavaScript is
+that you can control time in the Vitest test environment. To test
+implementations relying on
+[scheduled functions](/scheduling/scheduled-functions.mdx) use
+[Vitest's fake timers](https://vitest.dev/guide/mocking.html#timers) in
+combination with `t.finishInProgressScheduledFunctions`:
+
+```ts title="convex/scheduling.test.ts"
+import { convexTest } from "convex-test";
+import { expect, test, vi } from "vitest";
+import { api } from "./_generated/api";
+
+test("mutation scheduling action", async () => {
+  // Enable fake timers
+  vi.useFakeTimers();
+
+  const t = convexTest(schema);
+
+  // Call a function that schedules a mutation or action
+  const scheduledFunctionId = await t.mutation(
+    api.scheduler.mutationSchedulingAction,
+    { delayMs: 10000 },
+  );
+
+  // Advance the mocked time
+  vi.advanceTimersByTime(5000);
+
+  // Advance the mocked time past the scheduled time of the function
+  vi.advanceTimersByTime(6000);
+
+  // Or run all currently pending timers
+  vi.runAllTimers();
+
+  // At this point the scheduled function will be `inProgress`,
+  // now wait for it to finish
+  await t.finishInProgressScheduledFunctions();
+
+  // Assert that the scheduled function succeeded or failed
+  const scheduledFunctionStatus = t.run(async (ctx) => {
+    return await ctx.db.get(scheduledFunctionId);
+  });
+  expect(scheduledFunctionStatus).toMatchObject({ state: { kind: "success" } });
+
+  // Reset to normal `setTimeout` etc. implementation
+  vi.useRealTimers();
+});
+```
+
+If you have a chain of several scheduled functions, for example a mutation that
+schedules an action that schedules another action, you can use
+`t.finishAllScheduledFunctions` to wait for all scheduled functions, including
+recursively scheduled functions, to finish:
+
+```ts title="convex/chainedScheduling.test.ts"
+import { convexTest } from "convex-test";
+import { expect, test, vi } from "vitest";
+import { api } from "./_generated/api";
+
+test("mutation scheduling action scheduling action", async () => {
+  // Enable fake timers
+  vi.useFakeTimers();
+
+  const t = convexTest(schema);
+
+  // Call a function that schedules a mutation or action
+  await t.mutation(api.scheduler.mutationSchedulingActionSchedulingAction);
+
+  // Wait for all scheduled functions, repeatedly
+  // advancing time and waiting for currently in-progress
+  // functions to finish
+  await t.finishAllScheduledFunctions(vi.runAllTimers);
+
+  // Assert the resulting state after all scheduled functions finished
+  const createdTask = t.run(async (ctx) => {
+    return await ctx.db.query("tasks").first();
+  });
+  expect(createdTask).toMatchObject({ author: "AI" });
+
+  // Reset to normal `setTimeout` etc. implementation
+  vi.useRealTimers();
+});
+```
+
+Check out more examples in
+[this file](https://github.com/get-convex/convex-test/blob/main/convex/scheduler.test.ts).
+
+## Testing authentication with `t.withIdentity`
+
+To test functions which depend on the current [authenticated](/auth.mdx) user
+identity you can create a version of the `t` accessor with given
+[user identity attributes](/api/interfaces/server.UserIdentity). If you don't
+provide them, `issuer`, `subject` and `tokenIdentifier` will be generated
+automatically:
+
+```ts title="convex/tasks.test.ts"
+import { convexTest } from "convex-test";
+import { expect, test } from "vitest";
+import { api } from "./_generated/api";
+
+test("authenticated functions", async () => {
+  const t = convexTest(schema);
+
+  const asSarah = t.withIdentity({ name: "Sarah" });
+  await asSarah.mutation(api.tasks.create, { text: "Add tests" });
+
+  const sarahsTasks = await asSarah.query(api.tasks.list);
+  expect(sarahsTasks).toMatchObject([{ text: "Add tests" }]);
+
+  const asLee = t.withIdentity({ name: "Lee" });
+  const leesTasks = await asLee.query(api.tasks.list);
+  expect(leesTasks).toEqual([]);
+});
+```
+
+## Mocking `fetch` calls
+
+You can use Vitest's
+[vi.stubGlobal](https://vitest.dev/guide/mocking.html#globals) method:
+
+```ts title="convex/ai.test.ts"
+import { expect, test, vi } from "vitest";
+import { convexTest } from "../index";
+import { api } from "./_generated/api";
+
+test("ai", async () => {
+  const t = convexTest(schema);
+
+  vi.stubGlobal(
+    "fetch",
+    vi.fn(async () => ({ text: async () => "I am the overlord" }) as Response),
+  );
+
+  const reply = await t.action(api.messages.sendAIMessage, { prompt: "hello" });
+  expect(reply).toEqual("I am the overlord");
+
+  vi.unstubAllGlobals();
+});
+```
+
+## Asserting results
+
+See Vitest's [Expect](https://vitest.dev/api/expect.html) reference.
+
+[`toMatchObject()`](https://vitest.dev/api/expect.html#tomatchobject) is
+particularly helpful when asserting the shape of results without needing to list
+every object field.
+
+### Asserting errors
+
+To assert that a function throws, use
+[`.rejects.toThrowError()`](https://vitest.dev/api/expect.html#tothrowerror):
+
+```ts title="convex/messages.test.ts"
+import { convexTest } from "convex-test";
+import { expect, test } from "vitest";
+import { api } from "./_generated/api";
+
+test("messages validation", async () => {
+  const t = convexTest(schema);
+  expect(async () => {
+    await t.mutation(api.messages.send, { body: "", author: "James" });
+  }).rejects.toThrowError("Empty message body is not allowed");
+});
+```
+
+## Measuring test coverage
+
+You can get a printout of the code coverage provided by your tests. Besides
+answering the question "how much of my code is covered by tests" it is also
+helpful to check that your test is actually exercising the code that you want it
+to exercise.
+
+Run <CodeWithCopyButton text="npm run test:coverage" />. It will ask you to
+install a required dependency the first time you run it.
+
+<p style={{ textAlign: "center" }}>
+  <img
+    src="/screenshots/testing_coverage.png"
+    alt="example coverage printout"
+    width={700}
+  />
+</p>
+
+## Debugging tests
+
+You can attach a debugger to the running tests. Read the Vitest
+[Debugging docs](https://vitest.dev/guide/debugging.html) and then
+use&#32;<CodeWithCopyButton text="npm run test:debug" />.
+
+## Multiple environments
+
+If you want to use Vitest to test both your Convex functions and your React
+frontend, you might want to use multiple Vitest environments depending on the
+test file location via
+[environmentMatchGlobs](https://vitest.dev/config/#environmentmatchglobs):
+
+```ts title="vitest.config.mts"
+import { defineConfig } from "vitest/config";
+
+export default defineConfig({
+  test: {
+    environmentMatchGlobs: [
+      // all tests in convex/ will run in edge-runtime
+      ["convex/**", "edge-runtime"],
+      // all other tests use jsdom
+      ["**", "jsdom"],
+    ],
+    server: { deps: { inline: ["convex-test"] } },
+  },
+});
+```
+
+## Custom `convex/` folder name or location
+
+If your project has a
+[different name or location configured](/production/project-configuration.mdx#changing-the-convex-folder-name-or-location)
+for the `convex/` folder in `convex.json`, you need to call
+[`import.meta.glob`](https://vitejs.dev/guide/features#glob-import) and pass the
+result as the second argument to `convexTest`.
+
+The argument to `import.meta.glob` must be a glob pattern matching all the files
+containing your Convex functions. The paths are relative to the test file in
+which `import.meta.glob` is called. It's best to do this in one place in your
+custom functions folder:
+
+```ts title="src/convex/test.setup.ts"
+/// <reference types="vite/client" />
+export const modules = import.meta.glob("./**/!(*.*.*)*.*s");
+```
+
+This example glob pattern includes all files with a single extension ending in
+`s` (like `js` or `ts`) in the `src/convex` folder and any of its children.
+
+Use the result in your tests:
+
+```ts title="src/convex/messages.test.ts"
+import { convexTest } from "convex-test";
+import { test } from "vitest";
+
+import { modules } from "./test.setup";
+
+test("some behavior", async () => {
+  const t = convexTest(schema, modules);
+  // use `t`...
+});
+```
+
+## Limitations
+
+Since `convex-test` is only a mock implementation, it doesn't have many of the
+behaviors of the real Convex backend. Still, it should be helpful for testing
+the logic in your functions, and catching regressions caused by changes to your
+code.
+
+Some of the ways the mock differs:
+
+- Error messages content. You should not write product logic that relies on the
+  content of error messages thrown by the real backend, as they are always
+  subject to change.
+- Limits. The mock doesn't enforce size and time
+  [limits](/production/state/limits.mdx).
+- ID format. Your code should not depend on the document or storage ID format.
+- Runtime built-ins. Most of your functions are written for the
+  [Convex default runtime](/functions/runtimes.mdx), while Vitest uses a mock of
+  Vercel's Edge Runtime, which is similar but might differ from the Convex
+  runtime. You should always test new code manually to make sure it doesn't use
+  built-ins not available in the Convex runtime.
+- Some features have only simplified semantics, namely:
+  - [Text search](/search.mdx) returns all documents that include a word for
+    which at least one word in the searched string is a prefix. It does not
+    implement fuzzy searching and doesn't sort the results by relevance.
+  - [Vector search](/search/vector-search.mdx) returns results sorted by cosine
+    similarity, but doesn't use an efficient vector index in its implementation.
+  - There is no support for [cron jobs](/scheduling/cron-jobs.mdx), you should
+    trigger your functions manually from the test.
+
+To test your functions running on a real Convex backend, check out
+[Testing Local Backend](/testing/convex-backend.mdx).
+
+## CI
+
+See [Continuous Integration](/testing/ci.mdx) to run your tests on a shared
+remote machine.
diff --git a/synced/convex/docs/tutorial/actions.md b/synced/convex/docs/tutorial/actions.md
new file mode 100644
index 0000000..6da5826
--- /dev/null
+++ b/synced/convex/docs/tutorial/actions.md
@@ -0,0 +1,251 @@
+---
+title: "Convex Tutorial: Calling External Services"
+sidebar_label: "2. Calling external services"
+slug: "actions"
+sidebar_position: 200
+hide_table_of_contents: true
+---
+
+# Convex Tutorial: Calling external services
+
+In the [previous step](/tutorial/index.mdx), you built a fully self-contained
+chat app. Data in, data out.
+
+In order to power the automatic reactivity we just saw while providing strong
+database transactions, query and mutation functions in Convex are not allowed to
+make `fetch` calls to the outside world.
+
+Real apps aren't this simple. They often need to talk to the rest of the
+internet directly from the backend. Convex lets you do this too via **action**
+functions.
+
+Action functions let the sync engine access the external world by scheduling out
+work that can then write data back via mutations.
+
+Let's make our chat app a bit smarter by letting anyone in the chat get the
+Wikipedia summary of a topic using the Wikipedia API.
+
+## Your first `action`
+
+**Add the following action to your `convex/chat.ts` file.**
+
+```typescript
+// highlight-next-line
+// Update your server import like this:
+// highlight-next-line
+import { query, mutation, internalAction } from "./_generated/server";
+
+//...
+
+// highlight-next-line
+export const getWikipediaSummary = internalAction({
+  // highlight-next-line
+  args: { topic: v.string() },
+  // highlight-next-line
+  handler: async (ctx, args) => {
+    // highlight-next-line
+    const response = await fetch(
+      // highlight-next-line
+      "https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=" +
+        // highlight-next-line
+        args.topic,
+      // highlight-next-line
+    );
+    // highlight-next-line
+
+    // highlight-next-line
+    return getSummaryFromJSON(await response.json());
+    // highlight-next-line
+  },
+  // highlight-next-line
+});
+// highlight-next-line
+
+// highlight-next-line
+function getSummaryFromJSON(data: any) {
+  // highlight-next-line
+  const firstPageId = Object.keys(data.query.pages)[0];
+  // highlight-next-line
+  return data.query.pages[firstPageId].extract;
+  // highlight-next-line
+}
+```
+
+Let's walk through it:
+
+1. First, we created a new Convex action function called `getWikipediaSummary`.
+   We used `internalAction` because we want this function to be private to the
+   Convex backend and not exposed as a public API. This function does a simple
+   fetch to the Wikipedia API with our topic.
+1. Next, we have a helper TypeScript function called `getSummaryFromJSON` to
+   pull out the summary text from the JSON response.
+1. The `getWikipediaSummary` function calls our helper function like any other
+   TypeScript function.
+
+This is great and all, but how do I use it?
+
+To quickly test this function in the Convex dashboard, go to
+[https://dashboard.convex.dev](https://dashboard.convex.dev/deployment/functions)
+and navigate to your project. Click on the Functions in the left nav, and then
+click on the `getWikipediaSummary` function. Click "Run Function".
+
+The function runner UI will pop up. Try making a few searches.
+
+<video autoPlay playsInline muted loop width="100%">
+  <source src="/img/tutorial/tut_dashboard_action.mp4" type="video/mp4" />
+  Running a few Wikipedia queries
+</video>
+
+## Hooking it up to your app
+
+It's awesome that we can call Wikipedia, but we still need to show up in our
+chat. So, let's hook it all up.
+
+**Update your existing `sendMessage` mutation like this:**
+
+```typescript
+// highlight-next-line
+// Import the api reference
+// highlight-next-line
+import { api, internal } from "./_generated/api";
+
+//...
+
+export const sendMessage = mutation({
+  args: {
+    user: v.string(),
+    body: v.string(),
+  },
+  handler: async (ctx, args) => {
+    console.log("This TypeScript function is running on the server.");
+    await ctx.db.insert("messages", {
+      user: args.user,
+      body: args.body,
+    });
+
+    // highlight-next-line
+    // Add the following lines:
+    // highlight-next-line
+    if (args.body.startsWith("/wiki")) {
+      // highlight-next-line
+      // Get the string after the first space
+      // highlight-next-line
+      const topic = args.body.slice(args.body.indexOf(" ") + 1);
+      // highlight-next-line
+      await ctx.scheduler.runAfter(0, internal.chat.getWikipediaSummary, {
+        // highlight-next-line
+        topic,
+        // highlight-next-line
+      });
+      // highlight-next-line
+    }
+  },
+});
+```
+
+Wait a second! What's with this `ctx.scheduler` stuff? Convex comes with a
+powerful durable function scheduler. It's a fundamental part of the sync engine,
+and it's the way you coordinate asynchronous functions in Convex.
+
+In the case of mutations, it's the only way to call an action to fetch from the
+outside world. The really cool part is, if for some reason your mutation throws
+an exception, then nothing is scheduled. This is because mutations are
+transactions, and scheduling is just a write in the database to tell Convex to
+run this function at a future time.
+
+Ok so, we can schedule our action, but we still need to write the summary back
+to the chat.
+
+**Let's go back and update our `getWikipediaSummary` action:**
+
+```typescript
+export const getWikipediaSummary = internalAction({
+  args: { topic: v.string() },
+  handler: async (ctx, args) => {
+    const response = await fetch(
+      "https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=" +
+        args.topic,
+    );
+
+    // highlight-next-line
+    // Replace the `return ...` with the following.
+    // highlight-next-line
+    const summary = getSummaryFromJSON(await response.json());
+    // highlight-next-line
+    await ctx.scheduler.runAfter(0, api.chat.sendMessage, {
+      // highlight-next-line
+      user: "Wikipedia",
+      // highlight-next-line
+      body: summary,
+      // highlight-next-line
+    });
+  },
+});
+```
+
+Just like scheduling the action, we're now scheduling our `sendMessage` mutation
+to send the result of our Wikipedia lookup to our chat.
+
+Go ahead, now play with your app!
+
+<video autoPlay playsInline muted loop width="100%">
+  <source src="/img/tutorial/tut_wikipedia.mp4" type="video/mp4" />
+  Chat with Wikipedia
+</video>
+
+## The scheduler, actions, and the sync engine
+
+<div className="center-image" style={{ maxWidth: "900px" }}>
+  ![Sync engine with actions](/img/tutorial/ConvexSyncAction.png)
+</div>
+
+Queries and mutations are the only ways to interact with the database and the
+scheduler enables building sophisticated workflows with actions in between.
+
+[Actions](/functions/actions.mdx) are normal serverless functions like AWS
+Lambda and Google Cloud Run. They help model flows like calling AI APIs and
+using the Vector Store. They serve as an escape hatch. They deal with the
+reality of the messy outside world with few guarantees.
+
+Actions are not part of the sync engine. To talk to the database they have to
+talk through query and mutation functions. This restriction lets Convex enforce
+transactional guarantees in the database and keep the sync engine fast and
+nimble.
+
+The best way to structure your application for scale is to minimize the work
+that happens in an action. Only the part that needs the
+[non-determinism](https://en.wikipedia.org/wiki/Deterministic_algorithm), like
+making the external `fetch` call should use them. Keeping them as small as
+possible is the most scalable way to build Convex apps, enabling the highest
+throughput.
+
+The scheduler allows your app to keep most of its important logic in queries and
+mutations and structure your code as workflows in and out of actions.
+
+## What you built
+
+In this section of the tutorial, you built an action to talk to the outside
+world and used the scheduler to trigger this work.
+
+You learned that keeping our actions small and keeping most of our work in
+queries and mutations are fundamental to building scalable Convex backends.
+
+## Next up
+
+You've now learned the most important concepts in Convex. As a full-featured
+backend, Convex is capable of many things such as [authentication](/auth.mdx),
+[file storage](/file-storage.mdx) and [search](/search.mdx). You can add those
+features as needed by following the documentation.
+
+We touched a little bit on setting your app up for success. As your application
+scales, you will run into new challenges. Let's learn how to deal with some of
+these challenges in the [next section →](/tutorial/scale.mdx).
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "/tutorial/scale",
+    docId: "tutorial/scale",
+    label: "Scaling your app",
+  }}
+/>
diff --git a/synced/convex/docs/tutorial/index.md b/synced/convex/docs/tutorial/index.md
new file mode 100644
index 0000000..7cb0da8
--- /dev/null
+++ b/synced/convex/docs/tutorial/index.md
@@ -0,0 +1,349 @@
+---
+title: "Convex Tutorial: A Chat App"
+sidebar_label: "1. A chat app"
+sidebar_position: 100
+hide_table_of_contents: true
+pagination_next: tutorial/actions
+pagination_label: "Convex Tutorial: A chat app"
+---
+
+# Convex Tutorial: A chat app
+
+Convex provides you with a fully featured backend with cloud functions,
+database, scheduling, and a sync engine that keeps your frontend and backend up
+to date in real-time.
+
+Today, in about **10 lines of code,** we'll build a backend that reads and
+writes to the database and automatically updates all users in a chat app.
+
+After that we'll see how to connect to external services and setup your product
+for success and scale.
+
+## Start developing with Convex
+
+<Details summary="Before you begin: You'll need Node.js 18+ and Git">
+
+Ensure you have Node.js version 18 or greater installed on your computer. You
+can check your version of Node.js by running `node --version` in your terminal.
+If you don't have the appropriate version of Node.js installed,
+[install it from the Node.js website.](https://nodejs.org/en)
+
+In addition, this walkthrough requires Git, so verify you have it installed by
+running `git -v` in your terminal. If not, head over to the
+[Git website](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) for
+installation instructions.
+
+</Details>
+
+First, clone the example project repo from GitHub and install the dependencies:
+
+```shell
+git clone https://github.com/get-convex/convex-tutorial.git
+cd convex-tutorial
+npm install
+```
+
+This app's `dev` npm command sets up Convex and then runs the web app:
+
+```shell
+npm run dev
+```
+
+During setup, you'll see that Convex uses your GitHub account for
+authentication. Sign into Convex with GitHub and then accept the default project
+setup prompts.
+
+This will **automatically create your backend** and a folder called `convex/` in
+your project, where you'll write your backend code.
+
+**Make sure you keep this command (`npm run dev`) running in the background
+throughout this tutorial.** It's running both the dev web server for the
+frontend as well as the `convex` command in the background to keep your backend
+in sync with your local codebase.
+
+Once your server is up and running, open [localhost:5173](http://localhost:5173)
+and check it out:
+
+<div className="center-image" style={{ maxWidth: "676px" }}>
+  ![Chat UI](/img/tutorial/tut_chat_ui.png)
+</div>
+
+If you try sending a message now, you'll see an alert telling you the mutation
+is not yet implemented. We'll do that in a bit, but first here's a quick summary
+of how Convex works.
+
+## How Convex works
+
+<div className="center-image" style={{ maxWidth: "700px" }}>
+  ![Overview of the sync engine](/img/tutorial/ConvexSyncEngine.png)
+</div>
+
+**Database.** The Convex database is a document-relational database, which means
+you have tables with JSON like documents in them. All documents have an
+auto-generated `_id` that can be used to create relations between documents. You
+interact with the database through mutation and query functions that are written
+entirely in TypeScript.
+
+**Mutation functions.** Mutations are TypeScript functions that update the
+database. All mutation functions in Convex run as a database transaction. So
+either all the changes are committed, or none are.
+
+**Query functions.** Queries are TypeScript functions that can only read from
+the database. As we'll see in a bit, you subscribe to them from your frontend to
+keep your app automatically up to date.
+
+Your frontend registers to listen to query updates through the **client
+library**. The client libraries talk to Convex via WebSockets for fast realtime
+updates.
+
+The **sync engine** reruns query functions when any input to the function
+changes, including any changes to the documents in the database that the query
+reads. It then updates every app listening to the query. The sync engine is the
+combination of queries, mutations and the database.
+
+Now, let's dive into the code!
+
+## Your first `mutation`
+
+Create a new file in your `convex/` folder called `chat.ts`. This is where
+you'll write your Convex backend functions for this application.
+
+**Add the following to your `convex/chat.ts` file.**
+
+```typescript
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export const sendMessage = mutation({
+  args: {
+    user: v.string(),
+    body: v.string(),
+  },
+  handler: async (ctx, args) => {
+    console.log("This TypeScript function is running on the server.");
+    await ctx.db.insert("messages", {
+      user: args.user,
+      body: args.body,
+    });
+  },
+});
+```
+
+Let's break this down:
+
+1. You've added a new backend `mutation` function called `sendMessage` and
+   exposed it as a public api.
+1. The whole function automatically runs as a transaction that will roll back if
+   an exception is thrown.
+1. Since this is just a TypeScript function you can drop `console.log` lines to
+   do simple debugging on the server.
+1. `args:` ensures the function arguments are two strings named `user` and
+   `body`, both as types and runtime values.
+1. `ctx.db.insert` tells Convex to insert a new message document into the table.
+
+Now, let's connect this mutation to your web app.
+
+**Update your `src/App.tsx` file like so:**
+
+```tsx
+// highlight-next-line
+// Import `useMutation` and `api` from Convex.
+// highlight-next-line
+import { useMutation } from "convex/react";
+// highlight-next-line
+import { api } from "../convex/_generated/api";
+
+//...
+
+export default function App() {
+  // highlight-next-line
+  // Replace the "TODO: Add mutation hook here." with:
+  // highlight-next-line
+  const sendMessage = useMutation(api.chat.sendMessage);
+
+  //...
+
+  return (
+    <main className="chat">
+      {/* ... */}
+      <form
+        onSubmit={async (e) => {
+          e.preventDefault();
+          // highlight-next-line
+          // Replace "alert("Mutation not implemented yet");" with:
+          // highlight-next-line
+          await sendMessage({ user: NAME, body: newMessageText });
+
+          setNewMessageText("");
+        }}
+      >
+        {/* ... */}
+      </form>
+    </main>
+  );
+}
+```
+
+There are two steps to call a mutation in your frontend:
+
+1. `const sendMessage = useMutation(api.chat.sendMessage);` gives your frontend
+   app a handle to the mutation function
+2. `await sendMessage({ user: NAME, body: newMessageText });` calls the mutation
+   with the proper parameters.
+
+This is a good time to **open up the Convex dashboard**. Open a new browser
+window and go to [https://dashboard.convex.dev](https://dashboard.convex.dev)
+and find new `convex-tutorial` project.
+
+**Go to the "Data" screen**. So far, there is no data in your database.
+
+**Keep your chat app and dashboard windows open side by side**. Now try to send
+some messages from your chat app.
+
+<video autoPlay playsInline muted loop width="100%">
+  <source src="/img/tutorial/tut_first_mutation.mp4" type="video/mp4" />
+  Mutations hooked up to the Convex backend and database.
+</video>
+
+You'll notice new chat messages showing up live in the `messages` table.
+
+Convex automatically created a `messages` table when you sent the first message.
+In Convex, [schemas](/database/schemas.mdx) are optional. Eventually, you'll
+want to enforce the structure of your tables, but for the purposes of the
+tutorial we'll skip this.
+
+In the dashboard you can also go to the
+[logs screen](https://dashboard.convex.dev/deployment/logs) and see every call
+to the mutation as you ran with the log line we added earlier. The logs screen
+is a critical part of debugging your backend in development.
+
+You've successfully created a `mutation` function, which is also a database
+transaction, and connected it to your UI.
+
+Now, let's make sure your app can update live the same way the dashboard is
+updating live.
+
+## Your first `query`
+
+**Update your `convex/chat.ts` file like this:**
+
+```tsx
+// highlight-next-line
+// Update your server import like this:
+// highlight-next-line
+import { query, mutation } from "./_generated/server";
+
+// ...
+
+// highlight-next-line
+// Add the following function to the file:
+// highlight-next-line
+export const getMessages = query({
+  // highlight-next-line
+  args: {},
+  // highlight-next-line
+  handler: async (ctx) => {
+    // highlight-next-line
+    // Get most recent messages first
+    // highlight-next-line
+    const messages = await ctx.db.query("messages").order("desc").take(50);
+    // highlight-next-line
+    // Reverse the list so that it's in a chronological order.
+    // highlight-next-line
+    return messages.reverse();
+    // highlight-next-line
+  },
+  // highlight-next-line
+});
+```
+
+Let's break this down:
+
+1. You've added a new backend `query` function called `getMessages` and exposed
+   it as a public api.
+1. Since this is a query function, the `ctx.db` in this function only lets you
+   read data.
+1. In the first line of the `handler` you are querying the most recent 50
+   messages from newest to oldest.
+1. In the second line you're reversing the list using plain old TypeScript.
+
+**Now update `src/App.tsx` to read from your query:**
+
+```tsx
+// highlight-next-line
+// Update your convex/react import like this:
+// highlight-next-line
+import { useQuery, useMutation } from "convex/react";
+
+//...
+
+export default function App() {
+  // highlight-next-line
+  // Replace the `const messages = ...` line with the following
+  // highlight-next-line
+  const messages = useQuery(api.chat.getMessages);
+
+  //...
+}
+```
+
+That one `useQuery` line is doing a lot of work automatically for you. It's
+telling the Convex client library to subscribe to your `getMessages` function.
+Anytime there are new messages to show the query function is automatically
+rerun. The result is put in `const messages` variable and React rerenders your
+UI component to show the latest messages.
+
+That's it. Now go back to your app and try sending messages.
+
+Your app should be showing live updates as new messages arrive:
+
+<video autoPlay playsInline muted loop width="100%">
+  <source src="/img/tutorial/tut_first_query.mp4" type="video/mp4" />
+  Queries hooked up and live updating to the app.
+</video>
+
+<br />
+<br />
+Don't believe it? Try opening two chat windows side by side and send some
+messages:
+
+<video autoPlay playsInline muted loop width="100%">
+  <source src="/img/tutorial/tut_side_by_side.mp4" type="video/mp4" />
+  Live syncing chat app.
+</video>
+
+## What you built
+
+With just a few lines of code you've built a live updating chat app.
+
+1. You created a `mutation` TypeScript function that, in a transaction, adds new
+   chat messages to your database.
+1. You created a `query` TypeScript function updates your app with the latest
+   data.
+1. You used the client library that keeps your frontend in live sync with the
+   backend.
+
+You've learned the fundamentals of Convex and the sync engine that powers
+everything.
+
+## Next up
+
+In this tutorial we just touched on the very basics. It's ok to just stop here
+and go explore the rest of the docs, including
+[efficient queries via indexes](/database/reading-data/indexes/indexes.md) and
+traversing
+[relationships through joins](/database/reading-data/reading-data.mdx#join). If
+you're deeply curious about how Convex works, you can read this
+[excellent deep dive](https://stack.convex.dev/how-convex-works).
+
+But if you want to see how to call external services and build sophisticated
+backend workflows, jump into the [next section →](/tutorial/actions.mdx).
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    href: "/tutorial/actions",
+    docId: "tutorial/actions",
+    label: "Calling external services",
+  }}
+/>
diff --git a/synced/convex/docs/tutorial/scale.md b/synced/convex/docs/tutorial/scale.md
new file mode 100644
index 0000000..31b07ca
--- /dev/null
+++ b/synced/convex/docs/tutorial/scale.md
@@ -0,0 +1,83 @@
+---
+title: "Convex Tutorial: Scaling Your App"
+sidebar_label: "3. Scaling your app"
+slug: "scale"
+sidebar_position: 300
+hide_table_of_contents: true
+---
+
+
+# Convex Tutorial: Scaling your app
+
+Convex was designed from the ground up for scale. In the previous section we
+already talked about how keeping your actions small and most of your logic in
+queries and mutations are crucial to building fast scalable backends.
+
+Let's talk about a few other ways to keep your app fast and scalable.
+
+## Indexed queries
+
+Indexes tell the database to create a lookup structure to make it really fast to
+filter data. If, in our chat app we wanted to build a way to look up `messages`
+from just one user, we'd tell Convex to index the `user` field in the `messages`
+table and write the query with the `withIndex` syntax.
+
+[Learn how to use indexes](/database/reading-data/indexes/indexes.md).
+
+## Too many writes on the same document
+
+Let's say you decide to show a counter in your app. You may write a mutation
+that reads a number field, adds 1, and updates the same field in the database.
+At some point, this pattern may cause an
+[optimistic concurrency control conflict](/error#1). That means that the
+database isn't able to handle updating the document that fast. All databases
+have trouble with this sort of pattern.
+
+There are a [few ways to deal with this](/error#remediation), including building
+something called a sharded counter...
+
+But before you go learn advanced scaling techniques on your own, there is a
+better way with Convex components.
+
+## Scaling best practices with Convex Components
+
+In the case of the counter above, the Convex team has already built a
+[scalable counter](https://www.convex.dev/components/sharded-counter) Convex
+component for you to use.
+
+Convex components are installed in your Convex backend as an npm library. They
+are sandboxed, so they can't read your app's tables or call your app's functions
+unless explicitly provided.
+
+As you build more complicated features like AI agent
+[workflows](https://www.convex.dev/components/workflow),
+[leaderboards](https://www.convex.dev/components/aggregate),
+[feature flags](https://www.convex.dev/components/launchdarkly) or
+[rate limiters](https://www.convex.dev/components/rate-limiter), you may find
+that there is already a Convex component that solves this problem.
+
+<CardLink
+  className="convex-hero-card"
+  item={{
+    icon: <ComponentsIcon height={40} />,
+    href: "https://www.convex.dev/components",
+    label: "Components directory",
+  }}
+/>
+
+## Wrap up
+
+We've covered a lot of ground in this tutorial. We started by
+[building a chat app](/tutorial/index.mdx) with queries, mutations and the
+database that form the fundamental building blocks of the Convex sync engine. We
+then called an [external API](/tutorial/actions.mdx) from our backend, using the
+scheduler to coordinate the work. Finally, we learned that
+[Convex components](https://www.convex.dev/components) give you scaling best
+practices in neat packages.
+
+If you are looking for more tips, read our
+[best practices](/understanding/best-practices/best-practices.mdx) and join the
+[community](https://www.convex.dev/community).
+
+Convex enables you to build your MVP fast and then scale to new heights. Many
+great products have already done so. You're in good company.
diff --git a/synced/convex/docs/understanding/basic-overview.tldr b/synced/convex/docs/understanding/basic-overview.tldr
new file mode 100644
index 0000000..6fe98f7
--- /dev/null
+++ b/synced/convex/docs/understanding/basic-overview.tldr
@@ -0,0 +1 @@
+{"tldrawFileFormatVersion":1,"schema":{"schemaVersion":2,"sequences":{"com.tldraw.store":4,"com.tldraw.asset":1,"com.tldraw.camera":1,"com.tldraw.document":2,"com.tldraw.instance":25,"com.tldraw.instance_page_state":5,"com.tldraw.page":1,"com.tldraw.instance_presence":6,"com.tldraw.pointer":1,"com.tldraw.shape":4,"com.tldraw.asset.bookmark":2,"com.tldraw.asset.image":5,"com.tldraw.asset.video":5,"com.tldraw.shape.group":0,"com.tldraw.shape.text":2,"com.tldraw.shape.bookmark":2,"com.tldraw.shape.draw":2,"com.tldraw.shape.geo":9,"com.tldraw.shape.note":8,"com.tldraw.shape.line":5,"com.tldraw.shape.frame":0,"com.tldraw.shape.arrow":5,"com.tldraw.shape.highlight":1,"com.tldraw.shape.embed":4,"com.tldraw.shape.image":4,"com.tldraw.shape.video":2,"com.tldraw.binding.arrow":0}},"records":[{"gridSize":10,"name":"","meta":{},"id":"document:document","typeName":"document"},{"meta":{},"id":"page:pDVpkOKgp2Hp3KAd00WjE","name":"Page 1","index":"a1","typeName":"page"},{"x":490.75096950649385,"y":750.7650583829256,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:1M9IAqo0lbIGz2aPZ9Zko","type":"geo","props":{"w":742.8629850933874,"h":89.12998959109598,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"Server functions","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a25SN","typeName":"shape"},{"x":804.2705240864044,"y":549.357911209095,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:1tCrB5iOTq6yTmYSfoe0z","type":"text","props":{"color":"black","size":"m","w":105.8125,"text":"Web app","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a88cH","typeName":"shape"},{"x":492.62039877298133,"y":533.3421722862703,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:B97Psb1smTqAOGnpikJBV","type":"geo","props":{"w":742.8629850933874,"h":106.93803743443517,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a373g","typeName":"shape"},{"x":470.9594799083472,"y":679.1253977943051,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:FkU4nnD_GJTP_urf6RQlm","type":"arrow","props":{"dash":"dotted","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":0,"y":0},"end":{"x":785.7230697066873,"y":-1.7763568394002505e-15},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a2fXM","typeName":"shape"},{"x":801.5904017420219,"y":605.5568525860707,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:PxBkHX9h17r_E_wx9MxO2","type":"text","props":{"color":"black","size":"s","w":123.90625,"text":"Client library","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a90NW","typeName":"shape"},{"x":737.570666993138,"y":595.8599000747536,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:T3w1qpDBQvwzUDkcwOzs7","type":"geo","props":{"w":239.78125,"h":44.407699309848,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"solid","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a7BhV","typeName":"shape"},{"x":840.9338705949513,"y":700.6251512945876,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:W5AaLoprqQ75BMFSoi9HY","type":"arrow","props":{"dash":"solid","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":18.94413777124535,"y":-54.80514913399246},"end":{"x":18.94413777124536,"y":45.16086930187389},"arrowheadStart":"arrow","arrowheadEnd":"arrow","text":"WebSocket","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a2PGz","typeName":"shape"},{"x":483.1058232431381,"y":681.7441618846016,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:iNTkK0T2j_uu1OaF73BGl","type":"text","props":{"color":"black","size":"m","w":109.484375,"text":"Internet","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a49s4","typeName":"shape"},{"x":490.44907138249647,"y":866.7894943041504,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:oYAsQ9KXEGyk_7GakxBJx","type":"geo","props":{"w":742.8629850933874,"h":94.64624971778737,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"Database","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:pDVpkOKgp2Hp3KAd00WjE","index":"a1","typeName":"shape"},{"id":"pointer:pointer","typeName":"pointer","x":367.2789322875118,"y":140.74168267432964,"lastActivityTimestamp":1737076152520,"meta":{}},{"followingUserId":null,"opacityForNextShape":1,"stylesForNextShape":{},"brush":null,"scribbles":[],"cursor":{"type":"default","rotation":0},"isFocusMode":false,"exportBackground":true,"isDebugMode":false,"isToolLocked":false,"screenBounds":{"x":0,"y":0,"w":1690,"h":1555},"insets":[false,false,false,false],"zoomBrush":null,"isGridMode":false,"isPenMode":false,"chatMessage":"","isChatting":false,"highlightedUserIds":[],"isFocused":true,"devicePixelRatio":1,"isCoarsePointer":false,"isHoveringCanvas":false,"openMenus":[],"isChangingStyle":false,"isReadonly":false,"meta":{},"duplicateProps":null,"id":"instance:instance","currentPageId":"page:pDVpkOKgp2Hp3KAd00WjE","typeName":"instance"},{"editingShapeId":null,"croppingShapeId":null,"selectedShapeIds":[],"hoveredShapeId":null,"erasingShapeIds":[],"hintingShapeIds":[],"focusedGroupId":null,"meta":{},"id":"instance_page_state:page:pDVpkOKgp2Hp3KAd00WjE","pageId":"page:pDVpkOKgp2Hp3KAd00WjE","typeName":"instance_page_state"},{"x":-291.4854428602034,"y":-85.58610882724793,"z":0.77394716476617,"meta":{},"id":"camera:page:pDVpkOKgp2Hp3KAd00WjE","typeName":"camera"}]}
\ No newline at end of file
diff --git a/synced/convex/docs/understanding/best-practices/best-practices.md b/synced/convex/docs/understanding/best-practices/best-practices.md
new file mode 100644
index 0000000..13d9a78
--- /dev/null
+++ b/synced/convex/docs/understanding/best-practices/best-practices.md
@@ -0,0 +1,21965 @@
+---
+title: "Best Practices"
+sidebar_position: 400
+toc_max_heading_level: 2
+---
+
+
+
+
+
+
+This is a list of best practices and common anti-patterns around using Convex.
+We recommend going through this list before broadly releasing your app to
+production. You may choose to try using all of these best practices from the
+start, or you may wait until you've gotten major parts of your app working
+before going through and adopting the best practices here.
+
+## Await all Promises
+
+### Why?
+
+Convex functions use async / await. If you don't await all your promises (e.g.
+`await ctx.scheduler.runAfter`, `await ctx.db.patch`), you may run into
+unexpected behavior (e.g. failing to schedule a function) or miss handling
+errors.
+
+### How?
+
+We recommend the
+[no-floating-promises](https://typescript-eslint.io/rules/no-floating-promises/)
+eslint rule with TypeScript.
+
+## Avoid `.filter` on database queries
+
+### Why?
+
+Filtering in code instead of using the `.filter` syntax has the same
+performance, and is generally easier code to write. Conditions in `.withIndex`
+or `.withSearchIndex` are more efficient than `.filter` or filtering in code, so
+almost all uses of `.filter` should either be replaced with a `.withIndex` or
+`.withSearchIndex` condition, or written as TypeScript code.
+
+Read through the
+[indexes documentation](/database/reading-data/indexes/indexes-and-query-perf.md)
+for an overview of how to define indexes and how they work.
+
+### Examples
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### How?
+
+Search for `.filter` in your Convex codebase — a regex like `\.filter\(\(?q`
+will probably find all the ones on database queries.
+
+Decide whether they should be replaced with a `.withIndex` condition — per
+[this section](/understanding/best-practices/best-practices.mdx#only-use-collect-with-a-small-number-of-results),
+if you are filtering over a large (1000+) or potentially unbounded number of
+documents, you should use an index. If not using a `.withIndex` /
+`.withSearchIndex` condition, consider replacing them with a filter in code for
+more readability and flexibility.
+
+See [this article](https://stack.convex.dev/complex-filters-in-convex) for more
+strategies for filtering.
+
+### Exceptions
+
+Using `.filter` on a paginated query (`.paginate`) has advantages over filtering
+in code. The paginated query will return the number of documents requested,
+including the `.filter` condition, so filtering in code afterwards can result in
+a smaller page or even an empty page. Using `.withIndex` on a paginated query
+will still be more efficient than a `.filter`.
+
+## Only use `.collect` with a small number of results
+
+### Why?
+
+All results returned from `.collect` count towards database bandwidth (even ones
+filtered out by `.filter`). It also means that if any document in the result
+changes, the query will re-run or the mutation will hit a conflict.
+
+If there's a chance the number of results is large (say 1000+ documents), you
+should use an index to filter the results further before calling `.collect`, or
+find some other way to avoid loading all the documents such as using pagination,
+denormalizing data, or changing the product feature.
+
+### Example
+
+**Using an index:**
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+**Using pagination:**
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+**Using a limit or denormalizing:**
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### How?
+
+Search for `.collect` in your Convex codebase (a regex like `\.collect\(` will
+probably find these). And think through whether the number of results is small.
+This function health page in the dashboard can also help surface these.
+
+The [aggregate component](https://www.npmjs.com/package/@convex-dev/aggregate)
+or [database triggers](https://stack.convex.dev/triggers) can be helpful
+patterns for denormalizing data.
+
+### Exceptions
+
+If you're doing something that requires loading a large number of documents
+(e.g. performing a migration, making a summary), you may want to use an action
+to load them in batches via separate queries / mutations.
+
+## Check for redundant indexes
+
+### Why?
+
+Indexes like `by_foo` and `by_foo_and_bar` are usually redundant (you only need
+`by_foo_and_bar`). Reducing the number of indexes saves on database storage and
+reduces the overhead of writing to the table.
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### How?
+
+Look through your indexes, either in your `schema.ts` file or in the dashboard,
+and look for any indexes where one is a prefix of another.
+
+### Exceptions
+
+`.index("by_foo", ["foo"])` is really an index on the properties `foo` and
+`_creationTime`, while `.index("by_foo_and_bar", ["foo", "bar"])` is an index on
+the properties `foo`, `bar`, and `_creationTime`. If you have queries that need
+to be sorted by `foo` and then `_creationTime`, then you need both indexes.
+
+For example, `.index("by_channel", ["channel"])` on a table of messages can be
+used to query for the most recent messages in a channel, but
+`.index("by_channel_and_author", ["channel", "author"])` could not be used for
+this since it would first sort the messages by `author`.
+
+## Use argument validators for all public functions
+
+### Why?
+
+Public functions can be called by anyone, including potentially malicious
+attackers trying to break your app.
+[Argument validators](/functions/validation.mdx) (as well as return value
+validators) help ensure you're getting the traffic you expect.
+
+### Example
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### How?
+
+Search for `query`, `mutation`, and `action` in your Convex codebase, and ensure
+that all of them have argument validators (and optionally return value
+validators). If you have `httpAction`s, you may want to use something like `zod`
+to validate that the HTTP request is the shape you expect.
+
+## Use some form of access control for all public functions
+
+### Why?
+
+Public functions can be called by anyone, including potentially malicious
+attackers trying to break your app. If portions of your app should only be
+accessible when the user is signed in, make sure all these Convex functions
+check that `ctx.auth.getUserIdentity()` is set.
+
+You may also have specific checks, like only loading messages that were sent to
+or from the current user, which you'll want to apply in every relevant public
+function.
+
+Favoring more granular functions like `setTeamOwner` over `updateTeam` allows
+more granular checks for which users can do what.
+
+Access control checks should either use `ctx.auth.getUserIdentity()` or a
+function argument that is unguessable (e.g. a UUID, or a Convex ID, provided
+that this ID is never exposed to any client but the one user). In particular,
+don't use a function argument which could be spoofed (e.g. email) for access
+control checks.
+
+### Example
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### How?
+
+Search for `query`, `mutation`, `action`, and `httpAction` in your Convex
+codebase, and ensure that all of them have some form of access control.
+[Custom functions](https://github.com/get-convex/convex-helpers/blob/main/packages/convex-helpers/README.md#custom-functions)
+like
+[`authenticatedQuery`](https://stack.convex.dev/custom-functions#modifying-the-ctx-argument-to-a-server-function-for-user-auth)
+can be helpful.
+
+Some apps use Row Level Security (RLS) to check access to each document
+automatically whenever it's loaded, as described in
+[this article](https://stack.convex.dev/row-level-security). Alternatively, you
+can check access in each Convex function instead of checking access for each
+document.
+
+Helper functions for common checks and common operations can also be useful --
+e.g. `isTeamMember`, `isTeamAdmin`, `loadTeam` (which throws if the current user
+does not have access to the team).
+
+## Only schedule and `ctx.run*` internal functions
+
+### Why?
+
+Public functions can be called by anyone, including potentially malicious
+attackers trying to break your app, and should be carefully audited to ensure
+they can't be used maliciously. Functions that are only called within Convex can
+be marked as internal, and relax these checks since Convex will ensure that
+internal functions can only be called within Convex.
+
+### How?
+
+Search for `ctx.runQuery`, `ctx.runMutation`, and `ctx.runAction` in your Convex
+codebase. Also search for `ctx.scheduler` and check the `crons.ts` file. Ensure
+all of these use `internal.foo.bar` functions instead of `api.foo.bar`
+functions.
+
+If you have code you want to share between a public Convex function and an
+internal Convex function, create a helper function that can be called from both.
+The public function will likely have additional access control checks.
+
+Alternatively, make sure that `api` from `_generated/api.ts` is never used in
+your Convex functions directory.
+
+### Examples
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+## Use helper functions to write shared code
+
+### Why?
+
+Most logic should be written as plain TypeScript functions, with the `query`,
+`mutation`, and `action` wrapper functions being a thin wrapper around one or
+more helper function.
+
+Concretely, most of your code should live in a directory like `convex/model`,
+and your public API, which is defined with `query`, `mutation`, and `action`,
+should have very short functions that mostly just call into `convex/model`.
+
+Organizing your code this way makes several of the refactors mentioned in this
+list easier to do.
+
+See the [TypeScript page](/understanding/best-practices/typescript.mdx) for
+useful types.
+
+### Example
+
+**❌** This example overuses `ctx.runQuery` and `ctx.runMutation`, which is
+discussed more in the
+[Avoid sequential `ctx.runMutation` / `ctx.runQuery` from actions](/understanding/best-practices/best-practices.mdx#avoid-sequential-ctxrunmutation--ctxrunquery-calls-from-actions)
+section.
+
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+
+**✅** Most of the code here is now in the `convex/model` directory. The API for
+this application is in `convex/conversations.ts`, which contains very little
+code itself.
+
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+```ts
+import {
+  ActionBuilder,
+  DataModelFromSchemaDefinition,
+  GenericDocument,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  QueryBuilder,
+  anyApi,
+  defineSchema,
+  defineTable,
+} from "convex/server";
+import { GenericId, v } from "convex/values";
+/**
+ * See the comment at the top of ./index.ts for more details on the
+ * goals of these snippets + some strategies for writing syntactically
+ * correct code while glossing over some details.
+ */
+
+const schema = defineSchema({
+  conversations: defineTable({
+    members: v.array(v.id("users")),
+    summary: v.optional(v.string()),
+  }),
+  users: defineTable({
+    name: v.string(),
+  }),
+  messages: defineTable({
+    conversation: v.id("conversations"),
+    author: v.id("users"),
+    content: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+declare const OMIT_ME: any;
+
+declare const query: QueryBuilder<DataModel, "public">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+
+const api = anyApi;
+const internal = anyApi;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+
+type Doc<T extends keyof DataModel> = DataModel[T]["document"];
+type Id<T extends keyof DataModel> = GenericId<T>;
+
+// @snippet start usersWrong
+export const getCurrentUser_OMIT_1 = query({
+  args: {},
+  handler: async (ctx) => {
+    const userIdentity = await ctx.auth.getUserIdentity();
+    if (userIdentity === null) {
+      throw new Error("Unauthorized");
+    }
+    const user = /* query ctx.db to load the user */ OMIT_ME;
+    const userSettings = /* load other documents related to the user */ OMIT_ME;
+    return { user, settings: userSettings };
+  },
+});
+// @snippet end usersWrong
+
+// @snippet start conversationsWrong
+export const listMessages_OMIT_1 = query({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const user = await ctx.runQuery(api.users.getCurrentUser);
+    const conversation = await ctx.db.get(conversationId);
+    if (conversation === null || !conversation.members.includes(user._id)) {
+      throw new Error("Unauthorized");
+    }
+    const messages = /* query ctx.db to load the messages */ OMIT_ME;
+    return messages;
+  },
+});
+
+export const summarizeConversation_OMIT_1 = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(api.conversations.listMessages, {
+      conversationId,
+    });
+    // @skipNextLine
+    /* prettier-ignore */
+    const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+    await ctx.runMutation(api.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsWrong
+
+// @snippet start usersCorrect
+export async function getCurrentUser(ctx: QueryCtx) {
+  const userIdentity = await ctx.auth.getUserIdentity();
+  if (userIdentity === null) {
+    throw new Error("Unauthorized");
+  }
+  const user = /* query ctx.db to load the user */ OMIT_ME;
+  const userSettings = /* load other documents related to the user */ OMIT_ME;
+  return { user, settings: userSettings };
+}
+// @snippet end usersCorrect
+
+declare const Users: {
+  getCurrentUser: (ctx: QueryCtx) => Promise<Doc<"users">>;
+};
+
+// @snippet start conversationsModelCorrect
+export async function ensureHasAccess(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  const user = await Users.getCurrentUser(ctx);
+  const conversation = await ctx.db.get(conversationId);
+  if (conversation === null || !conversation.members.includes(user._id)) {
+    throw new Error("Unauthorized");
+  }
+  return conversation;
+}
+
+export async function listMessages_OMIT_2(
+  ctx: QueryCtx,
+  { conversationId }: { conversationId: Id<"conversations"> },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  const messages = /* query ctx.db to load the messages */ OMIT_ME;
+  return messages;
+}
+
+export async function addSummary_OMIT_1(
+  ctx: MutationCtx,
+  {
+    conversationId,
+    summary,
+  }: { conversationId: Id<"conversations">; summary: string },
+) {
+  await ensureHasAccess(ctx, { conversationId });
+  await ctx.db.patch(conversationId, { summary });
+}
+
+export async function generateSummary(
+  messages: Doc<"messages">[],
+  conversationId: Id<"conversations">,
+) {
+  // @skipNextLine
+  /* prettier-ignore */
+  const summary = /* call some external service to summarize the conversation */ OMIT_ME;
+  return summary;
+}
+// @snippet end conversationsModelCorrect
+
+declare const Conversations: {
+  addSummary: (
+    ctx: MutationCtx,
+    {
+      conversationId,
+      summary,
+    }: { conversationId: Id<"conversations">; summary: string },
+  ) => Promise<void>;
+  listMessages: (
+    ctx: QueryCtx,
+    { conversationId }: { conversationId: Id<"conversations"> },
+  ) => Promise<Doc<"messages">[]>;
+  generateSummary: (
+    messages: Doc<"messages">[],
+    conversationId: Id<"conversations">,
+  ) => Promise<string>;
+};
+
+// @snippet start conversationsApiCorrect
+export const addSummary = internalMutation({
+  args: {
+    conversationId: v.id("conversations"),
+    summary: v.string(),
+  },
+  handler: async (ctx, { conversationId, summary }) => {
+    await Conversations.addSummary(ctx, { conversationId, summary });
+  },
+});
+
+export const listMessages = internalQuery({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    return Conversations.listMessages(ctx, { conversationId });
+  },
+});
+
+export const summarizeConversation = action({
+  args: {
+    conversationId: v.id("conversations"),
+  },
+  handler: async (ctx, { conversationId }) => {
+    const messages = await ctx.runQuery(internal.conversations.listMessages, {
+      conversationId,
+    });
+    const summary = await Conversations.generateSummary(
+      messages,
+      conversationId,
+    );
+    await ctx.runMutation(internal.conversations.addSummary, {
+      conversationId,
+      summary,
+    });
+  },
+});
+// @snippet end conversationsApiCorrect
+```
+
+
+## Use `runAction` only when using a different runtime
+
+### Why?
+
+Calling `runAction` has more overhead than calling a plain TypeScript function.
+It counts as an extra function call with its own memory and CPU usage, while the
+parent action is doing nothing except waiting for the result. Therefore,
+`runAction` should almost always be replaced with calling a plain TypeScript
+function. However, if you want to call code that requires Node.js from a
+function in the Convex runtime (e.g. using a library that requires Node.js),
+then you can use `runAction` to call the Node.js code.
+
+### Example
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### How?
+
+Search for `runAction` in your Convex codebase, and see if the function it calls
+uses the same runtime as the parent function. If so, replace the `runAction`
+with a plain TypeScript function. You may want to structure your functions so
+the Node.js functions are in a separate directory so it's easier to spot these.
+
+## Avoid sequential `ctx.runMutation` / `ctx.runQuery` calls from actions
+
+### Why?
+
+Each `ctx.runMutation` or `ctx.runQuery` runs in its own transaction, which
+means if they're called separately, they may not be consistent with each other.
+If instead we call a single `ctx.runQuery` or `ctx.runMutation`, we're
+guaranteed that the results we get are consistent.
+
+### How?
+
+Audit your calls to `ctx.runQuery` and `ctx.runMutation` in actions. If you see
+multiple in a row with no other code between them, replace them with a single
+`ctx.runQuery` or `ctx.runMutation` that handles both things. Refactoring your
+code to use helper functions will make this easier.
+
+### Example: Queries
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### Example: Loops
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+
+### Exceptions
+
+If you're intentionally trying to process more data than fits in a single
+transaction, like running a migration or aggregating data, then it makes sense
+to have multiple sequential `ctx.runMutation` / `ctx.runQuery` calls.
+
+Multiple `ctx.runQuery` / `ctx.runMutation` calls are often necessary because
+the action does a side effect in between them. For example, reading some data,
+feeding it to an external service, and then writing the result back to the
+database.
+
+## Use `ctx.runQuery` and `ctx.runMutation` sparingly in queries and mutations
+
+### Why?
+
+While these queries and mutations run in the same transaction, and will give
+consistent results, they have extra overhead compared to plain TypeScript
+functions. Wanting a TypeScript helper function is much more common than needing
+`ctx.runQuery` or `ctx.runMutation`.
+
+### How?
+
+Audit your calls to `ctx.runQuery` and `ctx.runMutation` in queries and
+mutations. Unless one of the exceptions below applies, replace them with a plain
+TypeScript function.
+
+### Exceptions
+
+- If you're using components, these require `ctx.runQuery` or `ctx.runMutation`.
+- If you want partial rollback on an error, you will want `ctx.runMutation`
+  instead of a plain TypeScript function.
+
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
+```ts
+import { GenericId, v } from "convex/values";
+import {
+  ActionBuilder,
+  anyApi,
+  Crons,
+  DataModelFromSchemaDefinition,
+  defineSchema,
+  defineTable,
+  GenericActionCtx,
+  GenericMutationCtx,
+  GenericQueryCtx,
+  MutationBuilder,
+  PaginationOptions,
+  QueryBuilder,
+} from "convex/server";
+
+/**
+ * The snippets in our best practices guide are a little less
+ * rigorous than most of our snippets. They're more about illustrating
+ * "right" and "wrong" patterns side by side than providing complete
+ * code that can be copy-pasted and immediately run.
+ *
+ * We're more comfortable omitting import statements or glossing over
+ * portions of functions in these snippets than elsewhere.
+ *
+ * However we still want to write these in TypeScript so we write syntactically
+ * correct code (it's very easy to make mistakes in markdown).
+ *
+ * When changing things here, check that the "Best practices" page in
+ * docs still looks correct.
+ *
+ * A few tricks to write syntactically valid code while glossing over details:
+ * - Use `declare const` to declare variables we're using without actually needing
+ * to give them a value
+ * - Use blocks + `// @skipNextLine` to allow using the same `const` name
+ * twice for side by side examples within the same snippet
+ * - Use `foo_OMIT_1` + `foo_OMIT_2` with the `replacements` option on the
+ * snippet to use the same function name twice (especially for exported functions)
+ * - Use `/* do X *\/ OMIT_ME` + the `replacements` option on the snippet to
+ * avoid writing out details.
+ */
+
+const schema = defineSchema({
+  messages: defineTable({
+    author: v.string(),
+    body: v.string(),
+  }).index("by_author", ["author"]),
+  movies: defineTable({
+    director: v.string(),
+  }).index("by_director", ["director"]),
+  watchedMovies: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  watchedMoviesCount: defineTable({
+    user: v.string(),
+  }).index("by_user", ["user"]),
+  teamMembers: defineTable({
+    team: v.string(),
+    user: v.string(),
+  })
+    .index("by_team", ["team"])
+    .index("by_team_and_user", ["team", "user"]),
+  teams: defineTable({
+    name: v.string(),
+    owner: v.string(),
+  }),
+  failures: defineTable({
+    kind: v.string(),
+    body: v.string(),
+    author: v.string(),
+    error: v.string(),
+  }),
+});
+type DataModel = DataModelFromSchemaDefinition<typeof schema>;
+
+type QueryCtx = GenericQueryCtx<DataModel>;
+type MutationCtx = GenericMutationCtx<DataModel>;
+type ActionCtx = GenericActionCtx<DataModel>;
+
+declare const ctx: QueryCtx;
+
+declare const internalMutation: MutationBuilder<DataModel, "internal">;
+declare const internalQuery: QueryBuilder<DataModel, "internal">;
+declare const action: ActionBuilder<DataModel, "public">;
+declare const mutation: MutationBuilder<DataModel, "public">;
+
+declare const crons: Crons;
+
+const internal = anyApi;
+const api = anyApi;
+
+declare const OMIT_ME: any;
+
+// @snippet start filter
+// @skipNextLine
+{
+  // ❌
+  const tomsMessages = ctx.db
+    .query("messages")
+    .filter((q) => q.eq(q.field("author"), "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Option 1: Use an index
+  const tomsMessages = await ctx.db
+    .query("messages")
+    .withIndex("by_author", (q) => q.eq("author", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // Option 2: Filter in code
+  const allMessages = await ctx.db.query("messages").collect();
+  const tomsMessages = allMessages.filter((m) => m.author === "Tom");
+  // @skipNextLine
+}
+// @snippet end filter
+
+declare const paginationOptions: PaginationOptions;
+
+// @snippet start collectIndex
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const allMovies = await ctx.db.query("movies").collect();
+  const moviesByDirector = allMovies.filter(
+    (m) => m.director === "Steven Spielberg",
+  );
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- small number of results, so `collect` is fine
+  const moviesByDirector = await ctx.db
+    .query("movies")
+    .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
+    .collect();
+  // @skipNextLine
+}
+// @snippet end collectIndex
+
+// @snippet start collectPaginate
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- using pagination, showing recently watched movies first
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .order("desc")
+    .paginate(paginationOptions);
+  // @skipNextLine
+}
+// @snippet end collectPaginate
+
+// @snippet start collectCount
+// @skipNextLine
+{
+  // ❌ -- potentially unbounded
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .collect();
+  const numberOfWatchedMovies = watchedMovies.length;
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Show "99+" instead of needing to load all documents
+  const watchedMovies = await ctx.db
+    .query("watchedMovies")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .take(100);
+  const numberOfWatchedMovies =
+    watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅ -- Denormalize the number of watched movies in a separate table
+  const watchedMoviesCount = await ctx.db
+    .query("watchedMoviesCount")
+    .withIndex("by_user", (q) => q.eq("user", "Tom"))
+    .unique();
+  // @skipNextLine
+}
+// @snippet end collectCount
+
+declare const teamId: GenericId<"teams">;
+
+// @snippet start redundantIndexes
+// @skipNextLine
+{
+  // ❌
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+
+// @skipNextLine
+{
+  // ✅
+  // Just don't include a condition on `user` when querying for results on `team`
+  const allTeamMembers = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
+    .collect();
+  const currentUserId = /* get current user id from `ctx.auth` */ OMIT_ME;
+  const currentTeamMember = await ctx.db
+    .query("teamMembers")
+    .withIndex("by_team_and_user", (q) =>
+      q.eq("team", teamId).eq("user", currentUserId),
+    )
+    .unique();
+  // @skipNextLine
+}
+// @snippet end redundantIndexes
+
+// @snippet start validation
+// ❌ -- could be used to update any document (not just `messages`)
+export const updateMessage_OMIT_1 = mutation({
+  handler: async (ctx, { id, update }) => {
+    // @skipNextLine
+    // @ts-expect-error -- id has type `unknown` here
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- can only be called with an ID from the messages table, and can only update
+// the `body` and `author` fields
+export const updateMessage_OMIT_2 = mutation({
+  args: {
+    id: v.id("messages"),
+    update: v.object({
+      body: v.optional(v.string()),
+      author: v.optional(v.string()),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+// @snippet end validation
+
+type TeamMember = {
+  email: string;
+};
+// @snippet start accessControl
+// ❌ -- no checks! anyone can update any team if they get the ID
+export const updateTeam_OMIT_1 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ❌ -- checks access, but uses `email` which could be spoofed
+export const updateTeam_OMIT_2 = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+    email: v.string(),
+  },
+  handler: async (ctx, { id, update, email }) => {
+    const teamMembers = /* load team members */ OMIT_ME as TeamMember[];
+    if (!teamMembers.some((m) => m.email === email)) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- checks access, and uses `ctx.auth`, which cannot be spoofed
+export const updateTeam = mutation({
+  args: {
+    id: v.id("teams"),
+    update: v.object({
+      name: v.optional(v.string()),
+      owner: v.optional(v.id("users")),
+    }),
+  },
+  handler: async (ctx, { id, update }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, update);
+  },
+});
+
+// ✅ -- separate functions which have different access control
+export const setTeamOwner = mutation({
+  args: {
+    id: v.id("teams"),
+    owner: v.id("users"),
+  },
+  handler: async (ctx, { id, owner }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamOwner = /* check if user is the owner of the team */ OMIT_ME;
+    if (!isTeamOwner) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { owner: owner });
+  },
+});
+
+export const setTeamName = mutation({
+  args: {
+    id: v.id("teams"),
+    name: v.string(),
+  },
+  handler: async (ctx, { id, name }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    const isTeamMember = /* check if user is a member of the team */ OMIT_ME;
+    if (!isTeamMember) {
+      throw new Error("Unauthorized");
+    }
+    await ctx.db.patch(id, { name: name });
+  },
+});
+// @snippet end accessControl
+
+// @snippet start internal
+// ❌ -- using `api`
+export const sendMessage_OMIT_1 = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    // add message to the database
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  api.messages.sendMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+
+// ✅ Using `internal`
+// REPLACE_WITH_MUTATION_CTX_IMPORT
+async function sendMessageHelper(
+  ctx: MutationCtx,
+  args: { body: string; author: string },
+) {
+  // add message to the database
+}
+
+export const sendMessage_OMIT_2 = mutation({
+  args: {
+    body: v.string(),
+  },
+  handler: async (ctx, { body }) => {
+    const user = await ctx.auth.getUserIdentity();
+    if (user === null) {
+      throw new Error("Unauthorized");
+    }
+    await sendMessageHelper(ctx, { body, author: user.name ?? "Anonymous" });
+  },
+});
+
+export const sendInternalMessage = internalMutation({
+  args: {
+    body: v.string(),
+    // don't need to worry about `author` being spoofed since this is an internal function
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    await sendMessageHelper(ctx, { body, author });
+  },
+});
+
+// crons.ts
+crons.daily(
+  "send daily reminder",
+  { hourUTC: 17, minuteUTC: 30 },
+  internal.messages.sendInternalMessage,
+  { author: "System", body: "Share your daily update!" },
+);
+// @snippet end internal
+
+// @snippet start runAction
+// ❌ -- using `runAction`
+export const scrapeWebsite_OMIT_1 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) =>
+        ctx.runAction(internal.scrape.scrapeSinglePage, { url: page }),
+      ),
+    );
+  },
+});
+// @snippet end runAction
+
+// @snippet start scrapeModel
+// ✅ -- using a plain TypeScript function
+export async function scrapeSinglePage(
+  ctx: ActionCtx,
+  { url }: { url: string },
+) {
+  const page = await fetch(url);
+  const text = /* parse the page */ OMIT_ME;
+  await ctx.runMutation(internal.scrape.addPage, { url, text });
+}
+// @snippet end scrapeModel
+
+declare const Scrape: {
+  scrapeSinglePage: (ctx: ActionCtx, { url }: { url: string }) => Promise<void>;
+};
+// @snippet start scrapeAction
+export const scrapeWebsite_OMIT_2 = action({
+  args: {
+    siteMapUrl: v.string(),
+  },
+  handler: async (ctx, { siteMapUrl }) => {
+    const siteMap = await fetch(siteMapUrl);
+    const pages = /* parse the site map */ OMIT_ME as string[];
+    await Promise.all(
+      pages.map((page) => Scrape.scrapeSinglePage(ctx, { url: page })),
+    );
+  },
+});
+// @snippet end scrapeAction
+
+declare const assert: (condition: boolean) => void;
+
+// @snippet start runQueryWrong
+// ❌ -- this assertion could fail if the team changed between running the two queries
+const team = await ctx.runQuery(internal.teams.getTeam, { teamId });
+const teamOwner = await ctx.runQuery(internal.teams.getTeamOwner, { teamId });
+assert(team.owner === teamOwner._id);
+// @snippet end runQueryWrong
+
+declare const Teams: {
+  load: (
+    ctx: QueryCtx,
+    { teamId }: { teamId: GenericId<"teams"> },
+  ) => Promise<{ owner: GenericId<"users"> }>;
+};
+declare const Users: {
+  load: (
+    ctx: QueryCtx,
+    { userId }: { userId: GenericId<"users"> },
+  ) => Promise<{ _id: GenericId<"users"> }>;
+  insert: (
+    ctx: MutationCtx,
+    { name, email }: { name: string; email: string },
+  ) => Promise<void>;
+};
+
+// @snippet start runQueryCorrect
+export const sendBillingReminder = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // ✅ -- this will always pass
+    const teamAndOwner = await ctx.runQuery(internal.teams.getTeamAndOwner, {
+      teamId,
+    });
+    assert(teamAndOwner.team.owner === teamAndOwner.owner._id);
+    // send a billing reminder email to the owner
+  },
+});
+
+export const getTeamAndOwner = internalQuery({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    const team = await Teams.load(ctx, { teamId });
+    const owner = await Users.load(ctx, { userId: team.owner });
+    return { team, owner };
+  },
+});
+// @snippet end runQueryCorrect
+
+// Gets members on the team
+async function fetchTeamMemberData(teamId: string) {
+  return [{ name: "Alice", email: "alice@gmail.com" }];
+}
+// @snippet start runMutationWrong
+export const importTeams_OMIT_1 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ❌ This will run a separate mutation for inserting each user,
+    // which means you lose transaction guarantees like atomicity.
+    for (const member of teamMembers) {
+      await ctx.runMutation(internal.teams.insertUser, member);
+    }
+  },
+});
+export const insertUser = internalMutation({
+  args: { name: v.string(), email: v.string() },
+  handler: async (ctx, { name, email }) => {
+    await Users.insert(ctx, { name, email });
+  },
+});
+// @snippet end runMutationWrong
+
+// @snippet start runMutationCorrect
+export const importTeams_OMIT_2 = action({
+  args: {
+    teamId: v.id("teams"),
+  },
+  handler: async (ctx, { teamId }) => {
+    // Fetch team members from an external API
+    const teamMembers = await fetchTeamMemberData(teamId);
+
+    // ✅ This action runs a single mutation that inserts all users in the same transaction.
+    await ctx.runMutation(internal.teams.insertUsers, teamMembers);
+  },
+});
+export const insertUsers = internalMutation({
+  args: { users: v.array(v.object({ name: v.string(), email: v.string() })) },
+  handler: async (ctx, { users }) => {
+    for (const { name, email } of users) {
+      await Users.insert(ctx, { name, email });
+    }
+  },
+});
+// @snippet end runMutationCorrect
+
+// @snippet start partialRollback
+export const trySendMessage = mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  handler: async (ctx, { body, author }) => {
+    try {
+      await ctx.runMutation(internal.messages.sendMessage, { body, author });
+    } catch (e) {
+      // Record the failure, but rollback any writes from `sendMessage`
+      await ctx.db.insert("failures", {
+        kind: "MessageFailed",
+        body,
+        author,
+        error: `Error: ${e}`,
+      });
+    }
+  },
+});
+// @snippet end partialRollback
+```
+
diff --git a/synced/convex/docs/understanding/best-practices/other-recommendations.md b/synced/convex/docs/understanding/best-practices/other-recommendations.md
new file mode 100644
index 0000000..b4f937e
--- /dev/null
+++ b/synced/convex/docs/understanding/best-practices/other-recommendations.md
@@ -0,0 +1,210 @@
+---
+title: "Other Recommendations"
+sidebar_position: 170
+sidebar_class_name: "hidden"
+pagination_next: null
+---
+
+
+
+
+
+{/* This page was previously the Best Practices page which has been rewritten */}
+{/* with some of this content dropped. We are keeping this as a hidden page that is */}
+{/* still scrape-able */}
+
+Here's a collection of our recommendations on how best to use Convex to build
+your application. If you want guidance specific to your app's needs or have
+discovered other ways of using Convex,
+[message us on Discord](https://convex.dev/community)!
+
+## Use [TypeScript](/understanding/best-practices/typescript.mdx)
+
+All Convex libraries have complete type annotations and using theses types is a
+great way to learn the framework.
+
+Even better, Convex supports [code generation](/generated-api/) to create types
+that are specific to your app's [schema](/database/schemas.mdx) and
+[Convex functions](/functions.mdx).
+
+Code generation is run automatically by
+[`npx convex dev`](/cli.md#run-the-convex-dev-server).
+
+## Check generated code into version control
+
+Inside the convex folder is a `_generated/` directory containing code customized
+to your convex functions. Check this folder in to your git repo. That way your
+code will typecheck without needing to run `npx convex codegen` or
+`npx convex dev` (which includes codegen) first.
+
+This also allows developers to make changes to a project that uses convex by
+running it against the production deployment by setting an environment variable,
+without ever needing to run the Convex CLI tool. To run against a production
+deployment set an environment variable like VITE_CONVEX_URL (the exact variable
+name depends on the framework you use) to a production deployment URL like
+`https://happy-otter-123.convex.cloud` found in project's production deployment
+settings in the dashboard. Most frameworks search for variables like this in a
+file called `.env` or `.env.production`.
+
+## Functions
+
+### Use [argument validation](/functions/validation.mdx) in all public functions.
+
+Argument validation prevents malicious users from calling your functions with
+the wrong types of arguments. It's okay to skip argument validation for
+[internal functions](/functions/internal-functions.mdx) because they are not
+publicly accessible.
+
+### Use `console.log` to debug your Convex functions.
+
+All server-side logs from Convex functions are shown on the
+[dashboard Logs page](/dashboard/deployments/logs.md). If a server-side
+exception occurs, it will also be logged as an error event.
+
+On a **dev deployment** the logs will also be forwarded to the client and will
+show up in the browser developer tools Console for the user who invoked the
+function call, including full server error messages and server-side stack
+traces.
+
+### Use helper functions to write shared code.
+
+Write helper functions in your `convex/` directory and use them within your
+Convex functions. Helpers can be a powerful way to share business logic,
+authorization code, and more.
+
+Helper functions allow sharing code while still executing the entire query or
+mutation in a single transaction. For actions, sharing code via helper functions
+instead of using `ctx.runAction` reduces function calls and resource usage.
+
+See the [TypeScript page](/understanding/best-practices/typescript.mdx) for
+useful types.
+
+
+```ts
+import { QueryCtx, mutation } from "./_generated/server";
+import { v } from "convex/values";
+import { getCurrentUser } from "./userHelpers";
+import { Doc, Id } from "./_generated/dataModel";
+
+export const remove = mutation({
+  args: { teamId: v.id("teams") },
+  handler: async (ctx, { teamId }) => {
+    const currentUser = await getCurrentUser(ctx);
+    await ensureTeamAdmin(ctx, currentUser, teamId);
+    await ctx.db.delete(teamId);
+  },
+});
+
+async function ensureTeamAdmin(
+  ctx: QueryCtx,
+  user: Doc<"users">,
+  teamId: Id<"teams">,
+) {
+  // use `ctx.db` to check that `user` is a team admin and throw an error otherwise
+}
+```
+
+```js
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+import { getCurrentUser } from "./userHelpers";
+
+export const remove = mutation({
+  args: { teamId: v.id("teams") },
+  handler: async (ctx, { teamId }) => {
+    const currentUser = await getCurrentUser(ctx);
+    await ensureTeamAdmin(ctx, currentUser, teamId);
+    await ctx.db.delete(teamId);
+  },
+});
+
+async function ensureTeamAdmin(ctx, user, teamId) {
+  // use `ctx.db` to check that `user` is a team admin and throw an error otherwise
+}
+```
+
+
+
+```ts
+// @snippet start userHelpers
+import { Doc } from "./_generated/dataModel";
+import { QueryCtx } from "./_generated/server";
+
+export async function getCurrentUser(ctx: QueryCtx): Promise<Doc<"users">> {
+  // load user details using `ctx.auth` and `ctx.db`
+  // @snippet end userHelpers
+  return null as any;
+}
+```
+
+```js
+// @snippet start userHelpers
+export async function getCurrentUser(ctx) {
+  // load user details using `ctx.auth` and `ctx.db`
+  // @snippet end userHelpers
+  return null;
+}
+```
+
+
+### Prefer queries and mutations over actions
+
+You should generally avoid using actions when the same goal can be achieved
+using queries or mutations. Since actions can have side effects, they can't be
+automatically retried nor their results cached. Actions should be used in more
+limited scenarios, such as calling third-party services.
+
+## Database
+
+### Use indexes or paginate all large database queries.
+
+[Database indexes](/database/reading-data/indexes/indexes.md) with
+[range expressions](/database/reading-data/indexes/indexes.md#querying-documents-using-indexes)
+allow you to write efficient database queries that only scan a small number of
+documents in the table. [Pagination](/database/pagination.mdx) allows you to
+quickly display incremental lists of results. If your table could contain more
+than a few thousand documents, you should consider pagination or an index with a
+range expression to ensure that your queries stay fast.
+
+For more details, check out our
+[Introduction to Indexes and Query Performance](/database/reading-data/indexes/indexes-and-query-perf.md)
+article.
+
+### Use tables to separate logical object types.
+
+Even though Convex does support nested documents, it is often better to put
+separate objects into separate tables and use `Id`s to create references between
+them. This will give you more flexibility when loading and
+[querying documents](/database/reading-data/reading-data.mdx).
+
+You can read more about this at [Document IDs](/database/document-ids.mdx).
+
+## UI patterns
+
+### Check for `undefined` to determine if a query is loading.
+
+The [`useQuery` React hook](/api/modules/react#usequery) will return `undefined`
+when it is first mounted, before the query has been loaded from Convex. Once a
+query is loaded it will never be `undefined` again (even as the data reactively
+updates). `undefined` is not a valid return type for queries (you can see the
+types that Convex supports at [Data Types](/database/types.md))
+
+You can use this as a signal for when to render loading indicators and
+placeholder UI.
+
+### Add optimistic updates for the interactions you want to feel snappy.
+
+By default all relevant `useQuery` hooks will update automatically after a
+mutation is synced from Convex. If you would like some interactions to happen
+even faster, you can add
+[optimistic updates](/client/react/optimistic-updates.mdx) to your `useMutation`
+calls so that the UI updates instantaneously.
+
+### Use an exception handling service and error boundaries to manage errors.
+
+Inevitably, your Convex functions will have bugs and hit exceptions. If you have
+an exception handling service and error boundaries configured, you can ensure
+that you hear about these errors and your users see appropriate UI.
+
+See [Error Handling](/functions/error-handling/error-handling.mdx) for more
+information.
diff --git a/synced/convex/docs/understanding/best-practices/typescript.md b/synced/convex/docs/understanding/best-practices/typescript.md
new file mode 100644
index 0000000..0da4493
--- /dev/null
+++ b/synced/convex/docs/understanding/best-practices/typescript.md
@@ -0,0 +1,276 @@
+---
+title: "TypeScript"
+sidebar_position: 80
+description: "Move faster with end-to-end type safety."
+pagination_next: null
+---
+
+
+
+
+
+
+
+
+
+Convex provides end-to-end type support when Convex functions are written in
+[TypeScript](https://www.typescriptlang.org/).
+
+You can gradually add TypeScript to a Convex project: the following steps
+provide progressively better type support. For the best support you'll want to
+complete them all.
+
+**Example:**
+[TypeScript and Schema](https://github.com/get-convex/convex-demos/tree/main/typescript)
+
+## Writing Convex functions in TypeScript
+
+The first step to improving type support in a Convex project is to writing your
+Convex functions in TypeScript by using the `.ts` extension.
+
+If you are using [argument validation](/functions/validation.mdx), Convex will
+infer the types of your functions arguments automatically:
+
+
+```ts
+import { mutation } from "./_generated/server";
+import { v } from "convex/values";
+
+export default mutation({
+  args: {
+    body: v.string(),
+    author: v.string(),
+  },
+  // Convex knows that the argument type is `{body: string, author: string}`.
+  handler: async (ctx, args) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+
+Otherwise you can annotate the arguments type manually:
+
+
+```ts
+import { internalMutation } from "./_generated/server";
+
+export default internalMutation({
+  // To convert this function from JavaScript to
+  // TypeScript you annotate the type of the arguments object.
+  handler: async (ctx, args: { body: string; author: string }) => {
+    const { body, author } = args;
+    await ctx.db.insert("messages", { body, author });
+  },
+});
+```
+
+
+This can be useful for [internal functions](/functions/internal-functions.mdx)
+accepting complicated types.
+
+If TypeScript is installed in your project `npx convex dev` and
+`npx convex deploy` will typecheck Convex functions before sending code to the
+Convex backend.
+
+Convex functions are typechecked with the `tsconfig.json` in the Convex folder:
+you can modify some parts of this file to change typechecking settings, or
+delete this file to disable this typecheck.
+
+You'll find most database methods have a return type of `Promise<any>` until you
+add a schema.
+
+## Adding a schema
+
+Once you [define a schema](/database/schemas.mdx) the type signature of database
+methods will be known. You'll also be able to use types imported from
+`convex/_generated/dataModel` in both Convex functions and clients written in
+TypeScript (React, React Native, Node.js etc.).
+
+The types of documents in tables can be described using the
+[`Doc`](/generated-api/data-model#doc) type from the generated data model and
+references to documents can be described with parametrized
+[Document IDs](/database/document-ids.mdx).
+
+
+```ts
+import { query } from "./_generated/server";
+
+export const list = query({
+  args: {},
+  // The inferred return type of `handler` is now `Promise<Doc<"messages">[]>`
+  handler: (ctx) => {
+    return ctx.db.query("messages").collect();
+  },
+});
+```
+
+
+## Type annotating server-side helpers
+
+When you want to reuse logic across Convex functions you'll want to define
+helper TypeScript functions, and these might need some of the provided context,
+to access the database, authentication and any other Convex feature.
+
+Convex generates types corresponding to documents and IDs in your database,
+`Doc` and `Id`, as well as `QueryCtx`, `MutationCtx` and `ActionCtx` types based
+on your schema and declared Convex functions:
+
+
+```ts
+// Types based on your schema
+import { Doc, Id } from "./_generated/dataModel";
+// Types based on your schema and declared functions
+import {
+  QueryCtx,
+  MutationCtx,
+  ActionCtx,
+  DatabaseReader,
+  DatabaseWriter,
+} from "./_generated/server";
+// Types that don't depend on schema or function
+import {
+  Auth,
+  StorageReader,
+  StorageWriter,
+  StorageActionWriter,
+} from "convex/server";
+
+// Note that a `MutationCtx` also satisfies the `QueryCtx` interface
+export function myReadHelper(ctx: QueryCtx, id: Id<"channels">) {
+  /* ... */
+}
+
+export function myActionHelper(ctx: ActionCtx, doc: Doc<"messages">) {
+  /* ... */
+}
+```
+
+
+### Inferring types from validators
+
+Validators can be reused between
+[argument validation](/functions/validation.mdx) and
+[schema validation](/database/schemas.mdx). You can use the provided
+[`Infer`](/api/modules/values#infer) type to get a TypeScript type corresponding
+to a validator:
+
+
+```ts
+import { Infer, v } from "convex/values";
+
+export const courseValidator = v.union(
+  v.literal("appetizer"),
+  v.literal("main"),
+  v.literal("dessert"),
+);
+
+// The corresponding type can be used in server or client-side helpers:
+export type Course = Infer<typeof courseValidator>;
+// is inferred as `'appetizer' | 'main' | 'dessert'`
+```
+
+
+### Document types without system fields
+
+All documents in Convex include the built-in `_id` and `_creationTime` fields,
+and so does the generated `Doc` type. When creating or updating a document you
+might want use the type without the system fields. Convex provides
+[`WithoutSystemFields`](/api/modules/server#withoutsystemfields) for this
+purpose:
+
+
+```ts
+import { MutationCtx } from "./_generated/server";
+import { WithoutSystemFields } from "convex/server";
+import { Doc } from "./_generated/dataModel";
+
+export async function insertMessageHelper(
+  ctx: MutationCtx,
+  values: WithoutSystemFields<Doc<"messages">>,
+) {
+  // ...
+  await ctx.db.insert("messages", values);
+  // ...
+}
+```
+
+
+## Writing frontend code in TypeScript
+
+All Convex JavaScript clients, including React hooks like
+[`useQuery`](/api/modules/react#usequery) and
+[`useMutation`](/api/modules/react#usemutation) provide end to end type safety
+by ensuring that arguments and return values match the corresponding Convex
+functions declarations. For React, install and configure TypeScript so you can
+write your React components in `.tsx` files instead of `.jsx` files.
+
+Follow our [React](/quickstart/react.mdx) or [Next.js](/quickstart/nextjs.mdx)
+quickstart to get started with Convex and TypeScript.
+
+### Type annotating client-side code
+
+When you want to pass the result of calling a function around your client
+codebase, you can use the generated types `Doc` and `Id`, just like on the
+backend:
+
+
+```tsx
+import { Doc, Id } from "../convex/_generated/dataModel";
+
+function Channel(props: { channelId: Id<"channels"> }) {
+  // ...
+}
+
+function MessagesView(props: { message: Doc<"messages"> }) {
+  // ...
+}
+```
+
+
+You can also declare custom types inside your backend codebase which include
+`Doc`s and `Id`s, and import them in your client-side code.
+
+You can also use `WithoutSystemFields` and any types inferred from validators
+via `Infer`.
+
+#### Using inferred function return types
+
+Sometimes you might want to annotate a type on the client based on whatever your
+backend function returns. Beside manually declaring the type (on the backend or
+on the frontend), you can use the generic `FunctionReturnType` and
+`UsePaginatedQueryReturnType` types with a function reference:
+
+
+```ts
+import { FunctionReturnType } from "convex/server";
+import { UsePaginatedQueryReturnType } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function MyHelperComponent(props: {
+  data: FunctionReturnType<typeof api.myFunctions.getSomething>;
+}) {
+  // ...
+}
+
+export function MyPaginationHelperComponent(props: {
+  paginatedData: UsePaginatedQueryReturnType<
+    typeof api.myFunctions.getSomethingPaginated
+  >;
+}) {
+  // ...
+}
+```
+
+
+## Turning `string`s into valid document IDs
+
+See [Serializing IDs](/database/document-ids.mdx#serializing-ids).
+
+## Required TypeScript version
+
+Convex requires TypeScript version
+[5.0.3](https://www.npmjs.com/package/typescript/v/5.0.3) or newer.
+
+<StackPosts query="types" />
diff --git a/synced/convex/docs/understanding/convex-query-subscription.tldr b/synced/convex/docs/understanding/convex-query-subscription.tldr
new file mode 100644
index 0000000..5fbba2b
--- /dev/null
+++ b/synced/convex/docs/understanding/convex-query-subscription.tldr
@@ -0,0 +1 @@
+{"tldrawFileFormatVersion":1,"schema":{"schemaVersion":2,"sequences":{"com.tldraw.store":4,"com.tldraw.asset":1,"com.tldraw.camera":1,"com.tldraw.document":2,"com.tldraw.instance":25,"com.tldraw.instance_page_state":5,"com.tldraw.page":1,"com.tldraw.instance_presence":6,"com.tldraw.pointer":1,"com.tldraw.shape":4,"com.tldraw.asset.bookmark":2,"com.tldraw.asset.image":5,"com.tldraw.asset.video":5,"com.tldraw.shape.group":0,"com.tldraw.shape.text":2,"com.tldraw.shape.bookmark":2,"com.tldraw.shape.draw":2,"com.tldraw.shape.geo":9,"com.tldraw.shape.note":8,"com.tldraw.shape.line":5,"com.tldraw.shape.frame":0,"com.tldraw.shape.arrow":5,"com.tldraw.shape.highlight":1,"com.tldraw.shape.embed":4,"com.tldraw.shape.image":4,"com.tldraw.shape.video":2,"com.tldraw.binding.arrow":0}},"records":[{"meta":{},"id":"binding:0oEHa9ZYpISIYszCtP6KS","type":"arrow","fromId":"shape:Wn8LrysiMDg-ogNpz620O","toId":"shape:CORoZsXerRJgWFmLjsIT8","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.002411822769062935,"y":0.2235941510461233,"z":1},"terminal":"start"},"typeName":"binding"},{"meta":{},"id":"binding:2Vuo4eAGnLCntiPSsbsGq","type":"arrow","fromId":"shape:Wn8LrysiMDg-ogNpz620O","toId":"shape:CORoZsXerRJgWFmLjsIT8","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.9987815375912927,"y":0.22359415104612274,"z":1},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:QLEg2hannK8eLSflZfnB6","type":"arrow","fromId":"shape:F_r9cRU9knCU4_UZ34OFA","toId":"shape:atJaWMtzFvnmk_2Emg0GR","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.9987815375912927,"y":0.22359415104612274,"z":1},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:jbiT-j_vNiBdvSaFX3hSD","type":"arrow","fromId":"shape:F_r9cRU9knCU4_UZ34OFA","toId":"shape:atJaWMtzFvnmk_2Emg0GR","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.002411822769062935,"y":0.2235941510461233,"z":1},"terminal":"start"},"typeName":"binding"},{"gridSize":10,"name":"","meta":{},"id":"document:document","typeName":"document"},{"meta":{},"id":"page:page","name":"Page 1","index":"a1","typeName":"page"},{"x":485.83203125,"y":904.5859375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:0RNLWuXzvDJZ3fWJI9MeO","type":"text","props":{"color":"black","size":"m","w":48.890625,"text":"e4g","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aA5pF","typeName":"shape"},{"x":797.33203125,"y":862.6015625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:13ao4cC317ewoCsuOJWJD","type":"text","props":{"color":"black","size":"m","w":128.546875,"text":"completed","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"a94B0","typeName":"shape"},{"x":1084.2890625,"y":865.3203124999999,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:27xJ6Q7ukkl5kcoFVEFM4","type":"text","props":{"color":"black","size":"m","w":54.359375,"text":"title","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"a8b6j","typeName":"shape"},{"x":925.98828125,"y":630.76171875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:2e9JqUXOwr9Y7r3-c0e_g","type":"arrow","props":{"dash":"solid","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":4.040082260411392,"y":0.6151838787208987},"end":{"x":4.040082260411376,"y":-95.37626021428046},"arrowheadStart":"arrow","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"aRCCZ","typeName":"shape"},{"x":562.4296875,"y":903.73046875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:3Aa5U8Ec7oYLQgQjtqTiR","type":"text","props":{"color":"black","size":"m","w":219.1875,"text":"Grocery shopping","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aE9Z4","typeName":"shape"},{"x":564.16796875,"y":863.8125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:4_OmWEsUHFUG61EWknqzC","type":"text","props":{"color":"black","size":"m","w":54.359375,"text":"title","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"a86ss","typeName":"shape"},{"x":915.3514267967685,"y":587.1561142967686,"rotation":1.5707963267948966,"isLocked":false,"opacity":1,"meta":{},"id":"shape:5MHb23Q2zJugDWYyNyPfO","type":"line","props":{"dash":"dotted","size":"m","color":"black","spline":"line","points":{"a1":{"id":"a1","index":"a1","x":1.474376176702208e-13,"y":-534.4857751584711},"a21Oo":{"id":"a21Oo","index":"a21Oo","x":8.881784197001252e-14,"y":454.6497520760966}},"scale":1},"parentId":"page:page","index":"a00rC","typeName":"shape"},{"x":1183.0507812499998,"y":553.28125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:6OjBz0gcEx9H-lVae_fJY","type":"text","props":{"color":"light-green","size":"m","w":259.984375,"text":"4. Send updated \n    result to frontend","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aV4U3","typeName":"shape"},{"x":483.40234375,"y":951.15625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:6ySIGuQykezLOO-Abt1dl","type":"text","props":{"color":"black","size":"m","w":45.046875,"text":"s3k","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aB5aL","typeName":"shape"},{"x":1005.953125,"y":906.09375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:7o07L0jD_F7QbUqOuB4PC","type":"text","props":{"color":"black","size":"m","w":48.890625,"text":"e4g","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aAgQj","typeName":"shape"},{"x":473.52251800174406,"y":1024.74609375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:8qK_jT-9-XxNw60QZXERm","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":5.030934382427626,"y":1.1368683772161603e-13},"end":{"x":475.27538111700227,"y":1.1368683772161603e-13},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a10llE0","typeName":"shape"},{"x":852.37890625,"y":1027.32421875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:9hoFHc4qnI1VBVkS4jb2n","type":"text","props":{"color":"black","size":"m","w":54.03125,"text":"true","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aL5eW","typeName":"shape"},{"x":560.31640625,"y":990.5078125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:AJJJ8Ueq3VHzpxywJuSOV","type":"text","props":{"color":"black","size":"m","w":232.828125,"text":"Plant new flowers","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aG6uR","typeName":"shape"},{"x":1116.11328125,"y":808.80078125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Ao7A39_X7g4bCkSR2_7jY","type":"arrow","props":{"dash":"solid","size":"m","fill":"pattern","color":"black","labelColor":"black","bend":0,"start":{"x":65.42297616111546,"y":46.48603398980515},"end":{"x":65.42297616111546,"y":-62.51583820745046},"arrowheadStart":"none","arrowheadEnd":"arrow","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1eRrr8Y","typeName":"shape"},{"x":1371.5,"y":1028.83203125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Ap3rnc7aqOL5SVv8g37hg","type":"text","props":{"color":"black","size":"m","w":54.03125,"text":"true","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aM8TV","typeName":"shape"},{"x":1370.890625,"y":988.75390625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:BNTemnKo5muZ5HGQPZJZf","type":"text","props":{"color":"black","size":"m","w":54.03125,"text":"true","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aKkmc","typeName":"shape"},{"x":560.55859375,"y":1028.484375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Bx2ds6WnLLyg9V2ZQ0IUG","type":"text","props":{"color":"black","size":"m","w":187.78125,"text":"Donate clothes","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aH8J7","typeName":"shape"},{"x":477.07421875,"y":855.8359375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:CORoZsXerRJgWFmLjsIT8","type":"geo","props":{"w":471.42187499999994,"h":211.37109374999997,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"a1","typeName":"shape"},{"x":560,"y":946.37890625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:DEd2m8gup76SB49nTe6SD","type":"text","props":{"color":"black","size":"m","w":183.4375,"text":"Take out trash","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aF8PW","typeName":"shape"},{"x":838.39453125,"y":901.13671875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:FRZ9FQ3NnGi_iVqTQeu9R","type":"geo","props":{"w":93.28125,"h":43.328125,"geo":"ellipse","color":"light-green","labelColor":"black","fill":"semi","dash":"solid","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"a3X4T","typeName":"shape"},{"x":993.3965369170828,"y":902.26171875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:F_r9cRU9knCU4_UZ34OFA","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":0,"y":0},"end":{"x":325.5925429604492,"y":0},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a2hsr","typeName":"shape"},{"x":990.28515625,"y":774.6328125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Gbaj1yOjlDo5YT21Qm7bf","type":"arrow","props":{"dash":"solid","size":"m","fill":"pattern","color":"black","labelColor":"black","bend":-28.119537513285096,"start":{"x":-52.46681120482654,"y":68.62500000000004},"end":{"x":12.57421875,"y":74.06640625},"arrowheadStart":"none","arrowheadEnd":"arrow","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"aO46m","typeName":"shape"},{"x":1003.9296875,"y":990.8125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:GiL8SNArXW43cIkvN2L2Y","type":"text","props":{"color":"black","size":"m","w":46.796875,"text":"u9v","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aChkY","typeName":"shape"},{"x":486.3515625000001,"y":455.71484375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:H128ep4RYR6kBVNH_DNUQ","type":"geo","props":{"w":959.4179687499998,"h":76.83984375,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"Web app","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"aS9cI","typeName":"shape"},{"x":833.94921875,"y":981.94140625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:I1o9BoResco6qq-plE9mP","type":"geo","props":{"w":93.28125,"h":43.328125,"geo":"ellipse","color":"light-green","labelColor":"black","fill":"semi","dash":"solid","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"a5Gsv8jK","typeName":"shape"},{"x":632.8543312500001,"y":546.51953125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:J84mjimmMgAJJrAnT1gxX","type":"text","props":{"color":"light-green","size":"m","w":186.84375,"text":"1. Initial Query","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aPkBj","typeName":"shape"},{"x":506.3828125,"y":533.61328125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:JQdzp0nqSmuYM4R4Il3Ta","type":"arrow","props":{"dash":"solid","size":"m","fill":"pattern","color":"black","labelColor":"black","bend":0,"start":{"x":116.87175013597535,"y":98.23848190167975},"end":{"x":116.87175013597535,"y":1.3828125},"arrowheadStart":"arrow","arrowheadEnd":"arrow","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1CFvJ4","typeName":"shape"},{"x":853.9296875,"y":946.90234375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:KZStlVZ8QlzXb69JN3o3H","type":"text","props":{"color":"black","size":"m","w":54.03125,"text":"true","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aJBj7","typeName":"shape"},{"x":992.6058974461666,"y":943.0703125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Ko8I9ugrGju7FJ9AQKTQZ","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":5.030934382427626,"y":1.1368683772161603e-13},"end":{"x":470.77117578771544,"y":1.13464793116691e-13},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1vfZBeM","typeName":"shape"},{"x":1012.53125,"y":864.2031249999999,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Lt7MAHPpMnRSHwufs2_GY","type":"text","props":{"color":"black","size":"m","w":41.015625,"text":"_id","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"a6kG1","typeName":"shape"},{"x":851.76953125,"y":987.24609375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:MR1reXm2HsXo9BiAIbBZa","type":"text","props":{"color":"black","size":"m","w":61.96875,"text":"false","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aK5Rv","typeName":"shape"},{"x":1080.12109375,"y":947.88671875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:MoVLFolgHDeA5lLU94cnQ","type":"text","props":{"color":"black","size":"m","w":183.4375,"text":"Take out trash","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aFdbR","typeName":"shape"},{"x":469.23814554676846,"y":559.5350205467686,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:QDjyegzXufW6t_Nt_hq4t","type":"text","props":{"color":"black","size":"s","w":82.375,"text":"Internet","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aX9dk","typeName":"shape"},{"x":1082.55078125,"y":905.23828125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:RFuf0W9XTbt_B9r1eaMSt","type":"text","props":{"color":"black","size":"m","w":219.1875,"text":"Grocery shopping","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aEidy","typeName":"shape"},{"x":1080.4375,"y":992.015625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:RU8Oli1eESLs82D9NLekd","type":"text","props":{"color":"black","size":"m","w":232.828125,"text":"Plant new flowers","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aGhi2","typeName":"shape"},{"x":1372.01953125,"y":908.203125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:RqHZij2WczbhmKCnoAea4","type":"text","props":{"color":"black","size":"m","w":61.96875,"text":"false","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aIqhX","typeName":"shape"},{"x":482.8828125,"y":1028.640625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Sfyg6Zj_ETsG7RSneAZ14","type":"text","props":{"color":"black","size":"m","w":53.0625,"text":"w2p","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aD1tB","typeName":"shape"},{"x":1003.5234375,"y":952.6640625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Vmw6NTDe-ElvyKp8g4X3W","type":"text","props":{"color":"black","size":"m","w":45.046875,"text":"s3k","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aBcOV","typeName":"shape"},{"x":473.2754431670828,"y":900.75390625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:Wn8LrysiMDg-ogNpz620O","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":0,"y":0},"end":{"x":325.5925429604492,"y":0},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1OVY","typeName":"shape"},{"x":852.8984375,"y":906.6953125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:XJLVnXfP_dI7H0dyeiPKM","type":"text","props":{"color":"black","size":"m","w":61.96875,"text":"false","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aIC3P","typeName":"shape"},{"x":1354.45703125,"y":984.109375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:YFBfAqmx2eE_rnuJHOSiN","type":"geo","props":{"w":93.28125,"h":43.328125,"geo":"ellipse","color":"yellow","labelColor":"black","fill":"pattern","dash":"solid","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"a5nLGClP","typeName":"shape"},{"x":483.80859375,"y":989.3046875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:ZjlKn4ARBoOZysYBkSfbJ","type":"text","props":{"color":"black","size":"m","w":46.796875,"text":"u9v","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aC2BO","typeName":"shape"},{"x":1003.00390625,"y":1030.1484375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:aM2v5lJViz1VEb3AcSyAA","type":"text","props":{"color":"black","size":"m","w":53.0625,"text":"w2p","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aDalW","typeName":"shape"},{"x":472.4848036961667,"y":941.5625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:aSkujThi6irseMtFt00UV","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":5.030934382427626,"y":1.1368683772161603e-13},"end":{"x":477.69581533063126,"y":-0.8671875},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a134Fbd","typeName":"shape"},{"x":1373.05078125,"y":948.41015625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:aYwttSneUhZqwg1QstmZQ","type":"text","props":{"color":"black","size":"m","w":54.03125,"text":"true","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aJg2T","typeName":"shape"},{"x":997.1953125,"y":857.3437499999999,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:atJaWMtzFvnmk_2Emg0GR","type":"geo","props":{"w":465.35937499999994,"h":211.37109374999997,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"a1bzL","typeName":"shape"},{"x":993.643611751744,"y":1026.25390625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:bE9Z-H5MsaM-piJQHiZzB","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":5.030934382427626,"y":1.1368683772161603e-13},"end":{"x":470.7764575130649,"y":1.1368683772161603e-13},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1guOezC","typeName":"shape"},{"x":472.55274927569855,"y":985.44921875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:euaJK9pliO7O6VNZTO_lh","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":5.030934382427626,"y":1.1368683772161603e-13},"end":{"x":476.73203987248843,"y":1.1390888232654106e-13},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a11XBpf","typeName":"shape"},{"x":486.82421875,"y":863.296875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:fYkgX2SrdurWwNvQ5j7Ue","type":"text","props":{"color":"black","size":"m","w":41.015625,"text":"_id","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"a77rm","typeName":"shape"},{"x":992.6738430256985,"y":986.95703125,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:gTkolbZ4u5joFTfULsSH6","type":"arrow","props":{"dash":"draw","size":"m","fill":"none","color":"black","labelColor":"black","bend":0,"start":{"x":5.030934382427626,"y":1.1368683772161603e-13},"end":{"x":470.1051838052556,"y":1.1368683772161603e-13},"arrowheadStart":"none","arrowheadEnd":"none","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1lpS8Rb","typeName":"shape"},{"x":1301.28125,"y":866.7382812499999,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:i-idGhnLLeDCkdwyFFUio","type":"text","props":{"color":"black","size":"m","w":128.546875,"text":"completed","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"a9ix3","typeName":"shape"},{"x":1080.6796875,"y":1029.9921875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:j8EdMA_WUywvdiCKkubdg","type":"text","props":{"color":"black","size":"m","w":187.78125,"text":"Donate clothes","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aHoiv","typeName":"shape"},{"x":855.96875,"y":748.421875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:jgjC_We9XjzdbMGyoKcmE","type":"text","props":{"color":"light-green","size":"m","w":226.09375,"text":"2. Mutation \n    changes the db","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aPBtO","typeName":"shape"},{"x":1354.984375,"y":902.3984375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:pgGxAznEpg8fRnB_qawyk","type":"geo","props":{"w":93.28125,"h":43.328125,"geo":"ellipse","color":"light-green","labelColor":"black","fill":"semi","dash":"solid","size":"m","font":"draw","text":"","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"a5wEji4k","typeName":"shape"},{"x":495.47265625,"y":637.35546875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:vS2ki-5_QM0yHBpYTeg8E","type":"geo","props":{"w":262,"h":108.49609375,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"Query:\ngetAllOpenTasks","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"aQ55a","typeName":"shape"},{"x":476.08203125,"y":747.97265625,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:vSgaQDjt1vTm_r6qSuZ5J","type":"arrow","props":{"dash":"solid","size":"m","fill":"pattern","color":"black","labelColor":"black","bend":0,"start":{"x":149.9734248585034,"y":107.76746752343747},"end":{"x":150.21170610850336,"y":1.1722047362359262},"arrowheadStart":"none","arrowheadEnd":"arrow","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"a1689Gc","typeName":"shape"},{"x":1205.4921875,"y":747.29296875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:yc-l1IO3bQsCpDCu9iWYp","type":"text","props":{"color":"light-green","size":"m","w":241.859375,"text":"3. Rerun relevant \n    subscribed query","font":"draw","textAlign":"start","autoSize":true,"scale":1},"parentId":"page:page","index":"aN7oc","typeName":"shape"},{"id":"pointer:pointer","typeName":"pointer","x":168.64276132211538,"y":470.6245792425967,"lastActivityTimestamp":1737501541149,"meta":{}},{"followingUserId":null,"opacityForNextShape":1,"stylesForNextShape":{"tldraw:fill":"semi","tldraw:color":"black","tldraw:arrowheadStart":"arrow","tldraw:arrowheadEnd":"none"},"brush":null,"scribbles":[],"cursor":{"type":"default","rotation":0},"isFocusMode":false,"exportBackground":false,"isDebugMode":false,"isToolLocked":false,"screenBounds":{"x":0,"y":0,"w":1690,"h":1555},"insets":[false,false,false,false],"zoomBrush":null,"isGridMode":false,"isPenMode":false,"chatMessage":"","isChatting":false,"highlightedUserIds":[],"isFocused":true,"devicePixelRatio":1,"isCoarsePointer":false,"isHoveringCanvas":false,"openMenus":[],"isChangingStyle":false,"isReadonly":false,"meta":{},"duplicateProps":null,"id":"instance:instance","currentPageId":"page:page","typeName":"instance"},{"editingShapeId":null,"croppingShapeId":null,"selectedShapeIds":[],"hoveredShapeId":null,"erasingShapeIds":[],"hintingShapeIds":[],"focusedGroupId":null,"meta":{},"id":"instance_page_state:page:page","pageId":"page:page","typeName":"instance_page_state"},{"x":-158.25252973720288,"y":58.022746551424774,"z":0.9590588687618661,"meta":{},"id":"camera:page:page","typeName":"camera"},{"meta":{},"id":"binding:PCfgZhuWbUxEjzGc2AZWA","type":"arrow","fromId":"shape:aSkujThi6irseMtFt00UV","toId":"shape:CORoZsXerRJgWFmLjsIT8","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.9971169504420361,"y":0.405573728077471},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:Wvs-eN_ecwkMapm3vaoUh","type":"arrow","fromId":"shape:euaJK9pliO7O6VNZTO_lh","toId":"shape:CORoZsXerRJgWFmLjsIT8","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.9913057782800457,"y":0.6132024911755471},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:wuUrMVplZYBT2OYF-7m9a","type":"arrow","fromId":"shape:8qK_jT-9-XxNw60QZXERm","toId":"shape:CORoZsXerRJgWFmLjsIT8","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.9928880082399361,"y":0.7991166306296329},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:AVnhKenkgyHquY6lH4ryS","type":"arrow","fromId":"shape:Ko8I9ugrGju7FJ9AQKTQZ","toId":"shape:atJaWMtzFvnmk_2Emg0GR","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.991375397160514,"y":0.4055737280774715},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:EZzicQXx2TnmDhNHa5sgz","type":"arrow","fromId":"shape:gTkolbZ4u5joFTfULsSH6","toId":"shape:atJaWMtzFvnmk_2Emg0GR","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.9953637932924544,"y":0.6132024911755477},"terminal":"end"},"typeName":"binding"},{"meta":{},"id":"binding:nQPNeDtd_tLMYeURAkgcO","type":"arrow","fromId":"shape:bE9Z-H5MsaM-piJQHiZzB","toId":"shape:atJaWMtzFvnmk_2Emg0GR","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.998986912715378,"y":0.7991166306296323},"terminal":"end"},"typeName":"binding"},{"x":1093.01171875,"y":636.3984375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:a0mnZpv6KVz-t1wItp4c-","type":"geo","props":{"w":261.81640625,"h":108.49609375,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"Query:\ngetAllOpenTasks","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"aQdfS","typeName":"shape"},{"x":808.28515625,"y":634.77734375,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:2Thmf38U_evMo-K4eQIPo","type":"geo","props":{"w":262,"h":108.49609375,"geo":"rectangle","color":"black","labelColor":"black","fill":"none","dash":"draw","size":"m","font":"draw","text":"Mutation:\nsetTaskCompleted","align":"middle","verticalAlign":"middle","growY":0,"url":"","scale":1},"parentId":"page:page","index":"aQuw06GE","typeName":"shape"},{"x":1059.15625,"y":534.546875,"rotation":0,"isLocked":false,"opacity":1,"meta":{},"id":"shape:ES514HdRLJx2CYx6XLHsP","type":"arrow","props":{"dash":"solid","size":"m","fill":"pattern","color":"black","labelColor":"black","bend":0,"start":{"x":117.57487513597535,"y":100.58223190167975},"end":{"x":116.87175013597535,"y":1.3828125},"arrowheadStart":"none","arrowheadEnd":"arrow","text":"","labelPosition":0.5,"font":"draw","scale":1},"parentId":"page:page","index":"aY7dj","typeName":"shape"},{"meta":{},"id":"binding:3Mz-HroGmwO2Gz_MCfnxm","type":"arrow","fromId":"shape:vSgaQDjt1vTm_r6qSuZ5J","toId":"shape:CORoZsXerRJgWFmLjsIT8","props":{"isPrecise":true,"isExact":false,"normalizedAnchor":{"x":0.31653074776918944,"y":0.01198862849471059},"terminal":"start"},"typeName":"binding"}]}
\ No newline at end of file
diff --git a/synced/convex/docs/understanding/index.md b/synced/convex/docs/understanding/index.md
new file mode 100644
index 0000000..43d5d1e
--- /dev/null
+++ b/synced/convex/docs/understanding/index.md
@@ -0,0 +1,273 @@
+---
+title: "Convex Overview"
+hidden: false
+sidebar_position: 100
+pagination_next: understanding/workflow
+---
+
+Convex is the open source, reactive database where queries are TypeScript code
+running right in the database. Just like React components react to state
+changes, Convex queries react to database changes.
+
+Convex provides a database, a place to write your server functions, and client
+libraries. It makes it easy to build and scale dynamic live-updating apps.
+
+The following diagram shows the standard three-tier app architecture that Convex
+enables. We'll start at the bottom and work our way up to the top of this
+diagram.
+
+<div
+  className="center-image"
+  style={{ maxWidth: "600px", background: "white", borderRadius: "10px" }}
+>
+  ![Convex in your app](/img/basic-diagram.png)
+</div>
+
+## Database
+
+The [database](/database.mdx) is at the core of Convex. The Convex database is
+automatically provisioned when you create your project. There is no connection
+setup or cluster management.
+
+<Admonition type="info">
+  In Convex, your database queries are just [TypeScript
+  code](/database/reading-data/reading-data.mdx) written in your [server
+  functions](/functions.mdx). There is no SQL to write. There are no ORMs
+  needed.
+</Admonition>
+
+The Convex database is reactive. Whenever any data on which a query depends
+changes, the query is rerun, and client subscriptions are updated.
+
+Convex is a "document-relational" database. "Document" means you put JSON-like
+nested objects into your database. "Relational" means you have tables with
+relations, like `tasks` assigned to a `user` using IDs to reference documents in
+other tables.
+
+The Convex cloud offering runs on top of Amazon RDS using MySQL as its
+persistence layer. The Open Source version uses SQLite, Postgres and MySQL. The
+database is ACID-compliant and uses
+[serializable isolation and optimistic concurrency control](/database/advanced/occ.md).
+All that to say, Convex provides the strictest possible transactional
+guarantees, and you never see inconsistent data.
+
+## Server functions
+
+When you create a new Convex project, you automatically get a `convex/` folder
+where you write your [server functions](/functions.mdx). This is where all your
+backend application logic and database query code live.
+
+Example TypeScript server functions that read (query) and write (mutation) to
+the database.
+
+```typescript title="convex/tasks.ts"
+// A Convex query function
+export const getAllOpenTasks = query({
+  args: {},
+  handler: async (ctx, args) => {
+    // Query the database to get all items that are not completed
+    const tasks = await ctx.db
+      .query("tasks")
+      .withIndex("by_completed", (q) => q.eq("completed", false))
+      .collect();
+    return tasks;
+  },
+});
+
+// A Convex mutation function
+export const setTaskCompleted = mutation({
+  args: { taskId: v.id("tasks"), completed: v.boolean() },
+  handler: async (ctx, { taskId, completed }) => {
+    // Update the database using TypeScript
+    await ctx.db.patch(taskId, { completed });
+  },
+});
+```
+
+You read and write to your database through query or mutation functions.
+[Query functions](/functions/query-functions.mdx) are pure functions that can
+only read from the database.
+[Mutation functions](/functions/mutation-functions.mdx) are transactions that
+can read or write from the database. These two database functions are
+[not allowed to take any non-deterministic](/functions/runtimes.mdx#restrictions-on-queries-and-mutations)
+actions like network requests to ensure transactional guarantees.
+
+<Admonition type="info">
+  The entire Convex mutation function is a transaction. There are no `begin` or
+  `end` transaction statements to write. Convex automatically retries the
+  function on conflicts, and you don't have to manage anything.
+</Admonition>
+
+Convex also provides standard general-purpose serverless functions called
+actions. [Action functions](/functions/actions.mdx) can make network requests.
+They have to call query or mutation functions to read and write to the database.
+You use actions to call LLMs or send emails.
+
+You can also durably schedule Convex functions via the
+[scheduler](scheduling/scheduled-functions.mdx) or
+[cron jobs](scheduling/cron-jobs.mdx). Scheduling lets you build workflows like
+emailing a new user a day later if they haven't performed an onboarding task.
+
+You call your Convex functions via [client libraries](/client/react.mdx) or
+directly via [HTTP](/http-api/index.md#functions-api).
+
+## Client libraries
+
+Convex client libraries keep your frontend synced with the results of your
+server functions.
+
+```tsx
+// In your React component
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function TaskList() {
+  const data = useQuery(api.tasks.getAllOpenTasks);
+  return data ?? "Loading...";
+}
+```
+
+Like the `useState` hook that updates your React component when local state
+changes, the Convex `useQuery` hook automatically updates your component
+whenever the result of your query changes. There's no manual subscription
+management or state synchronization needed.
+
+When calling query functions, the client library subscribes to the results of
+the function. Convex tracks the dependencies of your query functions, including
+what data was read from the database. Whenever relevant data in the database
+changes, the Convex automatically reruns the query and sends the result to the
+client.
+
+The client library also queues up mutations in memory to send to the server. As
+mutations execute and cause query results to update, the client library keeps
+your app state consistent. It updates all subscriptions to the same logical
+moment in time in the database.
+
+Convex provides client libraries for nearly all popular web and native app
+frameworks. Client libraries connect to your Convex deployment via WebSockets.
+You can then call your public Convex functions
+[through the library](/client/react.mdx#fetching-data). You can also use Convex
+with [HTTP directly](/http-api/index.md#functions-api), you just won't get the
+automatic subscriptions.
+
+## Putting it all together
+
+Let's return to the `getAllOpenTasks` Convex query function from earlier that
+gets all tasks that are not marked as `completed`:
+
+```typescript title="convex/tasks.ts"
+export const getAllOpenTasks = query({
+  args: {},
+  handler: async (ctx, args) => {
+    // Query the database to get all items that are not completed
+    const tasks = await ctx.db
+      .query("tasks")
+      .withIndex("by_completed", (q) => q.eq("completed", false))
+      .collect();
+    return tasks;
+  },
+});
+```
+
+Let's follow along what happens when you subscribe to this query:
+
+<div
+  className="center-image"
+  style={{ maxWidth: "1800px", background: "white", borderRadius: "10px" }}
+>
+  ![Convex data flow](/img/convex-query-subscription.png)
+</div>
+
+The web app uses the `useQuery` hook to subscribe to this query, and the
+following happens to get an initial value:
+
+- The Convex client sends a message to the Convex server to subscribe to the
+  query
+- The Convex server runs the function, which reads data from the database
+- The Convex server sends a message to the client with the function's result
+
+In this case the initial result looks like this (1):
+
+```json
+[
+  { _id: "e4g", title: "Grocery shopping", complete: false },
+  { _id: "u9v", title: "Plant new flowers", complete: false },
+];
+```
+
+Then you use a mutation to mark an item as completed (2). Convex then reruns the
+query (3) to get an updated result. And pushes the result to the web app via the
+WebSocket connection (4):
+
+```json
+[
+  { _id: "e4g", title: "Grocery shopping", complete: false },
+];
+```
+
+## Beyond reactivity
+
+Beyond reactivity, Convex's architecture is crucial for a deeper reason. Convex
+does not let your app have inconsistent state at any layer of the stack.
+
+To illustrate this, let's imagine you're building a shopping cart for an
+e-commerce store.
+
+<div className="center-image" style={{ maxWidth: "600px" }}>
+  ![Convex in your app](/img/convex-swaghaus.png)
+</div>
+
+On the product listing page, you have two numbers, one showing the number of
+items remaining in stock and another showing the number of items in your
+shopping cart. Each number is a result of a different query function.
+
+Every time you press the "Add to Cart" button, a mutation is called to remove
+one item from the stock and add it to the shopping cart.
+
+The mutation to change the cart runs in a transaction, so your database is
+always in a consistent state. The reactive database knows that the queries
+showing the number of items in stock and the number of items in the shopping
+cart both need to be updated. The queries are invalidated and rerun. The results
+are pushed to the web app via the WebSocket connection.
+
+The client library makes sure that both queries update at the same time in the
+web app since they reflect a singular moment in time in your database. You never
+have a moment where those numbers don't add up. Your app always shows consistent
+data.
+
+You can see this example in action in the
+[Swaghaus sample app](https://swaghaus.biz/).
+
+## For human and AI generated code
+
+Convex is designed around a small set of composable abstractions with strong
+guarantees that result in code that is not only faster to write, it’s easier to
+read and maintain, whether written by a team member or an LLM. Key features make
+sure you get bug-free AI generated code:
+
+1. **Queries are Just TypeScript** Your database queries are pure TypeScript
+   functions with end-to-end type safety and IDE support. This means AI can
+   generate database code using the large training set of TypeScript code
+   without switching to SQL.
+1. **Less Code for the Same Work** Since so much infrastructure and boiler plate
+   is automatically manged by Convex there is less code to write, and thus less
+   code to get wrong.
+1. **Automatic Reactivity** The reactive system automatically tracks data
+   dependencies and updates your UI. AI doesn't need to manually manage
+   subscriptions, WebSocket connections, or complex state synchronization—Convex
+   handles all of this automatically.
+1. **Transactional Guarantees** Queries are read-only and mutations run in
+   transactions. These constraints make it nearly impossible for AI to write
+   code that could corrupt your data or leave your app in an inconsistent state.
+
+Together, these features mean AI can focus on your business logic while Convex's
+guarantees prevent common failure modes.
+
+## Learn more
+
+If you are intrigued about the details of how Convex pulls this all off, you can
+read Convex co-founder Sujay's excellent
+[How Convex Works](https://stack.convex.dev/how-convex-works) blog post.
+
+Now that you have a good sense of how Convex fits in your app. Let's walk
+through the overall workflow of setting up and launching a Convex app.
diff --git a/synced/convex/docs/understanding/workflow.md b/synced/convex/docs/understanding/workflow.md
new file mode 100644
index 0000000..115a10d
--- /dev/null
+++ b/synced/convex/docs/understanding/workflow.md
@@ -0,0 +1,210 @@
+---
+title: "Dev workflow"
+hidden: false
+sidebar_position: 200
+---
+
+Let's walk through everything that needs to happen from creating a new project
+to launching your app in production.
+
+This doc assumes you are building an app with Convex and React and you already
+have a basic React app already up and running. You can follow one of our
+[quickstarts](/quickstarts.mdx) to set this up.
+
+## Installing and running Convex
+
+You install Convex adding the npm dependency to your app:
+
+```sh
+npm i convex
+```
+
+Then you create your Convex project and start the backend dev loop:
+
+```sh
+npx convex dev
+```
+
+The first time you run the `npx convex dev` command you'll be asked whether you
+want start developing locally without an account or create an account.
+
+### Developing without an account
+
+`npx convex dev` will prompt you for the name of your project, and then start
+running the open-source Convex backend locally on your machine (this is also
+called a "deployment").
+
+The data for your project will be saved in the `~/.convex` directory.
+
+1. The name of your project will get saved to your `.env.local` file so future
+   runs of `npx convex dev` will know to use this project.
+1. A `convex/` folder will be created (if it doesn't exist), where you'll write
+   your Convex backend functions.
+
+You can run `npx convex login` in the future to create an account and link any
+existing projects.
+
+### Developing with an account
+
+`npx convex dev` will prompt you through creating an account if one doesn't
+exist, and will add your credentials to `~/.convex/config.json` on your machine.
+You can run `npx convex logout` to log you machine out of the account in the
+future.
+
+Next, `npx convex dev` will create a new project and provision a new personal
+development deployment for this project:
+
+1.  Deployment details will automatically be added to your `.env.local` file so
+    future runs of `npx convex dev` will know which dev deployment to connect
+    to.
+1.  A `convex/` folder will be created (if it doesn't exist), where you'll write
+    your Convex backend functions.
+
+<div className="center-image" style={{ maxWidth: "149px" }}>
+  ![Convex directory in your app](/img/convex-directory.png)
+</div>
+
+## Running the dev loop
+
+Keep the `npx convex dev` command running while you're working on your Convex
+app. This continuously pushes backend code you write in the `convex/` folder to
+your deployment. It also keeps the necessary TypeScript types up-to-date as you
+write your backend code.
+
+When you're developing with a locally running deployment, `npx convex dev` is
+also responsible for running your deployment.
+
+You can then add new server functions to your Convex backend:
+
+```typescript title="convex/tasks.ts"
+import { query } from "./_generated/server";
+import { v } from "convex/values";
+
+// Return the last 100 tasks in a given task list.
+export const getTaskList = query({
+  args: { taskListId: v.id("taskLists") },
+  handler: async (ctx, args) => {
+    const tasks = await ctx.db
+      .query("tasks")
+      .withIndex("taskListId", (q) => q.eq("taskListId", args.taskListId))
+      .order("desc")
+      .take(100);
+    return tasks;
+  },
+});
+```
+
+When you write and save this code in your editor, several things happen:
+
+1. The `npx convex dev` command typechecks your code and updates the
+   `convex/_generated` directory.
+1. The contents of your `convex/` directory get uploaded to your dev deployment.
+1. Your Convex dev deployment analyzes your code and finds all Convex functions.
+   In this example, it determines that `tasks.getTaskList` is a new public query
+   function.
+1. If there are any changes to the [schema](/database/schemas.mdx), the
+   deployment will automatically enforce them.
+1. The `npx convex dev` command updates generated TypeScript code in the
+   `convex/_generated` directory to provide end to end type safety for your
+   functions.
+
+<Admonition type="tip">
+  Check in everything in your `convex/_generated/` directory. This it ensures
+  that your code immediately type checks and runs without having to first run
+  `npx convex dev`. It's particularly useful when non-backend developers are
+  writing frontend code and want to ensure their code type checks against
+  currently deployed backend code.
+</Admonition>
+
+Once this is done you can use your new server function in your frontend:
+
+```typescript title="src/App.tsx"
+import { useQuery } from "convex/react";
+import { api } from "../convex/_generated/api";
+
+export function App() {
+  const data = useQuery(api.tasks.getTaskList);
+  return data ?? "Loading...";
+}
+```
+
+If you have other configuration like [crons](/scheduling/cron-jobs.mdx) or
+[auth](/auth.mdx) in your `convex/` folder, Convex ensures that they are applied
+and enforced on your backend.
+
+## Convex dashboard
+
+The [Convex dashboard](/dashboard/deployments/deployments.md) will be a trusty
+helper throughout your dev, debug and deploy workflow in Convex.
+
+`npx convex dashboard` will open a link to the dashboard for your deployment.
+
+### Logs
+
+Since Convex functions are TypeScript functions you can always use the standard
+`console.log` and `console.time` functions to debug your apps.
+
+Logs from your functions show up
+[in your dashboard](/dashboard/deployments/logs.md).
+
+![Logs Dashboard Page](/screenshots/logs.png)
+
+### Health, Data, Functions and more
+
+- [Health](/dashboard/deployments/health.md) - provides invaluable information
+  on how your app is performing in production, with deep insights on how your
+  Convex queries are doing.
+- [Data](/dashboard/deployments/data.md) - gives you a complete data browser to
+  spot check your data.
+- [Functions](/dashboard/deployments/functions.md) - gives you stats and run
+  functions to debug them.
+
+There is a lot more to to the dashboard. Be sure to click around or
+[check out the docs](/dashboard.md).
+
+## Deploying your app
+
+So far you've been working on your app against your personal dev deployment.
+
+All Convex projects have one production deployment running in the cloud. It has
+separate data and has a separate push process from personal dev deployments,
+which allows you and your teammates to work on new features using personal dev
+deployments without disrupting your app running in production.
+
+If you have not created a Convex account yet, you will need to do so with
+`npx convex login`. This will automatically link any projects you've started
+with your new account, and enable using your production deployment.
+
+To push your code to your production deployment for your project you run the
+deploy command:
+
+```sh
+npx convex deploy
+```
+
+<Admonition type="info">
+  If you're running this command for the first time, it will automatically
+  provision the prod deployment for your project.
+</Admonition>
+
+### Setting up your deployment pipeline
+
+It's rare to run `npx convex deploy` directly. Most production applications run
+an automated workflow that runs tests and deploys your backend and frontend
+together.
+
+You can see detailed deployment and frontend configuration instructions in the
+[Hosting and Deployment](/production/hosting/hosting.mdx) doc. For most React
+meta-frameworks Convex
+[automatically sets the correct environment variable](/production/hosting/vercel.mdx#how-it-works)
+to connect to the production deployment.
+
+## Up next
+
+You now know the basics of how Convex works and fits in your app. Go head and
+explore the docs further to learn more about the specific features you want to
+use.
+
+Whenever you're ready be sure the read the
+[Best Practices](/understanding/best-practices/best-practices.mdx), and then the
+[Zen of Convex](/understanding/zen.mdx) once you are ready to "think in Convex."
diff --git a/synced/convex/docs/understanding/zen.md b/synced/convex/docs/understanding/zen.md
new file mode 100644
index 0000000..d58f739
--- /dev/null
+++ b/synced/convex/docs/understanding/zen.md
@@ -0,0 +1,269 @@
+---
+title: "The Zen of Convex"
+slug: "zen"
+hidden: false
+sidebar_position: 500
+hide_table_of_contents: true
+---
+
+export function CategoryIcon(props) {
+  switch (props.title) {
+    case "Performance":
+      return (
+        <svg
+          fill="currentColor"
+          viewBox="0 0 24 24"
+          xmlns="http://www.w3.org/2000/svg"
+          aria-hidden="true"
+          {...props}
+        >
+          <path
+            clipRule="evenodd"
+            fillRule="evenodd"
+            d="M14.615 1.595a.75.75 0 01.359.852L12.982 9.75h7.268a.75.75 0 01.548 1.262l-10.5 11.25a.75.75 0 01-1.272-.71l1.992-7.302H3.75a.75.75 0 01-.548-1.262l10.5-11.25a.75.75 0 01.913-.143z"
+          />
+        </svg>
+      );
+    case "Architecture":
+      return (
+        <svg
+          fill="currentColor"
+          viewBox="0 0 24 24"
+          xmlns="http://www.w3.org/2000/svg"
+          aria-hidden="true"
+        >
+          <path d="M11.584 2.376a.75.75 0 01.832 0l9 6a.75.75 0 11-.832 1.248L12 3.901 3.416 9.624a.75.75 0 01-.832-1.248l9-6z" />
+          <path
+            clipRule="evenodd"
+            fillRule="evenodd"
+            d="M20.25 10.332v9.918H21a.75.75 0 010 1.5H3a.75.75 0 010-1.5h.75v-9.918a.75.75 0 01.634-.74A49.109 49.109 0 0112 9c2.59 0 5.134.202 7.616.592a.75.75 0 01.634.74zm-7.5 2.418a.75.75 0 00-1.5 0v6.75a.75.75 0 001.5 0v-6.75zm3-.75a.75.75 0 01.75.75v6.75a.75.75 0 01-1.5 0v-6.75a.75.75 0 01.75-.75zM9 12.75a.75.75 0 00-1.5 0v6.75a.75.75 0 001.5 0v-6.75z"
+          />
+          <path d="M12 7.875a1.125 1.125 0 100-2.25 1.125 1.125 0 000 2.25z" />
+          //{" "}
+        </svg>
+      );
+    case "Development workflow":
+      return (
+        <svg
+          fill="currentColor"
+          viewBox="0 0 24 24"
+          xmlns="http://www.w3.org/2000/svg"
+          aria-hidden="true"
+          {...props}
+        >
+          <path
+            clipRule="evenodd"
+            fillRule="evenodd"
+            d="M2.25 6a3 3 0 013-3h13.5a3 3 0 013 3v12a3 3 0 01-3 3H5.25a3 3 0 01-3-3V6zm3.97.97a.75.75 0 011.06 0l2.25 2.25a.75.75 0 010 1.06l-2.25 2.25a.75.75 0 01-1.06-1.06l1.72-1.72-1.72-1.72a.75.75 0 010-1.06zm4.28 4.28a.75.75 0 000 1.5h3a.75.75 0 000-1.5h-3z"
+          />
+        </svg>
+      );
+    default:
+      return null;
+  }
+}
+
+export function ZenHeader({ title }) {
+  return (
+    <h2 className="zen-header">
+      {title} <CategoryIcon title={title} />
+    </h2>
+  );
+}
+
+export function TipIcon({ type }) {
+  switch (type) {
+    case "do":
+      return (
+        <svg
+          xmlns="http://www.w3.org/2000/svg"
+          viewBox="0 0 24 24"
+          fill="currentColor"
+          className="w-6 h-6"
+        >
+          <path
+            fillRule="evenodd"
+            d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z"
+            clipRule="evenodd"
+          />
+        </svg>
+      );
+    case "do-not":
+      return (
+        <svg
+          xmlns="http://www.w3.org/2000/svg"
+          viewBox="0 0 24 24"
+          fill="currentColor"
+          className="w-6 h-6"
+        >
+          <path
+            fillRule="evenodd"
+            d="M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z"
+            clipRule="evenodd"
+          />
+        </svg>
+      );
+    default:
+      return null;
+  }
+}
+
+export function ZenTip({ type, title, children }) {
+  return (
+    <div className={`zen-tip zen-${type}`}>
+      <h3>
+        <TipIcon type={type} /> {title}
+      </h3>
+      {children}
+    </div>
+  );
+}
+
+<span className="convex-hero">
+Convex is an opinionated framework, with every element designed to pull developers into
+[the pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/).
+
+The Zen of Convex is a set of guidelines & best practices developers have
+discovered that keep their projects falling into this wonderful pit.
+
+</span>
+
+<ZenHeader title="Performance" />
+
+<ZenTip type="do" title={<span>Double down on the <a href="/tutorial#how-convex-works">sync engine</a></span>} >
+
+    There's a reason why a deterministic, reactive database is the beating heart
+    of Convex: the more you center your apps around its properties, the better
+    your projects will fare over time. Your projects will be easier to
+    understand and refactor. Your app's performance will stay screaming fast.
+    You won't have any consistency or state management problems.
+
+<Details summary="Use a query for nearly every app read">
+  Queries are the reactive, automatically cacheable, consistent and resilient
+  way to propagate data to your application and its jobs. With very few
+  exceptions, every read operation in your app should happen via a query
+  function.
+</Details>
+
+<Details summary="Keep sync engine functions light & fast">
+  In general, your mutations and queries should be working with less than a few
+  hundred records and should aim to finish in less than 100ms. It's nearly
+  impossible to maintain a snappy, responsive app if your synchronous
+  transactions involve a lot more work than this.
+</Details>
+
+<Details summary="Use actions sparingly and incrementally">
+  Actions are wonderful for batch jobs and/or integrating with outside services.
+  They're very powerful, but they're slower, more expensive, and Convex provides
+  a lot fewer guarantees about their behavior. So never use an action if a query
+  or mutation will get the job done.
+</Details>
+
+</ZenTip>
+
+<ZenTip type="do-not" title="Don't over-complicate client-side state management">
+
+Convex builds in a ton of its own caching and consistency controls into the
+app's client library. Rather than reinvent the wheel, let your client-side code
+take advantage of these built-in performance boosts.
+
+<Details summary="Let Convex handle caching & consistency">
+
+You might be tempted to quickly build your own local cache or state aggregation
+layer in Convex to sit between your components and your Convex functions. With
+Convex, most of the time, you won't end up needing this. More often than not,
+you can bind your components to Convex functions in pretty simple ways and
+things will Just Work and be plenty fast.
+
+</Details>
+
+<Details summary="Be thoughtful about the return values of mutations">
+  Mutation return values can be useful to trigger state changes in your app, but
+  it's rarely a good idea to use them to set in-app state to update the UI. Let
+  queries and the sync engine do that.
+</Details>
+
+</ZenTip>
+
+<ZenHeader title="Architecture" />
+
+<ZenTip type="do" title='Create server-side frameworks using "just code"'>
+  <p>
+    Convex's built-in primitives are pretty low level! They're just functions.
+    What about authentication frameworks? What about object-relational mappings?
+    Do you need to wait until Convex ships some in-built feature to get those?
+    Nope. In general, you should solve composition and encapsulation problems in
+    your server-side Convex code using the same methods you use for the rest of
+    your TypeScript code bases. After all, this is why Convex is "just code!"
+    [Stack](https://stack.convex.dev) always has
+    [great](https://stack.convex.dev/functional-relationships-helpers)
+    [examples](https://stack.convex.dev/wrappers-as-middleware-authentication)
+    of ways to tackle [these
+    needs](https://stack.convex.dev/row-level-security).
+  </p>
+</ZenTip>
+
+<ZenTip type="do-not" title="Don't misuse actions" >
+
+Actions are powerful, but it's important to be intentional in how they fit into
+your app's data flow.
+
+<Details summary="Don't invoke actions directly from your app">
+  In general, it's an anti-pattern to call actions from the browser. Usually,
+  actions are running on some dependent record that should be living in a Convex
+  table. So it's best trigger actions by invoking a mutation that both _writes_
+  that dependent record and _schedules_ the subsequent action to run in the
+  background.
+</Details>
+
+<Details summary="Don't think 'background jobs', think 'workflow'">
+   When actions are involved, it's useful to write chains of effects and
+   mutations, such as:
+
+action code &rarr; mutation &rarr; more action code &rarr; mutation.
+
+Then apps or other jobs can follow along with queries.
+
+</Details>
+
+<Details summary="Record progress one step at a time">
+  While actions _could_ work with thousands of records and call dozens of APIs,
+  it's normally best to do smaller batches of work and/or to perform individual
+  transformations with outside services. Then record your progress with a
+  mutation, of course. Using this pattern makes it easy to debug issues, resume
+  partial jobs, and report incremental progress in your app's UI.
+</Details>
+
+</ZenTip>
+
+<ZenHeader title="Development workflow" />
+
+<ZenTip type="do" title="Keep the dashboard by your side">
+  <p>
+    Working on your Convex project without using the dashboard is like driving a
+    car with your eyes closed. The dashboard lets you view logs, give
+    mutations/queries/actions a test run, make sure your configuration and
+    codebase are as you expect, inspect your tables, generate schemas, etc. It's
+    an invaluable part of your rapid development cycle.
+  </p>
+</ZenTip>
+
+<ZenTip type="do-not" title="Don't go it alone" >
+
+  <p>
+    Between these [docs](https://docs.convex.dev),
+    [Stack](https://stack.convex.dev), and [our
+    community](https://convex.dev/community), someone has _probably_ encountered
+    the design or architectural issue you're facing. So why try to figure things out the hard way, when you can take advantage of a whole community's experience?
+   </p>
+  
+  <Details summary="Leverage Convex developer search">
+  With so many great resources from the Convex team & community, it can be hard to know where to look first. If you want a quick way to
+    search across all of these, [we have a portal for
+    that](https://search.convex.dev)!
+  </Details>
+   
+  <Details summary="Join the Convex community">
+  Whether you're stuck on a tricky use case, you have a question or feature request for the Convex team, or you're excited to share the amazing app(s) you've built and help others learn, the Convex community is there for you! Join the party on [Discord](https://convex.dev/community).
+  </Details>
+</ZenTip>
diff --git a/synced/convex/docs/urls.ts b/synced/convex/docs/urls.ts
new file mode 100644
index 0000000..d9c5ba3
--- /dev/null
+++ b/synced/convex/docs/urls.ts
@@ -0,0 +1,22 @@
+export function dashboardUrl(): string | undefined {
+  if (window.location.hostname === "docs.convex.dev") {
+    return undefined;
+  }
+  if (window.location.hostname === "localhost") {
+    return `http://localhost:3000`;
+  }
+  return `https://${window.location.hostname}`;
+}
+
+export function gitUrl() {
+  if (
+    window.location.hostname === "docs.convex.dev" ||
+    window.location.hostname === "localhost"
+  ) {
+    return "https://github.com/get-convex/convex-demos.git";
+  }
+  return `https://${window.location.hostname.replace(
+    "-docs.",
+    ".",
+  )}/convex-demos.git`;
+}
