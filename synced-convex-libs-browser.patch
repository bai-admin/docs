diff --git a/synced/convex/libs/browser/http_client.test.ts b/synced/convex/libs/browser/http_client.test.ts
new file mode 100644
index 0000000..f31af31
--- /dev/null
+++ b/synced/convex/libs/browser/http_client.test.ts
@@ -0,0 +1,174 @@
+import { test, expect, afterEach, vi } from "vitest";
+import { ConvexHttpClient, setFetch } from "./http_client.js";
+import { makeFunctionReference } from "../server/index.js";
+
+const apiMutationFunc = makeFunctionReference<
+  "mutation",
+  { value: string },
+  string
+>("test:mutation");
+
+afterEach(() => {
+  setFetch(globalThis.fetch);
+});
+
+test("mutation queue processes mutations sequentially", async () => {
+  const client = new ConvexHttpClient("http://test");
+
+  // Mock fetch to simulate network delays
+  const fetchMock = vi.fn();
+  let resolveFirst: (value: any) => void;
+  let resolveSecond: (value: any) => void;
+
+  fetchMock.mockImplementation((url, options) => {
+    const body = JSON.parse(options.body);
+    if (body.path === "test:mutation" && body.args[0].value === "first") {
+      return new Promise((resolve) => {
+        resolveFirst = resolve;
+      });
+    }
+    if (body.path === "test:mutation" && body.args[0].value === "second") {
+      return new Promise((resolve) => {
+        resolveSecond = resolve;
+      });
+    }
+    return Promise.reject(new Error("Unexpected mutation"));
+  });
+
+  setFetch(fetchMock);
+
+  // Start two queued mutations
+  const firstPromise = client.mutation(apiMutationFunc, { value: "first" });
+  const secondPromise = client.mutation(apiMutationFunc, { value: "second" });
+
+  // Verify first mutation started but second hasn't
+  expect(fetchMock).toHaveBeenCalledTimes(1);
+  expect(JSON.parse(fetchMock.mock.calls[0][1].body).args[0].value).toBe(
+    "first",
+  );
+
+  // Resolve first mutation
+  resolveFirst!({
+    ok: true,
+    json: () => Promise.resolve({ status: "success", value: "first result" }),
+  });
+  await new Promise((resolve) => setTimeout(resolve, 0));
+
+  // Verify second mutation started
+  expect(fetchMock).toHaveBeenCalledTimes(2);
+  expect(JSON.parse(fetchMock.mock.calls[1][1].body).args[0].value).toBe(
+    "second",
+  );
+
+  // Resolve second mutation
+  resolveSecond!({
+    ok: true,
+    json: () => Promise.resolve({ status: "success", value: "second result" }),
+  });
+
+  // Verify both promises resolve
+  await expect(firstPromise).resolves.toBe("first result");
+  await expect(secondPromise).resolves.toBe("second result");
+});
+
+test("unqueued mutations skip the queue", async () => {
+  const client = new ConvexHttpClient("http://test");
+
+  const fetchMock = vi.fn();
+  let resolveQueued: (value: any) => void;
+
+  fetchMock.mockImplementation((url, options) => {
+    const body = JSON.parse(options.body);
+    if (body.path === "test:mutation" && body.args[0].value === "queued") {
+      return new Promise((resolve) => {
+        resolveQueued = resolve;
+      });
+    }
+    if (body.path === "test:mutation" && body.args[0].value === "unqueued") {
+      return Promise.resolve({
+        ok: true,
+        json: () =>
+          Promise.resolve({ status: "success", value: "unqueued result" }),
+      });
+    }
+    return Promise.reject(new Error("Unexpected mutation"));
+  });
+
+  setFetch(fetchMock);
+
+  // Start a queued mutation
+  const queuedPromise = client.mutation(apiMutationFunc, { value: "queued" });
+  expect(fetchMock).toHaveBeenCalledTimes(1);
+
+  // Start an unqueued mutation while first is still running
+  const unqueuedPromise = client.mutation(
+    apiMutationFunc,
+    { value: "unqueued" },
+    { skipQueue: true },
+  );
+  await new Promise((resolve) => setTimeout(resolve, 0));
+
+  // Verify both mutations started immediately
+  expect(fetchMock).toHaveBeenCalledTimes(2);
+
+  // Resolve the queued mutation
+  resolveQueued!({
+    ok: true,
+    json: () => Promise.resolve({ status: "success", value: "queued result" }),
+  });
+
+  // Verify both promises resolve
+  await expect(queuedPromise).resolves.toBe("queued result");
+  await expect(unqueuedPromise).resolves.toBe("unqueued result");
+});
+
+test("failed mutations don't block the queue", async () => {
+  const client = new ConvexHttpClient("http://test");
+
+  const fetchMock = vi.fn();
+  let resolveSecond: (value: any) => void;
+
+  fetchMock.mockImplementation((url, options) => {
+    const body = JSON.parse(options.body);
+    if (body.path === "test:mutation" && body.args[0].value === "first") {
+      return Promise.resolve({
+        ok: true,
+        json: () =>
+          Promise.resolve({
+            status: "error",
+            errorMessage: "First mutation failed",
+          }),
+      });
+    }
+    if (body.path === "test:mutation" && body.args[0].value === "second") {
+      return new Promise((resolve) => {
+        resolveSecond = resolve;
+      });
+    }
+    return Promise.reject(new Error("Unexpected mutation"));
+  });
+
+  setFetch(fetchMock);
+
+  // Start two queued mutations
+  const firstPromise = client.mutation(apiMutationFunc, { value: "first" });
+  const secondPromise = client.mutation(apiMutationFunc, { value: "second" });
+
+  await expect(firstPromise).rejects.toThrow("First mutation failed");
+
+  // First mutation failed, second should start
+  expect(fetchMock).toHaveBeenCalledTimes(2);
+  expect(JSON.parse(fetchMock.mock.calls[1][1].body).args[0].value).toBe(
+    "second",
+  );
+
+  // Resolve second mutation
+  resolveSecond!({
+    ok: true,
+    json: () => Promise.resolve({ status: "success", value: "second result" }),
+  });
+
+  // Verify first promise rejects and second resolves
+  await expect(firstPromise).rejects.toThrow("First mutation failed");
+  await expect(secondPromise).resolves.toBe("second result");
+});
diff --git a/synced/convex/libs/browser/http_client.ts b/synced/convex/libs/browser/http_client.ts
new file mode 100644
index 0000000..b92ac4a
--- /dev/null
+++ b/synced/convex/libs/browser/http_client.ts
@@ -0,0 +1,572 @@
+import {
+  FunctionReference,
+  FunctionReturnType,
+  OptionalRestArgs,
+  getFunctionName,
+} from "../server/api.js";
+import { parseArgs, validateDeploymentUrl } from "../common/index.js";
+import { version } from "../index.js";
+import {
+  ConvexError,
+  JSONValue,
+  convexToJson,
+  jsonToConvex,
+} from "../values/index.js";
+import {
+  instantiateDefaultLogger,
+  instantiateNoopLogger,
+  logForFunction,
+  Logger,
+} from "./logging.js";
+import {
+  ArgsAndOptions,
+  FunctionArgs,
+  UserIdentityAttributes,
+} from "../server/index.js";
+
+export const STATUS_CODE_OK = 200;
+export const STATUS_CODE_BAD_REQUEST = 400;
+// Special custom 5xx HTTP status code to mean that the UDF returned an error.
+//
+// Must match the constant of the same name in the backend.
+export const STATUS_CODE_UDF_FAILED = 560;
+
+// Allow fetch to be shimmed in for Node.js < 18
+let specifiedFetch: typeof globalThis.fetch | undefined = undefined;
+export function setFetch(f: typeof globalThis.fetch) {
+  specifiedFetch = f;
+}
+
+export type HttpMutationOptions = {
+  /**
+   * Skip the default queue of mutations and run this immediately.
+   *
+   * This allows the same HttpConvexClient to be used to request multiple
+   * mutations in parallel, something not possible with WebSocket-based clients.
+   */
+  skipQueue: boolean;
+};
+
+/**
+ * A Convex client that runs queries and mutations over HTTP.
+ *
+ * This client is stateful (it has user credentials and queues mutations)
+ * so take care to avoid sharing it between requests in a server.
+ *
+ * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive
+ * webapps.
+ *
+ * @public
+ */
+export class ConvexHttpClient {
+  private readonly address: string;
+  private auth?: string;
+  private adminAuth?: string;
+  private encodedTsPromise?: Promise<string>;
+  private debug: boolean;
+  private fetchOptions?: FetchOptions;
+  private logger: Logger;
+  private mutationQueue: Array<{
+    mutation: FunctionReference<"mutation">;
+    args: FunctionArgs<any>;
+    resolve: (value: any) => void;
+    reject: (error: any) => void;
+  }> = [];
+  private isProcessingQueue: boolean = false;
+
+  /**
+   * Create a new {@link ConvexHttpClient}.
+   *
+   * @param address - The url of your Convex deployment, often provided
+   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
+   * @param options - An object of options.
+   * - `skipConvexDeploymentUrlCheck` - Skip validating that the Convex deployment URL looks like
+   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted
+   * Convex backend that uses a different URL.
+   * - `logger` - A logger or a boolean. If not provided, logs to the console.
+   * You can construct your own logger to customize logging to log elsewhere
+   * or not log at all, or use `false` as a shorthand for a no-op logger.
+   * - `auth` - A JWT containing identity claims accessible in Convex functions.
+   * This identity may expire so it may be necessary to call `setAuth()` later,
+   * but for short-lived clients it's convenient to specify this value here.
+   */
+  constructor(
+    address: string,
+    options?: {
+      skipConvexDeploymentUrlCheck?: boolean;
+      logger?: Logger | boolean;
+      auth?: string;
+    },
+  ) {
+    if (typeof options === "boolean") {
+      throw new Error(
+        "skipConvexDeploymentUrlCheck as the second argument is no longer supported. Please pass an options object, `{ skipConvexDeploymentUrlCheck: true }`.",
+      );
+    }
+    const opts = options ?? {};
+    if (opts.skipConvexDeploymentUrlCheck !== true) {
+      validateDeploymentUrl(address);
+    }
+    this.logger =
+      options?.logger === false
+        ? instantiateNoopLogger({ verbose: false })
+        : options?.logger !== true && options?.logger
+          ? options.logger
+          : instantiateDefaultLogger({ verbose: false });
+    this.address = address;
+    this.debug = true;
+  }
+
+  /**
+   * Obtain the {@link ConvexHttpClient}'s URL to its backend.
+   * @deprecated Use url, which returns the url without /api at the end.
+   *
+   * @returns The URL to the Convex backend, including the client's API version.
+   */
+  backendUrl(): string {
+    return `${this.address}/api`;
+  }
+
+  /**
+   * Return the address for this client, useful for creating a new client.
+   *
+   * Not guaranteed to match the address with which this client was constructed:
+   * it may be canonicalized.
+   */
+  get url() {
+    return this.address;
+  }
+
+  /**
+   * Set the authentication token to be used for subsequent queries and mutations.
+   *
+   * Should be called whenever the token changes (i.e. due to expiration and refresh).
+   *
+   * @param value - JWT-encoded OpenID Connect identity token.
+   */
+  setAuth(value: string) {
+    this.clearAuth();
+    this.auth = value;
+  }
+
+  /**
+   * Set admin auth token to allow calling internal queries, mutations, and actions
+   * and acting as an identity.
+   *
+   * @internal
+   */
+  setAdminAuth(token: string, actingAsIdentity?: UserIdentityAttributes) {
+    this.clearAuth();
+    if (actingAsIdentity !== undefined) {
+      // Encode the identity to a base64 string
+      const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));
+      const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));
+      this.adminAuth = `${token}:${actingAsIdentityEncoded}`;
+    } else {
+      this.adminAuth = token;
+    }
+  }
+
+  /**
+   * Clear the current authentication token if set.
+   */
+  clearAuth() {
+    this.auth = undefined;
+    this.adminAuth = undefined;
+  }
+
+  /**
+   * Sets whether the result log lines should be printed on the console or not.
+   *
+   * @internal
+   */
+  setDebug(debug: boolean) {
+    this.debug = debug;
+  }
+
+  /**
+   * Used to customize the fetch behavior in some runtimes.
+   *
+   * @internal
+   */
+  setFetchOptions(fetchOptions: FetchOptions) {
+    this.fetchOptions = fetchOptions;
+  }
+
+  /**
+   * This API is experimental: it may change or disappear.
+   *
+   * Execute a Convex query function at the same timestamp as every other
+   * consistent query execution run by this HTTP client.
+   *
+   * This doesn't make sense for long-lived ConvexHttpClients as Convex
+   * backends can read a limited amount into the past: beyond 30 seconds
+   * in the past may not be available.
+   *
+   * Create a new client to use a consistent time.
+   *
+   * @param name - The name of the query.
+   * @param args - The arguments object for the query. If this is omitted,
+   * the arguments will be `{}`.
+   * @returns A promise of the query's result.
+   *
+   * @deprecated This API is experimental: it may change or disappear.
+   */
+  async consistentQuery<Query extends FunctionReference<"query">>(
+    query: Query,
+    ...args: OptionalRestArgs<Query>
+  ): Promise<FunctionReturnType<Query>> {
+    const queryArgs = parseArgs(args[0]);
+
+    const timestampPromise = this.getTimestamp();
+    return await this.queryInner(query, queryArgs, { timestampPromise });
+  }
+
+  private async getTimestamp() {
+    if (this.encodedTsPromise) {
+      return this.encodedTsPromise;
+    }
+    return (this.encodedTsPromise = this.getTimestampInner());
+  }
+
+  private async getTimestampInner() {
+    const localFetch = specifiedFetch || fetch;
+
+    const headers: Record<string, string> = {
+      "Content-Type": "application/json",
+      "Convex-Client": `npm-${version}`,
+    };
+    const response = await localFetch(`${this.address}/api/query_ts`, {
+      ...this.fetchOptions,
+      method: "POST",
+      headers: headers,
+    });
+    if (!response.ok) {
+      throw new Error(await response.text());
+    }
+    const { ts } = (await response.json()) as { ts: string };
+    return ts;
+  }
+
+  /**
+   * Execute a Convex query function.
+   *
+   * @param name - The name of the query.
+   * @param args - The arguments object for the query. If this is omitted,
+   * the arguments will be `{}`.
+   * @returns A promise of the query's result.
+   */
+  async query<Query extends FunctionReference<"query">>(
+    query: Query,
+    ...args: OptionalRestArgs<Query>
+  ): Promise<FunctionReturnType<Query>> {
+    const queryArgs = parseArgs(args[0]);
+    return await this.queryInner(query, queryArgs, {});
+  }
+
+  private async queryInner<Query extends FunctionReference<"query">>(
+    query: Query,
+    queryArgs: FunctionArgs<Query>,
+    options: { timestampPromise?: Promise<string> },
+  ): Promise<FunctionReturnType<Query>> {
+    const name = getFunctionName(query);
+    const args = [convexToJson(queryArgs)];
+    const headers: Record<string, string> = {
+      "Content-Type": "application/json",
+      "Convex-Client": `npm-${version}`,
+    };
+    if (this.adminAuth) {
+      headers["Authorization"] = `Convex ${this.adminAuth}`;
+    } else if (this.auth) {
+      headers["Authorization"] = `Bearer ${this.auth}`;
+    }
+    const localFetch = specifiedFetch || fetch;
+
+    const timestamp = options.timestampPromise
+      ? await options.timestampPromise
+      : undefined;
+
+    const body = JSON.stringify({
+      path: name,
+      format: "convex_encoded_json",
+      args,
+      ...(timestamp ? { ts: timestamp } : {}),
+    });
+    const endpoint = timestamp
+      ? `${this.address}/api/query_at_ts`
+      : `${this.address}/api/query`;
+
+    const response = await localFetch(endpoint, {
+      ...this.fetchOptions,
+      body,
+      method: "POST",
+      headers: headers,
+    });
+    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
+      throw new Error(await response.text());
+    }
+    const respJSON = await response.json();
+
+    if (this.debug) {
+      for (const line of respJSON.logLines ?? []) {
+        logForFunction(this.logger, "info", "query", name, line);
+      }
+    }
+    switch (respJSON.status) {
+      case "success":
+        return jsonToConvex(respJSON.value);
+      case "error":
+        if (respJSON.errorData !== undefined) {
+          throw forwardErrorData(
+            respJSON.errorData,
+            new ConvexError(respJSON.errorMessage),
+          );
+        }
+        throw new Error(respJSON.errorMessage);
+      default:
+        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
+    }
+  }
+
+  private async mutationInner<Mutation extends FunctionReference<"mutation">>(
+    mutation: Mutation,
+    mutationArgs: FunctionArgs<Mutation>,
+  ): Promise<FunctionReturnType<Mutation>> {
+    const name = getFunctionName(mutation);
+    const body = JSON.stringify({
+      path: name,
+      format: "convex_encoded_json",
+      args: [convexToJson(mutationArgs)],
+    });
+    const headers: Record<string, string> = {
+      "Content-Type": "application/json",
+      "Convex-Client": `npm-${version}`,
+    };
+    if (this.adminAuth) {
+      headers["Authorization"] = `Convex ${this.adminAuth}`;
+    } else if (this.auth) {
+      headers["Authorization"] = `Bearer ${this.auth}`;
+    }
+    const localFetch = specifiedFetch || fetch;
+    const response = await localFetch(`${this.address}/api/mutation`, {
+      ...this.fetchOptions,
+      body,
+      method: "POST",
+      headers: headers,
+    });
+    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
+      throw new Error(await response.text());
+    }
+    const respJSON = await response.json();
+    if (this.debug) {
+      for (const line of respJSON.logLines ?? []) {
+        logForFunction(this.logger, "info", "mutation", name, line);
+      }
+    }
+    switch (respJSON.status) {
+      case "success":
+        return jsonToConvex(respJSON.value);
+      case "error":
+        if (respJSON.errorData !== undefined) {
+          throw forwardErrorData(
+            respJSON.errorData,
+            new ConvexError(respJSON.errorMessage),
+          );
+        }
+        throw new Error(respJSON.errorMessage);
+      default:
+        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
+    }
+  }
+
+  private async processMutationQueue() {
+    if (this.isProcessingQueue) {
+      return;
+    }
+
+    this.isProcessingQueue = true;
+    while (this.mutationQueue.length > 0) {
+      const { mutation, args, resolve, reject } = this.mutationQueue.shift()!;
+      try {
+        const result = await this.mutationInner(mutation, args);
+        resolve(result);
+      } catch (error) {
+        reject(error);
+      }
+    }
+    this.isProcessingQueue = false;
+  }
+
+  private enqueueMutation<Mutation extends FunctionReference<"mutation">>(
+    mutation: Mutation,
+    args: FunctionArgs<Mutation>,
+  ): Promise<FunctionReturnType<Mutation>> {
+    return new Promise((resolve, reject) => {
+      this.mutationQueue.push({ mutation, args, resolve, reject });
+      void this.processMutationQueue();
+    });
+  }
+
+  /**
+   * Execute a Convex mutation function. Mutations are queued by default.
+   *
+   * @param name - The name of the mutation.
+   * @param args - The arguments object for the mutation. If this is omitted,
+   * the arguments will be `{}`.
+   * @param options - An optional object containing
+   * @returns A promise of the mutation's result.
+   */
+  async mutation<Mutation extends FunctionReference<"mutation">>(
+    mutation: Mutation,
+    ...args: ArgsAndOptions<Mutation, HttpMutationOptions>
+  ): Promise<FunctionReturnType<Mutation>> {
+    const [fnArgs, options] = args;
+    const mutationArgs = parseArgs(fnArgs);
+    const queued = !options?.skipQueue;
+
+    if (queued) {
+      return await this.enqueueMutation(mutation, mutationArgs);
+    } else {
+      return await this.mutationInner(mutation, mutationArgs);
+    }
+  }
+
+  /**
+   * Execute a Convex action function. Actions are not queued.
+   *
+   * @param name - The name of the action.
+   * @param args - The arguments object for the action. If this is omitted,
+   * the arguments will be `{}`.
+   * @returns A promise of the action's result.
+   */
+  async action<Action extends FunctionReference<"action">>(
+    action: Action,
+    ...args: OptionalRestArgs<Action>
+  ): Promise<FunctionReturnType<Action>> {
+    const actionArgs = parseArgs(args[0]);
+    const name = getFunctionName(action);
+    const body = JSON.stringify({
+      path: name,
+      format: "convex_encoded_json",
+      args: [convexToJson(actionArgs)],
+    });
+    const headers: Record<string, string> = {
+      "Content-Type": "application/json",
+      "Convex-Client": `npm-${version}`,
+    };
+    if (this.adminAuth) {
+      headers["Authorization"] = `Convex ${this.adminAuth}`;
+    } else if (this.auth) {
+      headers["Authorization"] = `Bearer ${this.auth}`;
+    }
+    const localFetch = specifiedFetch || fetch;
+    const response = await localFetch(`${this.address}/api/action`, {
+      ...this.fetchOptions,
+      body,
+      method: "POST",
+      headers: headers,
+    });
+    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
+      throw new Error(await response.text());
+    }
+    const respJSON = await response.json();
+    if (this.debug) {
+      for (const line of respJSON.logLines ?? []) {
+        logForFunction(this.logger, "info", "action", name, line);
+      }
+    }
+    switch (respJSON.status) {
+      case "success":
+        return jsonToConvex(respJSON.value);
+      case "error":
+        if (respJSON.errorData !== undefined) {
+          throw forwardErrorData(
+            respJSON.errorData,
+            new ConvexError(respJSON.errorMessage),
+          );
+        }
+        throw new Error(respJSON.errorMessage);
+      default:
+        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
+    }
+  }
+
+  /**
+   * Execute a Convex function of an unknown type. These function calls are not queued.
+   *
+   * @param name - The name of the function.
+   * @param args - The arguments object for the function. If this is omitted,
+   * the arguments will be `{}`.
+   * @returns A promise of the function's result.
+   *
+   * @internal
+   */
+  async function<
+    AnyFunction extends FunctionReference<"query" | "mutation" | "action">,
+  >(
+    anyFunction: AnyFunction | string,
+    componentPath?: string,
+    ...args: OptionalRestArgs<AnyFunction>
+  ): Promise<FunctionReturnType<AnyFunction>> {
+    const functionArgs = parseArgs(args[0]);
+    const name =
+      typeof anyFunction === "string"
+        ? anyFunction
+        : getFunctionName(anyFunction);
+    const body = JSON.stringify({
+      componentPath: componentPath,
+      path: name,
+      format: "convex_encoded_json",
+      args: convexToJson(functionArgs),
+    });
+    const headers: Record<string, string> = {
+      "Content-Type": "application/json",
+      "Convex-Client": `npm-${version}`,
+    };
+    if (this.adminAuth) {
+      headers["Authorization"] = `Convex ${this.adminAuth}`;
+    } else if (this.auth) {
+      headers["Authorization"] = `Bearer ${this.auth}`;
+    }
+    const localFetch = specifiedFetch || fetch;
+    const response = await localFetch(`${this.address}/api/function`, {
+      ...this.fetchOptions,
+      body,
+      method: "POST",
+      headers: headers,
+    });
+    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {
+      throw new Error(await response.text());
+    }
+    const respJSON = await response.json();
+    if (this.debug) {
+      for (const line of respJSON.logLines ?? []) {
+        logForFunction(this.logger, "info", "any", name, line);
+      }
+    }
+    switch (respJSON.status) {
+      case "success":
+        return jsonToConvex(respJSON.value);
+      case "error":
+        if (respJSON.errorData !== undefined) {
+          throw forwardErrorData(
+            respJSON.errorData,
+            new ConvexError(respJSON.errorMessage),
+          );
+        }
+        throw new Error(respJSON.errorMessage);
+      default:
+        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
+    }
+  }
+}
+
+function forwardErrorData(errorData: JSONValue, error: ConvexError<string>) {
+  (error as ConvexError<any>).data = jsonToConvex(errorData);
+  return error;
+}
+
+/**
+ * @internal
+ */
+type FetchOptions = { cache: "force-cache" | "no-store" };
diff --git a/synced/convex/libs/browser/index.ts b/synced/convex/libs/browser/index.ts
new file mode 100644
index 0000000..0391f3b
--- /dev/null
+++ b/synced/convex/libs/browser/index.ts
@@ -0,0 +1,37 @@
+/**
+ * Tools for accessing Convex in the browser.
+ *
+ * **If you are using React, use the {@link react} module instead.**
+ *
+ * ## Usage
+ *
+ * Create a {@link ConvexHttpClient} to connect to the Convex Cloud.
+ *
+ * ```typescript
+ * import { ConvexHttpClient } from "convex/browser";
+ * // typically loaded from an environment variable
+ * const address = "https://small-mouse-123.convex.cloud";
+ * const convex = new ConvexHttpClient(address);
+ * ```
+ *
+ * @module
+ */
+export { BaseConvexClient } from "./sync/client.js";
+export type {
+  BaseConvexClientOptions,
+  MutationOptions,
+  SubscribeOptions,
+  ConnectionState,
+} from "./sync/client.js";
+export type { ConvexClientOptions } from "./simple_client.js";
+export { ConvexClient } from "./simple_client.js";
+export type {
+  OptimisticUpdate,
+  OptimisticLocalStore,
+} from "./sync/optimistic_updates.js";
+export type { QueryToken } from "./sync/udf_path_utils.js";
+export { ConvexHttpClient } from "./http_client.js";
+export type { QueryJournal } from "./sync/protocol.js";
+/** @internal */
+export type { UserIdentityAttributes } from "./sync/protocol.js";
+export type { FunctionResult } from "./sync/function_result.js";
diff --git a/synced/convex/libs/browser/logging.ts b/synced/convex/libs/browser/logging.ts
new file mode 100644
index 0000000..f4f701b
--- /dev/null
+++ b/synced/convex/libs/browser/logging.ts
@@ -0,0 +1,167 @@
+/* eslint-disable no-console */ // This is the one file where we can `console.log` for the default logger implementation.
+import { ConvexError, Value } from "../values/index.js";
+import { FunctionFailure } from "./sync/function_result.js";
+
+// This is blue #9 from https://www.radix-ui.com/docs/colors/palette-composition/the-scales
+// It must look good in both light and dark mode.
+const INFO_COLOR = "color:rgb(0, 145, 255)";
+
+export type UdfType = "query" | "mutation" | "action" | "any";
+
+function prefix_for_source(source: UdfType) {
+  switch (source) {
+    case "query":
+      return "Q";
+    case "mutation":
+      return "M";
+    case "action":
+      return "A";
+    case "any":
+      return "?";
+  }
+}
+
+export type LogLevel = "debug" | "info" | "warn" | "error";
+
+/**
+ * A logger that can be used to log messages. By default, this is a wrapper
+ * around `console`, but can be configured to not log at all or to log somewhere
+ * else.
+ */
+export class Logger {
+  private _onLogLineFuncs: Record<
+    string,
+    (level: LogLevel, ...args: any[]) => void
+  >;
+  private _verbose: boolean;
+
+  constructor(options: { verbose: boolean }) {
+    this._onLogLineFuncs = {};
+    this._verbose = options.verbose;
+  }
+
+  addLogLineListener(
+    func: (level: LogLevel, ...args: any[]) => void,
+  ): () => void {
+    let id = Math.random().toString(36).substring(2, 15);
+    for (let i = 0; i < 10; i++) {
+      if (this._onLogLineFuncs[id] === undefined) {
+        break;
+      }
+      id = Math.random().toString(36).substring(2, 15);
+    }
+    this._onLogLineFuncs[id] = func;
+    return () => {
+      delete this._onLogLineFuncs[id];
+    };
+  }
+
+  logVerbose(...args: any[]) {
+    if (this._verbose) {
+      for (const func of Object.values(this._onLogLineFuncs)) {
+        func("debug", `${new Date().toISOString()}`, ...args);
+      }
+    }
+  }
+
+  log(...args: any[]) {
+    for (const func of Object.values(this._onLogLineFuncs)) {
+      func("info", ...args);
+    }
+  }
+
+  warn(...args: any[]) {
+    for (const func of Object.values(this._onLogLineFuncs)) {
+      func("warn", ...args);
+    }
+  }
+
+  error(...args: any[]) {
+    for (const func of Object.values(this._onLogLineFuncs)) {
+      func("error", ...args);
+    }
+  }
+}
+
+export function instantiateDefaultLogger(options: {
+  verbose: boolean;
+}): Logger {
+  const logger = new Logger(options);
+  logger.addLogLineListener((level, ...args) => {
+    switch (level) {
+      case "debug":
+        console.debug(...args);
+        break;
+      case "info":
+        console.log(...args);
+        break;
+      case "warn":
+        console.warn(...args);
+        break;
+      case "error":
+        console.error(...args);
+        break;
+      default: {
+        const _typecheck: never = level;
+        console.log(...args);
+      }
+    }
+  });
+  return logger;
+}
+
+export function instantiateNoopLogger(options: { verbose: boolean }): Logger {
+  return new Logger(options);
+}
+
+export function logForFunction(
+  logger: Logger,
+  type: "info" | "error",
+  source: UdfType,
+  udfPath: string,
+  message: string | { errorData: Value },
+) {
+  const prefix = prefix_for_source(source);
+
+  if (typeof message === "object") {
+    message = `ConvexError ${JSON.stringify(message.errorData, null, 2)}`;
+  }
+  if (type === "info") {
+    const match = message.match(/^\[.*?\] /);
+    if (match === null) {
+      logger.error(
+        `[CONVEX ${prefix}(${udfPath})] Could not parse console.log`,
+      );
+      return;
+    }
+    const level = message.slice(1, match[0].length - 2);
+    const args = message.slice(match[0].length);
+
+    logger.log(`%c[CONVEX ${prefix}(${udfPath})] [${level}]`, INFO_COLOR, args);
+  } else {
+    logger.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
+  }
+}
+
+export function logFatalError(logger: Logger, message: string): Error {
+  const errorMessage = `[CONVEX FATAL ERROR] ${message}`;
+  logger.error(errorMessage);
+  return new Error(errorMessage);
+}
+
+export function createHybridErrorStacktrace(
+  source: UdfType,
+  udfPath: string,
+  result: FunctionFailure,
+): string {
+  const prefix = prefix_for_source(source);
+  return `[CONVEX ${prefix}(${udfPath})] ${result.errorMessage}\n  Called by client`;
+}
+
+export function forwardData(
+  result: FunctionFailure,
+  error: ConvexError<string>,
+) {
+  (error as ConvexError<any>).data = result.errorData;
+  return error;
+}
diff --git a/synced/convex/libs/browser/long.ts b/synced/convex/libs/browser/long.ts
new file mode 100644
index 0000000..5df8531
--- /dev/null
+++ b/synced/convex/libs/browser/long.ts
@@ -0,0 +1,307 @@
+// Implements an unsigned long.
+// This is a subset of https://github.com/dcodeIO/Long.js,
+// vendored to decrease bundle size.
+// Copyright Daniel Wirtz <dcode@dcode.io>
+// License: Apache Version 2.0
+/*
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2023 Daniel Wirtz <dcode@dcode.io>
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+// This works... but don't try to compare one to a real Long.js Long!
+// For internal use only.
+// `| 0` assures the runtime that we are using integer arithmetic
+export class Long {
+  low: number;
+  high: number;
+  __isUnsignedLong__: boolean;
+
+  static isLong(obj: Long) {
+    return (obj && obj.__isUnsignedLong__) === true;
+  }
+
+  constructor(low: number, high: number) {
+    this.low = low | 0;
+    this.high = high | 0;
+    this.__isUnsignedLong__ = true;
+  }
+
+  // prettier-ignore
+  static fromBytesLE(bytes: number[]): Long {
+    return new Long(
+      bytes[0] |
+      bytes[1] << 8 |
+      bytes[2] << 16 |
+      bytes[3] << 24,
+      bytes[4] |
+      bytes[5] << 8 |
+      bytes[6] << 16 |
+      bytes[7] << 24,
+    );
+  }
+
+  // prettier-ignore
+  toBytesLE() {
+    const hi = this.high;
+    const lo = this.low;
+    return [
+      lo & 0xff,
+      lo >>> 8 & 0xff,
+      lo >>> 16 & 0xff,
+      lo >>> 24,
+      hi & 0xff,
+      hi >>> 8 & 0xff,
+      hi >>> 16 & 0xff,
+      hi >>> 24
+    ];
+  }
+
+  static fromNumber(value: number) {
+    if (isNaN(value)) return UZERO;
+    if (value < 0) return UZERO;
+    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
+    return new Long(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0);
+  }
+
+  toString() {
+    return (
+      BigInt(this.high) * BigInt(TWO_PWR_32_DBL) +
+      BigInt(this.low)
+    ).toString();
+  }
+
+  equals(other: Long) {
+    if (!Long.isLong(other)) other = Long.fromValue(other);
+    if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
+    return this.high === other.high && this.low === other.low;
+  }
+
+  notEquals(other: Long) {
+    return !this.equals(other);
+  }
+
+  comp(other: Long) {
+    if (!Long.isLong(other)) other = Long.fromValue(other);
+    if (this.equals(other)) return 0;
+    return other.high >>> 0 > this.high >>> 0 ||
+      (other.high === this.high && other.low >>> 0 > this.low >>> 0)
+      ? -1
+      : 1;
+  }
+
+  lessThanOrEqual(other: Long) {
+    return this.comp(/* validates */ other) <= 0;
+  }
+
+  static fromValue(val: any) {
+    if (typeof val === "number") return Long.fromNumber(val);
+    // Throws for non-objects, converts non-instanceof Long:
+    return new Long(val.low, val.high);
+  }
+}
+
+const UZERO = new Long(0, 0);
+const TWO_PWR_16_DBL = 1 << 16;
+const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
+const TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
+const MAX_UNSIGNED_VALUE = new Long(0xffffffff | 0, 0xffffffff | 0);
diff --git a/synced/convex/libs/browser/simple_client-node.ts b/synced/convex/libs/browser/simple_client-node.ts
new file mode 100644
index 0000000..fe496fb
--- /dev/null
+++ b/synced/convex/libs/browser/simple_client-node.ts
@@ -0,0 +1,13 @@
+import {
+  ConvexClient,
+  setDefaultWebSocketConstructor,
+} from "./simple_client.js";
+
+// This file is compiled with `bundle: true` with an exception for
+// `./simple_client.js` so this "ws" import will be inlined.
+import ws from "ws";
+const nodeWebSocket = ws as unknown as typeof WebSocket;
+
+setDefaultWebSocketConstructor(nodeWebSocket);
+
+export { ConvexClient };
diff --git a/synced/convex/libs/browser/simple_client.test.ts b/synced/convex/libs/browser/simple_client.test.ts
new file mode 100644
index 0000000..1e95a70
--- /dev/null
+++ b/synced/convex/libs/browser/simple_client.test.ts
@@ -0,0 +1,104 @@
+import { test, expect } from "vitest";
+import { withInMemoryWebSocket } from "./sync/client_node_test_helpers.js";
+import {
+  DefaultFunctionArgs,
+  getFunctionName,
+  makeFunctionReference,
+} from "../server/index.js";
+// This Node.js build sets up the WebSocket dependency automatically.
+import { ConvexClient } from "./simple_client-node.js";
+
+const apiQueryFunc = makeFunctionReference<
+  "query",
+  DefaultFunctionArgs,
+  string
+>("jeans style");
+const apiMutationFunc = makeFunctionReference<
+  "mutation",
+  DefaultFunctionArgs,
+  string
+>("jeans style");
+
+test("Subscriptions are deduplicated", async () => {
+  // The actual implementation of this dedupliation logic is in BaseConvexClient.
+  await withInMemoryWebSocket(async ({ address, receive }) => {
+    const client = new ConvexClient(address, {
+      unsavedChangesWarning: false,
+    });
+    expect((await receive()).type).toEqual("Connect");
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+
+    const { unsubscribe: unsub1 } = client.onUpdate(
+      apiQueryFunc,
+      {},
+      () => null,
+    );
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+
+    // The second subscribe to the same query should not send another query request.
+    const { unsubscribe: unsub2 } = client.onUpdate(
+      apiQueryFunc,
+      {},
+      () => null,
+    );
+    unsub1();
+    void client.mutation(apiMutationFunc, {});
+    // Receiving a mutation next means no third or fourth ModifyQuerySet.
+    expect((await receive()).type).toEqual("Mutation");
+
+    // Unsubscribing the second time should trigger the unsubscribe.
+    unsub2();
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+
+    await client.close();
+  });
+});
+
+test("Optimistic updates are applied", async () => {
+  await withInMemoryWebSocket(async ({ address, receive }) => {
+    const client = new ConvexClient(address, {
+      unsavedChangesWarning: false,
+    });
+    expect((await receive()).type).toEqual("Connect");
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+
+    let updateCount = 0;
+    let updateValue = "";
+    let optimisticUpdateRan = 0;
+
+    // Subscribe to a query, which *does not* immediately trigger an update.
+    const { unsubscribe } = client.onUpdate(apiQueryFunc, {}, (value) => {
+      updateCount++;
+      updateValue = value;
+    });
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+    expect(client.client.localQueryResult(getFunctionName(apiQueryFunc))).toBe(
+      undefined,
+    );
+
+    void client.mutation(
+      apiMutationFunc,
+      {},
+      {
+        optimisticUpdate: (localStore) => {
+          optimisticUpdateRan++;
+          localStore.setQuery(apiQueryFunc, {}, "optimisticValue");
+        },
+      },
+    );
+    expect((await receive()).type).toEqual("Mutation");
+
+    // The mutation also updates the local cache
+    expect(optimisticUpdateRan).toBe(1);
+    expect(updateCount).toBe(1);
+    expect(updateValue).toBe("optimisticValue");
+    expect(client.client.localQueryResult(getFunctionName(apiQueryFunc))).toBe(
+      "optimisticValue",
+    );
+
+    unsubscribe();
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+
+    await client.close();
+  });
+});
diff --git a/synced/convex/libs/browser/simple_client.ts b/synced/convex/libs/browser/simple_client.ts
new file mode 100644
index 0000000..f688a0c
--- /dev/null
+++ b/synced/convex/libs/browser/simple_client.ts
@@ -0,0 +1,410 @@
+import { validateDeploymentUrl } from "../common/index.js";
+import {
+  BaseConvexClient,
+  BaseConvexClientOptions,
+  MutationOptions,
+  QueryToken,
+  UserIdentityAttributes,
+} from "./index.js";
+import {
+  FunctionArgs,
+  FunctionReference,
+  FunctionReturnType,
+} from "../server/index.js";
+import { getFunctionName } from "../server/api.js";
+import { AuthTokenFetcher } from "./sync/authentication_manager.js";
+
+// In Node.js builds this points to a bundled WebSocket implementation. If no
+// WebSocket implementation is manually specified or globally available,
+// this one is used.
+let defaultWebSocketConstructor: typeof WebSocket | undefined;
+
+/** internal */
+export function setDefaultWebSocketConstructor(ws: typeof WebSocket) {
+  defaultWebSocketConstructor = ws;
+}
+
+export type ConvexClientOptions = BaseConvexClientOptions & {
+  /**
+   * `disabled` makes onUpdate callback registration a no-op and actions,
+   * mutations and one-shot queries throw. Setting disabled to true may be
+   * useful for server-side rendering, where subscriptions don't make sense.
+   */
+  disabled?: boolean;
+  /**
+   * Whether to prompt users in browsers about queued or in-flight mutations.
+   * This only works in environments where `window.onbeforeunload` is available.
+   *
+   * Defaults to true when `window` is defined, otherwise false.
+   */
+  unsavedChangesWarning?: boolean;
+};
+
+/**
+ * Stops callbacks from running.
+ *
+ * @public
+ */
+export type Unsubscribe<T> = {
+  /** Stop calling callback when query results changes. If this is the last listener on this query, stop received updates. */
+  (): void;
+  /** Stop calling callback when query results changes. If this is the last listener on this query, stop received updates. */
+  unsubscribe(): void;
+  /** Get the last known value, possibly with local optimistic updates applied. */
+  getCurrentValue(): T | undefined;
+  /** @internal */
+  getQueryLogs(): string[] | undefined;
+};
+
+/**
+ * Subscribes to Convex query functions and executes mutations and actions over a WebSocket.
+ *
+ * Optimistic updates for mutations are not provided for this client.
+ * Third party clients may choose to wrap {@link browser.BaseConvexClient} for additional control.
+ *
+ * ```ts
+ * const client = new ConvexClient("https://happy-otter-123.convex.cloud");
+ * const unsubscribe = client.onUpdate(api.messages.list, (messages) => {
+ *   console.log(messages[0].body);
+ * });
+ * ```
+ *
+ * @public
+ */
+export class ConvexClient {
+  private listeners: Set<QueryInfo>;
+  private _client: BaseConvexClient | undefined;
+  // A synthetic server event to run callbacks the first time
+  private callNewListenersWithCurrentValuesTimer:
+    | ReturnType<typeof setTimeout>
+    | undefined;
+  private _closed: boolean;
+  private _disabled: boolean;
+  /**
+   * Once closed no registered callbacks will fire again.
+   */
+  get closed(): boolean {
+    return this._closed;
+  }
+  get client(): BaseConvexClient {
+    if (this._client) return this._client;
+    throw new Error("ConvexClient is disabled");
+  }
+  get disabled(): boolean {
+    return this._disabled;
+  }
+
+  /**
+   * Construct a client and immediately initiate a WebSocket connection to the passed address.
+   *
+   * @public
+   */
+  constructor(address: string, options: ConvexClientOptions = {}) {
+    if (options.skipConvexDeploymentUrlCheck !== true) {
+      validateDeploymentUrl(address);
+    }
+    const { disabled, ...baseOptions } = options;
+    this._closed = false;
+    this._disabled = !!disabled;
+    if (
+      defaultWebSocketConstructor &&
+      !("webSocketConstructor" in baseOptions) &&
+      typeof WebSocket === "undefined"
+    ) {
+      baseOptions.webSocketConstructor = defaultWebSocketConstructor;
+    }
+    if (
+      typeof window === "undefined" &&
+      !("unsavedChangesWarning" in baseOptions)
+    ) {
+      baseOptions.unsavedChangesWarning = false;
+    }
+    if (!this.disabled) {
+      this._client = new BaseConvexClient(
+        address,
+        (updatedQueries) => this._transition(updatedQueries),
+        baseOptions,
+      );
+    }
+    this.listeners = new Set();
+  }
+
+  /**
+   * Call a callback whenever a new result for a query is received. The callback
+   * will run soon after being registered if a result for the query is already
+   * in memory.
+   *
+   * The return value is an {@link Unsubscribe} object which is both a function
+   * an an object with properties. Both of the patterns below work with this object:
+   *
+   *```ts
+   * // call the return value as a function
+   * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {
+   *   console.log(messages);
+   * });
+   * unsubscribe();
+   *
+   * // unpack the return value into its properties
+   * const {
+   *   getCurrentValue,
+   *   unsubscribe,
+   * } = client.onUpdate(api.messages.list, {}, (messages) => {
+   *   console.log(messages);
+   * });
+   *```
+   *
+   * @param query - A {@link server.FunctionReference} for the public query to run.
+   * @param args - The arguments to run the query with.
+   * @param callback - Function to call when the query result updates.
+   * @param onError - Function to call when the query result updates with an error.
+   * If not provided, errors will be thrown instead of calling the callback.
+   *
+   * @return an {@link Unsubscribe} function to stop calling the onUpdate function.
+   */
+  onUpdate<Query extends FunctionReference<"query">>(
+    query: Query,
+    args: FunctionArgs<Query>,
+    callback: (result: FunctionReturnType<Query>) => unknown,
+    onError?: (e: Error) => unknown,
+  ): Unsubscribe<Query["_returnType"]> {
+    if (this.disabled) {
+      const disabledUnsubscribe = (() => {}) as Unsubscribe<
+        Query["_returnType"]
+      >;
+      const unsubscribeProps: RemoveCallSignature<
+        Unsubscribe<Query["_returnType"]>
+      > = {
+        unsubscribe: disabledUnsubscribe,
+        getCurrentValue: () => undefined,
+        getQueryLogs: () => undefined,
+      };
+      Object.assign(disabledUnsubscribe, unsubscribeProps);
+      return disabledUnsubscribe;
+    }
+
+    // BaseConvexClient takes care of deduplicating queries subscriptions...
+    const { queryToken, unsubscribe } = this.client.subscribe(
+      getFunctionName(query),
+      args,
+    );
+
+    // ...but we still need to bookkeep callbacks to actually call them.
+    const queryInfo: QueryInfo = {
+      queryToken,
+      callback,
+      onError,
+      unsubscribe,
+      hasEverRun: false,
+      query,
+      args,
+    };
+    this.listeners.add(queryInfo);
+
+    // If the callback is registered for a query with a result immediately available
+    // schedule a fake transition to call the callback soon instead of waiting for
+    // a new server update (which could take seconds or days).
+    if (
+      this.queryResultReady(queryToken) &&
+      this.callNewListenersWithCurrentValuesTimer === undefined
+    ) {
+      this.callNewListenersWithCurrentValuesTimer = setTimeout(
+        () => this.callNewListenersWithCurrentValues(),
+        0,
+      );
+    }
+
+    const unsubscribeProps: RemoveCallSignature<
+      Unsubscribe<Query["_returnType"]>
+    > = {
+      unsubscribe: () => {
+        if (this.closed) {
+          // all unsubscribes already ran
+          return;
+        }
+        this.listeners.delete(queryInfo);
+        unsubscribe();
+      },
+      getCurrentValue: () => this.client.localQueryResultByToken(queryToken),
+      getQueryLogs: () => this.client.localQueryLogs(queryToken),
+    };
+    const ret = unsubscribeProps.unsubscribe as Unsubscribe<
+      Query["_returnType"]
+    >;
+    Object.assign(ret, unsubscribeProps);
+    return ret;
+  }
+
+  // Run all callbacks that have never been run before if they have a query
+  // result available now.
+  private callNewListenersWithCurrentValues() {
+    this.callNewListenersWithCurrentValuesTimer = undefined;
+    this._transition([], true);
+  }
+
+  private queryResultReady(queryToken: QueryToken): boolean {
+    return this.client.hasLocalQueryResultByToken(queryToken);
+  }
+
+  async close() {
+    if (this.disabled) return;
+    // prevent pending updates
+    this.listeners.clear();
+    this._closed = true;
+    return this.client.close();
+  }
+
+  /**
+   * Set the authentication token to be used for subsequent queries and mutations.
+   * `fetchToken` will be called automatically again if a token expires.
+   * `fetchToken` should return `null` if the token cannot be retrieved, for example
+   * when the user's rights were permanently revoked.
+   * @param fetchToken - an async function returning the JWT (typically an OpenID Connect Identity Token)
+   * @param onChange - a callback that will be called when the authentication status changes
+   */
+  setAuth(
+    fetchToken: AuthTokenFetcher,
+    onChange?: (isAuthenticated: boolean) => void,
+  ) {
+    if (this.disabled) return;
+    this.client.setAuth(
+      fetchToken,
+      onChange ??
+        (() => {
+          // Do nothing
+        }),
+    );
+  }
+
+  /**
+   * @internal
+   */
+  setAdminAuth(token: string, identity?: UserIdentityAttributes) {
+    if (this.closed) {
+      throw new Error("ConvexClient has already been closed.");
+    }
+    if (this.disabled) return;
+    this.client.setAdminAuth(token, identity);
+  }
+
+  /**
+   * @internal
+   */
+  _transition(updatedQueries: QueryToken[], callNewListeners = false) {
+    // Deduping subscriptions happens in the BaseConvexClient, so not much to do here.
+
+    // Call all callbacks in the order they were registered
+    for (const queryInfo of this.listeners) {
+      const { callback, queryToken, onError, hasEverRun } = queryInfo;
+      if (
+        updatedQueries.includes(queryToken) ||
+        (callNewListeners &&
+          !hasEverRun &&
+          this.client.hasLocalQueryResultByToken(queryToken))
+      ) {
+        queryInfo.hasEverRun = true;
+        let newValue;
+        try {
+          newValue = this.client.localQueryResultByToken(queryToken);
+        } catch (error) {
+          if (!(error instanceof Error)) throw error;
+          if (onError) {
+            onError(
+              error,
+              "Second argument to onUpdate onError is reserved for later use",
+            );
+          } else {
+            // Make some noise without unsubscribing or failing to call other callbacks.
+            void Promise.reject(error);
+          }
+          continue;
+        }
+        callback(
+          newValue,
+          "Second argument to onUpdate callback is reserved for later use",
+        );
+      }
+    }
+  }
+
+  /**
+   * Execute a mutation function.
+   *
+   * @param mutation - A {@link server.FunctionReference} for the public mutation
+   * to run.
+   * @param args - An arguments object for the mutation.
+   * @param options - A {@link MutationOptions} options object for the mutation.
+   * @returns A promise of the mutation's result.
+   */
+  async mutation<Mutation extends FunctionReference<"mutation">>(
+    mutation: Mutation,
+    args: FunctionArgs<Mutation>,
+    options?: MutationOptions,
+  ): Promise<Awaited<FunctionReturnType<Mutation>>> {
+    if (this.disabled) throw new Error("ConvexClient is disabled");
+    return await this.client.mutation(getFunctionName(mutation), args, options);
+  }
+
+  /**
+   * Execute an action function.
+   *
+   * @param action - A {@link server.FunctionReference} for the public action
+   * to run.
+   * @param args - An arguments object for the action.
+   * @returns A promise of the action's result.
+   */
+  async action<Action extends FunctionReference<"action">>(
+    action: Action,
+    args: FunctionArgs<Action>,
+  ): Promise<Awaited<FunctionReturnType<Action>>> {
+    if (this.disabled) throw new Error("ConvexClient is disabled");
+    return await this.client.action(getFunctionName(action), args);
+  }
+
+  /**
+   * Fetch a query result once.
+   *
+   * @param query - A {@link server.FunctionReference} for the public query
+   * to run.
+   * @param args - An arguments object for the query.
+   * @returns A promise of the query's result.
+   */
+  async query<Query extends FunctionReference<"query">>(
+    query: Query,
+    args: Query["_args"],
+  ): Promise<Awaited<Query["_returnType"]>> {
+    if (this.disabled) throw new Error("ConvexClient is disabled");
+    const value = this.client.localQueryResult(getFunctionName(query), args) as
+      | Awaited<Query["_returnType"]>
+      | undefined;
+    if (value !== undefined) return Promise.resolve(value);
+
+    return new Promise((resolve, reject) => {
+      const { unsubscribe } = this.onUpdate(
+        query,
+        args,
+        (value) => {
+          unsubscribe();
+          resolve(value);
+        },
+        (e: Error) => {
+          unsubscribe();
+          reject(e);
+        },
+      );
+    });
+  }
+}
+
+// internal information tracked about each registered callback
+type QueryInfo = {
+  callback: (result: any, meta: unknown) => unknown;
+  onError: ((e: Error, meta: unknown) => unknown) | undefined;
+  unsubscribe: () => void;
+  queryToken: QueryToken;
+  hasEverRun: boolean;
+  // query and args are just here for debugging, the queryToken is authoritative
+  query: FunctionReference<"query">;
+  args: any;
+};
+
+type RemoveCallSignature<T> = Omit<T, never>;
diff --git a/synced/convex/libs/browser/sync/authentication_manager.ts b/synced/convex/libs/browser/sync/authentication_manager.ts
new file mode 100644
index 0000000..041e2ef
--- /dev/null
+++ b/synced/convex/libs/browser/sync/authentication_manager.ts
@@ -0,0 +1,479 @@
+import { Logger } from "../logging.js";
+import { LocalSyncState } from "./local_state.js";
+import { AuthError, IdentityVersion, Transition } from "./protocol.js";
+import { jwtDecode } from "jwt-decode";
+
+// setTimout uses 32 bit integer, so it can only
+// schedule about 24 days in the future.
+const MAXIMUM_REFRESH_DELAY = 20 * 24 * 60 * 60 * 1000; // 20 days
+
+const MAX_TOKEN_CONFIRMATION_ATTEMPTS = 2;
+
+/**
+ * An async function returning the JWT-encoded OpenID Connect Identity Token
+ * if available.
+ *
+ * `forceRefreshToken` is `true` if the server rejected a previously
+ * returned token, and the client should try to fetch a new one.
+ *
+ * See {@link ConvexReactClient.setAuth}.
+ *
+ * @public
+ */
+export type AuthTokenFetcher = (args: {
+  forceRefreshToken: boolean;
+}) => Promise<string | null | undefined>;
+
+/**
+ * What is provided to the client.
+ */
+type AuthConfig = {
+  fetchToken: AuthTokenFetcher;
+  onAuthChange: (isAuthenticated: boolean) => void;
+};
+
+/**
+ * In general we take 3 steps:
+ *   1. Fetch a possibly cached token
+ *   2. Immediately fetch a fresh token without using a cache
+ *   3. Repeat step 2 before the end of the fresh token's lifetime
+ *
+ * When we fetch without using a cache we know when the token
+ * will expire, and can schedule refetching it.
+ *
+ * If we get an error before a scheduled refetch, we go back
+ * to step 2.
+ */
+type AuthState =
+  | { state: "noAuth" }
+  | {
+      state: "waitingForServerConfirmationOfCachedToken";
+      config: AuthConfig;
+      hasRetried: boolean;
+    }
+  | {
+      state: "initialRefetch";
+      config: AuthConfig;
+    }
+  | {
+      state: "waitingForServerConfirmationOfFreshToken";
+      config: AuthConfig;
+      hadAuth: boolean;
+      token: string;
+    }
+  | {
+      state: "waitingForScheduledRefetch";
+      config: AuthConfig;
+      refetchTokenTimeoutId: ReturnType<typeof setTimeout>;
+    }
+  // Special/weird state when we got a valid token
+  // but could not fetch a new one.
+  | {
+      state: "notRefetching";
+      config: AuthConfig;
+    };
+
+/**
+ * Handles the state transitions for auth. The server is the source
+ * of truth.
+ */
+export class AuthenticationManager {
+  private authState: AuthState = { state: "noAuth" };
+  // Used to detect races involving `setConfig` calls
+  // while a token is being fetched.
+  private configVersion = 0;
+  // Shared by the BaseClient so that the auth manager can easily inspect it
+  private readonly syncState: LocalSyncState;
+  // Passed down by BaseClient, sends a message to the server
+  private readonly authenticate: (token: string) => IdentityVersion;
+  private readonly stopSocket: () => Promise<void>;
+  private readonly tryRestartSocket: () => void;
+  private readonly pauseSocket: () => void;
+  private readonly resumeSocket: () => void;
+  // Passed down by BaseClient, sends a message to the server
+  private readonly clearAuth: () => void;
+  private readonly logger: Logger;
+  private readonly refreshTokenLeewaySeconds: number;
+  // Number of times we have attempted to confirm the latest token. We retry up
+  // to `MAX_TOKEN_CONFIRMATION_ATTEMPTS` times.
+  private tokenConfirmationAttempts = 0;
+  constructor(
+    syncState: LocalSyncState,
+    callbacks: {
+      authenticate: (token: string) => IdentityVersion;
+      stopSocket: () => Promise<void>;
+      tryRestartSocket: () => void;
+      pauseSocket: () => void;
+      resumeSocket: () => void;
+      clearAuth: () => void;
+    },
+    config: {
+      refreshTokenLeewaySeconds: number;
+      logger: Logger;
+    },
+  ) {
+    this.syncState = syncState;
+    this.authenticate = callbacks.authenticate;
+    this.stopSocket = callbacks.stopSocket;
+    this.tryRestartSocket = callbacks.tryRestartSocket;
+    this.pauseSocket = callbacks.pauseSocket;
+    this.resumeSocket = callbacks.resumeSocket;
+    this.clearAuth = callbacks.clearAuth;
+    this.logger = config.logger;
+    this.refreshTokenLeewaySeconds = config.refreshTokenLeewaySeconds;
+  }
+
+  async setConfig(
+    fetchToken: AuthTokenFetcher,
+    onChange: (isAuthenticated: boolean) => void,
+  ) {
+    this.resetAuthState();
+    this._logVerbose("pausing WS for auth token fetch");
+    this.pauseSocket();
+    const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {
+      forceRefreshToken: false,
+    });
+    if (token.isFromOutdatedConfig) {
+      return;
+    }
+    if (token.value) {
+      this.setAuthState({
+        state: "waitingForServerConfirmationOfCachedToken",
+        config: { fetchToken, onAuthChange: onChange },
+        hasRetried: false,
+      });
+      this.authenticate(token.value);
+    } else {
+      this.setAuthState({
+        state: "initialRefetch",
+        config: { fetchToken, onAuthChange: onChange },
+      });
+      // Try again with `forceRefreshToken: true`
+      await this.refetchToken();
+    }
+    this._logVerbose("resuming WS after auth token fetch");
+    this.resumeSocket();
+  }
+
+  onTransition(serverMessage: Transition) {
+    if (
+      !this.syncState.isCurrentOrNewerAuthVersion(
+        serverMessage.endVersion.identity,
+      )
+    ) {
+      // This is a stale transition - client has moved on to
+      // a newer auth version.
+      return;
+    }
+    if (
+      serverMessage.endVersion.identity <= serverMessage.startVersion.identity
+    ) {
+      // This transition did not change auth - it is not a response to Authenticate.
+      return;
+    }
+
+    if (this.authState.state === "waitingForServerConfirmationOfCachedToken") {
+      this._logVerbose("server confirmed auth token is valid");
+      void this.refetchToken();
+      this.authState.config.onAuthChange(true);
+      return;
+    }
+    if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
+      this._logVerbose("server confirmed new auth token is valid");
+      this.scheduleTokenRefetch(this.authState.token);
+      this.tokenConfirmationAttempts = 0;
+      if (!this.authState.hadAuth) {
+        this.authState.config.onAuthChange(true);
+      }
+    }
+  }
+
+  onAuthError(serverMessage: AuthError) {
+    // If the AuthError is not due to updating the token, and we're currently
+    // waiting on the result of a token update, ignore.
+    if (
+      serverMessage.authUpdateAttempted === false &&
+      (this.authState.state === "waitingForServerConfirmationOfFreshToken" ||
+        this.authState.state === "waitingForServerConfirmationOfCachedToken")
+    ) {
+      this._logVerbose("ignoring non-auth token expired error");
+      return;
+    }
+    const { baseVersion } = serverMessage;
+    // Versioned AuthErrors are ignored if the client advanced to
+    // a newer auth identity
+    // Error are reporting the previous version, since the server
+    // didn't advance, hence `+ 1`.
+    if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {
+      this._logVerbose("ignoring auth error for previous auth attempt");
+      return;
+    }
+    void this.tryToReauthenticate(serverMessage);
+    return;
+  }
+
+  // This is similar to `refetchToken` defined below, in fact we
+  // don't represent them as different states, but it is different
+  // in that we pause the WebSocket so that mutations
+  // don't retry with bad auth.
+  private async tryToReauthenticate(serverMessage: AuthError) {
+    this._logVerbose(`attempting to reauthenticate: ${serverMessage.error}`);
+    if (
+      // No way to fetch another token, kaboom
+      this.authState.state === "noAuth" ||
+      // We failed on a fresh token. After a small number of retries, we give up
+      // and clear the auth state to avoid infinite retries.
+      (this.authState.state === "waitingForServerConfirmationOfFreshToken" &&
+        this.tokenConfirmationAttempts >= MAX_TOKEN_CONFIRMATION_ATTEMPTS)
+    ) {
+      this.logger.error(
+        `Failed to authenticate: "${serverMessage.error}", check your server auth config`,
+      );
+      if (this.syncState.hasAuth()) {
+        this.syncState.clearAuth();
+      }
+      if (this.authState.state !== "noAuth") {
+        this.setAndReportAuthFailed(this.authState.config.onAuthChange);
+      }
+      return;
+    }
+    if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
+      this.tokenConfirmationAttempts++;
+      this._logVerbose(
+        `retrying reauthentication, ${MAX_TOKEN_CONFIRMATION_ATTEMPTS - this.tokenConfirmationAttempts} attempts remaining`,
+      );
+    }
+
+    await this.stopSocket();
+    const token = await this.fetchTokenAndGuardAgainstRace(
+      this.authState.config.fetchToken,
+      {
+        forceRefreshToken: true,
+      },
+    );
+    if (token.isFromOutdatedConfig) {
+      return;
+    }
+
+    if (token.value && this.syncState.isNewAuth(token.value)) {
+      this.authenticate(token.value);
+      this.setAuthState({
+        state: "waitingForServerConfirmationOfFreshToken",
+        config: this.authState.config,
+        token: token.value,
+        hadAuth:
+          this.authState.state === "notRefetching" ||
+          this.authState.state === "waitingForScheduledRefetch",
+      });
+    } else {
+      this._logVerbose("reauthentication failed, could not fetch a new token");
+      if (this.syncState.hasAuth()) {
+        this.syncState.clearAuth();
+      }
+      this.setAndReportAuthFailed(this.authState.config.onAuthChange);
+    }
+    this.tryRestartSocket();
+  }
+
+  // Force refetch the token and schedule another refetch
+  // before the token expires - an active client should never
+  // need to reauthenticate.
+  private async refetchToken() {
+    if (this.authState.state === "noAuth") {
+      return;
+    }
+    this._logVerbose("refetching auth token");
+    const token = await this.fetchTokenAndGuardAgainstRace(
+      this.authState.config.fetchToken,
+      {
+        forceRefreshToken: true,
+      },
+    );
+    if (token.isFromOutdatedConfig) {
+      return;
+    }
+
+    if (token.value) {
+      if (this.syncState.isNewAuth(token.value)) {
+        this.setAuthState({
+          state: "waitingForServerConfirmationOfFreshToken",
+          hadAuth: this.syncState.hasAuth(),
+          token: token.value,
+          config: this.authState.config,
+        });
+        this.authenticate(token.value);
+      } else {
+        this.setAuthState({
+          state: "notRefetching",
+          config: this.authState.config,
+        });
+      }
+    } else {
+      this._logVerbose("refetching token failed");
+      if (this.syncState.hasAuth()) {
+        this.clearAuth();
+      }
+      this.setAndReportAuthFailed(this.authState.config.onAuthChange);
+    }
+    // Restart in case this refetch was triggered via schedule during
+    // a reauthentication attempt.
+    this._logVerbose(
+      "restarting WS after auth token fetch (if currently stopped)",
+    );
+    this.tryRestartSocket();
+  }
+
+  private scheduleTokenRefetch(token: string) {
+    if (this.authState.state === "noAuth") {
+      return;
+    }
+    const decodedToken = this.decodeToken(token);
+    if (!decodedToken) {
+      // This is no longer really possible, because
+      // we wait on server response before scheduling token refetch,
+      // and the server currently requires JWT tokens.
+      this.logger.error(
+        "Auth token is not a valid JWT, cannot refetch the token",
+      );
+      return;
+    }
+    // iat: issued at time, UTC seconds timestamp at which the JWT was issued
+    // exp: expiration time, UTC seconds timestamp at which the JWT will expire
+    const { iat, exp } = decodedToken as { iat?: number; exp?: number };
+    if (!iat || !exp) {
+      this.logger.error(
+        "Auth token does not have required fields, cannot refetch the token",
+      );
+      return;
+    }
+    // Because the client and server clocks may be out of sync,
+    // we only know that the token will expire after `exp - iat`,
+    // and since we just fetched a fresh one we know when that
+    // will happen.
+    const tokenValiditySeconds = exp - iat;
+    if (tokenValiditySeconds <= 2) {
+      this.logger.error(
+        "Auth token does not live long enough, cannot refetch the token",
+      );
+      return;
+    }
+    // Attempt to refresh the token `refreshTokenLeewaySeconds` before it expires,
+    // or immediately if the token is already expiring soon.
+    let delay = Math.min(
+      MAXIMUM_REFRESH_DELAY,
+      (tokenValiditySeconds - this.refreshTokenLeewaySeconds) * 1000,
+    );
+    if (delay <= 0) {
+      // Refetch immediately, but this might be due to configuring a `refreshTokenLeewaySeconds`
+      // that is too large compared to the token's actual lifetime.
+      this.logger.warn(
+        `Refetching auth token immediately, configured leeway ${this.refreshTokenLeewaySeconds}s is larger than the token's lifetime ${tokenValiditySeconds}s`,
+      );
+      delay = 0;
+    }
+    const refetchTokenTimeoutId = setTimeout(() => {
+      this._logVerbose("running scheduled token refetch");
+      void this.refetchToken();
+    }, delay);
+    this.setAuthState({
+      state: "waitingForScheduledRefetch",
+      refetchTokenTimeoutId,
+      config: this.authState.config,
+    });
+    this._logVerbose(
+      `scheduled preemptive auth token refetching in ${delay}ms`,
+    );
+  }
+
+  // Protects against simultaneous calls to `setConfig`
+  // while we're fetching a token
+  private async fetchTokenAndGuardAgainstRace(
+    fetchToken: AuthTokenFetcher,
+    fetchArgs: {
+      forceRefreshToken: boolean;
+    },
+  ) {
+    const originalConfigVersion = ++this.configVersion;
+    this._logVerbose(
+      `fetching token with config version ${originalConfigVersion}`,
+    );
+    const token = await fetchToken(fetchArgs);
+    if (this.configVersion !== originalConfigVersion) {
+      // This is a stale config
+      this._logVerbose(
+        `stale config version, expected ${originalConfigVersion}, got ${this.configVersion}`,
+      );
+      return { isFromOutdatedConfig: true };
+    }
+    return { isFromOutdatedConfig: false, value: token };
+  }
+
+  stop() {
+    this.resetAuthState();
+    // Bump this in case we are mid-token-fetch when we get stopped
+    this.configVersion++;
+    this._logVerbose(`config version bumped to ${this.configVersion}`);
+  }
+
+  private setAndReportAuthFailed(
+    onAuthChange: (authenticated: boolean) => void,
+  ) {
+    onAuthChange(false);
+    this.resetAuthState();
+  }
+
+  private resetAuthState() {
+    this.setAuthState({ state: "noAuth" });
+  }
+
+  private setAuthState(newAuth: AuthState) {
+    const authStateForLog =
+      newAuth.state === "waitingForServerConfirmationOfFreshToken"
+        ? {
+            hadAuth: newAuth.hadAuth,
+            state: newAuth.state,
+            token: `...${newAuth.token.slice(-7)}`,
+          }
+        : { state: newAuth.state };
+    this._logVerbose(
+      `setting auth state to ${JSON.stringify(authStateForLog)}`,
+    );
+    switch (newAuth.state) {
+      case "waitingForScheduledRefetch":
+      case "notRefetching":
+      case "noAuth":
+        this.tokenConfirmationAttempts = 0;
+        break;
+      case "waitingForServerConfirmationOfFreshToken":
+      case "waitingForServerConfirmationOfCachedToken":
+      case "initialRefetch":
+        break;
+      default: {
+        const _typeCheck: never = newAuth;
+      }
+    }
+    if (this.authState.state === "waitingForScheduledRefetch") {
+      clearTimeout(this.authState.refetchTokenTimeoutId);
+
+      // The waitingForScheduledRefetch state is the most quiesced authed state.
+      // Let the syncState know that auth is in a good state, so it can reset failure backoffs
+      this.syncState.markAuthCompletion();
+    }
+    this.authState = newAuth;
+  }
+
+  private decodeToken(token: string) {
+    try {
+      return jwtDecode(token);
+    } catch (e) {
+      this._logVerbose(
+        `Error decoding token: ${e instanceof Error ? e.message : "Unknown error"}`,
+      );
+      return null;
+    }
+  }
+
+  private _logVerbose(message: string) {
+    this.logger.logVerbose(`${message} [v${this.configVersion}]`);
+  }
+}
diff --git a/synced/convex/libs/browser/sync/client.test.ts b/synced/convex/libs/browser/sync/client.test.ts
new file mode 100644
index 0000000..820a49b
--- /dev/null
+++ b/synced/convex/libs/browser/sync/client.test.ts
@@ -0,0 +1,37 @@
+/**
+ * @vitest-environment custom-vitest-environment.ts
+ */
+
+import { test, expect } from "vitest";
+
+import { BaseConvexClient } from "./client.js";
+import { anyApi } from "../../server/api.js";
+
+test("localQueryResult reflects optimistic results", async () => {
+  const client = new BaseConvexClient("http://127.0.0.1:8000", () => {
+    // ignore updates.
+  });
+
+  expect(client.localQueryResult("myUdf", {})).toBeUndefined();
+
+  // don't wait for mutation to complete
+  void client.mutation(
+    "myUdf",
+    {},
+    {
+      optimisticUpdate: (localQueryStore) => {
+        localQueryStore.setQuery(anyApi.myUdf.default, {}, true);
+      },
+    },
+  );
+  expect(client.localQueryResult("myUdf", {})).toBe(true);
+});
+
+test("Client warns when old clientConfig format is used", async () => {
+  expect(() => {
+    new BaseConvexClient(
+      { address: "http://127.0.0.1:8000" } as any,
+      () => null,
+    );
+  }).toThrow("no longer supported");
+});
diff --git a/synced/convex/libs/browser/sync/client.ts b/synced/convex/libs/browser/sync/client.ts
new file mode 100644
index 0000000..14396b3
--- /dev/null
+++ b/synced/convex/libs/browser/sync/client.ts
@@ -0,0 +1,1003 @@
+import { version } from "../../index.js";
+import { convexToJson, Value } from "../../values/index.js";
+import {
+  createHybridErrorStacktrace,
+  forwardData,
+  instantiateDefaultLogger,
+  instantiateNoopLogger,
+  logFatalError,
+  Logger,
+} from "../logging.js";
+import { LocalSyncState } from "./local_state.js";
+import { RequestManager } from "./request_manager.js";
+import {
+  OptimisticLocalStore,
+  OptimisticUpdate,
+} from "./optimistic_updates.js";
+import {
+  OptimisticQueryResults,
+  QueryResultsMap,
+} from "./optimistic_updates_impl.js";
+import {
+  ActionRequest,
+  MutationRequest,
+  QueryId,
+  QueryJournal,
+  RequestId,
+  ServerMessage,
+  TS,
+  UserIdentityAttributes,
+} from "./protocol.js";
+import { RemoteQuerySet } from "./remote_query_set.js";
+import { QueryToken, serializePathAndArgs } from "./udf_path_utils.js";
+import { ReconnectMetadata, WebSocketManager } from "./web_socket_manager.js";
+import { newSessionId } from "./session.js";
+import { FunctionResult } from "./function_result.js";
+import {
+  AuthenticationManager,
+  AuthTokenFetcher,
+} from "./authentication_manager.js";
+export { type AuthTokenFetcher } from "./authentication_manager.js";
+import { getMarksReport, mark, MarkName } from "./metrics.js";
+import { parseArgs, validateDeploymentUrl } from "../../common/index.js";
+import { ConvexError } from "../../values/errors.js";
+
+/**
+ * Options for {@link BaseConvexClient}.
+ *
+ * @public
+ */
+export interface BaseConvexClientOptions {
+  /**
+   * Whether to prompt the user if they have unsaved changes pending
+   * when navigating away or closing a web page.
+   *
+   * This is only possible when the `window` object exists, i.e. in a browser.
+   *
+   * The default value is `true` in browsers.
+   */
+  unsavedChangesWarning?: boolean;
+  /**
+   * Specifies an alternate
+   * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
+   * constructor to use for client communication with the Convex cloud.
+   * The default behavior is to use `WebSocket` from the global environment.
+   */
+  webSocketConstructor?: typeof WebSocket;
+  /**
+   * Adds additional logging for debugging purposes.
+   *
+   * The default value is `false`.
+   */
+  verbose?: boolean;
+  /**
+   * A logger, `true`, or `false`. If not provided or `true`, logs to the console.
+   * If `false`, logs are not printed anywhere.
+   *
+   * You can construct your own logger to customize logging to log elsewhere.
+   */
+  logger?: Logger | boolean;
+  /**
+   * Sends additional metrics to Convex for debugging purposes.
+   *
+   * The default value is `false`.
+   */
+  reportDebugInfoToConvex?: boolean;
+  /**
+   * This API is experimental: it may change or disappear.
+   *
+   * A function to call on receiving abnormal WebSocket close messages from the
+   * connected Convex deployment. The content of these messages is not stable,
+   * it is an implementation detail that may change.
+   *
+   * Consider this API an observability stopgap until higher level codes with
+   * recommendations on what to do are available, which could be a more stable
+   * interface instead of `string`.
+   *
+   * Check `connectionState` for more quantitative metrics about connection status.
+   */
+  onServerDisconnectError?: (message: string) => void;
+  /**
+   * Skip validating that the Convex deployment URL looks like
+   * `https://happy-animal-123.convex.cloud` or localhost.
+   *
+   * This can be useful if running a self-hosted Convex backend that uses a different
+   * URL.
+   *
+   * The default value is `false`
+   */
+  skipConvexDeploymentUrlCheck?: boolean;
+  /**
+   * If using auth, the number of seconds before a token expires that we should refresh it.
+   *
+   * The default value is `2`.
+   */
+  authRefreshTokenLeewaySeconds?: number;
+}
+
+/**
+ * State describing the client's connection with the Convex backend.
+ *
+ * @public
+ */
+export type ConnectionState = {
+  hasInflightRequests: boolean;
+  isWebSocketConnected: boolean;
+  timeOfOldestInflightRequest: Date | null;
+  /**
+   * True if the client has ever opened a WebSocket to the "ready" state.
+   */
+  hasEverConnected: boolean;
+  /**
+   * The number of times this client has connected to the Convex backend.
+   *
+   * A number of things can cause the client to reconnect -- server errors,
+   * bad internet, auth expiring. But this number being high is an indication
+   * that the client is having trouble keeping a stable connection.
+   */
+  connectionCount: number;
+  /**
+   * The number of times this client has tried (and failed) to connect to the Convex backend.
+   */
+  connectionRetries: number;
+  /**
+   * The number of mutations currently in flight.
+   */
+  inflightMutations: number;
+  /**
+   * The number of actions currently in flight.
+   */
+  inflightActions: number;
+};
+
+/**
+ * Options for {@link BaseConvexClient.subscribe}.
+ *
+ * @public
+ */
+export interface SubscribeOptions {
+  /**
+   * An (optional) journal produced from a previous execution of this query
+   * function.
+   *
+   * If there is an existing subscription to a query function with the same
+   * name and arguments, this journal will have no effect.
+   */
+  journal?: QueryJournal;
+
+  /**
+   * @internal
+   */
+  componentPath?: string;
+}
+
+/**
+ * Options for {@link BaseConvexClient.mutation}.
+ *
+ * @public
+ */
+export interface MutationOptions {
+  /**
+   * An optimistic update to apply along with this mutation.
+   *
+   * An optimistic update locally updates queries while a mutation is pending.
+   * Once the mutation completes, the update will be rolled back.
+   */
+  optimisticUpdate?: OptimisticUpdate<any>;
+}
+
+/**
+ * Type describing updates to a query within a `Transition`.
+ *
+ * @public
+ */
+export type QueryModification =
+  // `undefined` generally comes from an optimistic update setting the query to be loading
+  { kind: "Updated"; result: FunctionResult | undefined } | { kind: "Removed" };
+
+/**
+ * Object describing a transition passed into the `onTransition` handler.
+ *
+ * These can be from receiving a transition from the server, or from applying an
+ * optimistic update locally.
+ *
+ * @public
+ */
+export type Transition = {
+  queries: Array<{ token: QueryToken; modification: QueryModification }>;
+  reflectedMutations: Array<{ requestId: RequestId; result: FunctionResult }>;
+  timestamp: TS;
+};
+
+/**
+ * Low-level client for directly integrating state management libraries
+ * with Convex.
+ *
+ * Most developers should use higher level clients, like
+ * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.
+ *
+ * @public
+ */
+export class BaseConvexClient {
+  private readonly address: string;
+  private readonly state: LocalSyncState;
+  private readonly requestManager: RequestManager;
+  private readonly webSocketManager: WebSocketManager;
+  private readonly authenticationManager: AuthenticationManager;
+  private remoteQuerySet: RemoteQuerySet;
+  private readonly optimisticQueryResults: OptimisticQueryResults;
+  private _transitionHandlerCounter = 0;
+  private _nextRequestId: RequestId;
+  private _onTransitionFns: Map<number, (transition: Transition) => void> =
+    new Map();
+  private readonly _sessionId: string;
+  private firstMessageReceived = false;
+  private readonly debug: boolean;
+  private readonly logger: Logger;
+  private maxObservedTimestamp: TS | undefined;
+
+  /**
+   * @param address - The url of your Convex deployment, often provided
+   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
+   * @param onTransition - A callback receiving an array of query tokens
+   * corresponding to query results that have changed -- additional handlers
+   * can be added via `addOnTransitionHandler`.
+   * @param options - See {@link BaseConvexClientOptions} for a full description.
+   */
+  constructor(
+    address: string,
+    onTransition: (updatedQueries: QueryToken[]) => void,
+    options?: BaseConvexClientOptions,
+  ) {
+    if (typeof address === "object") {
+      throw new Error(
+        "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.",
+      );
+    }
+    if (options?.skipConvexDeploymentUrlCheck !== true) {
+      validateDeploymentUrl(address);
+    }
+    options = { ...options };
+    const authRefreshTokenLeewaySeconds =
+      options.authRefreshTokenLeewaySeconds ?? 2;
+    let webSocketConstructor = options.webSocketConstructor;
+    if (!webSocketConstructor && typeof WebSocket === "undefined") {
+      throw new Error(
+        "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient",
+      );
+    }
+    webSocketConstructor = webSocketConstructor || WebSocket;
+    this.debug = options.reportDebugInfoToConvex ?? false;
+    this.address = address;
+    this.logger =
+      options.logger === false
+        ? instantiateNoopLogger({ verbose: options.verbose ?? false })
+        : options.logger !== true && options.logger
+          ? options.logger
+          : instantiateDefaultLogger({ verbose: options.verbose ?? false });
+    // Substitute http(s) with ws(s)
+    const i = address.search("://");
+    if (i === -1) {
+      throw new Error("Provided address was not an absolute URL.");
+    }
+    const origin = address.substring(i + 3); // move past the double slash
+    const protocol = address.substring(0, i);
+    let wsProtocol;
+    if (protocol === "http") {
+      wsProtocol = "ws";
+    } else if (protocol === "https") {
+      wsProtocol = "wss";
+    } else {
+      throw new Error(`Unknown parent protocol ${protocol}`);
+    }
+    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;
+
+    this.state = new LocalSyncState();
+    this.remoteQuerySet = new RemoteQuerySet(
+      (queryId) => this.state.queryPath(queryId),
+      this.logger,
+    );
+    this.requestManager = new RequestManager(this.logger);
+    this.authenticationManager = new AuthenticationManager(
+      this.state,
+      {
+        authenticate: (token) => {
+          const message = this.state.setAuth(token);
+          this.webSocketManager.sendMessage(message);
+          return message.baseVersion;
+        },
+        stopSocket: () => this.webSocketManager.stop(),
+        tryRestartSocket: () => this.webSocketManager.tryRestart(),
+        pauseSocket: () => {
+          this.webSocketManager.pause();
+          this.state.pause();
+        },
+        resumeSocket: () => this.webSocketManager.resume(),
+        clearAuth: () => {
+          this.clearAuth();
+        },
+      },
+      {
+        logger: this.logger,
+        refreshTokenLeewaySeconds: authRefreshTokenLeewaySeconds,
+      },
+    );
+    this.optimisticQueryResults = new OptimisticQueryResults();
+    this.addOnTransitionHandler((transition) => {
+      onTransition(transition.queries.map((q) => q.token));
+    });
+    this._nextRequestId = 0;
+    this._sessionId = newSessionId();
+
+    const { unsavedChangesWarning } = options;
+    if (
+      typeof window === "undefined" ||
+      typeof window.addEventListener === "undefined"
+    ) {
+      if (unsavedChangesWarning === true) {
+        throw new Error(
+          "unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.",
+        );
+      }
+    } else if (unsavedChangesWarning !== false) {
+      // Listen for tab close events and notify the user on unsaved changes.
+      window.addEventListener("beforeunload", (e) => {
+        if (this.requestManager.hasIncompleteRequests()) {
+          // There are 3 different ways to trigger this pop up so just try all of
+          // them.
+
+          e.preventDefault();
+          // This confirmation message doesn't actually appear in most modern
+          // browsers but we tried.
+          const confirmationMessage =
+            "Are you sure you want to leave? Your changes may not be saved.";
+          (e || window.event).returnValue = confirmationMessage;
+          return confirmationMessage;
+        }
+      });
+    }
+
+    this.webSocketManager = new WebSocketManager(
+      wsUri,
+      {
+        onOpen: (reconnectMetadata: ReconnectMetadata) => {
+          // We have a new WebSocket!
+          this.mark("convexWebSocketOpen");
+          this.webSocketManager.sendMessage({
+            ...reconnectMetadata,
+            type: "Connect",
+            sessionId: this._sessionId,
+            maxObservedTimestamp: this.maxObservedTimestamp,
+          });
+
+          // Throw out our remote query, reissue queries
+          // and outstanding mutations, and reauthenticate.
+          const oldRemoteQueryResults = new Set(
+            this.remoteQuerySet.remoteQueryResults().keys(),
+          );
+          this.remoteQuerySet = new RemoteQuerySet(
+            (queryId) => this.state.queryPath(queryId),
+            this.logger,
+          );
+          const [querySetModification, authModification] = this.state.restart(
+            oldRemoteQueryResults,
+          );
+          if (authModification) {
+            this.webSocketManager.sendMessage(authModification);
+          }
+          this.webSocketManager.sendMessage(querySetModification);
+          for (const message of this.requestManager.restart()) {
+            this.webSocketManager.sendMessage(message);
+          }
+        },
+        onResume: () => {
+          const [querySetModification, authModification] = this.state.resume();
+          if (authModification) {
+            this.webSocketManager.sendMessage(authModification);
+          }
+          if (querySetModification) {
+            this.webSocketManager.sendMessage(querySetModification);
+          }
+          for (const message of this.requestManager.resume()) {
+            this.webSocketManager.sendMessage(message);
+          }
+        },
+        onMessage: (serverMessage: ServerMessage) => {
+          // Metrics events grow linearly with reconnection attempts so this
+          // conditional prevents n^2 metrics reporting.
+          if (!this.firstMessageReceived) {
+            this.firstMessageReceived = true;
+            this.mark("convexFirstMessageReceived");
+            this.reportMarks();
+          }
+          switch (serverMessage.type) {
+            case "Transition": {
+              this.observedTimestamp(serverMessage.endVersion.ts);
+              this.authenticationManager.onTransition(serverMessage);
+              this.remoteQuerySet.transition(serverMessage);
+              this.state.transition(serverMessage);
+              const completedRequests = this.requestManager.removeCompleted(
+                this.remoteQuerySet.timestamp(),
+              );
+              this.notifyOnQueryResultChanges(completedRequests);
+              break;
+            }
+            case "MutationResponse": {
+              if (serverMessage.success) {
+                this.observedTimestamp(serverMessage.ts);
+              }
+              const completedMutationInfo =
+                this.requestManager.onResponse(serverMessage);
+              if (completedMutationInfo !== null) {
+                this.notifyOnQueryResultChanges(
+                  new Map([
+                    [
+                      completedMutationInfo.requestId,
+                      completedMutationInfo.result,
+                    ],
+                  ]),
+                );
+              }
+              break;
+            }
+            case "ActionResponse": {
+              this.requestManager.onResponse(serverMessage);
+              break;
+            }
+            case "AuthError": {
+              this.authenticationManager.onAuthError(serverMessage);
+              break;
+            }
+            case "FatalError": {
+              const error = logFatalError(this.logger, serverMessage.error);
+              void this.webSocketManager.terminate();
+              throw error;
+            }
+            case "Ping":
+              break; // do nothing
+            default: {
+              const _typeCheck: never = serverMessage;
+            }
+          }
+
+          return {
+            hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect(),
+          };
+        },
+        onServerDisconnectError: options.onServerDisconnectError,
+      },
+      webSocketConstructor,
+      this.logger,
+    );
+    this.mark("convexClientConstructed");
+  }
+
+  /**
+   * Return true if there is outstanding work from prior to the time of the most recent restart.
+   * This indicates that the client has not proven itself to have gotten past the issue that
+   * potentially led to the restart. Use this to influence when to reset backoff after a failure.
+   */
+  private hasSyncedPastLastReconnect() {
+    const hasSyncedPastLastReconnect =
+      this.requestManager.hasSyncedPastLastReconnect() ||
+      this.state.hasSyncedPastLastReconnect();
+    return hasSyncedPastLastReconnect;
+  }
+
+  private observedTimestamp(observedTs: TS) {
+    if (
+      this.maxObservedTimestamp === undefined ||
+      this.maxObservedTimestamp.lessThanOrEqual(observedTs)
+    ) {
+      this.maxObservedTimestamp = observedTs;
+    }
+  }
+
+  getMaxObservedTimestamp() {
+    return this.maxObservedTimestamp;
+  }
+
+  /**
+   * Compute the current query results based on the remoteQuerySet and the
+   * current optimistic updates and call `onTransition` for all the changed
+   * queries.
+   *
+   * @param completedMutations - A set of mutation IDs whose optimistic updates
+   * are no longer needed.
+   */
+  private notifyOnQueryResultChanges(
+    completedRequests: Map<RequestId, FunctionResult>,
+  ) {
+    const remoteQueryResults: Map<QueryId, FunctionResult> =
+      this.remoteQuerySet.remoteQueryResults();
+    const queryTokenToValue: QueryResultsMap = new Map();
+    for (const [queryId, result] of remoteQueryResults) {
+      const queryToken = this.state.queryToken(queryId);
+      // It's possible that we've already unsubscribed to this query but
+      // the server hasn't learned about that yet. If so, ignore this one.
+
+      if (queryToken !== null) {
+        const query = {
+          result,
+          udfPath: this.state.queryPath(queryId)!,
+          args: this.state.queryArgs(queryId)!,
+        };
+        queryTokenToValue.set(queryToken, query);
+      }
+    }
+
+    // Query tokens that are new (because of new server results or new local optimistic updates)
+    // or differ from old values (because of changes from local optimistic updates or new results
+    // from the server).
+    const changedQueryTokens =
+      this.optimisticQueryResults.ingestQueryResultsFromServer(
+        queryTokenToValue,
+        new Set(completedRequests.keys()),
+      );
+
+    this.handleTransition({
+      queries: changedQueryTokens.map((token) => {
+        const optimisticResult =
+          this.optimisticQueryResults.rawQueryResult(token);
+        return {
+          token,
+          modification: {
+            kind: "Updated",
+            result: optimisticResult!.result,
+          },
+        };
+      }),
+      reflectedMutations: Array.from(completedRequests).map(
+        ([requestId, result]) => ({
+          requestId,
+          result,
+        }),
+      ),
+      timestamp: this.remoteQuerySet.timestamp(),
+    });
+  }
+
+  private handleTransition(transition: Transition) {
+    for (const fn of this._onTransitionFns.values()) {
+      fn(transition);
+    }
+  }
+
+  /**
+   * Add a handler that will be called on a transition.
+   *
+   * Any external side effects (e.g. setting React state) should be handled here.
+   *
+   * @param fn
+   *
+   * @returns
+   */
+  addOnTransitionHandler(fn: (transition: Transition) => void) {
+    const id = this._transitionHandlerCounter++;
+    this._onTransitionFns.set(id, fn);
+    return () => this._onTransitionFns.delete(id);
+  }
+
+  /**
+   * Set the authentication token to be used for subsequent queries and mutations.
+   * `fetchToken` will be called automatically again if a token expires.
+   * `fetchToken` should return `null` if the token cannot be retrieved, for example
+   * when the user's rights were permanently revoked.
+   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token
+   * @param onChange - a callback that will be called when the authentication status changes
+   */
+  setAuth(
+    fetchToken: AuthTokenFetcher,
+    onChange: (isAuthenticated: boolean) => void,
+  ) {
+    void this.authenticationManager.setConfig(fetchToken, onChange);
+  }
+
+  hasAuth() {
+    return this.state.hasAuth();
+  }
+
+  /** @internal */
+  setAdminAuth(value: string, fakeUserIdentity?: UserIdentityAttributes) {
+    const message = this.state.setAdminAuth(value, fakeUserIdentity);
+    this.webSocketManager.sendMessage(message);
+  }
+
+  clearAuth() {
+    const message = this.state.clearAuth();
+    this.webSocketManager.sendMessage(message);
+  }
+
+  /**
+   * Subscribe to a query function.
+   *
+   * Whenever this query's result changes, the `onTransition` callback
+   * passed into the constructor will be called.
+   *
+   * @param name - The name of the query.
+   * @param args - An arguments object for the query. If this is omitted, the
+   * arguments will be `{}`.
+   * @param options - A {@link SubscribeOptions} options object for this query.
+
+   * @returns An object containing a {@link QueryToken} corresponding to this
+   * query and an `unsubscribe` callback.
+   */
+  subscribe(
+    name: string,
+    args?: Record<string, Value>,
+    options?: SubscribeOptions,
+  ): { queryToken: QueryToken; unsubscribe: () => void } {
+    const argsObject = parseArgs(args);
+
+    const { modification, queryToken, unsubscribe } = this.state.subscribe(
+      name,
+      argsObject,
+      options?.journal,
+      options?.componentPath,
+    );
+    if (modification !== null) {
+      this.webSocketManager.sendMessage(modification);
+    }
+    return {
+      queryToken,
+      unsubscribe: () => {
+        const modification = unsubscribe();
+        if (modification) {
+          this.webSocketManager.sendMessage(modification);
+        }
+      },
+    };
+  }
+
+  /**
+   * A query result based only on the current, local state.
+   *
+   * The only way this will return a value is if we're already subscribed to the
+   * query or its value has been set optimistically.
+   */
+  localQueryResult(
+    udfPath: string,
+    args?: Record<string, Value>,
+  ): Value | undefined {
+    const argsObject = parseArgs(args);
+    const queryToken = serializePathAndArgs(udfPath, argsObject);
+    return this.optimisticQueryResults.queryResult(queryToken);
+  }
+
+  /**
+   * Get query result by query token based on current, local state
+   *
+   * The only way this will return a value is if we're already subscribed to the
+   * query or its value has been set optimistically.
+   *
+   * @internal
+   */
+  localQueryResultByToken(queryToken: QueryToken): Value | undefined {
+    return this.optimisticQueryResults.queryResult(queryToken);
+  }
+
+  /**
+   * Whether local query result is available for a toke.
+   *
+   * This method does not throw if the result is an error.
+   *
+   * @internal
+   */
+  hasLocalQueryResultByToken(queryToken: QueryToken): boolean {
+    return this.optimisticQueryResults.hasQueryResult(queryToken);
+  }
+
+  /**
+   * @internal
+   */
+  localQueryLogs(
+    udfPath: string,
+    args?: Record<string, Value>,
+  ): string[] | undefined {
+    const argsObject = parseArgs(args);
+    const queryToken = serializePathAndArgs(udfPath, argsObject);
+    return this.optimisticQueryResults.queryLogs(queryToken);
+  }
+
+  /**
+   * Retrieve the current {@link QueryJournal} for this query function.
+   *
+   * If we have not yet received a result for this query, this will be `undefined`.
+   *
+   * @param name - The name of the query.
+   * @param args - The arguments object for this query.
+   * @returns The query's {@link QueryJournal} or `undefined`.
+   */
+  queryJournal(
+    name: string,
+    args?: Record<string, Value>,
+  ): QueryJournal | undefined {
+    const argsObject = parseArgs(args);
+    const queryToken = serializePathAndArgs(name, argsObject);
+    return this.state.queryJournal(queryToken);
+  }
+
+  /**
+   * Get the current {@link ConnectionState} between the client and the Convex
+   * backend.
+   *
+   * @returns The {@link ConnectionState} with the Convex backend.
+   */
+  connectionState(): ConnectionState {
+    const wsConnectionState = this.webSocketManager.connectionState();
+    return {
+      hasInflightRequests: this.requestManager.hasInflightRequests(),
+      isWebSocketConnected: wsConnectionState.isConnected,
+      hasEverConnected: wsConnectionState.hasEverConnected,
+      connectionCount: wsConnectionState.connectionCount,
+      connectionRetries: wsConnectionState.connectionRetries,
+      timeOfOldestInflightRequest:
+        this.requestManager.timeOfOldestInflightRequest(),
+      inflightMutations: this.requestManager.inflightMutations(),
+      inflightActions: this.requestManager.inflightActions(),
+    };
+  }
+
+  /**
+   * Execute a mutation function.
+   *
+   * @param name - The name of the mutation.
+   * @param args - An arguments object for the mutation. If this is omitted,
+   * the arguments will be `{}`.
+   * @param options - A {@link MutationOptions} options object for this mutation.
+
+   * @returns - A promise of the mutation's result.
+   */
+  async mutation(
+    name: string,
+    args?: Record<string, Value>,
+    options?: MutationOptions,
+  ): Promise<any> {
+    const result = await this.mutationInternal(name, args, options);
+    if (!result.success) {
+      if (result.errorData !== undefined) {
+        throw forwardData(
+          result,
+          new ConvexError(
+            createHybridErrorStacktrace("mutation", name, result),
+          ),
+        );
+      }
+      throw new Error(createHybridErrorStacktrace("mutation", name, result));
+    }
+    return result.value;
+  }
+
+  /**
+   * @internal
+   */
+  async mutationInternal(
+    udfPath: string,
+    args?: Record<string, Value>,
+    options?: MutationOptions,
+    componentPath?: string,
+  ): Promise<FunctionResult> {
+    const { mutationPromise } = this.enqueueMutation(
+      udfPath,
+      args,
+      options,
+      componentPath,
+    );
+    return mutationPromise;
+  }
+
+  /**
+   * @internal
+   */
+  enqueueMutation(
+    udfPath: string,
+    args?: Record<string, Value>,
+    options?: MutationOptions,
+    componentPath?: string,
+  ): { requestId: RequestId; mutationPromise: Promise<FunctionResult> } {
+    const mutationArgs = parseArgs(args);
+    this.tryReportLongDisconnect();
+    const requestId = this.nextRequestId;
+    this._nextRequestId++;
+
+    if (options !== undefined) {
+      const optimisticUpdate = options.optimisticUpdate;
+      if (optimisticUpdate !== undefined) {
+        const wrappedUpdate = (localQueryStore: OptimisticLocalStore) => {
+          const result: unknown = optimisticUpdate(
+            localQueryStore,
+            mutationArgs,
+          );
+          if (result instanceof Promise) {
+            this.logger.warn(
+              "Optimistic update handler returned a Promise. Optimistic updates should be synchronous.",
+            );
+          }
+        };
+
+        const changedQueryTokens =
+          this.optimisticQueryResults.applyOptimisticUpdate(
+            wrappedUpdate,
+            requestId,
+          );
+
+        const changedQueries = changedQueryTokens.map((token) => {
+          const localResult = this.localQueryResultByToken(token);
+          return {
+            token,
+            modification: {
+              kind: "Updated" as const,
+              result:
+                localResult === undefined
+                  ? undefined
+                  : {
+                      success: true as const,
+                      value: localResult,
+                      logLines: [],
+                    },
+            },
+          };
+        });
+        this.handleTransition({
+          queries: changedQueries,
+          reflectedMutations: [],
+          timestamp: this.remoteQuerySet.timestamp(),
+        });
+      }
+    }
+
+    const message: MutationRequest = {
+      type: "Mutation",
+      requestId,
+      udfPath,
+      componentPath,
+      args: [convexToJson(mutationArgs)],
+    };
+    const mightBeSent = this.webSocketManager.sendMessage(message);
+    const mutationPromise = this.requestManager.request(message, mightBeSent);
+    return {
+      requestId,
+      mutationPromise,
+    };
+  }
+
+  /**
+   * Execute an action function.
+   *
+   * @param name - The name of the action.
+   * @param args - An arguments object for the action. If this is omitted,
+   * the arguments will be `{}`.
+   * @returns A promise of the action's result.
+   */
+  async action(name: string, args?: Record<string, Value>): Promise<any> {
+    const result = await this.actionInternal(name, args);
+    if (!result.success) {
+      if (result.errorData !== undefined) {
+        throw forwardData(
+          result,
+          new ConvexError(createHybridErrorStacktrace("action", name, result)),
+        );
+      }
+      throw new Error(createHybridErrorStacktrace("action", name, result));
+    }
+    return result.value;
+  }
+
+  /**
+   * @internal
+   */
+  async actionInternal(
+    udfPath: string,
+    args?: Record<string, Value>,
+    componentPath?: string,
+  ): Promise<FunctionResult> {
+    const actionArgs = parseArgs(args);
+    const requestId = this.nextRequestId;
+    this._nextRequestId++;
+    this.tryReportLongDisconnect();
+
+    const message: ActionRequest = {
+      type: "Action",
+      requestId,
+      udfPath,
+      componentPath,
+      args: [convexToJson(actionArgs)],
+    };
+
+    const mightBeSent = this.webSocketManager.sendMessage(message);
+    return this.requestManager.request(message, mightBeSent);
+  }
+
+  /**
+   * Close any network handles associated with this client and stop all subscriptions.
+   *
+   * Call this method when you're done with an {@link BaseConvexClient} to
+   * dispose of its sockets and resources.
+   *
+   * @returns A `Promise` fulfilled when the connection has been completely closed.
+   */
+  async close(): Promise<void> {
+    this.authenticationManager.stop();
+    return this.webSocketManager.terminate();
+  }
+
+  /**
+   * Return the address for this client, useful for creating a new client.
+   *
+   * Not guaranteed to match the address with which this client was constructed:
+   * it may be canonicalized.
+   */
+  get url() {
+    return this.address;
+  }
+
+  /**
+   * @internal
+   */
+  get nextRequestId() {
+    return this._nextRequestId;
+  }
+
+  /**
+   * @internal
+   */
+  get sessionId() {
+    return this._sessionId;
+  }
+
+  // Instance property so that `mark()` doesn't need to be called as a method.
+  private mark = (name: MarkName) => {
+    if (this.debug) {
+      mark(name, this.sessionId);
+    }
+  };
+
+  /**
+   * Reports performance marks to the server. This should only be called when
+   * we have a functional websocket.
+   */
+  private reportMarks() {
+    if (this.debug) {
+      const report = getMarksReport(this.sessionId);
+      this.webSocketManager.sendMessage({
+        type: "Event",
+        eventType: "ClientConnect",
+        event: report,
+      });
+    }
+  }
+
+  private tryReportLongDisconnect() {
+    if (!this.debug) {
+      return;
+    }
+    const timeOfOldestRequest =
+      this.connectionState().timeOfOldestInflightRequest;
+    if (
+      timeOfOldestRequest === null ||
+      Date.now() - timeOfOldestRequest.getTime() <= 60 * 1000
+    ) {
+      return;
+    }
+    const endpoint = `${this.address}/api/debug_event`;
+    fetch(endpoint, {
+      method: "POST",
+      headers: {
+        "Content-Type": "application/json",
+        "Convex-Client": `npm-${version}`,
+      },
+      body: JSON.stringify({ event: "LongWebsocketDisconnect" }),
+    })
+      .then((response) => {
+        if (!response.ok) {
+          this.logger.warn(
+            "Analytics request failed with response:",
+            response.body,
+          );
+        }
+      })
+      .catch((error) => {
+        this.logger.warn("Analytics response failed with error:", error);
+      });
+  }
+}
diff --git a/synced/convex/libs/browser/sync/client_node.test.ts b/synced/convex/libs/browser/sync/client_node.test.ts
new file mode 100644
index 0000000..85090eb
--- /dev/null
+++ b/synced/convex/libs/browser/sync/client_node.test.ts
@@ -0,0 +1,366 @@
+import child_process from "child_process";
+
+import { test, expect } from "vitest";
+import { Long } from "../long.js";
+
+import { BaseConvexClient } from "./client.js";
+import {
+  ActionRequest,
+  MutationRequest,
+  parseServerMessage,
+  RequestId,
+  ServerMessage,
+} from "./protocol.js";
+import {
+  encodeServerMessage,
+  nodeWebSocket,
+  UpdateQueue,
+  withInMemoryWebSocket,
+} from "./client_node_test_helpers.js";
+import { FunctionArgs, makeFunctionReference } from "../../server/index.js";
+
+test("BaseConvexClient protocol in node", async () => {
+  await withInMemoryWebSocket(async ({ address, receive }) => {
+    const client = new BaseConvexClient(
+      address,
+      () => {
+        // ignore updates.
+      },
+      { webSocketConstructor: nodeWebSocket, unsavedChangesWarning: false },
+    );
+
+    expect((await receive()).type).toEqual("Connect");
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+
+    await client.close();
+  });
+});
+
+// Run the test above in its own Node.js subprocess to ensure that it exists
+// cleanly. This is the only point of this test.
+test("BaseConvexClient closes cleanly", () => {
+  const p = child_process.spawnSync(
+    "node_modules/.bin/vitest",
+    [
+      "-t",
+      "BaseConvexClient protocol in node",
+      "src/browser/sync/client_node.test.ts",
+    ],
+    {
+      encoding: "utf-8",
+      timeout: 35000,
+      stdio: ["pipe", "pipe", "pipe"],
+      env: {
+        ...process.env,
+        FORCE_COLOR: "false",
+      },
+    },
+  );
+
+  // If this is a timeout, the test didn't exit cleanly! Check for timers.
+  expect(p.status).toBeFalsy();
+});
+
+test("Tests can encode longs in server messages", () => {
+  const orig: ServerMessage = {
+    type: "Transition",
+    startVersion: { querySet: 0, identity: 0, ts: Long.fromNumber(0) },
+    endVersion: { querySet: 1, identity: 0, ts: Long.fromNumber(1) },
+    modifications: [
+      {
+        type: "QueryUpdated",
+        queryId: 0,
+        value: 0.0,
+        logLines: ["[LOG] 'Got stuff'"],
+        journal: null,
+      },
+    ],
+  };
+  const encoded = encodeServerMessage(orig);
+  const decoded = parseServerMessage(JSON.parse(encoded));
+  expect(orig).toEqual(decoded);
+});
+
+// Detects an issue where actions sent before the WebSocket has connected
+// are failed upon first connecting.
+test("Actions can be called immediately", async () => {
+  await withInMemoryWebSocket(async ({ address, receive, send }) => {
+    const client = new BaseConvexClient(address, () => null, {
+      webSocketConstructor: nodeWebSocket,
+      unsavedChangesWarning: false,
+    });
+    const actionP = client.action("myAction", {});
+
+    expect((await receive()).type).toEqual("Connect");
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+    const actionRequest = await receive();
+    expect(actionRequest.type).toEqual("Action");
+    const requestId = (actionRequest as ActionRequest).requestId;
+
+    send(actionSuccess(requestId));
+    expect(await actionP).toBe(42);
+    await client.close();
+  });
+});
+
+function actionSuccess(requestId: RequestId): ServerMessage {
+  return {
+    type: "ActionResponse",
+    requestId: requestId,
+    success: true,
+    result: 42,
+    logLines: [],
+  };
+}
+
+test("maxObservedTimestamp is updated on mutation and transition", async () => {
+  await withInMemoryWebSocket(async ({ address, receive, send }) => {
+    const client = new BaseConvexClient(address, () => null, {
+      webSocketConstructor: nodeWebSocket,
+      unsavedChangesWarning: false,
+    });
+
+    expect(client.getMaxObservedTimestamp()).toBeUndefined();
+
+    const mutationP = client.mutation("myMutation", {});
+
+    expect((await receive()).type).toEqual("Connect");
+    expect((await receive()).type).toEqual("ModifyQuerySet");
+    const mutationRequest = await receive();
+    expect(mutationRequest.type).toEqual("Mutation");
+    const requestId = (mutationRequest as MutationRequest).requestId;
+
+    // Send a mutation, should update the max observed timestamp.
+    send({
+      type: "MutationResponse",
+      requestId: requestId,
+      success: true,
+      result: 42,
+      ts: Long.fromNumber(1000),
+      logLines: [],
+    });
+    // Wait until getMaxObservedTimestamp() gets updated
+    for (let i = 0; i < 10; i++) {
+      if (client.getMaxObservedTimestamp()) {
+        break;
+      }
+      await new Promise((resolve) => setTimeout(resolve, 100));
+    }
+    expect(client.getMaxObservedTimestamp()).toEqual(Long.fromNumber(1000));
+
+    // Send a transition from before the mutation. Should not update the max
+    // observed timestamp nor resolve the mutation.
+    send({
+      type: "Transition",
+      startVersion: {
+        querySet: 0,
+        ts: Long.fromNumber(0),
+        identity: 0,
+      },
+      endVersion: {
+        querySet: 0,
+        ts: Long.fromNumber(500),
+        identity: 0,
+      },
+      modifications: [],
+    });
+
+    // Wait a bit and confirm the max timestamp has not been updated.
+    await new Promise((resolve) => setTimeout(resolve, 200));
+    expect(client.getMaxObservedTimestamp()).toEqual(Long.fromNumber(1000));
+
+    // Send another transition with higher timestamp. This should resolve the
+    // transition and advanced the max observable timestamp.
+    send({
+      type: "Transition",
+      startVersion: {
+        querySet: 0,
+        ts: Long.fromNumber(500),
+        identity: 0,
+      },
+      endVersion: {
+        querySet: 0,
+        ts: Long.fromNumber(2000),
+        identity: 0,
+      },
+      modifications: [],
+    });
+    // Wait until the mutation is resolved.
+    expect(await mutationP).toBe(42);
+    expect(client.getMaxObservedTimestamp()).toEqual(Long.fromNumber(2000));
+
+    await client.close();
+  });
+});
+
+const apiQueriesA = makeFunctionReference<"query", {}, string>("queries:a");
+const apiQueriesB = makeFunctionReference<"query", {}, string>("queries:b");
+
+const _apiMutationsZ = makeFunctionReference<"mutation", {}>("mutations:z");
+
+/**
+ * Regression test for
+ * - subscribing to query a
+ * - running a mutation that sets an optimistic update for queries a and b
+ * - receiving an update for a
+ */
+test("Setting optimistic updates for queries that have not yet been subscribed to", async () => {
+  await withInMemoryWebSocket(async ({ address, receive, send }) => {
+    const q = new UpdateQueue(10);
+
+    const client = new BaseConvexClient(
+      address,
+      (queryTokens) => {
+        q.onTransition(client)(queryTokens);
+      },
+      {
+        webSocketConstructor: nodeWebSocket,
+        unsavedChangesWarning: false,
+        verbose: true,
+      },
+    );
+
+    client.subscribe("queries:a", {});
+
+    expect((await receive()).type).toEqual("Connect");
+    const modify = await receive();
+
+    expect(modify.type).toEqual("ModifyQuerySet");
+    if (modify.type !== "ModifyQuerySet") {
+      return;
+    }
+    expect(modify.modifications.length).toBe(1);
+    expect(modify.modifications).toEqual([
+      {
+        type: "Add",
+        queryId: 0,
+        udfPath: "queries:a",
+        args: [{}],
+      },
+    ]);
+
+    // Now that we're subscribed to queries:a,
+    // run a mutation that, optimistically and on the server,
+    // - modifies q1
+    // - modifies q2
+
+    const mutP = client.mutation(
+      "mutations:z",
+      {},
+      {
+        optimisticUpdate: (
+          localStore,
+          _args: FunctionArgs<typeof _apiMutationsZ>,
+        ) => {
+          const curA = localStore.getQuery(apiQueriesA, {});
+          localStore.setQuery(
+            apiQueriesA,
+            {},
+            curA === undefined ? "a local" : `${curA} with a local applied`,
+          );
+          const curB = localStore.getQuery(apiQueriesB, {});
+          localStore.setQuery(
+            apiQueriesB,
+            {},
+            curB === undefined ? "b local" : `${curB} with b local applied`,
+          );
+        },
+      },
+    );
+
+    // Synchronously, the local store should update and the changes should be broadcast.
+    expect(client.localQueryResult("queries:a", {})).toEqual("a local");
+    // We haven't actually subscribed to this query but it had a value set in an optimistic update.
+    expect(client.localQueryResult("queries:b", {})).toEqual("b local");
+    const update1 = await q.updatePromises[0];
+    expect(q.updates).toHaveLength(1);
+    expect(update1).toEqual({
+      '{"udfPath":"queries:a","args":{}}': "a local",
+      '{"udfPath":"queries:b","args":{}}': "b local",
+    });
+
+    // Now a transition arrives containing only an update to query a.
+    // This previously crashed this execution context.
+    send({
+      type: "Transition",
+      startVersion: {
+        querySet: 0,
+        identity: 0,
+        ts: Long.fromNumber(0),
+      },
+      endVersion: {
+        querySet: 1,
+        identity: 0,
+        ts: Long.fromNumber(100),
+      },
+      modifications: [
+        {
+          type: "QueryUpdated",
+          queryId: 0,
+          value: "a server",
+          logLines: [],
+          journal: null,
+        },
+      ],
+    });
+
+    const update2 = await q.updatePromises[1];
+    expect(update2).toEqual({
+      '{"udfPath":"queries:a","args":{}}': "a server with a local applied",
+      '{"udfPath":"queries:b","args":{}}': "b local",
+    });
+    expect(q.allResults).toEqual({
+      '{"udfPath":"queries:a","args":{}}': "a server with a local applied",
+      '{"udfPath":"queries:b","args":{}}': "b local",
+    });
+    expect(q.updates).toHaveLength(2);
+
+    const mutationRequest = await receive();
+    expect(mutationRequest.type).toEqual("Mutation");
+    expect(mutationRequest).toEqual({
+      type: "Mutation",
+      requestId: 0,
+      udfPath: "mutations:z",
+      args: [{}],
+    });
+
+    // Now the server sends:
+
+    // 1. MutationResponse saying the mutation has run
+    send({
+      type: "MutationResponse",
+      requestId: 0,
+      success: true,
+      result: null,
+      ts: Long.fromNumber(200), // "ZDhuVB3CRxg=", in example
+      logLines: [],
+    });
+
+    // 2. Transition bringing us up to date with the mutation
+    send({
+      type: "Transition",
+      startVersion: { querySet: 1, identity: 0, ts: Long.fromNumber(100) },
+      endVersion: { querySet: 1, identity: 0, ts: Long.fromNumber(200) },
+      modifications: [
+        {
+          type: "QueryUpdated",
+          queryId: 0,
+          value: "a server",
+          logLines: [],
+          journal: null,
+        },
+      ],
+    });
+
+    expect(await q.updatePromises[2]).toEqual({
+      '{"udfPath":"queries:a","args":{}}': "a server",
+      // Now there's no more optimistic value for b!
+      '{"udfPath":"queries:b","args":{}}': undefined,
+    });
+
+    // After all that the mutation should resolve.
+    await mutP;
+
+    await client.close();
+  }, true);
+});
diff --git a/synced/convex/libs/browser/sync/client_node_test_helpers.ts b/synced/convex/libs/browser/sync/client_node_test_helpers.ts
new file mode 100644
index 0000000..2d915f6
--- /dev/null
+++ b/synced/convex/libs/browser/sync/client_node_test_helpers.ts
@@ -0,0 +1,155 @@
+import { Base64 } from "../../values/index.js";
+import { Long } from "../long.js";
+
+// --experimental-vm-modules which we use for jest doesn't support named exports
+import WebSocket, { WebSocketServer } from "ws";
+
+// Let's pretend this ws WebSocket is a browser WebSocket (it's very close)
+export const nodeWebSocket = WebSocket as unknown as typeof window.WebSocket;
+
+import { ClientMessage, ServerMessage } from "./protocol.js";
+import { QueryToken } from "./udf_path_utils.js";
+import { BaseConvexClient } from "./client.js";
+
+export type InMemoryWebSocketTest = (args: {
+  address: string;
+  socket: () => WebSocket;
+  receive: () => Promise<ClientMessage>;
+  send: (message: ServerMessage) => void;
+  close: () => void;
+}) => Promise<void>;
+
+function listeningSocketServer(): Promise<WebSocketServer> {
+  return new Promise((resolve) => {
+    const wss = new WebSocketServer({ port: 0 });
+    wss.on("listening", () => resolve(wss));
+  });
+}
+
+// Run a test with a real node WebSocket instance connected
+export async function withInMemoryWebSocket(
+  cb: InMemoryWebSocketTest,
+  debug = false,
+) {
+  // These state variables are consistent over multiple sockets.
+  let received: (msg: string) => void;
+  // prettier-ignore
+  const messages: Promise<string>[] = [ new Promise((r) => { received = r; }) ];
+  let socket: WebSocket | null = null;
+
+  const wss = await listeningSocketServer();
+
+  const setUpSocket = () => {
+    wss.once("connection", function connection(ws: WebSocket) {
+      socket = ws;
+      ws.on("message", function message(data: string) {
+        received(data);
+        // eslint-disable-next-line no-console
+        if (debug) console.debug(`client --${JSON.parse(data).type}--> `);
+        messages.push(
+          new Promise((r) => {
+            received = r;
+          }),
+        );
+      });
+    });
+  };
+  setUpSocket();
+
+  // receive and send are stable across multiple socket connections
+  async function receive(): Promise<ClientMessage> {
+    const msgP = messages.shift();
+    if (!msgP) {
+      throw new Error("Receive() called twice? No message promise found.");
+    }
+    return JSON.parse(await msgP);
+  }
+  function send(message: ServerMessage) {
+    // eslint-disable-next-line no-console
+    if (debug) console.debug(`      <--${message.type}-- server`);
+    socket!.send(encodeServerMessage(message));
+  }
+
+  const s: any = wss.address();
+  const address = typeof s === "string" ? s : `http://127.0.0.1:${s.port}`;
+
+  try {
+    await cb({
+      address,
+      socket: () => socket as unknown as WebSocket,
+      receive,
+      send,
+      close: () => {
+        // eslint-disable-next-line no-console
+        if (debug) console.debug(`           -->8-CLOSE- server`);
+        socket!.close();
+        setUpSocket();
+      },
+    });
+  } finally {
+    socket!.close();
+    wss.close();
+  }
+}
+
+export function encodeServerMessage(message: ServerMessage): string {
+  function replacer(_key: string, value: any) {
+    if (Long.isLong(value)) {
+      return encodeLong(value);
+    }
+    return value;
+  }
+  return JSON.stringify(message, replacer);
+}
+
+function encodeLong(n: Long) {
+  const integerBytes = Uint8Array.from(n.toBytesLE());
+  return Base64.fromByteArray(integerBytes);
+}
+
+/**
+ * const q = new UpdateQueue();
+ * const client = new Client("http://...", q.onTransition);
+ *
+ * await q.updatePromises[3];
+ *
+ */
+export class UpdateQueue {
+  updateResolves: ((v: Record<QueryToken, any>) => void)[];
+  updatePromises: Promise<Record<QueryToken, any>>[];
+  updates: Record<QueryToken, any>[];
+  allResults: Record<QueryToken, any>;
+  nextIndex: number;
+
+  constructor(maxLength = 10) {
+    this.updateResolves = [];
+    this.updatePromises = [];
+    this.allResults = {};
+    this.updates = [];
+    this.nextIndex = 0;
+
+    let nextResolve: (v: Record<QueryToken, any>) => void;
+    let nextPromise: Promise<Record<QueryToken, any>>;
+
+    for (let i = 0; i < maxLength; i++) {
+      nextPromise = new Promise((r) => {
+        nextResolve = r;
+      });
+      this.updateResolves.push(nextResolve!);
+      this.updatePromises.push(nextPromise);
+    }
+  }
+
+  onTransition =
+    (client: BaseConvexClient) => (updatedQueryTokens: QueryToken[]) => {
+      const update: Record<QueryToken, any> = {};
+      for (const queryToken of updatedQueryTokens) {
+        const value = client.localQueryResultByToken(queryToken);
+        update[queryToken] = value;
+        this.allResults[queryToken] = value;
+      }
+      this.updateResolves[this.nextIndex](update);
+      this.updates.push(update);
+      this.nextIndex++;
+    };
+}
diff --git a/synced/convex/libs/browser/sync/function_result.ts b/synced/convex/libs/browser/sync/function_result.ts
new file mode 100644
index 0000000..fe4d259
--- /dev/null
+++ b/synced/convex/libs/browser/sync/function_result.ts
@@ -0,0 +1,22 @@
+import { Value } from "../../values/index.js";
+
+/**
+ * The result of running a function on the server.
+ *
+ * If the function hit an exception it will have an `errorMessage`. Otherwise
+ * it will produce a `Value`.
+ *
+ * @public
+ */
+export type FunctionResult = FunctionSuccess | FunctionFailure;
+export type FunctionSuccess = {
+  success: true;
+  value: Value;
+  logLines: string[];
+};
+export type FunctionFailure = {
+  success: false;
+  errorMessage: string;
+  errorData?: Value;
+  logLines: string[];
+};
diff --git a/synced/convex/libs/browser/sync/local_state.test.ts b/synced/convex/libs/browser/sync/local_state.test.ts
new file mode 100644
index 0000000..e07ba47
--- /dev/null
+++ b/synced/convex/libs/browser/sync/local_state.test.ts
@@ -0,0 +1,128 @@
+import { test, expect } from "vitest";
+import { Long } from "../long.js";
+
+import { LocalSyncState } from "./local_state.js";
+
+test("can create a local state", () => {
+  new LocalSyncState();
+});
+
+test("has outstanding state older than restart", () => {
+  const state = new LocalSyncState();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Restarting w/o outstanding queries
+  state.restart(new Set());
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Do two subscriptions.
+  state.subscribe("hello:world1", {});
+  state.subscribe("hello:world2", {});
+  const queryId1 = state.queryId("hello:world1", {})!;
+  const queryId2 = state.queryId("hello:world2", {})!;
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Restart before we get results. This should flip synced to false.
+  state.restart(new Set());
+  expect(state.hasSyncedPastLastReconnect()).toBe(false);
+
+  // If we provide partial results, then synced should remain false
+  state.transition({
+    type: "Transition",
+    startVersion: {
+      querySet: 0,
+      ts: Long.fromNumber(500),
+      identity: 0,
+    },
+    endVersion: {
+      querySet: 0,
+      ts: Long.fromNumber(1000),
+      identity: 0,
+    },
+    modifications: [
+      {
+        type: "QueryUpdated",
+        queryId: queryId1,
+        value: "hi",
+        logLines: [],
+        journal: null,
+      },
+    ],
+  });
+  expect(state.hasSyncedPastLastReconnect()).toBe(false);
+
+  // If we provide full results, then synced should go true
+  state.transition({
+    type: "Transition",
+    startVersion: {
+      querySet: 0,
+      ts: Long.fromNumber(1000),
+      identity: 0,
+    },
+    endVersion: {
+      querySet: 0,
+      ts: Long.fromNumber(1500),
+      identity: 0,
+    },
+    modifications: [
+      {
+        type: "QueryUpdated",
+        queryId: queryId2,
+        value: "hi",
+        logLines: [],
+        journal: null,
+      },
+    ],
+  });
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+});
+
+test("unsubscribe resets outstanding state older than restart", () => {
+  const state = new LocalSyncState();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Do one subscription.
+  const sub1 = state.subscribe("hello:world", {});
+
+  // Restart before we get results. This should flip synced to false.
+  state.restart(new Set());
+  expect(state.hasSyncedPastLastReconnect()).toBe(false);
+
+  // Unsubscribe. This should flip synced back to true, even before getting result.
+  sub1.unsubscribe();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+});
+
+test("complete auth resets outstanding state older than restart", () => {
+  const state = new LocalSyncState();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Set auth
+  state.setAuth("auth123");
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Restart before we get results. This should flip synced to false.
+  state.restart(new Set());
+  expect(state.hasSyncedPastLastReconnect()).toBe(false);
+
+  // Mark auth completion
+  state.markAuthCompletion();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+});
+
+test("cleared auth resets outstanding state older than restart", () => {
+  const state = new LocalSyncState();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Set auth
+  state.setAuth("auth123");
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Restart before we get results. This should flip synced to false.
+  state.restart(new Set());
+  expect(state.hasSyncedPastLastReconnect()).toBe(false);
+
+  // Mark auth cleared
+  state.clearAuth();
+  expect(state.hasSyncedPastLastReconnect()).toBe(true);
+});
diff --git a/synced/convex/libs/browser/sync/local_state.ts b/synced/convex/libs/browser/sync/local_state.ts
new file mode 100644
index 0000000..83a432b
--- /dev/null
+++ b/synced/convex/libs/browser/sync/local_state.ts
@@ -0,0 +1,384 @@
+import { convexToJson, Value } from "../../values/index.js";
+import {
+  AddQuery,
+  RemoveQuery,
+  QueryId,
+  QuerySetModification,
+  QuerySetVersion,
+  IdentityVersion,
+  Authenticate,
+  QueryJournal,
+  Transition,
+  AdminAuthentication,
+  UserIdentityAttributes,
+} from "./protocol.js";
+import {
+  canonicalizeUdfPath,
+  QueryToken,
+  serializePathAndArgs,
+} from "./udf_path_utils.js";
+
+type LocalQuery = {
+  id: QueryId;
+  canonicalizedUdfPath: string;
+  args: Record<string, Value>;
+  numSubscribers: number;
+  journal?: QueryJournal;
+  componentPath?: string;
+};
+
+export class LocalSyncState {
+  private nextQueryId: QueryId;
+  private querySetVersion: QuerySetVersion;
+  private readonly querySet: Map<QueryToken, LocalQuery>;
+  private readonly queryIdToToken: Map<QueryId, QueryToken>;
+  private identityVersion: IdentityVersion;
+  private auth?: {
+    tokenType: "Admin" | "User";
+    value: string;
+    impersonating?: UserIdentityAttributes;
+  };
+  private readonly outstandingQueriesOlderThanRestart: Set<QueryId>;
+  private outstandingAuthOlderThanRestart: boolean;
+  private paused: boolean;
+  private pendingQuerySetModifications: Map<QueryId, AddQuery | RemoveQuery>;
+
+  constructor() {
+    this.nextQueryId = 0;
+    this.querySetVersion = 0;
+    this.identityVersion = 0;
+    this.querySet = new Map();
+    this.queryIdToToken = new Map();
+    this.outstandingQueriesOlderThanRestart = new Set();
+    this.outstandingAuthOlderThanRestart = false;
+    this.paused = false;
+    this.pendingQuerySetModifications = new Map();
+  }
+
+  hasSyncedPastLastReconnect(): boolean {
+    return (
+      this.outstandingQueriesOlderThanRestart.size === 0 &&
+      !this.outstandingAuthOlderThanRestart
+    );
+  }
+
+  markAuthCompletion() {
+    this.outstandingAuthOlderThanRestart = false;
+  }
+
+  subscribe(
+    udfPath: string,
+    args: Record<string, Value>,
+    journal?: QueryJournal,
+    componentPath?: string,
+  ): {
+    queryToken: QueryToken;
+    modification: QuerySetModification | null;
+    unsubscribe: () => QuerySetModification | null;
+  } {
+    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
+    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
+
+    const existingEntry = this.querySet.get(queryToken);
+
+    if (existingEntry !== undefined) {
+      existingEntry.numSubscribers += 1;
+      return {
+        queryToken,
+        modification: null,
+        unsubscribe: () => this.removeSubscriber(queryToken),
+      };
+    } else {
+      const queryId = this.nextQueryId++;
+      const query: LocalQuery = {
+        id: queryId,
+        canonicalizedUdfPath,
+        args,
+        numSubscribers: 1,
+        journal,
+        componentPath,
+      };
+      this.querySet.set(queryToken, query);
+      this.queryIdToToken.set(queryId, queryToken);
+
+      const baseVersion = this.querySetVersion;
+      const newVersion = this.querySetVersion + 1;
+
+      const add: AddQuery = {
+        type: "Add",
+        queryId,
+        udfPath: canonicalizedUdfPath,
+        args: [convexToJson(args)],
+        journal,
+        componentPath,
+      };
+
+      if (this.paused) {
+        this.pendingQuerySetModifications.set(queryId, add);
+      } else {
+        this.querySetVersion = newVersion;
+      }
+
+      const modification: QuerySetModification = {
+        type: "ModifyQuerySet",
+        baseVersion,
+        newVersion,
+        modifications: [add],
+      };
+      return {
+        queryToken,
+        modification,
+        unsubscribe: () => this.removeSubscriber(queryToken),
+      };
+    }
+  }
+
+  transition(transition: Transition) {
+    for (const modification of transition.modifications) {
+      switch (modification.type) {
+        case "QueryUpdated":
+        case "QueryFailed": {
+          this.outstandingQueriesOlderThanRestart.delete(modification.queryId);
+          const journal = modification.journal;
+          if (journal !== undefined) {
+            const queryToken = this.queryIdToToken.get(modification.queryId);
+            // We may have already unsubscribed to this query by the time the server
+            // sends us the journal. If so, just ignore it.
+            if (queryToken !== undefined) {
+              this.querySet.get(queryToken)!.journal = journal;
+            }
+          }
+
+          break;
+        }
+        case "QueryRemoved": {
+          this.outstandingQueriesOlderThanRestart.delete(modification.queryId);
+          break;
+        }
+        default: {
+          // Enforce that the switch-case is exhaustive.
+          const _: never = modification;
+          throw new Error(`Invalid modification ${(modification as any).type}`);
+        }
+      }
+    }
+  }
+
+  queryId(udfPath: string, args: Record<string, Value>): QueryId | null {
+    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);
+    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);
+    const existingEntry = this.querySet.get(queryToken);
+    if (existingEntry !== undefined) {
+      return existingEntry.id;
+    }
+    return null;
+  }
+
+  isCurrentOrNewerAuthVersion(version: IdentityVersion): boolean {
+    return version >= this.identityVersion;
+  }
+
+  setAuth(value: string): Authenticate {
+    this.auth = {
+      tokenType: "User",
+      value: value,
+    };
+    const baseVersion = this.identityVersion;
+    if (!this.paused) {
+      this.identityVersion = baseVersion + 1;
+    }
+    return {
+      type: "Authenticate",
+      baseVersion: baseVersion,
+      ...this.auth,
+    };
+  }
+
+  setAdminAuth(
+    value: string,
+    actingAs?: UserIdentityAttributes,
+  ): AdminAuthentication {
+    const auth: typeof this.auth & {
+      tokenType: "Admin";
+    } = {
+      tokenType: "Admin",
+      value,
+      impersonating: actingAs,
+    };
+    this.auth = auth;
+    const baseVersion = this.identityVersion;
+    if (!this.paused) {
+      this.identityVersion = baseVersion + 1;
+    }
+    return {
+      type: "Authenticate",
+      baseVersion: baseVersion,
+      ...auth,
+    };
+  }
+
+  clearAuth(): Authenticate {
+    this.auth = undefined;
+    this.markAuthCompletion();
+    const baseVersion = this.identityVersion;
+    if (!this.paused) {
+      this.identityVersion = baseVersion + 1;
+    }
+    return {
+      type: "Authenticate",
+      tokenType: "None",
+      baseVersion: baseVersion,
+    };
+  }
+
+  hasAuth(): boolean {
+    return !!this.auth;
+  }
+
+  isNewAuth(value: string): boolean {
+    return this.auth?.value !== value;
+  }
+
+  queryPath(queryId: QueryId): string | null {
+    const pathAndArgs = this.queryIdToToken.get(queryId);
+    if (pathAndArgs) {
+      return this.querySet.get(pathAndArgs)!.canonicalizedUdfPath;
+    }
+    return null;
+  }
+
+  queryArgs(queryId: QueryId): Record<string, Value> | null {
+    const pathAndArgs = this.queryIdToToken.get(queryId);
+    if (pathAndArgs) {
+      return this.querySet.get(pathAndArgs)!.args;
+    }
+    return null;
+  }
+
+  queryToken(queryId: QueryId): string | null {
+    return this.queryIdToToken.get(queryId) ?? null;
+  }
+
+  queryJournal(queryToken: QueryToken): QueryJournal | undefined {
+    return this.querySet.get(queryToken)?.journal;
+  }
+
+  restart(
+    oldRemoteQueryResults: Set<QueryId>,
+  ): [QuerySetModification, Authenticate?] {
+    // Restart works whether we are paused or unpaused.
+    // The `this.pendingQuerySetModifications` is not used
+    // when restarting as the AddQuery and RemoveQuery are computed
+    // from scratch, based on the old remote query results, here.
+    this.unpause();
+
+    this.outstandingQueriesOlderThanRestart.clear();
+    const modifications = [];
+    for (const localQuery of this.querySet.values()) {
+      const add: AddQuery = {
+        type: "Add",
+        queryId: localQuery.id,
+        udfPath: localQuery.canonicalizedUdfPath,
+        args: [convexToJson(localQuery.args)],
+        journal: localQuery.journal,
+        componentPath: localQuery.componentPath,
+      };
+      modifications.push(add);
+
+      if (!oldRemoteQueryResults.has(localQuery.id)) {
+        this.outstandingQueriesOlderThanRestart.add(localQuery.id);
+      }
+    }
+    this.querySetVersion = 1;
+    const querySet: QuerySetModification = {
+      type: "ModifyQuerySet",
+      baseVersion: 0,
+      newVersion: 1,
+      modifications,
+    };
+    // If there's no auth, no need to send an update as the server will also start with an unknown identity.
+    if (!this.auth) {
+      this.identityVersion = 0;
+      return [querySet, undefined];
+    }
+    this.outstandingAuthOlderThanRestart = true;
+    const authenticate: Authenticate = {
+      type: "Authenticate",
+      baseVersion: 0,
+      ...this.auth,
+    };
+    this.identityVersion = 1;
+    return [querySet, authenticate];
+  }
+
+  pause() {
+    this.paused = true;
+  }
+
+  resume(): [QuerySetModification?, Authenticate?] {
+    const querySet: QuerySetModification | undefined =
+      this.pendingQuerySetModifications.size > 0
+        ? {
+            type: "ModifyQuerySet",
+            baseVersion: this.querySetVersion,
+            newVersion: ++this.querySetVersion,
+            modifications: Array.from(
+              this.pendingQuerySetModifications.values(),
+            ),
+          }
+        : undefined;
+    const authenticate: Authenticate | undefined =
+      this.auth !== undefined
+        ? {
+            type: "Authenticate",
+            baseVersion: this.identityVersion++,
+            ...this.auth,
+          }
+        : undefined;
+
+    this.unpause();
+
+    return [querySet, authenticate];
+  }
+
+  private unpause() {
+    this.paused = false;
+    this.pendingQuerySetModifications.clear();
+  }
+
+  private removeSubscriber(
+    queryToken: QueryToken,
+  ): QuerySetModification | null {
+    const localQuery = this.querySet.get(queryToken)!;
+
+    if (localQuery.numSubscribers > 1) {
+      localQuery.numSubscribers -= 1;
+      return null;
+    } else {
+      this.querySet.delete(queryToken);
+      this.queryIdToToken.delete(localQuery.id);
+      this.outstandingQueriesOlderThanRestart.delete(localQuery.id);
+      const baseVersion = this.querySetVersion;
+      const newVersion = this.querySetVersion + 1;
+      const remove: RemoveQuery = {
+        type: "Remove",
+        queryId: localQuery.id,
+      };
+      if (this.paused) {
+        if (this.pendingQuerySetModifications.has(localQuery.id)) {
+          this.pendingQuerySetModifications.delete(localQuery.id);
+        } else {
+          this.pendingQuerySetModifications.set(localQuery.id, remove);
+        }
+      } else {
+        this.querySetVersion = newVersion;
+      }
+      return {
+        type: "ModifyQuerySet",
+        baseVersion,
+        newVersion,
+        modifications: [remove],
+      };
+    }
+  }
+}
diff --git a/synced/convex/libs/browser/sync/metrics.ts b/synced/convex/libs/browser/sync/metrics.ts
new file mode 100644
index 0000000..f5bca3b
--- /dev/null
+++ b/synced/convex/libs/browser/sync/metrics.ts
@@ -0,0 +1,61 @@
+// Marks share a global namespace with other developer code.
+const markNames = [
+  "convexClientConstructed",
+  "convexWebSocketOpen",
+  "convexFirstMessageReceived",
+] as const;
+export type MarkName = (typeof markNames)[number];
+
+// Mark details are not reported to the server.
+type MarkDetail = {
+  sessionId: string;
+};
+
+// `PerformanceMark`s are efficient and show up in browser's performance
+// timeline. They can be cleared with `performance.clearMarks()`.
+// This is a memory leak, but a worthwhile one: automatic
+// cleanup would make in-browser debugging more difficult.
+export function mark(name: MarkName, sessionId: string) {
+  const detail: MarkDetail = { sessionId };
+  // `performance` APIs exists in browsers, Node.js, Deno, and more but it
+  // is not required by the Convex client.
+  if (typeof performance === "undefined" || !performance.mark) return;
+  performance.mark(name, { detail });
+}
+
+// `PerfomanceMark` has a built-in toJSON() but the return type varies
+// between implementations, e.g. Node.js returns details but Chrome does not.
+function performanceMarkToJson(mark: PerformanceMark): MarkJson {
+  // Remove "convex" prefix
+  let name = mark.name.slice("convex".length);
+  // lowercase the first letter
+  name = name.charAt(0).toLowerCase() + name.slice(1);
+  return {
+    name,
+    startTime: mark.startTime,
+  };
+}
+
+// Similar to the return type of `PerformanceMark.toJson()`.
+export type MarkJson = {
+  name: string;
+  // `startTime` is in milliseconds since the time origin like `performance.now()`.
+  // https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#the_time_origin
+  startTime: number;
+};
+
+export function getMarksReport(sessionId: string): MarkJson[] {
+  if (typeof performance === "undefined" || !performance.getEntriesByName) {
+    return [];
+  }
+  const allMarks: PerformanceMark[] = [];
+  for (const name of markNames) {
+    const marks = (
+      performance
+        .getEntriesByName(name)
+        .filter((entry) => entry.entryType === "mark") as PerformanceMark[]
+    ).filter((mark) => mark.detail.sessionId === sessionId);
+    allMarks.push(...marks);
+  }
+  return allMarks.map(performanceMarkToJson);
+}
diff --git a/synced/convex/libs/browser/sync/optimistic_query_set.test.ts b/synced/convex/libs/browser/sync/optimistic_query_set.test.ts
new file mode 100644
index 0000000..3adcabd
--- /dev/null
+++ b/synced/convex/libs/browser/sync/optimistic_query_set.test.ts
@@ -0,0 +1,253 @@
+import { Value } from "../../values/index.js";
+import { test, expect, beforeEach } from "vitest";
+
+import {
+  OptimisticQueryResults,
+  QueryResultsMap,
+} from "./optimistic_updates_impl.js";
+import { serializePathAndArgs } from "./udf_path_utils.js";
+import { FunctionResult } from "./function_result.js";
+import { anyApi } from "../../server/api.js";
+
+let optimisticQuerySet: OptimisticQueryResults;
+beforeEach(() => {
+  optimisticQuerySet = new OptimisticQueryResults();
+});
+
+function success(value: Value): FunctionResult {
+  return { success: true, value, logLines: [] };
+}
+
+test("server results are returned back if no optimistic updates exist", () => {
+  const queryToken1 = serializePathAndArgs("query1", {});
+  const queryToken2 = serializePathAndArgs("query2", {});
+  const queryResults: QueryResultsMap = new Map([
+    [
+      queryToken1,
+      {
+        result: success("query1 result"),
+        udfPath: "query1",
+        args: {},
+      },
+    ],
+    [
+      queryToken2,
+      {
+        result: success("query2 result"),
+        udfPath: "query2",
+        args: {},
+      },
+    ],
+  ]);
+  const changedQueries = optimisticQuerySet.ingestQueryResultsFromServer(
+    queryResults,
+    new Set(),
+  );
+
+  expect(changedQueries).toEqual([queryToken1, queryToken2]);
+  expect(optimisticQuerySet.queryResult(queryToken1)).toEqual("query1 result");
+  expect(optimisticQuerySet.queryResult(queryToken2)).toEqual("query2 result");
+});
+
+test("errors are thrown if we receive an error from the server", () => {
+  const queryToken = serializePathAndArgs("query", {});
+  const serverQueryResults: QueryResultsMap = new Map([
+    [
+      queryToken,
+      {
+        result: {
+          success: false,
+          errorMessage: "Server Error",
+          logLines: [],
+        },
+        udfPath: "query",
+        args: {},
+      },
+    ],
+  ]);
+  const changedQueries = optimisticQuerySet.ingestQueryResultsFromServer(
+    serverQueryResults,
+    new Set(),
+  );
+  expect(changedQueries).toEqual([queryToken]);
+  expect(() => optimisticQuerySet.queryResult(queryToken)).toThrow(
+    "[CONVEX Q(query)] Server Error",
+  );
+});
+
+test("optimistic updates edit query results", () => {
+  const queryToken = serializePathAndArgs("query", {});
+  function createQueryResults(value: number): QueryResultsMap {
+    return new Map([
+      [
+        queryToken,
+        {
+          result: success(value),
+          udfPath: "query",
+          args: {},
+        },
+      ],
+    ]);
+  }
+
+  // Add a query to our store
+  const changedQueries = optimisticQuerySet.ingestQueryResultsFromServer(
+    createQueryResults(100),
+    new Set(),
+  );
+  expect(changedQueries).toEqual([queryToken]);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(100);
+
+  // Edit the query with an optimistic update and confirm it ran.
+  const changedQueries2 = optimisticQuerySet.applyOptimisticUpdate(
+    (localStore) => {
+      const oldResult = localStore.getQuery(anyApi.query.default, {});
+      localStore.setQuery(anyApi.query.default, {}, oldResult + 1);
+    },
+    0,
+  );
+  expect(changedQueries2).toEqual([queryToken]);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(101);
+
+  // If we receive a new query result while the update is in place, the update is
+  // replayed on top.
+  const changedQueries3 = optimisticQuerySet.ingestQueryResultsFromServer(
+    createQueryResults(200),
+    new Set(),
+  );
+  expect(changedQueries3).toEqual([queryToken]);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(201);
+
+  // The update can be dropped
+  const changedQueries4 = optimisticQuerySet.ingestQueryResultsFromServer(
+    createQueryResults(300),
+    new Set([0]),
+  );
+  expect(changedQueries4).toEqual([queryToken]);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(300);
+});
+
+test("optimistic updates only notify changed queries", () => {
+  // Set up 2 queries
+  const queryToken1 = serializePathAndArgs("query1", {});
+  const queryToken2 = serializePathAndArgs("query2", {});
+  const queryResults: QueryResultsMap = new Map([
+    [
+      queryToken1,
+      {
+        result: success("query1 result"),
+        udfPath: "query1",
+        args: {},
+      },
+    ],
+    [
+      queryToken2,
+      {
+        result: success("query2 result"),
+        udfPath: "query2",
+        args: {},
+      },
+    ],
+  ]);
+  const changedQueries = optimisticQuerySet.ingestQueryResultsFromServer(
+    queryResults,
+    new Set(),
+  );
+  // Confirm they were both added
+  expect(changedQueries).toEqual([queryToken1, queryToken2]);
+  expect(optimisticQuerySet.queryResult(queryToken1)).toEqual("query1 result");
+  expect(optimisticQuerySet.queryResult(queryToken2)).toEqual("query2 result");
+
+  // Update the first query
+  const changedQueries2 = optimisticQuerySet.applyOptimisticUpdate(
+    (localStore) => {
+      localStore.setQuery(anyApi.query1.default, {}, "new query1 result");
+    },
+    0,
+  );
+
+  // Only the first query changed
+  expect(changedQueries2).toEqual([queryToken1]);
+  expect(optimisticQuerySet.queryResult(queryToken1)).toEqual(
+    "new query1 result",
+  );
+  expect(optimisticQuerySet.queryResult(queryToken2)).toEqual("query2 result");
+});
+
+test("optimistic updates stack", () => {
+  // Start our server query value at 2.
+  const queryToken = serializePathAndArgs("query", {});
+  const serverQueryResults: QueryResultsMap = new Map([
+    [
+      queryToken,
+      {
+        result: success(2),
+        udfPath: "query",
+        args: {},
+      },
+    ],
+  ]);
+  optimisticQuerySet.ingestQueryResultsFromServer(
+    serverQueryResults,
+    new Set(),
+  );
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(2);
+
+  // The first update adds 1.
+  optimisticQuerySet.applyOptimisticUpdate((localStore) => {
+    const oldResult = localStore.getQuery(anyApi.query.default, {});
+    localStore.setQuery(anyApi.query.default, {}, oldResult + 1);
+  }, 0);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(3);
+
+  // The second update multiplies by 2.
+  optimisticQuerySet.applyOptimisticUpdate((localStore) => {
+    const oldResult = localStore.getQuery(anyApi.query.default, {});
+    localStore.setQuery(anyApi.query.default, {}, oldResult * 2);
+  }, 1);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(6);
+
+  // Drop the first update. Now we're just multiplying by 2.
+  optimisticQuerySet.ingestQueryResultsFromServer(
+    serverQueryResults,
+    new Set([0]),
+  );
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(4);
+  // Drop the second update. We're back to the start
+  optimisticQuerySet.ingestQueryResultsFromServer(
+    serverQueryResults,
+    new Set([1]),
+  );
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(2);
+});
+
+test("optimistic updates can set query results to undefined", () => {
+  // This is an important use case because we want to allow devs to set queries
+  // to be "loading"
+
+  // set up a query
+  const queryToken = serializePathAndArgs("query", {});
+  const serverQueryResults: QueryResultsMap = new Map([
+    [
+      queryToken,
+      {
+        result: success("query value"),
+        udfPath: "query",
+        args: {},
+      },
+    ],
+  ]);
+  const changedQueries = optimisticQuerySet.ingestQueryResultsFromServer(
+    serverQueryResults,
+    new Set(),
+  );
+  expect(changedQueries).toEqual([queryToken]);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual("query value");
+
+  // make it undefined
+  optimisticQuerySet.applyOptimisticUpdate((localStore) => {
+    localStore.setQuery(anyApi.query.default, {}, undefined);
+  }, 0);
+  expect(changedQueries).toEqual([queryToken]);
+  expect(optimisticQuerySet.queryResult(queryToken)).toEqual(undefined);
+});
diff --git a/synced/convex/libs/browser/sync/optimistic_updates.ts b/synced/convex/libs/browser/sync/optimistic_updates.ts
new file mode 100644
index 0000000..06c071e
--- /dev/null
+++ b/synced/convex/libs/browser/sync/optimistic_updates.ts
@@ -0,0 +1,93 @@
+import { Value } from "../../values/index.js";
+import {
+  FunctionArgs,
+  FunctionReference,
+  FunctionReturnType,
+  OptionalRestArgs,
+} from "../../server/api.js";
+
+/**
+ * A view of the query results currently in the Convex client for use within
+ * optimistic updates.
+ *
+ * @public
+ */
+export interface OptimisticLocalStore {
+  /**
+   * Retrieve the result of a query from the client.
+   *
+   * Important: Query results should be treated as immutable!
+   * Always make new copies of structures within query results to avoid
+   * corrupting data within the client.
+   *
+   * @param query - A {@link FunctionReference} for the query to get.
+   * @param args - The arguments object for this query.
+   * @returns The query result or `undefined` if the query is not currently
+   * in the client.
+   */
+  getQuery<Query extends FunctionReference<"query">>(
+    query: Query,
+    ...args: OptionalRestArgs<Query>
+  ): undefined | FunctionReturnType<Query>;
+
+  /**
+   * Retrieve the results and arguments of all queries with a given name.
+   *
+   * This is useful for complex optimistic updates that need to inspect and
+   * update many query results (for example updating a paginated list).
+   *
+   * Important: Query results should be treated as immutable!
+   * Always make new copies of structures within query results to avoid
+   * corrupting data within the client.
+   *
+   * @param query - A {@link FunctionReference} for the query to get.
+   * @returns An array of objects, one for each query of the given name.
+   * Each object includes:
+   *   - `args` - The arguments object for the query.
+   *   - `value` The query result or `undefined` if the query is loading.
+   */
+  getAllQueries<Query extends FunctionReference<"query">>(
+    query: Query,
+  ): {
+    args: FunctionArgs<Query>;
+    value: undefined | FunctionReturnType<Query>;
+  }[];
+
+  /**
+   * Optimistically update the result of a query.
+   *
+   * This can either be a new value (perhaps derived from the old value from
+   * {@link OptimisticLocalStore.getQuery}) or `undefined` to remove the query.
+   * Removing a query is useful to create loading states while Convex recomputes
+   * the query results.
+   *
+   * @param query - A {@link FunctionReference} for the query to set.
+   * @param args - The arguments object for this query.
+   * @param value - The new value to set the query to or `undefined` to remove
+   * it from the client.
+   */
+  setQuery<Query extends FunctionReference<"query">>(
+    query: Query,
+    args: FunctionArgs<Query>,
+    value: undefined | FunctionReturnType<Query>,
+  ): void;
+}
+/**
+ * A temporary, local update to query results within this client.
+ *
+ * This update will always be executed when a mutation is synced to the Convex
+ * server and rolled back when the mutation completes.
+ *
+ * Note that optimistic updates can be called multiple times! If the client
+ * loads new data while the mutation is in progress, the update will be replayed
+ * again.
+ *
+ * @param localQueryStore - An interface to read and edit local query results.
+ * @param args - The arguments to the mutation.
+ *
+ * @public
+ */
+export type OptimisticUpdate<Args extends Record<string, Value>> = (
+  localQueryStore: OptimisticLocalStore,
+  args: Args,
+) => void;
diff --git a/synced/convex/libs/browser/sync/optimistic_updates_impl.ts b/synced/convex/libs/browser/sync/optimistic_updates_impl.ts
new file mode 100644
index 0000000..97165f1
--- /dev/null
+++ b/synced/convex/libs/browser/sync/optimistic_updates_impl.ts
@@ -0,0 +1,247 @@
+import {
+  FunctionArgs,
+  FunctionReference,
+  FunctionReturnType,
+  OptionalRestArgs,
+  getFunctionName,
+} from "../../server/api.js";
+import { parseArgs } from "../../common/index.js";
+import { Value } from "../../values/index.js";
+import { createHybridErrorStacktrace, forwardData } from "../logging.js";
+import { FunctionResult } from "./function_result.js";
+import { OptimisticLocalStore } from "./optimistic_updates.js";
+import { RequestId } from "./protocol.js";
+import {
+  canonicalizeUdfPath,
+  QueryToken,
+  serializePathAndArgs,
+} from "./udf_path_utils.js";
+import { ConvexError } from "../../values/errors.js";
+
+/**
+ * An optimistic update function that has been curried over its arguments.
+ */
+type WrappedOptimisticUpdate = (locaQueryStore: OptimisticLocalStore) => void;
+
+/**
+ * The implementation of `OptimisticLocalStore`.
+ *
+ * This class provides the interface for optimistic updates to modify query results.
+ */
+class OptimisticLocalStoreImpl implements OptimisticLocalStore {
+  // A references of the query results in OptimisticQueryResults
+  private readonly queryResults: QueryResultsMap;
+
+  // All of the queries modified by this class
+  readonly modifiedQueries: QueryToken[];
+
+  constructor(queryResults: QueryResultsMap) {
+    this.queryResults = queryResults;
+    this.modifiedQueries = [];
+  }
+
+  getQuery<Query extends FunctionReference<"query">>(
+    query: Query,
+    ...args: OptionalRestArgs<Query>
+  ): undefined | FunctionReturnType<Query> {
+    const queryArgs = parseArgs(args[0]);
+    const name = getFunctionName(query);
+    const queryResult = this.queryResults.get(
+      serializePathAndArgs(name, queryArgs),
+    );
+    if (queryResult === undefined) {
+      return undefined;
+    }
+    return OptimisticLocalStoreImpl.queryValue(queryResult.result);
+  }
+
+  getAllQueries<Query extends FunctionReference<"query">>(
+    query: Query,
+  ): {
+    args: FunctionArgs<Query>;
+    value: undefined | FunctionReturnType<Query>;
+  }[] {
+    const queriesWithName: {
+      args: FunctionArgs<Query>;
+      value: undefined | FunctionReturnType<Query>;
+    }[] = [];
+    const name = getFunctionName(query);
+    for (const queryResult of this.queryResults.values()) {
+      if (queryResult.udfPath === canonicalizeUdfPath(name)) {
+        queriesWithName.push({
+          args: queryResult.args as FunctionArgs<Query>,
+          value: OptimisticLocalStoreImpl.queryValue(queryResult.result),
+        });
+      }
+    }
+    return queriesWithName;
+  }
+
+  setQuery<QueryReference extends FunctionReference<"query">>(
+    queryReference: QueryReference,
+    args: FunctionArgs<QueryReference>,
+    value: undefined | FunctionReturnType<QueryReference>,
+  ): void {
+    const queryArgs = parseArgs(args);
+    const name = getFunctionName(queryReference);
+    const queryToken = serializePathAndArgs(name, queryArgs);
+
+    let result: FunctionResult | undefined;
+    if (value === undefined) {
+      result = undefined;
+    } else {
+      result = {
+        success: true,
+        value,
+        // It's an optimistic update, so there are no function logs to show.
+        logLines: [],
+      };
+    }
+    const query: Query = {
+      udfPath: name,
+      args: queryArgs,
+      result,
+    };
+    this.queryResults.set(queryToken, query);
+    this.modifiedQueries.push(queryToken);
+  }
+
+  private static queryValue(
+    result: FunctionResult | undefined,
+  ): Value | undefined {
+    if (result === undefined) {
+      return undefined;
+    } else if (result.success) {
+      return result.value;
+    } else {
+      // If the query is an error state, just return `undefined` as though
+      // it's loading. Optimistic updates should already handle `undefined` well
+      // and there isn't a need to break the whole update because it tried
+      // to load a single query that errored.
+      return undefined;
+    }
+  }
+}
+
+type OptimisticUpdateAndId = {
+  update: WrappedOptimisticUpdate;
+  mutationId: RequestId;
+};
+
+type Query = {
+  // undefined means the query was set to be loading (undefined) in an optimistic update.
+  // Note that we can also have queries not present in the QueryResultMap
+  // at all because they are still loading from the server and have no optimistic update
+  // setting an optimistic value in advance.
+  result: FunctionResult | undefined;
+  udfPath: string;
+  args: Record<string, Value>;
+};
+export type QueryResultsMap = Map<QueryToken, Query>;
+
+type ChangedQueries = QueryToken[];
+
+/**
+ * A view of all of our query results with optimistic updates applied on top.
+ */
+export class OptimisticQueryResults {
+  private queryResults: QueryResultsMap;
+  private optimisticUpdates: OptimisticUpdateAndId[];
+
+  constructor() {
+    this.queryResults = new Map();
+    this.optimisticUpdates = [];
+  }
+
+  /**
+   * Apply all optimistic updates on top of server query results
+   */
+  ingestQueryResultsFromServer(
+    serverQueryResults: QueryResultsMap,
+    optimisticUpdatesToDrop: Set<RequestId>,
+  ): ChangedQueries {
+    this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId) => {
+      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);
+    });
+
+    const oldQueryResults = this.queryResults;
+    this.queryResults = new Map(serverQueryResults);
+    const localStore = new OptimisticLocalStoreImpl(this.queryResults);
+    for (const updateAndId of this.optimisticUpdates) {
+      updateAndId.update(localStore);
+    }
+
+    // To find the changed queries, just do a shallow comparison
+    // TODO(CX-733): Change this so we avoid unnecessary rerenders
+    const changedQueries: ChangedQueries = [];
+    for (const [queryToken, query] of this.queryResults) {
+      const oldQuery = oldQueryResults.get(queryToken);
+      if (oldQuery === undefined || oldQuery.result !== query.result) {
+        changedQueries.push(queryToken);
+      }
+    }
+
+    return changedQueries;
+  }
+
+  applyOptimisticUpdate(
+    update: WrappedOptimisticUpdate,
+    mutationId: RequestId,
+  ): ChangedQueries {
+    // Apply the update to our store
+    this.optimisticUpdates.push({
+      update,
+      mutationId,
+    });
+    const localStore = new OptimisticLocalStoreImpl(this.queryResults);
+    update(localStore);
+
+    // Notify about any query results that changed
+    // TODO(CX-733): Change this so we avoid unnecessary rerenders
+    return localStore.modifiedQueries;
+  }
+
+  /**
+   * @internal
+   */
+  rawQueryResult(queryToken: QueryToken): Query | undefined {
+    return this.queryResults.get(queryToken);
+  }
+
+  queryResult(queryToken: QueryToken): Value | undefined {
+    const query = this.queryResults.get(queryToken);
+    if (query === undefined) {
+      return undefined;
+    }
+    const result = query.result;
+    if (result === undefined) {
+      return undefined;
+    } else if (result.success) {
+      return result.value;
+    } else {
+      if (result.errorData !== undefined) {
+        throw forwardData(
+          result,
+          new ConvexError(
+            createHybridErrorStacktrace("query", query.udfPath, result),
+          ),
+        );
+      }
+      throw new Error(
+        createHybridErrorStacktrace("query", query.udfPath, result),
+      );
+    }
+  }
+
+  hasQueryResult(queryToken: QueryToken): boolean {
+    return this.queryResults.get(queryToken) !== undefined;
+  }
+
+  /**
+   * @internal
+   */
+  queryLogs(queryToken: QueryToken): string[] | undefined {
+    const query = this.queryResults.get(queryToken);
+    return query?.result?.logLines;
+  }
+}
diff --git a/synced/convex/libs/browser/sync/protocol.test.ts b/synced/convex/libs/browser/sync/protocol.test.ts
new file mode 100644
index 0000000..366921b
--- /dev/null
+++ b/synced/convex/libs/browser/sync/protocol.test.ts
@@ -0,0 +1,14 @@
+/**
+ * @vitest-environment custom-vitest-environment.ts
+ */
+
+import { test, expect } from "vitest";
+
+import { Long } from "../long.js";
+import { longToU64, u64ToLong } from "./protocol.js";
+
+test("Long serialization", async () => {
+  expect(Long.fromNumber(89234097497)).toEqual(
+    u64ToLong(longToU64(Long.fromNumber(89234097497))),
+  );
+});
diff --git a/synced/convex/libs/browser/sync/protocol.ts b/synced/convex/libs/browser/sync/protocol.ts
new file mode 100644
index 0000000..212f7d1
--- /dev/null
+++ b/synced/convex/libs/browser/sync/protocol.ts
@@ -0,0 +1,330 @@
+import type { UserIdentityAttributes } from "../../server/authentication.js";
+export type { UserIdentityAttributes } from "../../server/authentication.js";
+import { JSONValue, Base64 } from "../../values/index.js";
+import { Long } from "../long.js";
+
+/**
+ * Shared schema
+ */
+
+export function u64ToLong(encoded: EncodedU64): U64 {
+  const integerBytes = Base64.toByteArray(encoded);
+  return Long.fromBytesLE(Array.from(integerBytes));
+}
+
+export function longToU64(raw: U64): EncodedU64 {
+  const integerBytes = new Uint8Array(raw.toBytesLE());
+  return Base64.fromByteArray(integerBytes);
+}
+
+export function parseServerMessage(
+  encoded: EncodedServerMessage,
+): ServerMessage {
+  switch (encoded.type) {
+    case "FatalError":
+    case "AuthError":
+    case "ActionResponse":
+    case "Ping": {
+      return { ...encoded };
+    }
+    case "MutationResponse": {
+      if (encoded.success) {
+        return { ...encoded, ts: u64ToLong(encoded.ts) };
+      } else {
+        return { ...encoded };
+      }
+    }
+    case "Transition": {
+      return {
+        ...encoded,
+        startVersion: {
+          ...encoded.startVersion,
+          ts: u64ToLong(encoded.startVersion.ts),
+        },
+        endVersion: {
+          ...encoded.endVersion,
+          ts: u64ToLong(encoded.endVersion.ts),
+        },
+      };
+    }
+    default: {
+      const _exhaustivenessCheck: never = encoded;
+    }
+  }
+  return undefined as never;
+}
+
+export function encodeClientMessage(
+  message: ClientMessage,
+): EncodedClientMessage {
+  switch (message.type) {
+    case "Authenticate":
+    case "ModifyQuerySet":
+    case "Mutation":
+    case "Action":
+    case "Event": {
+      return { ...message };
+    }
+    case "Connect": {
+      if (message.maxObservedTimestamp !== undefined) {
+        return {
+          ...message,
+          maxObservedTimestamp: longToU64(message.maxObservedTimestamp),
+        };
+      } else {
+        return { ...message, maxObservedTimestamp: undefined };
+      }
+    }
+    default: {
+      const _exhaustivenessCheck: never = message;
+    }
+  }
+  return undefined as never;
+}
+
+type U64 = Long;
+type EncodedU64 = string;
+
+/**
+ * Unique nonnegative integer identifying a single query.
+ */
+export type QueryId = number; // nonnegative int
+
+export type QuerySetVersion = number; // nonnegative int
+
+export type RequestId = number; // nonnegative int
+
+export type IdentityVersion = number; // nonnegative int
+
+/**
+ * A serialized representation of decisions made during a query's execution.
+ *
+ * A journal is produced when a query function first executes and is re-used
+ * when a query is re-executed.
+ *
+ * Currently this is used to store pagination end cursors to ensure
+ * that pages of paginated queries will always end at the same cursor. This
+ * enables gapless, reactive pagination.
+ *
+ * `null` is used to represent empty journals.
+ * @public
+ */
+export type QueryJournal = string | null;
+
+/**
+ * Client message schema
+ */
+
+type Connect = {
+  type: "Connect";
+  sessionId: string;
+  connectionCount: number;
+  lastCloseReason: string | null;
+  maxObservedTimestamp?: TS;
+};
+
+export type AddQuery = {
+  type: "Add";
+  queryId: QueryId;
+  udfPath: string;
+  args: JSONValue[];
+  journal?: QueryJournal;
+  /**
+   * @internal
+   */
+  componentPath?: string;
+};
+
+export type RemoveQuery = {
+  type: "Remove";
+  queryId: QueryId;
+};
+
+export type QuerySetModification = {
+  type: "ModifyQuerySet";
+  baseVersion: QuerySetVersion;
+  newVersion: QuerySetVersion;
+  modifications: (AddQuery | RemoveQuery)[];
+};
+
+export type MutationRequest = {
+  type: "Mutation";
+  requestId: RequestId;
+  udfPath: string;
+  args: JSONValue[];
+  // Execute the mutation on a specific component.
+  // Only admin auth is allowed to run mutations on non-root components.
+  componentPath?: string;
+};
+
+export type ActionRequest = {
+  type: "Action";
+  requestId: RequestId;
+  udfPath: string;
+  args: JSONValue[];
+  // Execute the action on a specific component.
+  // Only admin auth is allowed to run actions on non-root components.
+  componentPath?: string;
+};
+
+export type AdminAuthentication = {
+  type: "Authenticate";
+  tokenType: "Admin";
+  value: string;
+  baseVersion: IdentityVersion;
+  impersonating?: UserIdentityAttributes;
+};
+
+export type Authenticate =
+  | AdminAuthentication
+  | {
+      type: "Authenticate";
+      tokenType: "User";
+      value: string;
+      baseVersion: IdentityVersion;
+    }
+  | {
+      type: "Authenticate";
+      tokenType: "None";
+      baseVersion: IdentityVersion;
+    };
+
+export type Event = {
+  type: "Event";
+  eventType: string;
+  event: any;
+};
+export type ClientMessage =
+  | Connect
+  | Authenticate
+  | QuerySetModification
+  | MutationRequest
+  | ActionRequest
+  | Event;
+
+type EncodedConnect = Omit<Connect, "maxObservedTimestamp"> & {
+  maxObservedTimestamp?: EncodedTS;
+};
+
+type EncodedClientMessage =
+  | EncodedConnect
+  | Authenticate
+  | QuerySetModification
+  | MutationRequest
+  | ActionRequest
+  | Event;
+
+/**
+ * Server message schema
+ */
+export type TS = U64;
+type EncodedTS = EncodedU64;
+type LogLines = string[];
+
+export type StateVersion = {
+  querySet: QuerySetVersion;
+  ts: TS;
+  identity: IdentityVersion;
+};
+type EncodedStateVersion = Omit<StateVersion, "ts"> & { ts: EncodedTS };
+
+type StateModification =
+  | {
+      type: "QueryUpdated";
+      queryId: QueryId;
+      value: JSONValue;
+      logLines: LogLines;
+      journal: QueryJournal;
+    }
+  | {
+      type: "QueryFailed";
+      queryId: QueryId;
+      errorMessage: string;
+      logLines: LogLines;
+      errorData: JSONValue;
+      journal: QueryJournal;
+    }
+  | {
+      type: "QueryRemoved";
+      queryId: QueryId;
+    };
+
+export type Transition = {
+  type: "Transition";
+  startVersion: StateVersion;
+  endVersion: StateVersion;
+  modifications: StateModification[];
+};
+
+type MutationSuccess = {
+  type: "MutationResponse";
+  requestId: RequestId;
+  success: true;
+  result: JSONValue;
+  ts: TS;
+  logLines: LogLines;
+};
+type MutationFailed = {
+  type: "MutationResponse";
+  requestId: RequestId;
+  success: false;
+  result: string;
+  logLines: LogLines;
+  errorData?: JSONValue;
+};
+export type MutationResponse = MutationSuccess | MutationFailed;
+type ActionSuccess = {
+  type: "ActionResponse";
+  requestId: RequestId;
+  success: true;
+  result: JSONValue;
+  logLines: LogLines;
+};
+type ActionFailed = {
+  type: "ActionResponse";
+  requestId: RequestId;
+  success: false;
+  result: string;
+  logLines: LogLines;
+  errorData?: JSONValue;
+};
+export type ActionResponse = ActionSuccess | ActionFailed;
+export type AuthError = {
+  type: "AuthError";
+  error: string;
+  baseVersion: IdentityVersion;
+  // True if this error is in response to processing a new `Authenticate` message.
+  // Other AuthErrors may occur due to executing a function with expired auth and
+  // should be handled differently.
+  authUpdateAttempted: boolean;
+};
+type FatalError = {
+  type: "FatalError";
+  error: string;
+};
+type Ping = {
+  type: "Ping";
+};
+
+export type ServerMessage =
+  | Transition
+  | MutationResponse
+  | ActionResponse
+  | FatalError
+  | AuthError
+  | Ping;
+
+type EncodedTransition = Omit<Transition, "startVersion" | "endVersion"> & {
+  startVersion: EncodedStateVersion;
+  endVersion: EncodedStateVersion;
+};
+type EncodedMutationSuccess = Omit<MutationSuccess, "ts"> & { ts: EncodedTS };
+type EncodedMutationResponse = MutationFailed | EncodedMutationSuccess;
+
+type EncodedServerMessage =
+  | EncodedTransition
+  | EncodedMutationResponse
+  | ActionResponse
+  | FatalError
+  | AuthError
+  | Ping;
diff --git a/synced/convex/libs/browser/sync/remote_query_set.ts b/synced/convex/libs/browser/sync/remote_query_set.ts
new file mode 100644
index 0000000..016000b
--- /dev/null
+++ b/synced/convex/libs/browser/sync/remote_query_set.ts
@@ -0,0 +1,94 @@
+import { jsonToConvex } from "../../values/index.js";
+import { Long } from "../long.js";
+import { logForFunction, Logger } from "../logging.js";
+import { QueryId, StateVersion, Transition } from "./protocol.js";
+import { FunctionResult } from "./function_result.js";
+
+/**
+ * A represention of the query results we've received on the current WebSocket
+ * connection.
+ *
+ * Queries you won't find here include:
+ * - queries which have been requested, but no query transition has been received yet for
+ * - queries which are populated only though active optimistic updates, but are not subscribed to
+ */
+export class RemoteQuerySet {
+  private version: StateVersion;
+  private readonly remoteQuerySet: Map<QueryId, FunctionResult>;
+  private readonly queryPath: (queryId: QueryId) => string | null;
+  private readonly logger: Logger;
+
+  constructor(queryPath: (queryId: QueryId) => string | null, logger: Logger) {
+    this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };
+    this.remoteQuerySet = new Map();
+    this.queryPath = queryPath;
+    this.logger = logger;
+  }
+
+  transition(transition: Transition): void {
+    const start = transition.startVersion;
+    if (
+      this.version.querySet !== start.querySet ||
+      this.version.ts.notEquals(start.ts) ||
+      this.version.identity !== start.identity
+    ) {
+      throw new Error(
+        `Invalid start version: ${start.ts.toString()}:${start.querySet}`,
+      );
+    }
+    for (const modification of transition.modifications) {
+      switch (modification.type) {
+        case "QueryUpdated": {
+          const queryPath = this.queryPath(modification.queryId);
+          if (queryPath) {
+            for (const line of modification.logLines) {
+              logForFunction(this.logger, "info", "query", queryPath, line);
+            }
+          }
+          const value = jsonToConvex(modification.value ?? null);
+          this.remoteQuerySet.set(modification.queryId, {
+            success: true,
+            value,
+            logLines: modification.logLines,
+          });
+          break;
+        }
+        case "QueryFailed": {
+          const queryPath = this.queryPath(modification.queryId);
+          if (queryPath) {
+            for (const line of modification.logLines) {
+              logForFunction(this.logger, "info", "query", queryPath, line);
+            }
+          }
+          const { errorData } = modification;
+          this.remoteQuerySet.set(modification.queryId, {
+            success: false,
+            errorMessage: modification.errorMessage,
+            errorData:
+              errorData !== undefined ? jsonToConvex(errorData) : undefined,
+            logLines: modification.logLines,
+          });
+          break;
+        }
+        case "QueryRemoved": {
+          this.remoteQuerySet.delete(modification.queryId);
+          break;
+        }
+        default: {
+          // Enforce that the switch-case is exhaustive.
+          const _: never = modification;
+          throw new Error(`Invalid modification ${(modification as any).type}`);
+        }
+      }
+    }
+    this.version = transition.endVersion;
+  }
+
+  remoteQueryResults(): Map<QueryId, FunctionResult> {
+    return this.remoteQuerySet;
+  }
+
+  timestamp(): Long {
+    return this.version.ts;
+  }
+}
diff --git a/synced/convex/libs/browser/sync/request_manager.test.ts b/synced/convex/libs/browser/sync/request_manager.test.ts
new file mode 100644
index 0000000..27e3315
--- /dev/null
+++ b/synced/convex/libs/browser/sync/request_manager.test.ts
@@ -0,0 +1,215 @@
+import { test, expect, beforeEach } from "vitest";
+import { RequestManager } from "./request_manager.js";
+import { Long } from "../long.js";
+import { ActionRequest, MutationRequest } from "./protocol.js";
+import { instantiateDefaultLogger } from "../logging.js";
+
+let requestManager: RequestManager;
+
+beforeEach(() => {
+  requestManager = new RequestManager(
+    instantiateDefaultLogger({ verbose: false }),
+  );
+});
+
+test("hasIncompleteRequests", () => {
+  // Starts false.
+  expect(requestManager.hasIncompleteRequests()).toBe(false);
+
+  // When we request a mutation it becomes true.
+  let message: MutationRequest = {
+    type: "Mutation",
+    requestId: 0,
+    udfPath: "myMutation",
+    args: [],
+  };
+  let _ = requestManager.request(message, true);
+  expect(requestManager.hasIncompleteRequests()).toBe(true);
+
+  // Request a second mutation and receive the first's response.
+  // Should still have an outstanding mutation.
+  message = {
+    type: "Mutation",
+    requestId: 1,
+    udfPath: "myMutation",
+    args: [],
+  };
+  _ = requestManager.request(message, true);
+  requestManager.onResponse({
+    type: "MutationResponse",
+    requestId: 0,
+    success: true,
+    result: null,
+    ts: Long.fromNumber(0),
+    logLines: [],
+  });
+  expect(requestManager.hasIncompleteRequests()).toBe(true);
+
+  // When the second response comes back we no longer have any outstanding mutations.
+  requestManager.onResponse({
+    type: "MutationResponse",
+    requestId: 1,
+    success: true,
+    result: null,
+    ts: Long.fromNumber(0),
+    logLines: [],
+  });
+  expect(requestManager.hasIncompleteRequests()).toBe(false);
+});
+
+/**
+ * A test that simulates a WebSocket disconnection half-way through the mutation
+ * flow.
+ */
+test("mutation retries", async () => {
+  // Request a mutation.
+  const message: MutationRequest = {
+    type: "Mutation",
+    requestId: 0,
+    udfPath: "myMutation",
+    args: [],
+  };
+  const mutationRequest = requestManager.request(message, true);
+
+  // Receive the response.
+  requestManager.onResponse({
+    type: "MutationResponse",
+    requestId: 0,
+    success: true,
+    result: null,
+    ts: Long.fromNumber(0),
+    logLines: [],
+  });
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Pretend that we become disconnected and reconnect.
+  // We should request the mutation because we haven't transitioned past the
+  // timestamp the mutation was committed at yet.
+  expect(requestManager.restart()).toEqual([message]);
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(false);
+
+  // Receive another response (because we restarted and requested it again)
+  requestManager.onResponse({
+    type: "MutationResponse",
+    requestId: 0,
+    success: true,
+    result: null,
+    ts: Long.fromNumber(0),
+    logLines: [],
+  });
+
+  // Transition to ts=1
+  requestManager.removeCompleted(Long.fromNumber(1));
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Return the result of the mutation now that we've transitioned past the
+  // mutation timestamp.
+  const result = await mutationRequest;
+  expect(result).toEqual({ success: true, value: null, logLines: [] });
+
+  // The if we restart now, the mutation should no longer be re-requested.
+  expect(requestManager.restart()).toEqual([]);
+});
+
+/**
+ * Another disconnection test
+ *
+ * This time upon reconnect we transition past the mutation immediately when we
+ * reconnect (before getting the second response).
+ */
+test("mutation retries with transition", async () => {
+  // Request a mutation.
+  const message: MutationRequest = {
+    type: "Mutation",
+    requestId: 0,
+    udfPath: "myMutation",
+    args: [],
+  };
+  const mutationRequest = requestManager.request(message, true);
+
+  // Receive the response.
+  requestManager.onResponse({
+    type: "MutationResponse",
+    requestId: 0,
+    success: true,
+    result: null,
+    ts: Long.fromNumber(0),
+    logLines: [],
+  });
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Pretend that we become disconnected and reconnect.
+  // We should request the mutation because we haven't transitioned past the
+  // timestamp the mutation was committed at yet.
+  expect(requestManager.restart()).toEqual([message]);
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(false);
+
+  // Transition to ts=1
+  requestManager.removeCompleted(Long.fromNumber(1));
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Return the result of the mutation now that we've transitioned past the
+  // mutation timestamp.
+  const result = await mutationRequest;
+  expect(result).toEqual({ success: true, value: null, logLines: [] });
+
+  // The if we restart now, the mutation should no longer be re-requested because
+  // we've already observed it.
+  expect(requestManager.restart()).toEqual([]);
+  expect(requestManager.hasSyncedPastLastReconnect()).toBe(true);
+
+  // Receive another response (because we requested it again).
+  // This response just needs to not crash the client.
+  requestManager.onResponse({
+    type: "MutationResponse",
+    requestId: 0,
+    success: true,
+    result: null,
+    ts: Long.fromNumber(0),
+    logLines: [],
+  });
+});
+
+/**
+ * A test that simulates a WebSocket disconnection half-way through the action
+ * flow. Makes sure the action doe not get retried.
+ */
+test("actions are retried only if unsent", async () => {
+  // Request a mutation.
+  const message1: ActionRequest = {
+    type: "Action",
+    requestId: 0,
+    udfPath: "myAction1",
+    args: [],
+  };
+  const actionRequest1 = requestManager.request(message1, true);
+  const message2: ActionRequest = {
+    type: "Action",
+    requestId: 1,
+    udfPath: "myAction2",
+    args: [],
+  };
+  const actionRequest2 = requestManager.request(message2, false);
+
+  // Pretend that we become disconnected and reconnect.
+  // We should only resend message2.
+  expect(requestManager.restart()).toEqual([message2]);
+
+  // The sent action promise should resolve with an error.
+  const result = await actionRequest1;
+  expect(result).toEqual({
+    success: false,
+    errorMessage: "Connection lost while action was in flight",
+    logLines: [],
+  });
+
+  // If we reconnect again, we should not retry anything. The second promise
+  // should also resolve with an error.
+  expect(requestManager.restart()).toEqual([]);
+  const result2 = await actionRequest2;
+  expect(result2).toEqual({
+    success: false,
+    errorMessage: "Connection lost while action was in flight",
+    logLines: [],
+  });
+});
diff --git a/synced/convex/libs/browser/sync/request_manager.ts b/synced/convex/libs/browser/sync/request_manager.ts
new file mode 100644
index 0000000..4b2e85b
--- /dev/null
+++ b/synced/convex/libs/browser/sync/request_manager.ts
@@ -0,0 +1,292 @@
+import { jsonToConvex } from "../../values/index.js";
+import { logForFunction, Logger } from "../logging.js";
+import { Long } from "../long.js";
+import { FunctionResult } from "./function_result.js";
+import {
+  ActionRequest,
+  ActionResponse,
+  ClientMessage,
+  MutationRequest,
+  MutationResponse,
+  RequestId,
+} from "./protocol.js";
+
+type RequestStatus =
+  | {
+      status: "Requested" | "NotSent";
+      onResult: (result: FunctionResult) => void;
+      requestedAt: Date;
+    }
+  | {
+      status: "Completed";
+      result: FunctionResult;
+      onResolve: () => void;
+      ts: Long;
+    };
+
+export class RequestManager {
+  private inflightRequests: Map<
+    RequestId,
+    {
+      message: MutationRequest | ActionRequest;
+      status: RequestStatus;
+    }
+  >;
+  private requestsOlderThanRestart: Set<RequestId>;
+  private inflightMutationsCount: number = 0;
+  private inflightActionsCount: number = 0;
+  constructor(private readonly logger: Logger) {
+    this.inflightRequests = new Map();
+    this.requestsOlderThanRestart = new Set();
+  }
+
+  request(
+    message: MutationRequest | ActionRequest,
+    sent: boolean,
+  ): Promise<FunctionResult> {
+    const result = new Promise<FunctionResult>((resolve) => {
+      const status = sent ? "Requested" : "NotSent";
+      this.inflightRequests.set(message.requestId, {
+        message,
+        status: { status, requestedAt: new Date(), onResult: resolve },
+      });
+
+      if (message.type === "Mutation") {
+        this.inflightMutationsCount++;
+      } else if (message.type === "Action") {
+        this.inflightActionsCount++;
+      }
+    });
+
+    return result;
+  }
+
+  /**
+   * Update the state after receiving a response.
+   *
+   * @returns A RequestId if the request is complete and its optimistic update
+   * can be dropped, null otherwise.
+   */
+  onResponse(
+    response: MutationResponse | ActionResponse,
+  ): { requestId: RequestId; result: FunctionResult } | null {
+    const requestInfo = this.inflightRequests.get(response.requestId);
+    if (requestInfo === undefined) {
+      // Annoyingly we can occasionally get responses to mutations that we're no
+      // longer tracking. One flow where this happens is:
+      // 1. Client sends mutation 1
+      // 2. Client gets response for mutation 1. The sever says that it was committed at ts=10.
+      // 3. Client is disconnected
+      // 4. Client reconnects and re-issues queries and this mutation.
+      // 5. Server sends transition message to ts=20
+      // 6. Client drops mutation because it's already been observed.
+      // 7. Client receives a second response for mutation 1 but doesn't know about it anymore.
+
+      // The right fix for this is probably to add a reconciliation phase on
+      // reconnection where we receive responses to all the mutations before
+      // the transition message so this flow could never happen (CX-1513).
+
+      // For now though, we can just ignore this message.
+      return null;
+    }
+
+    // Because `.restart()` re-requests completed requests, we may get some
+    // responses for requests that are already in the "Completed" state.
+    // We can safely ignore those because we've already notified the UI about
+    // their results.
+    if (requestInfo.status.status === "Completed") {
+      return null;
+    }
+
+    const udfType =
+      requestInfo.message.type === "Mutation" ? "mutation" : "action";
+    const udfPath = requestInfo.message.udfPath;
+
+    for (const line of response.logLines) {
+      logForFunction(this.logger, "info", udfType, udfPath, line);
+    }
+
+    const status = requestInfo.status;
+    let result: FunctionResult;
+    let onResolve;
+    if (response.success) {
+      result = {
+        success: true,
+        logLines: response.logLines,
+        value: jsonToConvex(response.result),
+      };
+      onResolve = () => status.onResult(result);
+    } else {
+      const errorMessage = response.result as string;
+      const { errorData } = response;
+      logForFunction(this.logger, "error", udfType, udfPath, errorMessage);
+      result = {
+        success: false,
+        errorMessage,
+        errorData:
+          errorData !== undefined ? jsonToConvex(errorData) : undefined,
+        logLines: response.logLines,
+      };
+      onResolve = () => status.onResult(result);
+    }
+
+    // We can resolve Mutation failures immediately since they don't have any
+    // side effects. Actions are intentionally decoupled from
+    // queries/mutations here on the sync protocol since they have different
+    // guarantees.
+    if (response.type === "ActionResponse" || !response.success) {
+      onResolve();
+      this.inflightRequests.delete(response.requestId);
+      this.requestsOlderThanRestart.delete(response.requestId);
+
+      if (requestInfo.message.type === "Action") {
+        this.inflightActionsCount--;
+      } else if (requestInfo.message.type === "Mutation") {
+        this.inflightMutationsCount--;
+      }
+
+      return { requestId: response.requestId, result };
+    }
+
+    // We have to wait to resolve the request promise until after we transition
+    // past this timestamp so clients can read their own writes.
+    requestInfo.status = {
+      status: "Completed",
+      result,
+      ts: response.ts,
+      onResolve,
+    };
+
+    return null;
+  }
+
+  // Remove and returns completed requests.
+  removeCompleted(ts: Long): Map<RequestId, FunctionResult> {
+    const completeRequests: Map<RequestId, FunctionResult> = new Map();
+    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {
+      const status = requestInfo.status;
+      if (status.status === "Completed" && status.ts.lessThanOrEqual(ts)) {
+        status.onResolve();
+        completeRequests.set(requestId, status.result);
+
+        if (requestInfo.message.type === "Mutation") {
+          this.inflightMutationsCount--;
+        } else if (requestInfo.message.type === "Action") {
+          this.inflightActionsCount--;
+        }
+
+        this.inflightRequests.delete(requestId);
+        this.requestsOlderThanRestart.delete(requestId);
+      }
+    }
+    return completeRequests;
+  }
+
+  restart(): ClientMessage[] {
+    // When we reconnect to the backend, re-request all requests that are safe
+    // to be resend.
+
+    this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());
+    const allMessages = [];
+    for (const [requestId, value] of this.inflightRequests) {
+      if (value.status.status === "NotSent") {
+        value.status.status = "Requested";
+        allMessages.push(value.message);
+        continue;
+      }
+
+      if (value.message.type === "Mutation") {
+        // This includes ones that have already been completed because we still
+        // want to tell the backend to transition the client past the completed
+        // timestamp. This is safe since mutations are idempotent.
+        allMessages.push(value.message);
+      } else if (value.message.type === "Action") {
+        // Unlike mutations, actions are not idempotent. When we reconnect to the
+        // backend, we don't know if it is safe to resend in-flight actions, so we
+        // cancel them and consider them failed.
+        this.inflightRequests.delete(requestId);
+        this.requestsOlderThanRestart.delete(requestId);
+        this.inflightActionsCount--;
+        if (value.status.status === "Completed") {
+          throw new Error("Action should never be in 'Completed' state");
+        }
+        value.status.onResult({
+          success: false,
+          errorMessage: "Connection lost while action was in flight",
+          logLines: [],
+        });
+      }
+    }
+    return allMessages;
+  }
+
+  resume(): ClientMessage[] {
+    const allMessages = [];
+    for (const [, value] of this.inflightRequests) {
+      if (value.status.status === "NotSent") {
+        value.status.status = "Requested";
+        allMessages.push(value.message);
+        continue;
+      }
+    }
+    return allMessages;
+  }
+
+  /**
+   * @returns true if there are any requests that have been requested but have
+   * not be completed yet.
+   */
+  hasIncompleteRequests(): boolean {
+    for (const requestInfo of this.inflightRequests.values()) {
+      if (requestInfo.status.status === "Requested") {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * @returns true if there are any inflight requests, including ones that have
+   * completed on the server, but have not been applied.
+   */
+  hasInflightRequests(): boolean {
+    return this.inflightRequests.size > 0;
+  }
+
+  /**
+   * @returns true if there are any inflight requests, that have been hanging around
+   * since prior to the most recent restart.
+   */
+  hasSyncedPastLastReconnect(): boolean {
+    return this.requestsOlderThanRestart.size === 0;
+  }
+
+  timeOfOldestInflightRequest(): Date | null {
+    if (this.inflightRequests.size === 0) {
+      return null;
+    }
+    let oldestInflightRequest = Date.now();
+    for (const request of this.inflightRequests.values()) {
+      if (request.status.status !== "Completed") {
+        if (request.status.requestedAt.getTime() < oldestInflightRequest) {
+          oldestInflightRequest = request.status.requestedAt.getTime();
+        }
+      }
+    }
+    return new Date(oldestInflightRequest);
+  }
+
+  /**
+   * @returns The number of mutations currently in flight.
+   */
+  inflightMutations(): number {
+    return this.inflightMutationsCount;
+  }
+
+  /**
+   * @returns The number of actions currently in flight.
+   */
+  inflightActions(): number {
+    return this.inflightActionsCount;
+  }
+}
diff --git a/synced/convex/libs/browser/sync/session.ts b/synced/convex/libs/browser/sync/session.ts
new file mode 100644
index 0000000..d0f08b5
--- /dev/null
+++ b/synced/convex/libs/browser/sync/session.ts
@@ -0,0 +1,12 @@
+export function newSessionId() {
+  return uuidv4();
+}
+
+// From https://stackoverflow.com/a/2117523
+function uuidv4() {
+  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
+    const r = (Math.random() * 16) | 0,
+      v = c === "x" ? r : (r & 0x3) | 0x8;
+    return v.toString(16);
+  });
+}
diff --git a/synced/convex/libs/browser/sync/udf_path_utils.ts b/synced/convex/libs/browser/sync/udf_path_utils.ts
new file mode 100644
index 0000000..fc51073
--- /dev/null
+++ b/synced/convex/libs/browser/sync/udf_path_utils.ts
@@ -0,0 +1,37 @@
+import { convexToJson, Value } from "../../values/index.js";
+
+export function canonicalizeUdfPath(udfPath: string): string {
+  const pieces = udfPath.split(":");
+  let moduleName: string;
+  let functionName: string;
+  if (pieces.length === 1) {
+    moduleName = pieces[0];
+    functionName = "default";
+  } else {
+    moduleName = pieces.slice(0, pieces.length - 1).join(":");
+    functionName = pieces[pieces.length - 1];
+  }
+  if (moduleName.endsWith(".js")) {
+    moduleName = moduleName.slice(0, -3);
+  }
+  return `${moduleName}:${functionName}`;
+}
+
+/**
+ * A string representing the name and arguments of a query.
+ *
+ * This is used by the {@link BaseConvexClient}.
+ *
+ * @public
+ */
+export type QueryToken = string;
+
+export function serializePathAndArgs(
+  udfPath: string,
+  args: Record<string, Value>,
+): QueryToken {
+  return JSON.stringify({
+    udfPath: canonicalizeUdfPath(udfPath),
+    args: convexToJson(args),
+  });
+}
diff --git a/synced/convex/libs/browser/sync/web_socket_manager.ts b/synced/convex/libs/browser/sync/web_socket_manager.ts
new file mode 100644
index 0000000..7a6bfb3
--- /dev/null
+++ b/synced/convex/libs/browser/sync/web_socket_manager.ts
@@ -0,0 +1,613 @@
+import { Logger } from "../logging.js";
+import {
+  ClientMessage,
+  encodeClientMessage,
+  parseServerMessage,
+  ServerMessage,
+} from "./protocol.js";
+
+const CLOSE_NORMAL = 1000;
+const CLOSE_GOING_AWAY = 1001;
+const CLOSE_NO_STATUS = 1005;
+/** Convex-specific close code representing a "404 Not Found".
+ * The edge Onramp accepts websocket upgrades before confirming that the
+ * intended destination exists, so this code is sent once we've discovered that
+ * the destination does not exist.
+ */
+const CLOSE_NOT_FOUND = 4040;
+
+/**
+ * The various states our WebSocket can be in:
+ *
+ * - "disconnected": We don't have a WebSocket, but plan to create one.
+ * - "connecting": We have created the WebSocket and are waiting for the
+ *   `onOpen` callback.
+ * - "ready": We have an open WebSocket.
+ * - "stopped": The WebSocket was closed and a new one can be created via `.restart()`.
+ * - "terminated": We have closed the WebSocket and will never create a new one.
+ *
+ *
+ * WebSocket State Machine
+ * -----------------------
+ * initialState: disconnected
+ * validTransitions:
+ *   disconnected:
+ *     new WebSocket() -> connecting
+ *     terminate() -> terminated
+ *   connecting:
+ *     onopen -> ready
+ *     close() -> disconnected
+ *     terminate() -> terminated
+ *   ready:
+ *     close() -> disconnected
+ *     stop() -> stopped
+ *     terminate() -> terminated
+ *   stopped:
+ *     restart() -> connecting
+ *     terminate() -> terminated
+ * terminalStates:
+ *   terminated
+ *
+ *
+ *
+ *                                        
+ *                terminate()  disconnected  
+ *                                         
+ *                                                         
+ *                  new WebSocket()        
+ *       terminated                            
+ *                                      
+ *                         terminate()           close() close()
+ *          terminate()                                   
+ *                                                       
+ *               
+ *          stopped     restart()   connecting     
+ *                       
+ *                                                         
+ *                                              onopen      
+ *                                                         
+ *                                                         
+ * terminate()                             
+ *               stop()     ready      
+ *                                       
+ *                                                
+ *                                                
+ *    
+ *
+ * The `connecting` and `ready` state have a sub-state-machine for pausing.
+ */
+
+type Socket =
+  | { state: "disconnected" }
+  | { state: "connecting"; ws: WebSocket; paused: "yes" | "no" }
+  | { state: "ready"; ws: WebSocket; paused: "yes" | "no" | "uninitialized" }
+  | { state: "stopped" }
+  | { state: "terminated" };
+
+export type ReconnectMetadata = {
+  connectionCount: number;
+  lastCloseReason: string | null;
+};
+
+export type OnMessageResponse = {
+  hasSyncedPastLastReconnect: boolean;
+};
+
+const serverDisconnectErrors = {
+  // A known error, e.g. during a restart or push
+  InternalServerError: { timeout: 1000 },
+  // ErrorMetadata::overloaded() messages that we realy should back off
+  SubscriptionsWorkerFullError: { timeout: 3000 },
+  TooManyConcurrentRequests: { timeout: 3000 },
+  CommitterFullError: { timeout: 3000 },
+  AwsTooManyRequestsException: { timeout: 3000 },
+  ExecuteFullError: { timeout: 3000 },
+  SystemTimeoutError: { timeout: 3000 },
+  ExpiredInQueue: { timeout: 3000 },
+  // More ErrorMetadata::overloaded() that typically indicate a deploy just happened
+  VectorIndexesUnavailable: { timeout: 1000 },
+  SearchIndexesUnavailable: { timeout: 1000 },
+  // More ErrorMeatadata::overloaded()
+  VectorIndexTooLarge: { timeout: 3000 },
+  SearchIndexTooLarge: { timeout: 3000 },
+  TooManyWritesInTimePeriod: { timeout: 3000 },
+} as const satisfies Record<string, { timeout: number }>;
+
+type ServerDisconnectError = keyof typeof serverDisconnectErrors | "Unknown";
+
+function classifyDisconnectError(s?: string): ServerDisconnectError {
+  if (s === undefined) return "Unknown";
+  // startsWith so more info could be at the end (although currently there isn't)
+
+  for (const prefix of Object.keys(
+    serverDisconnectErrors,
+  ) as ServerDisconnectError[]) {
+    if (s.startsWith(prefix)) {
+      return prefix;
+    }
+  }
+  return "Unknown";
+}
+
+/**
+ * A wrapper around a websocket that handles errors, reconnection, and message
+ * parsing.
+ */
+export class WebSocketManager {
+  private socket: Socket;
+
+  private connectionCount: number;
+  private _hasEverConnected: boolean = false;
+  private lastCloseReason:
+    | "InitialConnect"
+    | "OnCloseInvoked"
+    | (string & {}) // a full serverErrorReason (not just the prefix) or a new one
+    | null;
+
+  /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */
+  private readonly defaultInitialBackoff: number;
+
+  /** We backoff exponentially, but we need to cap that--this is the jittered max. */
+  private readonly maxBackoff: number;
+
+  /** How many times have we failed consecutively? */
+  private retries: number;
+
+  /** How long before lack of server response causes us to initiate a reconnect,
+   * in ms */
+  private readonly serverInactivityThreshold: number;
+
+  private reconnectDueToServerInactivityTimeout: ReturnType<
+    typeof setTimeout
+  > | null;
+
+  private readonly uri: string;
+  private readonly onOpen: (reconnectMetadata: ReconnectMetadata) => void;
+  private readonly onResume: () => void;
+  private readonly onMessage: (message: ServerMessage) => OnMessageResponse;
+  private readonly webSocketConstructor: typeof WebSocket;
+  private readonly logger: Logger;
+  private readonly onServerDisconnectError:
+    | ((message: string) => void)
+    | undefined;
+
+  constructor(
+    uri: string,
+    callbacks: {
+      onOpen: (reconnectMetadata: ReconnectMetadata) => void;
+      onResume: () => void;
+      onMessage: (message: ServerMessage) => OnMessageResponse;
+      onServerDisconnectError?: (message: string) => void;
+    },
+    webSocketConstructor: typeof WebSocket,
+    logger: Logger,
+  ) {
+    this.webSocketConstructor = webSocketConstructor;
+    this.socket = { state: "disconnected" };
+    this.connectionCount = 0;
+    this.lastCloseReason = "InitialConnect";
+
+    // backoff for unknown errors
+    this.defaultInitialBackoff = 1000;
+    this.maxBackoff = 16000;
+    this.retries = 0;
+
+    this.serverInactivityThreshold = 30000;
+    this.reconnectDueToServerInactivityTimeout = null;
+
+    this.uri = uri;
+    this.onOpen = callbacks.onOpen;
+    this.onResume = callbacks.onResume;
+    this.onMessage = callbacks.onMessage;
+    this.onServerDisconnectError = callbacks.onServerDisconnectError;
+    this.logger = logger;
+
+    this.connect();
+  }
+
+  private setSocketState(state: Socket) {
+    this.socket = state;
+    this._logVerbose(
+      `socket state changed: ${this.socket.state}, paused: ${
+        "paused" in this.socket ? this.socket.paused : undefined
+      }`,
+    );
+  }
+
+  private connect() {
+    if (this.socket.state === "terminated") {
+      return;
+    }
+    if (
+      this.socket.state !== "disconnected" &&
+      this.socket.state !== "stopped"
+    ) {
+      throw new Error(
+        "Didn't start connection from disconnected state: " + this.socket.state,
+      );
+    }
+
+    const ws = new this.webSocketConstructor(this.uri);
+    this._logVerbose("constructed WebSocket");
+    this.setSocketState({
+      state: "connecting",
+      ws,
+      paused: "no",
+    });
+
+    // Kick off server inactivity timer before WebSocket connection is established
+    // so we can detect cases where handshake fails.
+    // The `onopen` event only fires after the connection is established:
+    // Source: https://datatracker.ietf.org/doc/html/rfc6455#page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and
+    this.resetServerInactivityTimeout();
+
+    ws.onopen = () => {
+      this.logger.logVerbose("begin ws.onopen");
+      if (this.socket.state !== "connecting") {
+        throw new Error("onopen called with socket not in connecting state");
+      }
+      this.setSocketState({
+        state: "ready",
+        ws,
+        paused: this.socket.paused === "yes" ? "uninitialized" : "no",
+      });
+      this.resetServerInactivityTimeout();
+      if (this.socket.paused === "no") {
+        this._hasEverConnected = true;
+        this.onOpen({
+          connectionCount: this.connectionCount,
+          lastCloseReason: this.lastCloseReason,
+        });
+      }
+
+      if (this.lastCloseReason !== "InitialConnect") {
+        this.logger.log("WebSocket reconnected");
+      }
+
+      this.connectionCount += 1;
+      this.lastCloseReason = null;
+    };
+    // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.
+    ws.onerror = (error) => {
+      const message = (error as ErrorEvent).message;
+      this.logger.log(`WebSocket error: ${message}`);
+    };
+    ws.onmessage = (message) => {
+      this.resetServerInactivityTimeout();
+      const serverMessage = parseServerMessage(JSON.parse(message.data));
+      this._logVerbose(`received ws message with type ${serverMessage.type}`);
+      const response = this.onMessage(serverMessage);
+      if (response.hasSyncedPastLastReconnect) {
+        // Reset backoff to 0 once all outstanding requests are complete.
+        this.retries = 0;
+      }
+    };
+    ws.onclose = (event) => {
+      this._logVerbose("begin ws.onclose");
+      if (this.lastCloseReason === null) {
+        this.lastCloseReason = event.reason ?? "OnCloseInvoked";
+      }
+      if (
+        event.code !== CLOSE_NORMAL &&
+        event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded
+        event.code !== CLOSE_NO_STATUS &&
+        event.code !== CLOSE_NOT_FOUND // Note that we want to retry on a 404, as it can be transient during a push.
+      ) {
+        let msg = `WebSocket closed with code ${event.code}`;
+        if (event.reason) {
+          msg += `: ${event.reason}`;
+        }
+        this.logger.log(msg);
+        if (this.onServerDisconnectError) {
+          // This callback is a unstable API, InternalServerErrors may be removed in the future
+          // since they reflect a expected temporary outage. But until a quantitative measure
+          // of uptime is reported this unstable API errs on the inclusive side.
+          this.onServerDisconnectError(msg);
+        }
+      }
+      const reason = classifyDisconnectError(event.reason);
+      this.scheduleReconnect(reason);
+      return;
+    };
+  }
+
+  /**
+   * @returns The state of the {@link Socket}.
+   */
+  socketState(): string {
+    return this.socket.state;
+  }
+
+  /**
+   * @param message - A ClientMessage to send.
+   * @returns Whether the message (might have been) sent.
+   */
+  sendMessage(message: ClientMessage) {
+    const messageForLog = {
+      type: message.type,
+      ...(message.type === "Authenticate" && message.tokenType === "User"
+        ? {
+            value: `...${message.value.slice(-7)}`,
+          }
+        : {}),
+    };
+    if (this.socket.state === "ready" && this.socket.paused === "no") {
+      const encodedMessage = encodeClientMessage(message);
+      const request = JSON.stringify(encodedMessage);
+      try {
+        this.socket.ws.send(request);
+      } catch (error: any) {
+        this.logger.log(
+          `Failed to send message on WebSocket, reconnecting: ${error}`,
+        );
+        this.closeAndReconnect("FailedToSendMessage");
+      }
+      // We are not sure if this was sent or not.
+      this._logVerbose(
+        `sent message with type ${message.type}: ${JSON.stringify(
+          messageForLog,
+        )}`,
+      );
+      return true;
+    }
+    this._logVerbose(
+      `message not sent (socket state: ${this.socket.state}, paused: ${"paused" in this.socket ? this.socket.paused : undefined}): ${JSON.stringify(
+        messageForLog,
+      )}`,
+    );
+
+    return false;
+  }
+
+  private resetServerInactivityTimeout() {
+    if (this.socket.state === "terminated") {
+      // Don't reset any timers if we were trying to terminate.
+      return;
+    }
+    if (this.reconnectDueToServerInactivityTimeout !== null) {
+      clearTimeout(this.reconnectDueToServerInactivityTimeout);
+      this.reconnectDueToServerInactivityTimeout = null;
+    }
+    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {
+      this.closeAndReconnect("InactiveServer");
+    }, this.serverInactivityThreshold);
+  }
+
+  private scheduleReconnect(reason: "client" | ServerDisconnectError) {
+    this.socket = { state: "disconnected" };
+    const backoff = this.nextBackoff(reason);
+    this.logger.log(`Attempting reconnect in ${backoff}ms`);
+    setTimeout(() => this.connect(), backoff);
+  }
+
+  /**
+   * Close the WebSocket and schedule a reconnect.
+   *
+   * This should be used when we hit an error and would like to restart the session.
+   */
+  private closeAndReconnect(closeReason: string) {
+    this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);
+    switch (this.socket.state) {
+      case "disconnected":
+      case "terminated":
+      case "stopped":
+        // Nothing to do if we don't have a WebSocket.
+        return;
+      case "connecting":
+      case "ready": {
+        this.lastCloseReason = closeReason;
+        // Close the old socket asynchronously, we'll open a new socket in reconnect.
+        void this.close();
+        this.scheduleReconnect("client");
+        return;
+      }
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+      }
+    }
+  }
+
+  /**
+   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant
+   * calls. Use this instead of directly calling `ws.close()`
+   *
+   * It is the callers responsibility to update the state after this method is called so that the
+   * closed socket is not accessible or used again after this method is called
+   */
+  private close(): Promise<void> {
+    switch (this.socket.state) {
+      case "disconnected":
+      case "terminated":
+      case "stopped":
+        // Nothing to do if we don't have a WebSocket.
+        return Promise.resolve();
+      case "connecting": {
+        const ws = this.socket.ws;
+        return new Promise((r) => {
+          ws.onclose = () => {
+            this._logVerbose("Closed after connecting");
+            r();
+          };
+          ws.onopen = () => {
+            this._logVerbose("Opened after connecting");
+            ws.close();
+          };
+        });
+      }
+      case "ready": {
+        this._logVerbose("ws.close called");
+        const ws = this.socket.ws;
+        const result: Promise<void> = new Promise((r) => {
+          ws.onclose = () => {
+            r();
+          };
+        });
+        ws.close();
+        return result;
+      }
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+        return Promise.resolve();
+      }
+    }
+  }
+
+  /**
+   * Close the WebSocket and do not reconnect.
+   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
+   */
+  terminate(): Promise<void> {
+    if (this.reconnectDueToServerInactivityTimeout) {
+      clearTimeout(this.reconnectDueToServerInactivityTimeout);
+    }
+    switch (this.socket.state) {
+      case "terminated":
+      case "stopped":
+      case "disconnected":
+      case "connecting":
+      case "ready": {
+        const result = this.close();
+        this.setSocketState({ state: "terminated" });
+        return result;
+      }
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+        throw new Error(
+          `Invalid websocket state: ${(this.socket as any).state}`,
+        );
+      }
+    }
+  }
+
+  stop(): Promise<void> {
+    switch (this.socket.state) {
+      case "terminated":
+        // If we're terminating we ignore stop
+        return Promise.resolve();
+      case "connecting":
+      case "stopped":
+      case "disconnected":
+      case "ready": {
+        const result = this.close();
+        this.socket = { state: "stopped" };
+        return result;
+      }
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+        return Promise.resolve();
+      }
+    }
+  }
+
+  /**
+   * Create a new WebSocket after a previous `stop()`, unless `terminate()` was
+   * called before.
+   */
+  tryRestart(): void {
+    switch (this.socket.state) {
+      case "stopped":
+        break;
+      case "terminated":
+      case "connecting":
+      case "ready":
+      case "disconnected":
+        this.logger.logVerbose("Restart called without stopping first");
+        return;
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+      }
+    }
+    this.connect();
+  }
+
+  pause(): void {
+    switch (this.socket.state) {
+      case "disconnected":
+      case "stopped":
+      case "terminated":
+        // If already stopped or stopping ignore.
+        return;
+      case "connecting":
+      case "ready": {
+        this.socket = { ...this.socket, paused: "yes" };
+        return;
+      }
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+        return;
+      }
+    }
+  }
+
+  /**
+   * Resume the state machine if previously paused.
+   */
+  resume(): void {
+    switch (this.socket.state) {
+      case "connecting":
+        this.socket = { ...this.socket, paused: "no" };
+        return;
+      case "ready":
+        if (this.socket.paused === "uninitialized") {
+          this.socket = { ...this.socket, paused: "no" };
+          this.onOpen({
+            connectionCount: this.connectionCount,
+            lastCloseReason: this.lastCloseReason,
+          });
+        } else if (this.socket.paused === "yes") {
+          this.socket = { ...this.socket, paused: "no" };
+          this.onResume();
+        }
+        return;
+      case "terminated":
+      case "stopped":
+      case "disconnected":
+        // Ignore resume if not paused, perhaps we already resumed.
+        return;
+      default: {
+        // Enforce that the switch-case is exhaustive.
+        const _: never = this.socket;
+      }
+    }
+    this.connect();
+  }
+
+  connectionState(): {
+    isConnected: boolean;
+    hasEverConnected: boolean;
+    connectionCount: number;
+    connectionRetries: number;
+  } {
+    return {
+      isConnected: this.socket.state === "ready",
+      hasEverConnected: this._hasEverConnected,
+      connectionCount: this.connectionCount,
+      connectionRetries: this.retries,
+    };
+  }
+
+  private _logVerbose(message: string) {
+    this.logger.logVerbose(message);
+  }
+
+  private nextBackoff(reason: "client" | ServerDisconnectError): number {
+    const initialBackoff: number =
+      reason === "client"
+        ? 100 // There's no evidence of a server problem, retry quickly
+        : reason === "Unknown"
+          ? this.defaultInitialBackoff
+          : serverDisconnectErrors[reason].timeout;
+
+    const baseBackoff = initialBackoff * Math.pow(2, this.retries);
+    this.retries += 1;
+    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);
+    const jitter = actualBackoff * (Math.random() - 0.5);
+    return actualBackoff + jitter;
+  }
+}
